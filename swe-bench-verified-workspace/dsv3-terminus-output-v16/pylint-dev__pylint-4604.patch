diff --git a/debug_astroid.py b/debug_astroid.py
new file mode 100644
index 000000000..b28aae7e9
--- /dev/null
+++ b/debug_astroid.py
@@ -0,0 +1,23 @@
+import astroid
+
+code = """
+import os
+import sys
+
+X = ...  # type: os.path.sep
+Y = ...  # type: sys.modules
+Z = ...  # type: os.path.join('a', 'b').upper()
+"""
+
+module = astroid.parse(code)
+print("Module locals:", module.locals)
+
+for node in module.nodes_of_class(astroid.Assign):
+    if hasattr(node, 'type_annotation'):
+        print(f"\nNode: {node}")
+        print(f"Type annotation: {node.type_annotation}")
+        print(f"Type annotation class: {type(node.type_annotation)}")
+        
+        if hasattr(node.type_annotation, 'expr'):
+            print(f"Expression: {node.type_annotation.expr}")
+            print(f"Expression class: {type(node.type_annotation.expr)}")
\ No newline at end of file
diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 3ddafd599..af4c6c15e 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1826,6 +1826,17 @@ class VariablesChecker(BaseChecker):
             self._type_annotation_names.append(type_annotation.name)
             return
 
+        if isinstance(type_annotation, astroid.Attribute):
+            # Handle qualified names like abc.ABC, os.path.sep, etc.
+            # Extract the module name from the attribute expression by traversing
+            # the attribute chain until we find a Name node
+            expr = type_annotation.expr
+            while isinstance(expr, astroid.Attribute):
+                expr = expr.expr
+            if isinstance(expr, astroid.Name):
+                self._type_annotation_names.append(expr.name)
+            return
+
         if not isinstance(type_annotation, astroid.Subscript):
             return
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..ba4ac30f5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,7 @@
+"""Docstring."""
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
\ No newline at end of file
diff --git a/test_astroid.py b/test_astroid.py
new file mode 100644
index 000000000..e235cc289
--- /dev/null
+++ b/test_astroid.py
@@ -0,0 +1,21 @@
+import astroid
+
+code = """
+\"\"\"Docstring.\"\"\"
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+"""
+
+module = astroid.parse(code)
+print("Module locals:", module.locals)
+print("Type comments found:")
+
+for node in module.nodes_of_class(astroid.Assign):
+    if hasattr(node, 'type_comment'):
+        print(f"Node: {node}, Type comment: {node.type_comment}")
+    if hasattr(node, 'type_annotation'):
+        print(f"Node: {node}, Type annotation: {node.type_annotation}")
\ No newline at end of file
diff --git a/test_complex_attributes.py b/test_complex_attributes.py
new file mode 100644
index 000000000..48b333d1c
--- /dev/null
+++ b/test_complex_attributes.py
@@ -0,0 +1,12 @@
+"""Test complex attribute expressions in type comments."""
+
+import os
+import sys
+
+# Test chained attributes
+X = ...  # type: os.path.sep
+Y = ...  # type: sys.modules
+
+# Test that we don't break on non-Name expressions
+# This should not cause any issues even if it's not a simple module.attribute
+Z = ...  # type: os.path.join('a', 'b').upper()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 000000000..bbdcb4185
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,38 @@
+"""Comprehensive test for type comment handling."""
+
+import os
+import sys
+import abc
+from os import path
+from sys import argv
+from abc import ABC
+
+# Test basic cases
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+
+# Test nested attributes
+Z = ...  # type: os.path.sep
+W = ...  # type: sys.modules
+
+# Test from imports
+A = ...  # type: path
+B = ...  # type: argv
+
+# Test complex nested attributes
+C = ...  # type: os.path.dirname(__file__)
+
+# Test that regular code usage still works
+def test_func():
+    print(os.name)
+    print(sys.version)
+    print(abc.__name__)
+    return path.join('a', 'b'), argv[0]
+
+# Test mix of type comments and regular annotations
+D: str = "hello"
+E = ...  # type: int
+
+# Test unused imports (should still be flagged)
+import json  # This should be flagged as unused
+import math  # This should be flagged as unused
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..2b9e20d88
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,23 @@
+"""Test edge cases for type comments."""
+
+import os
+import sys
+from os import path
+from sys import argv
+
+# Test various type comment patterns
+X = ...  # type: os.PathLike
+Y = ...  # type: path
+Z = ...  # type: sys.argv
+W = ...  # type: argv
+
+# Test nested attributes
+A = ...  # type: os.path.abspath
+
+# Test regular annotations (should still work)
+B: str = "test"
+C: int = 42
+
+# Test type comments with subscriptions
+D = ...  # type: List[str]
+E = ...  # type: Dict[str, int]
\ No newline at end of file