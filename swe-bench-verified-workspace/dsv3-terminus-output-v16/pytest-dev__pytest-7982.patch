diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..690623e11
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the symlink directory collection issue.
+This script creates a test directory structure with symlinks and
+verifies that pytest collects tests from symlinked directories.
+"""
+
+import os
+import tempfile
+import shutil
+import subprocess
+import sys
+
+def create_test_structure():
+    """Create a test directory structure with symlinks."""
+    # Create a temporary directory
+    test_dir = tempfile.mkdtemp(prefix="pytest_symlink_test_")
+    print(f"Created test directory: {test_dir}")
+    
+    # Create main test directory
+    main_test_dir = os.path.join(test_dir, "main_tests")
+    os.makedirs(main_test_dir)
+    
+    # Create a test file in main directory
+    with open(os.path.join(main_test_dir, "test_main.py"), "w") as f:
+        f.write("""
+def test_main():
+    assert True
+""")
+    
+    # Create a symlinked test directory
+    symlink_test_dir = os.path.join(test_dir, "symlink_tests")
+    os.makedirs(symlink_test_dir)
+    
+    # Create a test file in symlink directory
+    with open(os.path.join(symlink_test_dir, "test_symlink.py"), "w") as f:
+        f.write("""
+def test_symlink():
+    assert True
+""")
+    
+    # Create a symlink from main directory to symlink directory
+    symlink_path = os.path.join(main_test_dir, "symlinked_dir")
+    os.symlink(symlink_test_dir, symlink_path)
+    
+    print(f"Created symlink: {symlink_path} -> {symlink_test_dir}")
+    
+    return test_dir, main_test_dir
+
+def run_pytest_collection(test_dir):
+    """Run pytest collection on the test directory."""
+    print("Running pytest collection...")
+    
+    # Change to the test directory
+    old_cwd = os.getcwd()
+    os.chdir(test_dir)
+    
+    try:
+        # Run pytest with collection only
+        result = subprocess.run([
+            sys.executable, "-m", "pytest", 
+            "main_tests", 
+            "--collect-only", 
+            "-q"
+        ], capture_output=True, text=True)
+        
+        print("Pytest output:")
+        print(result.stdout)
+        if result.stderr:
+            print("Pytest stderr:")
+            print(result.stderr)
+        
+        # Check if both tests are collected
+        collected_tests = []
+        for line in result.stdout.split('\n'):
+            if 'test_' in line and '::' in line:
+                collected_tests.append(line.strip())
+        
+        print(f"\nCollected tests: {collected_tests}")
+        
+        # Check if the symlinked test was collected
+        symlink_collected = any("symlinked_dir" in test for test in collected_tests)
+        print(f"Symlinked test collected: {symlink_collected}")
+        
+        return symlink_collected, result.returncode == 0
+        
+    finally:
+        os.chdir(old_cwd)
+
+def main():
+    """Main function to reproduce the issue."""
+    print("Reproducing pytest symlink directory collection issue...")
+    
+    # Create test structure
+    test_dir, main_test_dir = create_test_structure()
+    
+    try:
+        # Run pytest collection
+        symlink_collected, success = run_pytest_collection(test_dir)
+        
+        if not symlink_collected:
+            print("\n❌ ISSUE REPRODUCED: Symlinked directory not collected!")
+            return False
+        else:
+            print("\n✅ Symlinked directory was collected correctly")
+            return True
+            
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir)
+        print(f"Cleaned up test directory: {test_dir}")
+
+if __name__ == "__main__":
+    success = main()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py
index f0bdb1481..b96cba069 100644
--- a/src/_pytest/pathlib.py
+++ b/src/_pytest/pathlib.py
@@ -558,7 +558,7 @@ def visit(
     entries = sorted(os.scandir(path), key=lambda entry: entry.name)
     yield from entries
     for entry in entries:
-        if entry.is_dir(follow_symlinks=False) and recurse(entry):
+        if entry.is_dir() and recurse(entry):
             yield from visit(entry.path, recurse)
 
 
diff --git a/test_symlink_edge_cases.py b/test_symlink_edge_cases.py
new file mode 100644
index 000000000..843babc09
--- /dev/null
+++ b/test_symlink_edge_cases.py
@@ -0,0 +1,143 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for symlink directory collection.
+This script tests various scenarios to ensure the fix is robust.
+"""
+
+import os
+import tempfile
+import shutil
+import subprocess
+import sys
+
+def create_test_structure_with_edge_cases():
+    """Create a test directory structure with various symlink edge cases."""
+    # Create a temporary directory
+    test_dir = tempfile.mkdtemp(prefix="pytest_symlink_edge_test_")
+    print(f"Created test directory: {test_dir}")
+    
+    # Create main test directory
+    main_test_dir = os.path.join(test_dir, "main_tests")
+    os.makedirs(main_test_dir)
+    
+    # Create a test file in main directory
+    with open(os.path.join(main_test_dir, "test_main.py"), "w") as f:
+        f.write("""
+def test_main():
+    assert True
+""")
+    
+    # Test case 1: Regular symlink to directory
+    symlink_test_dir = os.path.join(test_dir, "symlink_tests")
+    os.makedirs(symlink_test_dir)
+    
+    with open(os.path.join(symlink_test_dir, "test_symlink.py"), "w") as f:
+        f.write("""
+def test_symlink():
+    assert True
+""")
+    
+    symlink_path = os.path.join(main_test_dir, "symlinked_dir")
+    os.symlink(symlink_test_dir, symlink_path)
+    print(f"Created regular symlink: {symlink_path} -> {symlink_test_dir}")
+    
+    # Test case 2: Symlink to nested directory
+    nested_test_dir = os.path.join(test_dir, "nested_tests")
+    os.makedirs(nested_test_dir)
+    nested_subdir = os.path.join(nested_test_dir, "subdir")
+    os.makedirs(nested_subdir)
+    
+    with open(os.path.join(nested_subdir, "test_nested.py"), "w") as f:
+        f.write("""
+def test_nested():
+    assert True
+""")
+    
+    nested_symlink_path = os.path.join(main_test_dir, "nested_symlinked_dir")
+    os.symlink(nested_test_dir, nested_symlink_path)
+    print(f"Created nested symlink: {nested_symlink_path} -> {nested_test_dir}")
+    
+    # Test case 3: Broken symlink (should be handled gracefully)
+    broken_symlink_path = os.path.join(main_test_dir, "broken_symlink")
+    os.symlink("/nonexistent/path", broken_symlink_path)
+    print(f"Created broken symlink: {broken_symlink_path} -> /nonexistent/path")
+    
+    return test_dir, main_test_dir
+
+def run_pytest_collection(test_dir):
+    """Run pytest collection on the test directory."""
+    print("Running pytest collection...")
+    
+    # Change to the test directory
+    old_cwd = os.getcwd()
+    os.chdir(test_dir)
+    
+    try:
+        # Run pytest with collection only
+        result = subprocess.run([
+            sys.executable, "-m", "pytest", 
+            "main_tests", 
+            "--collect-only", 
+            "-q"
+        ], capture_output=True, text=True)
+        
+        print("Pytest output:")
+        print(result.stdout)
+        if result.stderr:
+            print("Pytest stderr:")
+            print(result.stderr)
+        
+        # Check collected tests
+        collected_tests = []
+        for line in result.stdout.split('\n'):
+            if 'test_' in line and '::' in line:
+                collected_tests.append(line.strip())
+        
+        print(f"\nCollected tests: {collected_tests}")
+        
+        # Check if regular symlink was collected
+        regular_symlink_collected = any("symlinked_dir" in test for test in collected_tests)
+        print(f"Regular symlink collected: {regular_symlink_collected}")
+        
+        # Check if nested symlink was collected
+        nested_symlink_collected = any("nested_symlinked_dir" in test for test in collected_tests)
+        print(f"Nested symlink collected: {nested_symlink_collected}")
+        
+        # Check if broken symlink caused any issues (should not be collected)
+        broken_symlink_collected = any("broken_symlink" in test for test in collected_tests)
+        print(f"Broken symlink collected: {broken_symlink_collected}")
+        
+        # We expect both regular and nested symlinks to be collected, but not broken ones
+        success = regular_symlink_collected and nested_symlink_collected and not broken_symlink_collected
+        
+        return success, result.returncode == 0
+        
+    finally:
+        os.chdir(old_cwd)
+
+def main():
+    """Main function to test edge cases."""
+    print("Testing pytest symlink directory collection edge cases...")
+    
+    # Create test structure
+    test_dir, main_test_dir = create_test_structure_with_edge_cases()
+    
+    try:
+        # Run pytest collection
+        success, pytest_success = run_pytest_collection(test_dir)
+        
+        if success and pytest_success:
+            print("\n✅ All edge cases handled correctly!")
+            return True
+        else:
+            print("\n❌ Some edge cases failed!")
+            return False
+            
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir)
+        print(f"Cleaned up test directory: {test_dir}")
+
+if __name__ == "__main__":
+    success = main()
+    sys.exit(0 if success else 1)
\ No newline at end of file