diff --git a/debug_field_properties.py b/debug_field_properties.py
new file mode 100644
index 0000000000..d4e042cc2d
--- /dev/null
+++ b/debug_field_properties.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models with proper app_label
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+# Get the fields and examine their properties
+restaurant_field = Waiter._meta.get_field('restaurant')
+place_field = Restaurant._meta.get_field('place')
+country_field = Place._meta.get_field('country')
+
+print("=== Restaurant field properties ===")
+print(f"Field: {restaurant_field}")
+print(f"Field type: {type(restaurant_field)}")
+print(f"Is relation: {restaurant_field.is_relation}")
+print(f"Is one-to-one: {restaurant_field.one_to_one}")
+print(f"Is foreign key: {restaurant_field.many_to_one}")
+print(f"Concrete: {restaurant_field.concrete}")
+print(f"Primary key: {restaurant_field.primary_key}")
+print(f"Path infos: {restaurant_field.path_infos}")
+if restaurant_field.path_infos:
+    print(f"Target fields: {restaurant_field.path_infos[-1].target_fields}")
+    for tf in restaurant_field.path_infos[-1].target_fields:
+        print(f"  Target field: {tf}")
+        print(f"  Target field type: {type(tf)}")
+        print(f"  Target field is relation: {tf.is_relation}")
+        print(f"  Target field one-to-one: {tf.one_to_one}")
+        print(f"  Target field primary key: {tf.primary_key}")
+
+print("\n=== Place field properties ===")
+print(f"Field: {place_field}")
+print(f"Field type: {type(place_field)}")
+print(f"Is relation: {place_field.is_relation}")
+print(f"Is one-to-one: {place_field.one_to_one}")
+print(f"Is foreign key: {place_field.many_to_one}")
+print(f"Concrete: {place_field.concrete}")
+print(f"Primary key: {place_field.primary_key}")
+print(f"Path infos: {place_field.path_infos}")
+if place_field.path_infos:
+    print(f"Target fields: {place_field.path_infos[-1].target_fields}")
+
+print("\n=== Country field properties ===")
+print(f"Field: {country_field}")
+print(f"Field type: {type(country_field)}")
+print(f"Is relation: {country_field.is_relation}")
+print(f"Is one-to-one: {country_field.one_to_one}")
+print(f"Is foreign key: {country_field.many_to_one}")
+print(f"Concrete: {country_field.concrete}")
+print(f"Primary key: {country_field.primary_key}")
+print(f"Path infos: {country_field.path_infos}")
+if country_field.path_infos:
+    print(f"Target fields: {country_field.path_infos[-1].target_fields}")
\ No newline at end of file
diff --git a/debug_lookup.py b/debug_lookup.py
new file mode 100644
index 0000000000..a20108eb98
--- /dev/null
+++ b/debug_lookup.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models with proper app_label
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Create admin site
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+# Debug the lookup_allowed method
+lookup = 'restaurant__place__country'
+value = 'test_value'
+
+model = ma.model
+relation_parts = []
+prev_field = None
+LOOKUP_SEP = '__'
+
+print(f"Processing lookup: {lookup}")
+print(f"Starting model: {model}")
+
+for part in lookup.split(LOOKUP_SEP):
+    print(f"\nProcessing part: {part}")
+    try:
+        field = model._meta.get_field(part)
+        print(f"Found field: {field}")
+        print(f"Field type: {type(field)}")
+        print(f"Field is_relation: {field.is_relation}")
+        if hasattr(field, 'path_infos'):
+            print(f"Field path_infos: {field.path_infos}")
+            if field.path_infos:
+                print(f"Last path_info target_fields: {field.path_infos[-1].target_fields}")
+    except Exception as e:
+        print(f"Error getting field {part}: {e}")
+        break
+    
+    # Check the condition that determines if part is added to relation_parts
+    condition_result = not prev_field or (
+        prev_field.is_relation
+        and field not in prev_field.path_infos[-1].target_fields
+    )
+    print(f"Condition result: {condition_result}")
+    
+    if condition_result:
+        relation_parts.append(part)
+        print(f"Added {part} to relation_parts")
+    
+    if not getattr(field, "path_infos", None):
+        print(f"No path_infos, breaking")
+        break
+    
+    prev_field = field
+    model = field.path_infos[-1].to_opts.model
+    print(f"New model: {model}")
+
+print(f"\nFinal relation_parts: {relation_parts}")
+print(f"Valid lookups from list_filter: {ma.list_filter}")
+
+# Check if the lookup should be allowed
+valid_lookups = {ma.date_hierarchy}
+for filter_item in ma.list_filter:
+    if hasattr(filter_item, 'parameter_name'):
+        valid_lookups.add(filter_item.parameter_name)
+    elif isinstance(filter_item, (list, tuple)):
+        valid_lookups.add(filter_item[0])
+    else:
+        valid_lookups.add(filter_item)
+
+print(f"Valid lookups set: {valid_lookups}")
+
+# Check if relation_parts matches any valid lookups
+check1 = LOOKUP_SEP.join(relation_parts)
+check2 = LOOKUP_SEP.join(relation_parts + [part]) if relation_parts else ""
+
+print(f"Checking: {check1} and {check2}")
+print(f"Result: {not {check1, check2}.isdisjoint(valid_lookups)}")
\ No newline at end of file
diff --git a/debug_parent_link.py b/debug_parent_link.py
new file mode 100644
index 0000000000..968972a143
--- /dev/null
+++ b/debug_parent_link.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models with proper app_label
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+# Check if the place field has parent_link=True
+place_field = Restaurant._meta.get_field('place')
+print(f"Place field: {place_field}")
+print(f"Place field parent_link: {getattr(place_field, 'parent_link', False)}")
+
+# For comparison, let's create a concrete inheritance example
+class Parent(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Child(Parent):
+    extra_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+# Check the automatically created OneToOneField
+child_field = Child._meta.get_field('parent_ptr')
+print(f"\nChild parent_ptr field: {child_field}")
+print(f"Child parent_ptr parent_link: {getattr(child_field, 'parent_link', False)}")
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5240b07cd6..eac7c6883c 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -464,9 +464,14 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
             # It is allowed to filter on values that would be found from local
             # model anyways. For example, if you filter on employee__department__id,
             # then the id value would be found already from employee__department_id.
+            # However, we should not skip relationship fields that are part of a
+            # multi-step relationship chain, even if they are in target_fields.
             if not prev_field or (
                 prev_field.is_relation
-                and field not in prev_field.path_infos[-1].target_fields
+                and (
+                    field not in prev_field.path_infos[-1].target_fields
+                    or field.is_relation
+                )
             ):
                 relation_parts.append(part)
             if not getattr(field, "path_infos", None):
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..e5d26400cf
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,191 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+print("=== Final comprehensive test ===")
+
+# Test 1: Original issue from GitHub - foreign key as primary key
+print("1. Testing original issue: Foreign key as primary key")
+
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+print(f"   restaurant__place__country: {result}")
+assert result == True, "Original issue should be fixed"
+print("   ✓ PASS: Original issue is fixed\n")
+
+# Test 2: Existing Django tests should still work
+print("2. Testing existing Django functionality")
+
+# Test 2a: OneToOneField test (from existing test suite)
+class Department(models.Model):
+    code = models.CharField(max_length=4, unique=True)
+    class Meta:
+        app_label = 'testapp'
+
+class Employee(models.Model):
+    department = models.ForeignKey(Department, models.CASCADE, to_field='code')
+    class Meta:
+        app_label = 'testapp'
+
+class EmployeeProfile(models.Model):
+    employee = models.OneToOneField(Employee, models.CASCADE)
+    class Meta:
+        app_label = 'testapp'
+
+class EmployeeInfo(models.Model):
+    employee = models.OneToOneField(Employee, models.CASCADE)
+    description = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'testapp'
+
+class EmployeeProfileAdmin(ModelAdmin):
+    list_filter = [
+        'employee__employeeinfo__description',
+        'employee__department__code',
+    ]
+
+ma_employee = EmployeeProfileAdmin(EmployeeProfile, site)
+result1 = ma_employee.lookup_allowed('employee__employeeinfo__description', 'test_value')
+result2 = ma_employee.lookup_allowed('employee__department__code', 'test_value')
+print(f"   employee__employeeinfo__description: {result1}")
+print(f"   employee__department__code: {result2}")
+assert result1 == True and result2 == True, "Existing OneToOneField tests should work"
+print("   ✓ PASS: Existing OneToOneField functionality works\n")
+
+# Test 2b: Nonexistent lookup test (from existing test suite)
+class Band(models.Model):
+    name = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'testapp'
+
+class BandAdmin(ModelAdmin):
+    fields = ['name']
+
+ma_band = BandAdmin(Band, site)
+result = ma_band.lookup_allowed('name__nonexistent', 'test_value')
+print(f"   name__nonexistent: {result}")
+assert result == True, "Nonexistent lookup should return True"
+print("   ✓ PASS: Nonexistent lookup functionality works\n")
+
+# Test 3: Edge cases
+print("3. Testing edge cases")
+
+# Test 3a: Multi-level with FK as PK
+class Level1(models.Model):
+    name = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'testapp'
+
+class Level2(models.Model):
+    level1 = models.OneToOneField(Level1, models.CASCADE, primary_key=True)
+    class Meta:
+        app_label = 'testapp'
+
+class Level3(models.Model):
+    level2 = models.ForeignKey(Level2, models.CASCADE)
+    class Meta:
+        app_label = 'testapp'
+
+class Level3Admin(ModelAdmin):
+    list_filter = ['level2__level1__name']
+
+ma_level = Level3Admin(Level3, site)
+result = ma_level.lookup_allowed('level2__level1__name', 'test_value')
+print(f"   Multi-level FK as PK: {result}")
+assert result == True, "Multi-level FK as PK should work"
+print("   ✓ PASS: Multi-level FK as PK works\n")
+
+# Test 3b: Regular lookups should still work
+class Simple(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    class Meta:
+        app_label = 'testapp'
+
+class SimpleAdmin(ModelAdmin):
+    list_filter = ['name', 'value']
+
+ma_simple = SimpleAdmin(Simple, site)
+result1 = ma_simple.lookup_allowed('name', 'test_value')
+result2 = ma_simple.lookup_allowed('value', 'test_value')
+print(f"   Simple lookups: name={result1}, value={result2}")
+assert result1 == True and result2 == True, "Simple lookups should work"
+print("   ✓ PASS: Simple lookups work\n")
+
+# Test 4: Non-allowed lookups should return False
+print("4. Testing non-allowed lookups")
+
+class RestrictedAdmin(ModelAdmin):
+    list_filter = ['name']
+
+ma_restricted = RestrictedAdmin(Simple, site)
+result = ma_restricted.lookup_allowed('value', 'test_value')  # value not in list_filter
+print(f"   Non-allowed lookup: {result}")
+assert result == False, "Non-allowed lookups should return False"
+print("   ✓ PASS: Non-allowed lookups correctly return False\n")
+
+print("🎉 ALL TESTS PASSED! The fix is working correctly.")
+print("✅ Original issue is fixed")
+print("✅ Existing functionality is preserved")
+print("✅ Edge cases are handled correctly")
+print("✅ Non-allowed lookups still return False")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..03ea879a39
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models with proper app_label
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'contenttypes'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Create admin site and test the lookup
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+try:
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"lookup_allowed result: {result}")
+    if result:
+        print("SUCCESS: lookup_allowed returned True as expected")
+    else:
+        print("FAILURE: lookup_allowed returned False, but should return True")
+except Exception as e:
+    print(f"ERROR: {e}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..e73ad93862
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+print("=== Testing edge cases ===")
+
+# Edge case 1: Multiple levels with foreign key as primary key
+class Level1(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Level2(models.Model):
+    level1 = models.OneToOneField(Level1, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Level3(models.Model):
+    level2 = models.ForeignKey(Level2, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Level4(models.Model):
+    level3 = models.ForeignKey(Level3, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Level4Admin(ModelAdmin):
+    list_filter = [
+        'level3__level2__level1__name',
+    ]
+
+site = AdminSite()
+ma = Level4Admin(Level4, site)
+
+result = ma.lookup_allowed('level3__level2__level1__name', 'test_value')
+print(f"Multi-level lookup with FK as PK: {result}")
+assert result == True, "Multi-level lookup should work"
+print("✓ PASS: Multi-level lookup with FK as PK works\n")
+
+# Edge case 2: Regular concrete inheritance (should still work)
+class Parent(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Child(Parent):
+    extra_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class ChildAdmin(ModelAdmin):
+    list_filter = [
+        'name',  # Field from parent
+    ]
+
+ma_child = ChildAdmin(Child, site)
+result = ma_child.lookup_allowed('name', 'test_value')
+print(f"Concrete inheritance lookup: {result}")
+assert result == True, "Concrete inheritance lookup should work"
+print("✓ PASS: Concrete inheritance lookup works\n")
+
+# Edge case 3: Mixed regular and FK-as-PK relationships
+class A(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class B(models.Model):
+    a = models.OneToOneField(A, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class C(models.Model):
+    b = models.ForeignKey(B, models.CASCADE)
+    extra = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class CAdmin(ModelAdmin):
+    list_filter = [
+        'b__a__name',
+        'extra',
+    ]
+
+ma_c = CAdmin(C, site)
+result1 = ma_c.lookup_allowed('b__a__name', 'test_value')
+result2 = ma_c.lookup_allowed('extra', 'test_value')
+print(f"Mixed lookup 1 (b__a__name): {result1}")
+print(f"Mixed lookup 2 (extra): {result2}")
+assert result1 == True, "Mixed lookup with FK as PK should work"
+assert result2 == True, "Mixed regular lookup should work"
+print("✓ PASS: Mixed lookups work correctly\n")
+
+print("All edge case tests passed! The fix handles various scenarios correctly.")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..8a2d88b501
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,129 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Test 1: Original issue - foreign key as primary key
+print("=== Test 1: Foreign key as primary key (original issue) ===")
+
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+print(f"lookup_allowed('restaurant__place__country', 'test_value'): {result}")
+assert result == True, "Should return True for restaurant__place__country"
+print("✓ PASS: Foreign key as primary key lookup works correctly\n")
+
+# Test 2: Regular case that should still work
+print("=== Test 2: Regular case (should still work) ===")
+
+class Department(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class Employee(models.Model):
+    name = models.CharField(max_length=100)
+    department = models.ForeignKey(Department, models.CASCADE)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class EmployeeAdmin(ModelAdmin):
+    list_filter = [
+        'department__name',
+    ]
+
+ma_employee = EmployeeAdmin(Employee, site)
+result = ma_employee.lookup_allowed('department__name', 'test_value')
+print(f"lookup_allowed('department__name', 'test_value'): {result}")
+assert result == True, "Should return True for department__name"
+print("✓ PASS: Regular lookup still works correctly\n")
+
+# Test 3: ID field shortcut (should still work)
+print("=== Test 3: ID field shortcut (should still work) ===")
+
+class EmployeeAdmin2(ModelAdmin):
+    list_filter = [
+        'department',
+    ]
+
+ma_employee2 = EmployeeAdmin2(Employee, site)
+result = ma_employee2.lookup_allowed('department__id', 'test_value')
+print(f"lookup_allowed('department__id', 'test_value'): {result}")
+assert result == True, "Should return True for department__id"
+print("✓ PASS: ID field shortcut still works correctly\n")
+
+# Test 4: Non-allowed lookup (should return False)
+print("=== Test 4: Non-allowed lookup (should return False) ===")
+
+class EmployeeAdmin3(ModelAdmin):
+    list_filter = [
+        'department',
+    ]
+
+ma_employee3 = EmployeeAdmin3(Employee, site)
+result = ma_employee3.lookup_allowed('department__name', 'test_value')  # department__name not in list_filter
+print(f"lookup_allowed('department__name', 'test_value'): {result}")
+assert result == False, "Should return False for department__name (not in list_filter)"
+print("✓ PASS: Non-allowed lookup correctly returns False\n")
+
+print("All tests passed! The fix works correctly.")
\ No newline at end of file