diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 88c9ca9f28..fcea1597ef 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):
         return NotImplemented
 
     def __hash__(self):
-        return hash((
-            self.creation_counter,
-            self.model._meta.app_label if hasattr(self, 'model') else None,
-            self.model._meta.model_name if hasattr(self, 'model') else None,
-        ))
+        return hash(self.creation_counter)
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..72d13736b2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the Field.__hash__() issue described in the GitHub issue.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+def test_field_hash_issue():
+    print("Testing Field.__hash__() issue...")
+    
+    # Create a field instance
+    f = models.CharField(max_length=200)
+    
+    # Store the field in a dictionary
+    d = {f: 1}
+    print(f"Field hash before assignment: {hash(f)}")
+    print(f"Field in dictionary before assignment: {f in d}")
+    
+    # Assign the field to a model class
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"Field hash after assignment: {hash(f)}")
+    print(f"Field in dictionary after assignment: {f in d}")
+    
+    # This should raise an AssertionError according to the issue
+    try:
+        assert f in d
+        print("SUCCESS: Assertion passed - field still in dictionary")
+    except AssertionError:
+        print("FAILURE: Assertion failed - field not found in dictionary")
+        raise
+
+if __name__ == "__main__":
+    test_field_hash_issue()
\ No newline at end of file
diff --git a/test_additional_fields.py b/test_additional_fields.py
new file mode 100644
index 0000000000..a2ad080128
--- /dev/null
+++ b/test_additional_fields.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Test the Field.__hash__() fix with additional field types.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+def test_different_field_types():
+    print("Testing different field types...")
+    
+    # Test CharField
+    char_field = models.CharField(max_length=100)
+    char_dict = {char_field: 'char'}
+    print(f"CharField hash before: {hash(char_field)}")
+    
+    class CharModel(models.Model):
+        name = char_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"CharField hash after: {hash(char_field)}")
+    print(f"CharField in dict: {char_field in char_dict}")
+    
+    # Test IntegerField
+    int_field = models.IntegerField()
+    int_dict = {int_field: 'int'}
+    print(f"IntegerField hash before: {hash(int_field)}")
+    
+    class IntModel(models.Model):
+        value = int_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"IntegerField hash after: {hash(int_field)}")
+    print(f"IntegerField in dict: {int_field in int_dict}")
+    
+    # Test BooleanField
+    bool_field = models.BooleanField()
+    bool_dict = {bool_field: 'bool'}
+    print(f"BooleanField hash before: {hash(bool_field)}")
+    
+    class BoolModel(models.Model):
+        active = bool_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"BooleanField hash after: {hash(bool_field)}")
+    print(f"BooleanField in dict: {bool_field in bool_dict}")
+
+if __name__ == "__main__":
+    test_different_field_types()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..b5d1a9064f
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for Field hash and equality to ensure our fix doesn't break anything.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+def test_edge_cases():
+    print("Testing edge cases for Field hash and equality...")
+    
+    # Test 1: Fields with same creation_counter (should be equal)
+    # This can happen with copied fields or special scenarios
+    field1 = models.CharField(max_length=100)
+    
+    # Create a field with the same creation_counter by copying
+    field2 = field1
+    assert field1 == field2, "Fields with same creation_counter should be equal"
+    assert hash(field1) == hash(field2), "Fields with same creation_counter should have same hash"
+    print("✓ Same creation_counter equality test passed")
+    
+    # Test 2: Fields with different creation_counter (should not be equal)
+    field3 = models.CharField(max_length=100)
+    assert field1 != field3, "Fields with different creation_counter should not be equal"
+    # Note: They might have the same hash due to hash collision, but equality should still work
+    print("✓ Different creation_counter inequality test passed")
+    
+    # Test 3: Field assigned to different models
+    field4 = models.CharField(max_length=100)
+    
+    class ModelA(models.Model):
+        name = field4
+        
+        class Meta:
+            app_label = 'test'
+    
+    hash_after_model_a = hash(field4)
+    
+    class ModelB(models.Model):
+        title = field4
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Hash should remain consistent even after assigning to different models
+    assert hash(field4) == hash_after_model_a, "Field hash should not change after multiple model assignments"
+    print("✓ Multiple model assignments hash consistency test passed")
+    
+    # Test 4: Field comparison with non-Field objects
+    non_field = "not a field"
+    assert field1 != non_field, "Field should not be equal to non-Field object"
+    print("✓ Non-Field object comparison test passed")
+    
+    print("All edge case tests passed! ✅")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_exact_issue_scenario.py b/test_exact_issue_scenario.py
new file mode 100644
index 0000000000..55acbfca8f
--- /dev/null
+++ b/test_exact_issue_scenario.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+"""
+Test the exact scenario described in the GitHub issue.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+def test_exact_issue_scenario():
+    print("Testing the exact scenario from the GitHub issue...")
+    
+    # Exact code from the GitHub issue
+    f = models.CharField(max_length=200)
+    d = {f: 1}
+    
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    # This assertion should now pass (it was failing before the fix)
+    assert f in d
+    print("✓ GitHub issue scenario test passed!")
+    
+    # Additional verification
+    assert d[f] == 1
+    print("✓ Dictionary value integrity verified!")
+
+if __name__ == "__main__":
+    test_exact_issue_scenario()
\ No newline at end of file
diff --git a/test_field_hash_comprehensive.py b/test_field_hash_comprehensive.py
new file mode 100644
index 0000000000..c3f318c95b
--- /dev/null
+++ b/test_field_hash_comprehensive.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for Field.__hash__() fix to ensure it works correctly
+and maintains proper equality semantics.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'test',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import models
+
+def test_field_hash_and_equality():
+    print("Testing Field hash and equality semantics...")
+    
+    # Test 1: Basic hash consistency
+    field1 = models.CharField(max_length=100)
+    original_hash = hash(field1)
+    
+    class TestModel(models.Model):
+        name = field1
+        
+        class Meta:
+            app_label = 'test'
+    
+    assert hash(field1) == original_hash, "Field hash changed after model assignment"
+    print("✓ Hash consistency test passed")
+    
+    # Test 2: Dictionary behavior
+    field_dict = {field1: 'test_value'}
+    assert field1 in field_dict, "Field not found in dictionary after model assignment"
+    assert field_dict[field1] == 'test_value', "Field value in dictionary incorrect"
+    print("✓ Dictionary behavior test passed")
+    
+    # Test 3: Equality with same creation_counter
+    field2 = models.CharField(max_length=100)
+    # field1 and field2 should not be equal even though they have the same type
+    # because they have different creation_counter values
+    assert field1 != field2, "Different fields with different creation_counters should not be equal"
+    print("✓ Equality with different creation_counters test passed")
+    
+    # Test 4: Set behavior
+    field_set = {field1, field2}
+    assert len(field_set) == 2, "Set should contain both distinct fields"
+    assert field1 in field_set, "Field1 not found in set"
+    assert field2 in field_set, "Field2 not found in set"
+    print("✓ Set behavior test passed")
+    
+    # Test 5: Multiple field types
+    int_field = models.IntegerField()
+    bool_field = models.BooleanField()
+    
+    mixed_dict = {
+        field1: 'char',
+        int_field: 'int', 
+        bool_field: 'bool'
+    }
+    
+    class AnotherModel(models.Model):
+        value = int_field
+        active = bool_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    # All fields should still be found in the dictionary
+    assert field1 in mixed_dict and mixed_dict[field1] == 'char'
+    assert int_field in mixed_dict and mixed_dict[int_field] == 'int'
+    assert bool_field in mixed_dict and mixed_dict[bool_field] == 'bool'
+    print("✓ Multiple field types test passed")
+    
+    print("All tests passed! ✅")
+
+if __name__ == "__main__":
+    test_field_hash_and_equality()
\ No newline at end of file