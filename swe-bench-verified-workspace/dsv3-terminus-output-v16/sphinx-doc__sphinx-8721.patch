diff --git a/final_test.py b/final_test.py
new file mode 100644
index 000000000..a0c9819f4
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Final test to demonstrate the epub viewcode fix.
+"""
+
+def test_epub_viewcode_fix():
+    print("=== Testing the viewcode epub fix ===\n")
+    
+    # Read the collect_pages function
+    with open('/testbed/sphinx/ext/viewcode.py', 'r') as f:
+        content = f.read()
+    
+    # Check that the fix is in place
+    if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in content:
+        print("✓ Fix is in place: collect_pages function checks for epub builder and viewcode_enable_epub setting")
+        
+        # Find the exact line
+        lines = content.split('\n')
+        for i, line in enumerate(lines):
+            if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in line:
+                print(f"✓ Found the check at line {i+1}")
+                break
+                
+        # Verify it's in the right function
+        collect_pages_start = content.find('def collect_pages(')
+        collect_pages_end = content.find('def ', collect_pages_start + 1)
+        collect_pages_code = content[collect_pages_start:collect_pages_end]
+        
+        if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in collect_pages_code:
+            print("✓ Check is correctly placed in collect_pages function")
+        else:
+            print("✗ Check is not in collect_pages function")
+            return False
+            
+        # Compare with doctree_read function which already had this check
+        if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in content:
+            print("✓ Both doctree_read and collect_pages now have the same epub check")
+        else:
+            print("✗ doctree_read function doesn't have the epub check (it should)")
+            return False
+            
+        print("\n=== Summary ===")
+        print("The fix ensures that when viewcode_enable_epub=False:")
+        print("1. doctree_read() skips processing for epub builders")
+        print("2. collect_pages() skips generating module pages for epub builders")
+        print("3. This prevents viewcode from creating pages for epub when disabled")
+        print("\n✓ Fix is complete and working correctly!")
+        return True
+    else:
+        print("✗ Fix not found in viewcode.py")
+        return False
+
+if __name__ == '__main__':
+    success = test_epub_viewcode_fix()
+    print(f"\nFinal test result: {'PASS' if success else 'FAIL'}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..0134bcd75
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the viewcode epub issue.
+"""
+
+import tempfile
+import os
+import shutil
+from sphinx.application import Sphinx
+from sphinx.ext.viewcode import collect_pages
+
+def test_viewcode_epub_issue():
+    # Create a temporary directory for the test
+    with tempfile.TemporaryDirectory() as tmpdir:
+        srcdir = os.path.join(tmpdir, 'source')
+        outdir = os.path.join(tmpdir, 'build')
+        doctreedir = os.path.join(tmpdir, 'doctrees')
+        
+        os.makedirs(srcdir)
+        
+        # Create a simple conf.py with viewcode extension
+        conf_py_content = '''
+extensions = ['sphinx.ext.viewcode']
+viewcode_enable_epub = False
+'''
+        with open(os.path.join(srcdir, 'conf.py'), 'w') as f:
+            f.write(conf_py_content)
+        
+        # Create a simple index.rst
+        index_rst_content = '''
+Test Documentation
+==================
+
+.. automodule:: os.path
+   :members:
+'''
+        with open(os.path.join(srcdir, 'index.rst'), 'w') as f:
+            f.write(index_rst_content)
+        
+        # Let's examine the collect_pages function directly
+        # The issue is that collect_pages doesn't check viewcode_enable_epub for epub builders
+        # Let's look at the source code to understand the issue
+        
+        print("Examining the collect_pages function in viewcode.py...")
+        print("The function should check for epub builder and viewcode_enable_epub setting")
+        print("but currently it doesn't have this check like doctree_read does")
+        
+        # Let's create a simple test by patching the function temporarily
+        original_collect_pages = collect_pages
+        
+        def patched_collect_pages(app):
+            env = app.builder.env
+            # Add the epub check like in doctree_read
+            if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:
+                return iter([])  # Return empty iterator instead of None
+            return original_collect_pages(app)
+        
+        # Test with our patched version
+        class MockConfig:
+            def __init__(self):
+                self.viewcode_enable_epub = False
+                self.highlight_language = 'python'
+        
+        class MockEnv:
+            def __init__(self, config):
+                self._viewcode_modules = {'os.path': ('code', {'join': ('function', 1, 2)}, {'join': 'index'}, 'os.path')}
+                self.config = config
+            
+        class MockBuilder:
+            def __init__(self, name, env):
+                self.name = name
+                self.env = env
+                self.highlighter = None
+                self.get_relative_uri = lambda x, y: f"{x}->{y}"
+        
+        class MockApp:
+            def __init__(self, builder_name):
+                config = MockConfig()
+                env = MockEnv(config)
+                self.builder = MockBuilder(builder_name, env)
+                self.verbosity = 1
+        
+        # Test with epub builder - should generate no pages
+        epub_app = MockApp('epub')
+        pages = list(patched_collect_pages(epub_app))
+        
+        print(f"Number of pages generated for epub builder with patched function: {len(pages)}")
+        if len(pages) == 0:
+            print("PATCH WORKS: No pages generated for epub builder when viewcode_enable_epub=False")
+            return True
+        else:
+            print("PATCH FAILED: Pages still generated")
+            return False
+
+if __name__ == '__main__':
+    success = test_viewcode_epub_issue()
+    print(f"Test result: {'PASS' if success else 'FAIL'}")
\ No newline at end of file
diff --git a/setup.py b/setup.py
index 8d40de1a8..03f325278 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..0de6b5a88
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify the epub check in collect_pages function.
+"""
+
+def test_epub_check():
+    print("Testing the epub check in collect_pages function...")
+    
+    # Read the collect_pages function and check if it has the epub check
+    with open('/testbed/sphinx/ext/viewcode.py', 'r') as f:
+        content = f.read()
+    
+    # Check if the epub check exists in collect_pages
+    if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in content:
+        # Find the line numbers
+        lines = content.split('\n')
+        for i, line in enumerate(lines):
+            if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in line:
+                print(f"✓ Found epub check at line {i+1}")
+                break
+        
+        # Check if it's in the collect_pages function
+        collect_pages_start = content.find('def collect_pages(')
+        collect_pages_end = content.find('def ', collect_pages_start + 1)
+        collect_pages_code = content[collect_pages_start:collect_pages_end]
+        
+        if 'if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:' in collect_pages_code:
+            print("✓ Epub check is correctly placed in collect_pages function")
+            return True
+        else:
+            print("✗ Epub check is not in collect_pages function")
+            return False
+    else:
+        print("✗ Epub check not found in viewcode.py")
+        return False
+
+if __name__ == '__main__':
+    success = test_epub_check()
+    print(f"Test result: {'PASS' if success else 'FAIL'}")
\ No newline at end of file
diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py
index a7d52a91c..060604e25 100644
--- a/sphinx/ext/viewcode.py
+++ b/sphinx/ext/viewcode.py
@@ -182,6 +182,8 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non
     env = app.builder.env
     if not hasattr(env, '_viewcode_modules'):
         return
+    if app.builder.name.startswith("epub") and not env.config.viewcode_enable_epub:
+        return
     highlighter = app.builder.highlighter  # type: ignore
     urito = app.builder.get_relative_uri
 
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..18c00af48
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the viewcode epub fix works correctly.
+"""
+
+from sphinx.ext.viewcode import collect_pages
+
+def test_fix():
+    print("Testing the viewcode epub fix...")
+    
+    # Mock classes for testing
+    class MockConfig:
+        def __init__(self, viewcode_enable_epub=False):
+            self.viewcode_enable_epub = viewcode_enable_epub
+            self.highlight_language = 'python'
+    
+    class MockEnv:
+        def __init__(self, config):
+            self._viewcode_modules = {'os.path': ('code', {'join': ('function', 1, 2)}, {'join': 'index'}, 'os.path')}
+            self.config = config
+    
+    class MockBuilder:
+        def __init__(self, name, env):
+            self.name = name
+            self.env = env
+            self.highlighter = None
+            self.get_relative_uri = lambda x, y: f"{x}->{y}"
+    
+    class MockApp:
+        def __init__(self, builder_name, viewcode_enable_epub=False):
+            config = MockConfig(viewcode_enable_epub)
+            env = MockEnv(config)
+            self.builder = MockBuilder(builder_name, env)
+            self.verbosity = 1
+    
+    # Test 1: epub builder with viewcode_enable_epub=False (should generate no pages)
+    print("\nTest 1: epub builder with viewcode_enable_epub=False")
+    epub_app_false = MockApp('epub', False)
+    pages = list(collect_pages(epub_app_false))
+    print(f"Pages generated: {len(pages)}")
+    assert len(pages) == 0, "Should generate no pages for epub when viewcode_enable_epub=False"
+    print("✓ PASS")
+    
+    # Test 2: epub builder with viewcode_enable_epub=True (should generate pages)
+    print("\nTest 2: epub builder with viewcode_enable_epub=True")
+    epub_app_true = MockApp('epub', True)
+    pages = list(collect_pages(epub_app_true))
+    print(f"Pages generated: {len(pages)}")
+    assert len(pages) > 0, "Should generate pages for epub when viewcode_enable_epub=True"
+    print("✓ PASS")
+    
+    # Test 3: html builder (should generate pages regardless of viewcode_enable_epub)
+    print("\nTest 3: html builder with viewcode_enable_epub=False")
+    html_app = MockApp('html', False)
+    pages = list(collect_pages(html_app))
+    print(f"Pages generated: {len(pages)}")
+    assert len(pages) > 0, "Should generate pages for html builder regardless of viewcode_enable_epub"
+    print("✓ PASS")
+    
+    # Test 4: epub3 builder (should also be handled)
+    print("\nTest 4: epub3 builder with viewcode_enable_epub=False")
+    epub3_app = MockApp('epub3', False)
+    pages = list(collect_pages(epub3_app))
+    print(f"Pages generated: {len(pages)}")
+    assert len(pages) == 0, "Should generate no pages for epub3 when viewcode_enable_epub=False"
+    print("✓ PASS")
+    
+    print("\nAll tests passed! The fix is working correctly.")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index 21a0faec3..be1a9127e 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3