diff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py
index ac97f13161..d178493599 100644
--- a/django/core/management/commands/loaddata.py
+++ b/django/core/management/commands/loaddata.py
@@ -362,7 +362,7 @@ class Command(BaseCommand):
         """
         dirs = []
         fixture_dirs = settings.FIXTURE_DIRS
-        if len(fixture_dirs) != len(set(fixture_dirs)):
+        if len(fixture_dirs) != len(set(str(d) for d in fixture_dirs)):
             raise ImproperlyConfigured("settings.FIXTURE_DIRS contains duplicates.")
         for app_config in apps.get_app_configs():
             app_label = app_config.label
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d93612ac98
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where FIXTURE_DIRS duplicates are not detected
+when dir is a Path instance.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key-for-reproduction',
+    FIXTURE_DIRS=[],
+)
+
+def test_path_duplicates():
+    """Test that Path instances in FIXTURE_DIRS are properly checked for duplicates."""
+    
+    # Create a temporary directory for testing
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create two Path objects pointing to the same directory
+    path1 = Path(test_dir)
+    path2 = Path(test_dir)
+    
+    print(f"Path 1: {path1}")
+    print(f"Path 2: {path2}")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    
+    # Set up FIXTURE_DIRS with duplicate Path instances
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    print(f"FIXTURE_DIRS: {settings.FIXTURE_DIRS}")
+    print(f"Number of directories: {len(settings.FIXTURE_DIRS)}")
+    print(f"Number of unique directories: {len(set(settings.FIXTURE_DIRS))}")
+    
+    # Create a command instance and try to access fixture_dirs
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+def test_string_duplicates():
+    """Test that string paths in FIXTURE_DIRS are properly checked for duplicates."""
+    
+    # Create a temporary directory for testing
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create two string paths pointing to the same directory
+    str1 = test_dir
+    str2 = test_dir
+    
+    print(f"String 1: {str1}")
+    print(f"String 2: {str2}")
+    print(f"Are they equal? {str1 == str2}")
+    
+    # Set up FIXTURE_DIRS with duplicate string paths
+    settings.FIXTURE_DIRS = [str1, str2]
+    
+    print(f"FIXTURE_DIRS: {settings.FIXTURE_DIRS}")
+    print(f"Number of directories: {len(settings.FIXTURE_DIRS)}")
+    print(f"Number of unique directories: {len(set(settings.FIXTURE_DIRS))}")
+    
+    # Create a command instance and try to access fixture_dirs
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing Path instance duplicates...")
+    path_result = test_path_duplicates()
+    
+    print("\nTesting string duplicates...")
+    string_result = test_string_duplicates()
+    
+    print(f"\nPath duplicates test: {'PASSED' if path_result else 'FAILED'}")
+    print(f"String duplicates test: {'PASSED' if string_result else 'FAILED'}")
\ No newline at end of file
diff --git a/reproduce_issue_detailed.py b/reproduce_issue_detailed.py
new file mode 100644
index 0000000000..22372311e4
--- /dev/null
+++ b/reproduce_issue_detailed.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+"""
+Detailed script to reproduce the issue where FIXTURE_DIRS duplicates are not detected
+when dir is a Path instance with different representations of the same path.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key-for-reproduction',
+    FIXTURE_DIRS=[],
+)
+
+def test_different_path_representations():
+    """Test with different Path representations of the same directory."""
+    
+    # Create a temporary directory for testing
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create different Path representations of the same directory
+    path1 = Path(test_dir)
+    path2 = Path("/tmp") / "test_fixtures"  # Different way to construct the same path
+    path3 = Path(test_dir + "/")  # With trailing slash
+    
+    print(f"Path 1: {path1} (type: {type(path1)})")
+    print(f"Path 2: {path2} (type: {type(path2)})")
+    print(f"Path 3: {path3} (type: {type(path3)})")
+    print(f"Path1 == Path2: {path1 == path2}")
+    print(f"Path1 == Path3: {path1 == path3}")
+    print(f"str(Path1) == str(Path2): {str(path1) == str(path2)}")
+    print(f"str(Path1) == str(Path3): {str(path1) == str(path3)}")
+    
+    # Test with the original duplicate detection logic
+    fixture_dirs = [path1, path2]
+    print(f"\nOriginal logic - len(fixture_dirs): {len(fixture_dirs)}")
+    print(f"Original logic - len(set(fixture_dirs)): {len(set(fixture_dirs))}")
+    print(f"Original logic - duplicates detected: {len(fixture_dirs) != len(set(fixture_dirs))}")
+    
+    # Test with string conversion for duplicate detection
+    str_fixture_dirs = [str(d) for d in fixture_dirs]
+    print(f"\nString conversion - len(str_fixture_dirs): {len(str_fixture_dirs)}")
+    print(f"String conversion - len(set(str_fixture_dirs)): {len(set(str_fixture_dirs))}")
+    print(f"String conversion - duplicates detected: {len(str_fixture_dirs) != len(set(str_fixture_dirs))}")
+    
+    # Now test with the actual Django command
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    print(f"\nFIXTURE_DIRS: {settings.FIXTURE_DIRS}")
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+def test_real_world_scenario():
+    """Test a more realistic scenario that might trigger the bug."""
+    
+    # Create different path representations that should be considered duplicates
+    base_dir = "/tmp/test_fixtures"
+    os.makedirs(base_dir, exist_ok=True)
+    
+    # Different ways to represent the same path
+    path_reprs = [
+        Path(base_dir),
+        Path("/tmp/test_fixtures"),
+        Path("/tmp") / "test_fixtures",
+        Path(base_dir + "/"),
+        Path("/tmp/test_fixtures/"),
+    ]
+    
+    print("Testing different path representations of the same directory:")
+    for i, path in enumerate(path_reprs):
+        print(f"  {i+1}. {path} -> {str(path)}")
+    
+    # Test each pair combination
+    for i in range(len(path_reprs)):
+        for j in range(i+1, len(path_reprs)):
+            path1, path2 = path_reprs[i], path_reprs[j]
+            settings.FIXTURE_DIRS = [path1, path2]
+            
+            print(f"\nTesting pair: {path1} vs {path2}")
+            print(f"  Are they equal? {path1 == path2}")
+            print(f"  String representations equal? {str(path1) == str(path2)}")
+            
+            command = Command()
+            
+            try:
+                dirs = command.fixture_dirs
+                print("  RESULT: No duplicate detected (POTENTIAL BUG)")
+                return False
+            except ImproperlyConfigured as e:
+                print(f"  RESULT: Duplicate detected properly: {e}")
+            except Exception as e:
+                print(f"  UNEXPECTED ERROR: {e}")
+                return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("=== Testing different Path representations ===")
+    result1 = test_different_path_representations()
+    
+    print("\n=== Testing real-world scenarios ===")
+    result2 = test_real_world_scenario()
+    
+    print(f"\nPath representations test: {'PASSED' if result1 else 'FAILED'}")
+    print(f"Real-world scenarios test: {'PASSED' if result2 else 'FAILED'}")
\ No newline at end of file
diff --git a/test_fix_verification.py b/test_fix_verification.py
new file mode 100644
index 0000000000..22acf2fe78
--- /dev/null
+++ b/test_fix_verification.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python3
+"""
+Test to verify that the fix for Path object duplicates works correctly.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_fix():
+    """Test that the fix properly detects duplicates with mixed types."""
+    
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Test scenarios that should be detected as duplicates
+    scenarios = [
+        # Mixed Path and string
+        [Path(test_dir), test_dir],
+        
+        # Mixed Path and string with trailing slash
+        [Path(test_dir), test_dir + "/"],
+        
+        # Different Path objects representing same path
+        [Path(test_dir), Path("/tmp/test_fixtures")],
+        
+        # Path objects constructed differently
+        [Path(test_dir), Path("/tmp") / "test_fixtures"],
+    ]
+    
+    print("=== Testing Fix for Path Object Duplicates ===")
+    
+    for i, paths in enumerate(scenarios, 1):
+        print(f"\nScenario {i}: {paths}")
+        
+        # Test the fixed duplicate detection logic
+        fixture_dirs = paths
+        unique_dirs = set(str(d) for d in fixture_dirs)
+        duplicates_detected = len(fixture_dirs) != len(unique_dirs)
+        
+        print(f"  Number of directories: {len(fixture_dirs)}")
+        print(f"  Number of unique directories (string-based): {len(unique_dirs)}")
+        print(f"  Duplicates detected: {duplicates_detected}")
+        
+        # Test with actual Django command
+        settings.FIXTURE_DIRS = paths
+        
+        command = Command()
+        
+        try:
+            dirs = command.fixture_dirs
+            if duplicates_detected:
+                print("  ERROR: Duplicates should have been detected but weren't!")
+                return False
+            else:
+                print("  SUCCESS: No duplicates detected (as expected)")
+        except ImproperlyConfigured as e:
+            if duplicates_detected:
+                print(f"  SUCCESS: Duplicates properly detected: {e}")
+            else:
+                print(f"  ERROR: Unexpected duplicate detection: {e}")
+                return False
+        except Exception as e:
+            print(f"  UNEXPECTED ERROR: {e}")
+            return False
+    
+    return True
+
+if __name__ == "__main__":
+    result = test_fix()
+    print(f"\nOverall test result: {'PASSED' if result else 'FAILED'}")
\ No newline at end of file
diff --git a/test_github_issue_scenario.py b/test_github_issue_scenario.py
new file mode 100644
index 0000000000..19b2728201
--- /dev/null
+++ b/test_github_issue_scenario.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Test to reproduce the exact scenario described in the GitHub issue.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_github_issue_scenario():
+    """Test the exact scenario described in the GitHub issue."""
+    
+    print("=== Testing GitHub Issue Scenario ===")
+    
+    # Create a test directory
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Simulate how FIXTURE_DIRS might be set in a real Django project
+    # where Path instances are used instead of strings
+    
+    # Scenario 1: Path instances created at different times
+    path1 = Path(test_dir)
+    path2 = Path(test_dir)  # Another Path instance for the same directory
+    
+    print(f"Path 1: {path1} (id: {id(path1)})")
+    print(f"Path 2: {path2} (id: {id(path2)})")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    
+    # Test the current Django duplicate detection
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    print(f"FIXTURE_DIRS: {settings.FIXTURE_DIRS}")
+    
+    # The issue might be that the duplicate detection happens at a different
+    # point in the code, or there might be a timing issue
+    
+    # Let's test the exact code from the fixture_dirs method
+    fixture_dirs = settings.FIXTURE_DIRS
+    print(f"Number of fixture_dirs: {len(fixture_dirs)}")
+    print(f"Number of unique fixture_dirs (set): {len(set(fixture_dirs))}")
+    
+    # This is the exact check from the Django source code
+    if len(fixture_dirs) != len(set(fixture_dirs)):
+        print("SUCCESS: Duplicates detected by current logic")
+        raise ImproperlyConfigured("settings.FIXTURE_DIRS contains duplicates.")
+    else:
+        print("ERROR: Duplicates not detected by current logic")
+        return False
+    
+    return True
+
+def test_with_actual_command():
+    """Test with the actual loaddata command."""
+    
+    print("\n=== Testing with Actual Command ===")
+    
+    test_dir = "/tmp/test_fixtures"
+    path1 = Path(test_dir)
+    path2 = Path(test_dir)
+    
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    try:
+        result1 = test_github_issue_scenario()
+        print(f"GitHub issue test: {'PASSED' if result1 else 'FAILED'}")
+    except ImproperlyConfigured as e:
+        print(f"GitHub issue test: PASSED (Exception: {e})")
+        result1 = True
+    
+    result2 = test_with_actual_command()
+    print(f"Actual command test: {'PASSED' if result2 else 'FAILED'}")
\ No newline at end of file
diff --git a/test_mixed_types.py b/test_mixed_types.py
new file mode 100644
index 0000000000..d63fcf0c92
--- /dev/null
+++ b/test_mixed_types.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+"""
+Test scenarios with mixed types in FIXTURE_DIRS that might cause duplicate detection issues.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_mixed_types_scenario():
+    """Test scenarios with mixed types in FIXTURE_DIRS."""
+    
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    scenarios = [
+        # Scenario 1: Mixed Path and string
+        [Path(test_dir), test_dir],
+        
+        # Scenario 2: Mixed Path and string with different representations
+        [Path(test_dir), test_dir + "/"],
+        
+        # Scenario 3: Path objects from different sources
+        [Path(test_dir), Path("/tmp/test_fixtures")],
+    ]
+    
+    for i, paths in enumerate(scenarios, 1):
+        print(f"=== Scenario {i} ===")
+        print(f"Paths: {paths}")
+        
+        # Test the current Django duplicate detection logic
+        fixture_dirs = paths
+        print(f"Number of fixture_dirs: {len(fixture_dirs)}")
+        print(f"Number of unique fixture_dirs (set): {len(set(fixture_dirs))}")
+        
+        # This is the exact check from the Django source code
+        if len(fixture_dirs) != len(set(fixture_dirs)):
+            print("SUCCESS: Duplicates detected by current logic")
+            try:
+                raise ImproperlyConfigured("settings.FIXTURE_DIRS contains duplicates.")
+            except ImproperlyConfigured as e:
+                print(f"Exception: {e}")
+        else:
+            print("ERROR: Duplicates not detected by current logic")
+        
+        print()
+
+def test_with_actual_django():
+    """Test with actual Django command to see if there are any edge cases."""
+    
+    print("=== Testing with Actual Django Command ===")
+    
+    test_dir = "/tmp/test_fixtures"
+    
+    # Test the scenario that might cause issues: mixed Path and string
+    settings.FIXTURE_DIRS = [Path(test_dir), test_dir]
+    
+    print(f"FIXTURE_DIRS: {settings.FIXTURE_DIRS}")
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    test_mixed_types_scenario()
+    result = test_with_actual_django()
+    print(f"Test result: {'PASSED' if result else 'FAILED'}")
\ No newline at end of file
diff --git a/test_path_comparison.py b/test_path_comparison.py
new file mode 100644
index 0000000000..998cd22ec9
--- /dev/null
+++ b/test_path_comparison.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Test to understand how Path objects are compared in sets.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+def test_path_comparison():
+    """Test how Path objects behave in set comparisons."""
+    
+    # Create a test directory
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create different Path objects pointing to the same directory
+    path1 = Path(test_dir)
+    path2 = Path("/tmp/test_fixtures")  # Different Path object, same directory
+    path3 = Path("/tmp") / "test_fixtures"  # Another way to construct the same path
+    path4 = Path(test_dir + "/")  # With trailing slash
+    
+    paths = [path1, path2, path3, path4]
+    
+    print("Testing Path object comparison:")
+    for i, path in enumerate(paths):
+        print(f"  Path {i+1}: {path} (id: {id(path)})")
+    
+    print("\nComparison results:")
+    for i in range(len(paths)):
+        for j in range(i+1, len(paths)):
+            p1, p2 = paths[i], paths[j]
+            print(f"  {p1} == {p2}: {p1 == p2}")
+            print(f"  {p1} is {p2}: {p1 is p2}")
+            print(f"  hash({p1}) == hash({p2}): {hash(p1) == hash(p2)}")
+    
+    print("\nSet behavior:")
+    path_set = set(paths)
+    print(f"  Original list length: {len(paths)}")
+    print(f"  Set length: {len(path_set)}")
+    print(f"  Set contents: {path_set}")
+    
+    # Test with string conversion
+    str_paths = [str(p) for p in paths]
+    str_set = set(str_paths)
+    print(f"\nString conversion:")
+    print(f"  Original string list length: {len(str_paths)}")
+    print(f"  String set length: {len(str_set)}")
+    print(f"  String set contents: {str_set}")
+
+if __name__ == "__main__":
+    test_path_comparison()
\ No newline at end of file
diff --git a/test_path_duplicate_issue.py b/test_path_duplicate_issue.py
new file mode 100644
index 0000000000..14ec890f7d
--- /dev/null
+++ b/test_path_duplicate_issue.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+"""
+Test to reproduce the issue with Path object duplicates in FIXTURE_DIRS.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_path_duplicates():
+    """Test that duplicate Path objects are detected."""
+    
+    # Create a test directory
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create different Path objects pointing to the same directory
+    path1 = Path(test_dir)
+    path2 = Path("/tmp/test_fixtures")  # Different Path object, same directory
+    
+    print(f"Path 1: {path1} (id: {id(path1)})")
+    print(f"Path 2: {path2} (id: {id(path2)})")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    
+    # Test the current duplicate detection logic
+    fixture_dirs = [path1, path2]
+    print(f"Number of directories: {len(fixture_dirs)}")
+    print(f"Number of unique directories (set): {len(set(fixture_dirs))}")
+    
+    # Check if duplicates would be detected
+    duplicates_detected = len(fixture_dirs) != len(set(fixture_dirs))
+    print(f"Duplicates detected by current logic: {duplicates_detected}")
+    
+    # Test with actual Django command
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        print(f"Fixture dirs: {dirs}")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    result = test_path_duplicates()
+    print(f"\nTest result: {'PASSED' if result else 'FAILED'}")
\ No newline at end of file
diff --git a/test_path_duplicates.py b/test_path_duplicates.py
new file mode 100644
index 0000000000..b9d4c89147
--- /dev/null
+++ b/test_path_duplicates.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Test to reproduce the specific issue with Path object duplicates in FIXTURE_DIRS.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+from django.test import TestCase, override_settings
+
+def test_path_duplicate_detection():
+    """Test that duplicate Path objects in FIXTURE_DIRS are properly detected."""
+    
+    # Get the current directory for testing
+    _cur_dir = os.path.dirname(os.path.abspath(__file__))
+    
+    # Create different Path objects that represent the same directory
+    path1 = Path(_cur_dir) / "fixtures_1"
+    path2 = Path(_cur_dir) / "fixtures_1"  # This creates a new Path object
+    
+    print(f"Path 1: {path1} (id: {id(path1)})")
+    print(f"Path 2: {path2} (id: {id(path2)})")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    
+    # Test the current duplicate detection logic
+    fixture_dirs = [path1, path2]
+    print(f"Number of directories: {len(fixture_dirs)}")
+    print(f"Number of unique directories (set): {len(set(fixture_dirs))}")
+    
+    # The issue: set() comparison might not work correctly with Path objects
+    # if they are different objects but represent the same path
+    unique_dirs = set(fixture_dirs)
+    print(f"Unique directories: {unique_dirs}")
+    
+    # Check if the current logic would detect duplicates
+    duplicates_detected = len(fixture_dirs) != len(unique_dirs)
+    print(f"Duplicates detected by current logic: {duplicates_detected}")
+    
+    # Now test with the actual Django command
+    with override_settings(FIXTURE_DIRS=[path1, path2]):
+        command = Command()
+        
+        try:
+            dirs = command.fixture_dirs
+            print("ERROR: Duplicate detection failed! No exception was raised.")
+            print(f"Fixture dirs: {dirs}")
+            return False
+        except ImproperlyConfigured as e:
+            print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+            return True
+        except Exception as e:
+            print(f"UNEXPECTED ERROR: {e}")
+            return False
+
+if __name__ == "__main__":
+    django.setup()
+    result = test_path_duplicate_detection()
+    print(f"\nTest result: {'PASSED' if result else 'FAILED'}")
\ No newline at end of file
diff --git a/test_path_edge_case.py b/test_path_edge_case.py
new file mode 100644
index 0000000000..8b949603fc
--- /dev/null
+++ b/test_path_edge_case.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+"""
+Test to find edge cases where Path objects might not compare equal in sets.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+def test_path_edge_cases():
+    """Test edge cases where Path objects might not compare equal."""
+    
+    # Test case 1: Path objects with different types but same path
+    print("=== Test Case 1: Different Path types ===")
+    
+    # Create Path objects in different ways that might cause issues
+    path1 = Path("/tmp/test")
+    path2 = Path("/tmp") / "test"
+    path3 = Path("/tmp/../tmp/test")  # This should resolve to /tmp/test
+    
+    paths = [path1, path2, path3]
+    print(f"Paths: {paths}")
+    
+    # Test equality
+    for i in range(len(paths)):
+        for j in range(i+1, len(paths)):
+            p1, p2 = paths[i], paths[j]
+            print(f"  {p1} == {p2}: {p1 == p2}")
+            print(f"  hash({p1}) == hash({p2}): {hash(p1) == hash(p2)}")
+    
+    # Test set behavior
+    path_set = set(paths)
+    print(f"Set length: {len(path_set)} (original: {len(paths)})")
+    print(f"Set contents: {path_set}")
+    
+    # Test case 2: Path objects with non-existent paths
+    print("\n=== Test Case 2: Non-existent paths ===")
+    path1 = Path("/non/existent/path")
+    path2 = Path("/non/existent/path")
+    
+    paths = [path1, path2]
+    print(f"Paths: {paths}")
+    
+    # Test equality
+    print(f"  {path1} == {path2}: {path1 == path2}")
+    print(f"  hash({path1}) == hash({path2}): {hash(path1) == hash(path2)}")
+    
+    # Test set behavior
+    path_set = set(paths)
+    print(f"Set length: {len(path_set)} (original: {len(paths)})")
+    print(f"Set contents: {path_set}")
+    
+    # Test case 3: Path objects from different pathlib versions or implementations
+    print("\n=== Test Case 3: Path objects with different string representations ===")
+    path1 = Path("/tmp/test/")
+    path2 = Path("/tmp/test")
+    
+    paths = [path1, path2]
+    print(f"Paths: {paths}")
+    
+    # Test equality
+    print(f"  {path1} == {path2}: {path1 == path2}")
+    print(f"  hash({path1}) == hash({path2}): {hash(path1) == hash(path2)}")
+    
+    # Test set behavior
+    path_set = set(paths)
+    print(f"Set length: {len(path_set)} (original: {len(paths)})")
+    print(f"Set contents: {path_set}")
+
+if __name__ == "__main__":
+    test_path_edge_cases()
\ No newline at end of file
diff --git a/test_path_edge_cases.py b/test_path_edge_cases.py
new file mode 100644
index 0000000000..d9cf724bc7
--- /dev/null
+++ b/test_path_edge_cases.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for Path object comparison that might cause the duplicate detection issue.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_path_edge_cases():
+    """Test various edge cases with Path objects."""
+    
+    # Create a test directory
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Test case 1: Different Path objects representing the same path
+    print("=== Test Case 1: Different Path objects, same path ===")
+    path1 = Path(test_dir)
+    path2 = Path("/tmp/test_fixtures")
+    test_duplicate_detection([path1, path2])
+    
+    # Test case 2: Path objects with trailing slashes
+    print("\n=== Test Case 2: Path objects with trailing slashes ===")
+    path1 = Path(test_dir)
+    path2 = Path(test_dir + "/")
+    test_duplicate_detection([path1, path2])
+    
+    # Test case 3: Path objects constructed differently
+    print("\n=== Test Case 3: Path objects constructed differently ===")
+    path1 = Path(test_dir)
+    path2 = Path("/tmp") / "test_fixtures"
+    test_duplicate_detection([path1, path2])
+    
+    # Test case 4: Relative vs absolute paths
+    print("\n=== Test Case 4: Relative vs absolute paths ===")
+    path1 = Path(test_dir)
+    path2 = Path("./test_fixtures")  # This should be different
+    test_duplicate_detection([path1, path2])
+    
+    # Test case 5: Resolved paths
+    print("\n=== Test Case 5: Resolved paths ===")
+    path1 = Path(test_dir)
+    path2 = Path("/tmp/../tmp/test_fixtures")  # This should resolve to the same path
+    test_duplicate_detection([path1, path2])
+
+def test_duplicate_detection(paths):
+    """Test duplicate detection with the given paths."""
+    
+    print(f"Testing paths: {paths}")
+    
+    # Test set behavior
+    path_set = set(paths)
+    print(f"  Set length: {len(path_set)} (original: {len(paths)})")
+    print(f"  Set contents: {path_set}")
+    
+    # Test Django duplicate detection
+    settings.FIXTURE_DIRS = paths
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("  RESULT: No duplicate detected")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"  RESULT: Duplicate detected: {e}")
+        return True
+    except Exception as e:
+        print(f"  UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    test_path_edge_cases()
\ No newline at end of file
diff --git a/test_realistic_scenario.py b/test_realistic_scenario.py
new file mode 100644
index 0000000000..348e3ae8c9
--- /dev/null
+++ b/test_realistic_scenario.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Test a more realistic scenario that might trigger the Path duplicate detection issue.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+def test_realistic_scenario():
+    """Test a scenario that might reveal the Path duplicate detection issue."""
+    
+    # Create a test directory structure
+    base_dir = "/tmp/test_project"
+    os.makedirs(base_dir, exist_ok=True)
+    
+    # Simulate different ways Path objects might be created in a real project
+    scenarios = [
+        # Scenario 1: Path objects created from different string representations
+        [Path("/tmp/test_project"), Path("/tmp/test_project/")],
+        
+        # Scenario 2: Path objects created using different construction methods
+        [Path("/tmp/test_project"), Path("/tmp") / "test_project"],
+        
+        # Scenario 3: Path objects with different case (on case-insensitive filesystems)
+        [Path("/tmp/test_project"), Path("/tmp/TEST_PROJECT")],
+        
+        # Scenario 4: Path objects from different modules or imports
+        [Path("/tmp/test_project"), Path("/tmp/test_project")],
+    ]
+    
+    for i, paths in enumerate(scenarios, 1):
+        print(f"=== Scenario {i} ===")
+        print(f"Paths: {paths}")
+        
+        # Test basic equality
+        equal = paths[0] == paths[1]
+        print(f"  Equal: {equal}")
+        
+        # Test hash equality
+        hash_equal = hash(paths[0]) == hash(paths[1])
+        print(f"  Hash equal: {hash_equal}")
+        
+        # Test set behavior
+        path_set = set(paths)
+        duplicates_detected = len(paths) != len(path_set)
+        print(f"  Duplicates detected by set: {duplicates_detected}")
+        print(f"  Set length: {len(path_set)} (original: {len(paths)})")
+        
+        # Test string conversion approach
+        str_paths = [str(p) for p in paths]
+        str_set = set(str_paths)
+        str_duplicates_detected = len(str_paths) != len(str_set)
+        print(f"  String-based duplicates detected: {str_duplicates_detected}")
+        print(f"  String set length: {len(str_set)}")
+        
+        print()
+
+if __name__ == "__main__":
+    test_realistic_scenario()
\ No newline at end of file
diff --git a/test_realpath_issue.py b/test_realpath_issue.py
new file mode 100644
index 0000000000..353722c311
--- /dev/null
+++ b/test_realpath_issue.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+"""
+Test to see if os.path.realpath() on Path objects could cause issues.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+def test_realpath_with_path_objects():
+    """Test how os.path.realpath() behaves with Path objects."""
+    
+    # Create a test directory with a symlink to test realpath behavior
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # Create a symlink to test realpath behavior
+    symlink_path = "/tmp/fixtures_symlink"
+    if os.path.exists(symlink_path):
+        os.remove(symlink_path)
+    os.symlink(test_dir, symlink_path)
+    
+    # Test different scenarios
+    scenarios = [
+        # Regular Path objects
+        [Path(test_dir), Path(test_dir)],
+        
+        # Path objects with symlinks
+        [Path(test_dir), Path(symlink_path)],
+        
+        # Mixed Path and string
+        [Path(test_dir), test_dir],
+    ]
+    
+    for i, paths in enumerate(scenarios, 1):
+        print(f"=== Scenario {i} ===")
+        print(f"Input paths: {paths}")
+        
+        # Test os.path.realpath on each path
+        realpaths = [os.path.realpath(str(p)) if isinstance(p, Path) else os.path.realpath(p) for p in paths]
+        print(f"Realpaths: {realpaths}")
+        
+        # Test if they become the same after realpath
+        unique_realpaths = set(realpaths)
+        print(f"Unique realpaths: {unique_realpaths}")
+        print(f"Duplicates detected: {len(realpaths) != len(unique_realpaths)}")
+        
+        print()
+
+if __name__ == "__main__":
+    test_realpath_with_path_objects()
\ No newline at end of file
diff --git a/test_simple_fix.py b/test_simple_fix.py
new file mode 100644
index 0000000000..dc8a6c9d49
--- /dev/null
+++ b/test_simple_fix.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify the fix for the specific GitHub issue scenario.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure minimal settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    FIXTURE_DIRS=[],
+)
+
+def test_simple_scenario():
+    """Test the specific scenario mentioned in the GitHub issue."""
+    
+    test_dir = "/tmp/test_fixtures"
+    os.makedirs(test_dir, exist_ok=True)
+    
+    # The specific scenario: FIXTURE_DIRS contains Path instances
+    path1 = Path(test_dir)
+    path2 = Path(test_dir)  # Another Path instance for the same directory
+    
+    print("=== Testing GitHub Issue Scenario ===")
+    print(f"Path 1: {path1}")
+    print(f"Path 2: {path2}")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    
+    # Test the fixed duplicate detection logic
+    fixture_dirs = [path1, path2]
+    unique_dirs = set(str(d) for d in fixture_dirs)
+    duplicates_detected = len(fixture_dirs) != len(unique_dirs)
+    
+    print(f"Number of directories: {len(fixture_dirs)}")
+    print(f"Number of unique directories (string-based): {len(unique_dirs)}")
+    print(f"Duplicates detected: {duplicates_detected}")
+    
+    # Test with actual Django command
+    settings.FIXTURE_DIRS = [path1, path2]
+    
+    command = Command()
+    
+    try:
+        dirs = command.fixture_dirs
+        print("ERROR: Duplicate detection failed! No exception was raised.")
+        return False
+    except ImproperlyConfigured as e:
+        print(f"SUCCESS: Duplicate detection worked! Exception: {e}")
+        return True
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+
+if __name__ == "__main__":
+    result = test_simple_scenario()
+    print(f"\nTest result: {'PASSED' if result else 'FAILED'}")
\ No newline at end of file