diff --git a/debug_precedence.py b/debug_precedence.py
new file mode 100644
index 0000000000..5f50bb487d
--- /dev/null
+++ b/debug_precedence.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, symbols, Mul
+from sympy.printing.precedence import precedence
+from sympy.printing.pycode import PythonCodePrinter
+
+x, y = symbols('x y')
+
+# Test different expressions
+expr1 = Mod(x, y)
+expr2 = -Mod(x, y)
+expr3 = 2 * Mod(x, y)
+expr4 = (x + 1) * Mod(x, y)
+
+print("Precedence values:")
+print(f"Mod(x, y): {precedence(expr1)}")
+print(f"-Mod(x, y): {precedence(expr2)}")
+print(f"2 * Mod(x, y): {precedence(expr3)}")
+print(f"(x + 1) * Mod(x, y): {precedence(expr4)}")
+
+print("\nTesting parenthesize behavior:")
+printer = PythonCodePrinter()
+
+# Test how parenthesize works with Mod
+PREC = precedence(expr1)
+print(f"Parenthesize Mod(x, y): {printer.parenthesize(expr1, PREC)}")
+
+# Test how parenthesize works with -Mod(x, y)
+PREC2 = precedence(expr2)
+print(f"Parenthesize -Mod(x, y): {printer.parenthesize(expr2, PREC2)}")
+
+# Test the actual _print_Mod output
+print(f"_print_Mod(Mod(x, y)): {printer._print_Mod(expr1)}")
+print(f"_print_Mod as part of -Mod(x, y): {printer._print(expr2)}")
+
+# Let's also check what the Mul precedence is
+print(f"Precedence of Mul: {precedence(Mul(2, Mod(x, y)))}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..6fb0146db0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Reproduce the issue described in the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Testing lambdify without modules parameter:")
+f = lambdify([x, y], expr)
+print(f"f(3, 7) = {f(3, 7)}")
+print("Source code:")
+print(inspect.getsource(f))
+print()
+
+print("Testing lambdify with modules=[]:")
+g = lambdify([x, y], expr, modules=[])
+print(f"g(3, 7) = {g(3, 7)}")
+print("Source code:")
+print(inspect.getsource(g))
+print()
+
+# Let's also test some other cases
+print("Testing with positive multiplier:")
+expr2 = 2 * Mod(x, y)
+h = lambdify([x, y], expr2, modules=[])
+print(f"h(3, 7) = {h(3, 7)}")
+print("Source code:")
+print(inspect.getsource(h))
+print()
+
+print("Testing with complex expression:")
+expr3 = (x + 1) * Mod(x, y)
+i = lambdify([x, y], expr3, modules=[])
+print(f"i(3, 7) = {i(3, 7)}")
+print("Source code:")
+print(inspect.getsource(i))
\ No newline at end of file
diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py
index 47ff463faf..9a2c9c21d9 100644
--- a/sympy/printing/precedence.py
+++ b/sympy/printing/precedence.py
@@ -48,6 +48,7 @@
     "KroneckerProduct": PRECEDENCE["Mul"],
     "Equality": PRECEDENCE["Mul"],
     "Unequality": PRECEDENCE["Mul"],
+    "Mod": PRECEDENCE["Mul"],
 }
 
 # Sometimes it's not enough to assign a fixed precedence value to a
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..1e116ef3c1 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -234,7 +234,16 @@ def _print_ComplexInfinity(self, expr):
 
     def _print_Mod(self, expr):
         PREC = precedence(expr)
-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+        mod_str = '{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args))
+        
+        # The modulus operator % in Python has lower precedence than unary operations
+        # but Mod expressions inherit Function precedence which is higher than unary operations.
+        # We need to ensure Mod expressions are properly parenthesized when used in larger expressions.
+        # Check if this is part of a larger expression where parentheses are needed.
+        if PREC > 40:  # If Mod precedence is higher than unary operations (40), force parentheses
+            return '({})'.format(mod_str)
+        else:
+            return mod_str
 
     def _print_Piecewise(self, expr):
         result = []
diff --git a/test_parenthesize.py b/test_parenthesize.py
new file mode 100644
index 0000000000..5b1c1b4647
--- /dev/null
+++ b/test_parenthesize.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, symbols, Mul
+from sympy.printing.precedence import precedence
+from sympy.printing.pycode import PythonCodePrinter
+
+x, y = symbols('x y')
+
+# Test the parenthesize method behavior
+printer = PythonCodePrinter()
+
+# Test Mod expression
+mod_expr = Mod(x, y)
+mod_prec = precedence(mod_expr)
+print(f"Mod(x, y) precedence: {mod_prec}")
+
+# Test unary minus expression
+neg_expr = -mod_expr
+neg_prec = precedence(neg_expr)
+print(f"-Mod(x, y) precedence: {neg_prec}")
+
+# Test what parenthesize does
+print(f"parenthesize(Mod(x, y), {neg_prec}): {printer.parenthesize(mod_expr, neg_prec)}")
+print(f"parenthesize(Mod(x, y), {mod_prec}): {printer.parenthesize(mod_expr, mod_prec)}")
+
+# The issue: when we have -Mod(x, y), the parenthesize method should add parentheses
+# around the Mod expression because the modulus operator has lower precedence than unary minus
+
+# Let's test what the actual Python precedence is
+print("\nPython operator precedence test:")
+print("Precedence of unary minus is higher than modulus operator %")
+print("-3 % 7 =", -3 % 7, "(unary minus has higher precedence)")
+print("-(3 % 7) =", -(3 % 7), "(modulus has higher precedence with parentheses)")
+
+# The fix: Mod expressions should always be parenthesized when used in contexts
+# where the modulus operator would have incorrect precedence
\ No newline at end of file