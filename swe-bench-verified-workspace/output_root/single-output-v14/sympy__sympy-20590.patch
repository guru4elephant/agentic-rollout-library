diff --git a/debug_symbol.py b/debug_symbol.py
new file mode 100644
index 0000000000..16426a7462
--- /dev/null
+++ b/debug_symbol.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+
+import sympy
+
+def debug_symbol_creation():
+    """Debug the Symbol creation process to understand why __dict__ exists"""
+    
+    # Create a symbol
+    s = sympy.Symbol('s')
+    
+    print("=== Symbol instance analysis ===")
+    print(f"Symbol('s'): {s}")
+    print(f"Symbol('s').__slots__: {s.__slots__}")
+    print(f"hasattr(s, '__dict__'): {hasattr(s, '__dict__')}")
+    
+    # Check MRO
+    print(f"\n=== MRO (Method Resolution Order) ===")
+    for i, cls in enumerate(s.__class__.__mro__):
+        print(f"{i}: {cls.__name__} (__slots__: {getattr(cls, '__slots__', 'NOT DEFINED')})")
+    
+    # Check if any class in MRO has __dict__ defined
+    print(f"\n=== Classes with __dict__ in MRO ===")
+    for cls in s.__class__.__mro__:
+        if hasattr(cls, '__dict__'):
+            print(f"{cls.__name__}: has __dict__")
+    
+    # Check if any class dynamically adds attributes
+    print(f"\n=== Checking for dynamic attribute assignment ===")
+    
+    # Let's see what's in the __dict__
+    if hasattr(s, '__dict__'):
+        print(f"s.__dict__ contents: {s.__dict__}")
+        print(f"len(s.__dict__): {len(s.__dict__)}")
+    
+    # Let's also check if we can assign new attributes
+    try:
+        s.new_attr = "test"
+        print(f"SUCCESS: Could assign new attribute: s.new_attr = {s.new_attr}")
+    except AttributeError as e:
+        print(f"FAILED: Could not assign new attribute: {e}")
+
+if __name__ == "__main__":
+    debug_symbol_creation()
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..f9b02156f8
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+
+import sympy
+
+def test_github_issue_reproduction():
+    """Test the exact scenario described in the GitHub issue"""
+    
+    print("=== Testing GitHub Issue Scenario ===")
+    
+    # Reproduce the exact test from the issue
+    s = sympy.Symbol('s')
+    
+    # Test 1: Check that __dict__ doesn't exist (should raise AttributeError)
+    try:
+        result = s.__dict__
+        print(f"FAIL: s.__dict__ returned: {result}")
+        return False
+    except AttributeError as e:
+        print(f"PASS: s.__dict__ raised AttributeError: {e}")
+    
+    # Test 2: Check that __slots__ exists and has the correct value
+    try:
+        slots = s.__slots__
+        if slots == ('name',):
+            print(f"PASS: s.__slots__ is correct: {slots}")
+        else:
+            print(f"FAIL: s.__slots__ is incorrect: {slots}")
+            return False
+    except AttributeError as e:
+        print(f"FAIL: s.__slots__ raised AttributeError: {e}")
+        return False
+    
+    # Test 3: Verify we can't assign arbitrary attributes
+    try:
+        s.new_attr = "test"
+        print("FAIL: Could assign new attribute to Symbol")
+        return False
+    except AttributeError:
+        print("PASS: Cannot assign new attributes to Symbol")
+    
+    # Test 4: Verify existing functionality still works
+    if s.name == 's':
+        print("PASS: s.name access works correctly")
+    else:
+        print(f"FAIL: s.name returned {s.name}, expected 's'")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_github_issue_reproduction()
+    print(f"\nOverall test {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..83578feb31
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+import sympy
+
+def test_symbol_dict_issue():
+    """Test the issue where Symbol instances have __dict__ in 1.7 but not in 1.6.2"""
+    
+    # Create a symbol
+    s = sympy.Symbol('s')
+    
+    print(f"Symbol('s'): {s}")
+    print(f"Symbol('s').__slots__: {s.__slots__}")
+    
+    # Check if __dict__ exists
+    has_dict = hasattr(s, '__dict__')
+    print(f"Symbol('s') has __dict__: {has_dict}")
+    
+    if has_dict:
+        print(f"Symbol('s').__dict__: {s.__dict__}")
+    
+    # Check if we can access __dict__ directly (this should fail if properly using __slots__)
+    try:
+        dict_result = s.__dict__
+        print(f"ERROR: Successfully accessed s.__dict__: {dict_result}")
+        return False
+    except AttributeError as e:
+        print(f"SUCCESS: AttributeError when accessing s.__dict__: {e}")
+        return True
+    
+    return not has_dict
+
+if __name__ == "__main__":
+    success = test_symbol_dict_issue()
+    print(f"\nTest {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/sympy/core/_print_helpers.py b/sympy/core/_print_helpers.py
index 96d7e72676..f7875b9eec 100644
--- a/sympy/core/_print_helpers.py
+++ b/sympy/core/_print_helpers.py
@@ -17,6 +17,8 @@ class Printable:
     This also adds support for LaTeX printing in jupyter notebooks.
     """
 
+    __slots__ = ()
+
     # Note, we always use the default ordering (lex) in __str__ and __repr__,
     # regardless of the global setting. See issue 5487.
     def __str__(self):