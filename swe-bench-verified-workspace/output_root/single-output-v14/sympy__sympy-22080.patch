diff --git a/detailed_test.py b/detailed_test.py
new file mode 100644
index 0000000000..1e226ea87f
--- /dev/null
+++ b/detailed_test.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Original expression:", expr)
+print()
+
+# Test with default modules
+print("=== With default modules ===")
+f = lambdify([x, y], expr)
+print("f(3, 7) =", f(3, 7))
+source = inspect.getsource(f)
+print("Source:")
+print(source)
+print()
+
+# Test with modules=[]
+print("=== With modules=[] ===")
+g = lambdify([x, y], expr, modules=[])
+print("g(3, 7) =", g(3, 7))
+source = inspect.getsource(g)
+print("Source:")
+print(source)
+print()
+
+# Test with modules='math'
+print("=== With modules='math' ===")
+h = lambdify([x, y], expr, modules='math')
+print("h(3, 7) =", h(3, 7))
+source = inspect.getsource(h)
+print("Source:")
+print(source)
+print()
+
+# Test with modules='numpy' (skipping since numpy not available)
+print("=== With modules='numpy' ===")
+print("Skipping numpy test (not available)")
+print()
+
+# Test what the correct result should be
+print("=== Expected results ===")
+print("Mod(3, 7) =", Mod(3, 7))
+print("-Mod(3, 7) =", -Mod(3, 7))
+print("-(3 % 7) =", -(3 % 7))
+print("(-3) % 7 =", (-3) % 7)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..72ddc2ee3e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Reproduce the issue described in the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test with default modules
+print("Testing with default modules:")
+f = lambdify([x, y], expr)
+print(f"f(3, 7) = {f(3, 7)}")
+print("Source code:")
+print(inspect.getsource(f))
+print()
+
+# Test with modules=[]
+print("Testing with modules=[]:")
+g = lambdify([x, y], expr, modules=[])
+print(f"g(3, 7) = {g(3, 7)}")
+print("Source code:")
+print(inspect.getsource(g))
+print()
+
+# Expected result should be the same for both
+print("Expected result: -Mod(3, 7) = -3")
+print(f"Actual with default: {f(3, 7)}")
+print(f"Actual with modules=[]: {g(3, 7)}")
\ No newline at end of file
diff --git a/test_mod_behavior.py b/test_mod_behavior.py
new file mode 100644
index 0000000000..19271a928a
--- /dev/null
+++ b/test_mod_behavior.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+from sympy import Mod, symbols
+import math
+
+# Test the Mod function behavior
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Symbolic expression:", expr)
+print("Substituting x=3, y=7:", expr.subs({x: 3, y: 7}))
+
+# Test Python's modulo behavior
+print("\nPython modulo behavior:")
+print("3 % 7 =", 3 % 7)
+print("-3 % 7 =", -3 % 7)
+print("-(3 % 7) =", -(3 % 7))
+
+# Test what should happen mathematically
+print("\nMathematical expectation:")
+print("Mod(3, 7) =", Mod(3, 7))
+print("-Mod(3, 7) =", -Mod(3, 7))
+print("Which should evaluate to:", -Mod(3, 7).evalf())
\ No newline at end of file
diff --git a/test_mod_precedence.py b/test_mod_precedence.py
new file mode 100644
index 0000000000..0e9f954414
--- /dev/null
+++ b/test_mod_precedence.py
@@ -0,0 +1,17 @@
+#!/usr/bin/env python3
+
+# Test Python's modulo operator precedence
+print("Testing Python modulo operator precedence:")
+print("-3 % 7 =", -3 % 7)  # This is (-3) % 7 = 4
+print("-(3 % 7) =", -(3 % 7))  # This is -(3) = -3
+
+# Test with variables
+x, y = 3, 7
+print("-x % y =", -x % y)  # This is (-x) % y = 4
+print("-(x % y) =", -(x % y))  # This is -(3) = -3
+
+# Test what happens when we force parentheses
+print("(-x) % y =", (-x) % y)  # This is (-3) % 7 = 4
+print("-(x % y) =", -(x % y))  # This is -(3) = -3
+
+# The issue is that -x % y is interpreted as (-x) % y, not as -(x % y)
\ No newline at end of file
diff --git a/test_python_precedence.py b/test_python_precedence.py
new file mode 100644
index 0000000000..96f544edaf
--- /dev/null
+++ b/test_python_precedence.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+# Test Python operator precedence
+print("Testing Python operator precedence:")
+
+# Test unary minus vs modulo
+x, y = 3, 7
+result1 = -x % y  # This should be (-x) % y
+result2 = -(x % y)  # This should be -(x % y)
+
+print(f"-x % y = {result1} (interpreted as (-x) % y)")
+print(f"-(x % y) = {result2} (interpreted as -(x % y))")
+
+# Test with explicit parentheses to see the difference
+result3 = (-x) % y
+result4 = -(x % y)
+
+print(f"(-x) % y = {result3}")
+print(f"-(x % y) = {result4}")
+
+# The issue is that modulo operator % has higher precedence than unary minus
+# So -x % y is parsed as (-x) % y, not as -(x % y)
\ No newline at end of file