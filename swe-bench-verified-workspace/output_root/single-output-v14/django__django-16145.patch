diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..37cef18561
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to ensure the fix doesn't break edge cases.
+"""
+import re
+
+def test_comprehensive():
+    """Test comprehensive edge cases"""
+    
+    def get_display_addr(addr, _raw_ipv6):
+        """Replicate the fixed logic from runserver.py"""
+        if _raw_ipv6:
+            return "[%s]" % addr
+        else:
+            return "0.0.0.0" if addr == "0" else addr
+    
+    # Test various edge cases
+    test_cases = [
+        # Basic cases
+        ("0", False, "0.0.0.0"),
+        ("0.0.0.0", False, "0.0.0.0"),
+        ("127.0.0.1", False, "127.0.0.1"),
+        
+        # Edge cases that should NOT be changed
+        ("0.0.0.1", False, "0.0.0.1"),  # Not exactly "0"
+        ("0.1.0.0", False, "0.1.0.0"),  # Not exactly "0"
+        ("1.0.0.0", False, "1.0.0.0"),  # Not exactly "0"
+        ("00", False, "00"),  # Not exactly "0"
+        ("000", False, "000"),  # Not exactly "0"
+        ("0x0", False, "0x0"),  # Not exactly "0"
+        
+        # Empty and None cases (should handle gracefully)
+        ("", False, ""),
+        (None, False, None),  # This might occur in edge cases
+        
+        # IPv6 cases (should work as before)
+        ("::1", True, "[::1]"),
+        ("2001:db8::1", True, "[2001:db8::1]"),
+    ]
+    
+    print("Comprehensive edge case testing:")
+    print("=" * 50)
+    
+    all_passed = True
+    for addr, _raw_ipv6, expected in test_cases:
+        try:
+            result = get_display_addr(addr, _raw_ipv6)
+            status = "‚úì PASS" if result == expected else "‚úó FAIL"
+            print(f"{status}: addr='{addr}', _raw_ipv6={_raw_ipv6}")
+            print(f"    Expected: '{expected}'")
+            print(f"    Got:      '{result}'")
+            
+            if result != expected:
+                all_passed = False
+                
+        except Exception as e:
+            print(f"‚úó ERROR: addr='{addr}', _raw_ipv6={_raw_ipv6} - {e}")
+            all_passed = False
+            
+        print()
+    
+    if all_passed:
+        print("All tests passed! üéâ")
+    else:
+        print("Some tests failed! ‚ùå")
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/django/core/management/commands/runserver.py b/django/core/management/commands/runserver.py
index 3c39f57e4d..67a36ef2b7 100644
--- a/django/core/management/commands/runserver.py
+++ b/django/core/management/commands/runserver.py
@@ -147,7 +147,7 @@ class Command(BaseCommand):
                 "version": self.get_version(),
                 "settings": settings.SETTINGS_MODULE,
                 "protocol": self.protocol,
-                "addr": "[%s]" % self.addr if self._raw_ipv6 else self.addr,
+                "addr": "[%s]" % self.addr if self._raw_ipv6 else ("0.0.0.0" if self.addr == "0" else self.addr),
                 "port": self.port,
                 "quit_command": quit_command,
             }
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..ff8fda4e64
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix works with actual Django runserver logic.
+"""
+import re
+
+def test_actual_logic():
+    """Test the actual logic from the fixed runserver.py"""
+    
+    # This replicates the exact logic from the fixed runserver.py
+    def simulate_runserver_display(addr, _raw_ipv6):
+        """Simulate the fixed display logic from line 150"""
+        return "[%s]" % addr if _raw_ipv6 else ("0.0.0.0" if addr == "0" else addr)
+    
+    # Test the specific case mentioned in the issue
+    print("Testing the specific issue case: '0:8000'")
+    print("=" * 50)
+    
+    # Simulate parsing '0:8000'
+    naiveip_re = re.compile(
+        r"""^(?:
+    (?P<addr>
+        (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
+        (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
+        (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
+    ):)?(?P<port>\d+)$""",
+        re.X,
+    )
+    
+    test_addrport = "0:8000"
+    m = re.match(naiveip_re, test_addrport)
+    if m:
+        addr, _ipv4, _ipv6, _fqdn, port = m.groups()
+        
+        # Simulate the runserver logic
+        use_ipv6 = False
+        _raw_ipv6 = False
+        
+        display_addr = simulate_runserver_display(addr, _raw_ipv6)
+        
+        print(f"Input: {test_addrport}")
+        print(f"Parsed address: '{addr}'")
+        print(f"Parsed port: '{port}'")
+        print(f"Display address (after fix): '{display_addr}'")
+        print(f"Final URL: http://{display_addr}:{port}/")
+        
+        # Verify the fix
+        if display_addr == "0.0.0.0":
+            print("‚úÖ SUCCESS: Address '0' is correctly displayed as '0.0.0.0'")
+            print("‚úÖ The URL is now browser-friendly!")
+        else:
+            print("‚ùå FAILED: Address display was not fixed")
+            
+    print("\n" + "="*50)
+    print("Testing that other addresses are not affected:")
+    
+    # Test other addresses to ensure they're not broken
+    other_tests = [
+        ("0.0.0.0", False, "0.0.0.0"),
+        ("127.0.0.1", False, "127.0.0.1"),
+        ("localhost", False, "localhost"),
+        ("192.168.1.1", False, "192.168.1.1"),
+    ]
+    
+    for addr, _raw_ipv6, expected in other_tests:
+        result = simulate_runserver_display(addr, _raw_ipv6)
+        status = "‚úÖ" if result == expected else "‚ùå"
+        print(f"{status} {addr} -> {result} (expected: {expected})")
+
+if __name__ == "__main__":
+    test_actual_logic()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e420258b32
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the runserver address display issue.
+"""
+import os
+import sys
+import subprocess
+
+# Add the django directory to Python path
+sys.path.insert(0, './django')
+
+def test_runserver_address_display():
+    """Test what address is displayed when running runserver with '0:8000'"""
+    
+    # Set up minimal Django settings
+    os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.settings'
+    
+    from django.core.management import execute_from_command_line
+    
+    # Mock the actual server running to just get the output
+    from django.core.management.commands.runserver import Command
+    
+    # Create command instance
+    cmd = Command()
+    
+    # Test with '0:8000' argument
+    test_addrport = '0:8000'
+    
+    # Simulate the handle method logic
+    from django.conf import settings
+    settings.configure(
+        DEBUG=True,
+        ALLOWED_HOSTS=['*'],
+        SECRET_KEY='test-key-for-reproduction'
+    )
+    
+    # Parse the address like the command does
+    import re
+    from django.utils.regex_helper import _lazy_re_compile
+    
+    naiveip_re = _lazy_re_compile(
+        r"""^(?:
+    (?P<addr>
+        (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
+        (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
+        (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
+    ):)?(?P<port>\d+)$""",
+        re.X,
+    )
+    
+    m = re.match(naiveip_re, test_addrport)
+    if m:
+        addr, _ipv4, _ipv6, _fqdn, port = m.groups()
+        print(f"Parsed address: {addr}")
+        print(f"Parsed port: {port}")
+        
+        # Simulate what happens in the display logic
+        use_ipv6 = False
+        _raw_ipv6 = False
+        
+        if not addr:
+            default_addr_ipv6 = "::1"
+            default_addr = "127.0.0.1"
+            addr = default_addr_ipv6 if use_ipv6 else default_addr
+            _raw_ipv6 = use_ipv6
+        
+        # This is the current display logic (line 150 in runserver.py)
+        display_addr = "[%s]" % addr if _raw_ipv6 else addr
+        print(f"Current display address: {display_addr}")
+        print(f"URL would be: http://{display_addr}:{port}/")
+        
+        # Expected behavior according to the issue
+        if addr == "0":
+            expected_addr = "0.0.0.0"
+            print(f"Expected display address: {expected_addr}")
+            print(f"Expected URL: http://{expected_addr}:{port}/")
+        else:
+            print("No issue - address is not '0'")
+
+if __name__ == "__main__":
+    test_runserver_address_display()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..695bc78095
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the runserver address display issue.
+"""
+import re
+
+def test_address_parsing():
+    """Test the address parsing logic from runserver.py"""
+    
+    # The regex pattern from runserver.py
+    naiveip_re = re.compile(
+        r"""^(?:
+    (?P<addr>
+        (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
+        (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
+        (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
+    ):)?(?P<port>\d+)$""",
+        re.X,
+    )
+    
+    test_cases = [
+        "0:8000",
+        "0.0.0.0:8000", 
+        "127.0.0.1:8000",
+        "localhost:8000",
+        "8000"  # default address
+    ]
+    
+    for test_addrport in test_cases:
+        print(f"\nTesting: {test_addrport}")
+        
+        m = re.match(naiveip_re, test_addrport)
+        if m is None:
+            print(f"  ERROR: Invalid format")
+            continue
+            
+        addr, _ipv4, _ipv6, _fqdn, port = m.groups()
+        print(f"  Parsed address: '{addr}'")
+        print(f"  Parsed port: '{port}'")
+        
+        # Simulate the current display logic
+        use_ipv6 = False
+        _raw_ipv6 = False
+        
+        if not addr:
+            default_addr_ipv6 = "::1"
+            default_addr = "127.0.0.1"
+            addr = default_addr_ipv6 if use_ipv6 else default_addr
+            _raw_ipv6 = use_ipv6
+        
+        # Current behavior (line 150 in runserver.py)
+        display_addr = "[%s]" % addr if _raw_ipv6 else addr
+        print(f"  Current display: {display_addr}")
+        print(f"  Current URL: http://{display_addr}:{port}/")
+        
+        # Expected behavior according to the issue
+        if addr == "0":
+            expected_addr = "0.0.0.0"
+            print(f"  Expected display: {expected_addr}")
+            print(f"  Expected URL: http://{expected_addr}:{port}/")
+            print(f"  ISSUE: URL is not browser-friendly!")
+
+if __name__ == "__main__":
+    test_address_parsing()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..1f74ca0f31
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for runserver address display issue.
+"""
+import re
+
+def test_fixed_address_display():
+    """Test the fixed address display logic"""
+    
+    # Simulate the fixed display logic
+    def get_display_addr(addr, _raw_ipv6):
+        """Replicate the fixed logic from runserver.py"""
+        if _raw_ipv6:
+            return "[%s]" % addr
+        else:
+            return "0.0.0.0" if addr == "0" else addr
+    
+    test_cases = [
+        ("0", False, "0.0.0.0"),  # Should be fixed
+        ("0.0.0.0", False, "0.0.0.0"),  # Should remain unchanged
+        ("127.0.0.1", False, "127.0.0.1"),  # Should remain unchanged
+        ("localhost", False, "localhost"),  # Should remain unchanged
+        ("::1", True, "[::1]"),  # IPv6 should work as before
+        ("192.168.1.1", False, "192.168.1.1"),  # Should remain unchanged
+    ]
+    
+    print("Testing the fixed address display logic:")
+    print("=" * 50)
+    
+    for addr, _raw_ipv6, expected in test_cases:
+        result = get_display_addr(addr, _raw_ipv6)
+        status = "‚úì PASS" if result == expected else "‚úó FAIL"
+        print(f"{status}: addr='{addr}', _raw_ipv6={_raw_ipv6}")
+        print(f"    Expected: '{expected}'")
+        print(f"    Got:      '{result}'")
+        print()
+
+if __name__ == "__main__":
+    test_fixed_address_display()
\ No newline at end of file