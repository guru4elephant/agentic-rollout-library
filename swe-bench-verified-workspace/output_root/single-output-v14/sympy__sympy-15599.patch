diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..ec77975c8d
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Mod, Float
+
+# Test the failing case
+x = Symbol('x')
+point3 = Float(3.3) % 1
+print(f"Float(3.3) % 1 = {point3}")
+
+result1 = (x - 3.3) % 1
+result2 = Mod(1.*x + 1 - point3, 1)
+
+print(f"(x - 3.3) % 1 = {result1}")
+print(f"Mod(1.*x + 1 - point3, 1) = {result2}")
+print(f"Are they equal? {result1 == result2}")
+
+# Let's also test what happens with regular numbers
+print(f"\nTesting with numbers:")
+print(f"3.3 % 1 = {3.3 % 1}")
+print(f"Float(3.3) % 1 = {Float(3.3) % 1}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..86c63ea4d0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,24 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Mod, sympify
+
+# Reproduce the issue described in the GitHub issue
+i = Symbol('i', integer=True)
+k = Symbol('k', integer=True)
+
+print("Testing Mod(3*i, 2):")
+result = Mod(3*i, 2)
+print(f"Mod(3*i, 2) = {result}")
+print(f"Expected: Mod(i, 2)")
+
+print("\nTesting sympify(3*k%2):")
+result2 = sympify(3*k%2)
+print(f"sympify(3*k%2) = {result2}")
+print(f"Expected: Mod(k, 2)")
+
+# Test if the results are equal to what we expect
+expected1 = Mod(i, 2)
+expected2 = Mod(k, 2)
+
+print(f"\nMod(3*i, 2) == Mod(i, 2): {result == expected1}")
+print(f"sympify(3*k%2) == Mod(k, 2): {result2 == expected2}")
\ No newline at end of file
diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index eae25630cc..f0aff0e74f 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -123,9 +123,22 @@ def doit(p, q):
             for arg in p.args:
                 both_l[isinstance(arg, cls)].append(arg)
 
-            if mod_l and all(inner.args[1] == q for inner in mod_l):
+            # Check if we can simplify non-modulus terms by applying modulus
+            # Only do this for integer coefficients to avoid issues with floats and rationals
+            can_simplify_non_mod = True
+            for x in non_mod_l:
+                # Don't simplify if we have floating point numbers or non-integer rationals
+                if x.is_Float or (x.is_Rational and not x.is_Integer):
+                    can_simplify_non_mod = False
+                    break
+            
+            # Also check if we have any modulus terms with the same divisor
+            has_mod_terms = mod_l and all(inner.args[1] == q for inner in mod_l)
+            
+            if (can_simplify_non_mod and non_mod_l) or has_mod_terms:
                 # finding distributive term
-                non_mod_l = [cls(x, q) for x in non_mod_l]
+                if can_simplify_non_mod and non_mod_l:
+                    non_mod_l = [cls(x, q) for x in non_mod_l]
                 mod = []
                 non_mod = []
                 for j in non_mod_l:
@@ -135,7 +148,7 @@ def doit(p, q):
                         non_mod.append(j)
                 prod_mod = Mul(*mod)
                 prod_non_mod = Mul(*non_mod)
-                prod_mod1 = Mul(*[i.args[0] for i in mod_l])
+                prod_mod1 = Mul(*[i.args[0] for i in mod_l]) if mod_l else 1
                 net = prod_mod1*prod_mod
                 return prod_non_mod*cls(net, q)