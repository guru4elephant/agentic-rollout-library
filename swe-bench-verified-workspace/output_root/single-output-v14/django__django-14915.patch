diff --git a/django/forms/models.py b/django/forms/models.py
index 5dcf923c12..bc7e6959e7 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -1171,6 +1171,9 @@ class ModelChoiceIteratorValue:
             other = other.value
         return self.value == other
 
+    def __hash__(self):
+        return hash(self.value)
+
 
 class ModelChoiceIterator:
     def __init__(self, field):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..90618cdd61
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+"""Script to reproduce the ModelChoiceIteratorValue hashability issue."""
+
+import os
+import sys
+
+# Add the Django project to the path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.db import models
+from django import forms
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_modelchoice_iterator_value_hashability():
+    """Test that ModelChoiceIteratorValue is hashable."""
+    print("Testing ModelChoiceIteratorValue hashability...")
+    
+    # Create a simple test object
+    class SimpleObject:
+        def __str__(self):
+            return "Test Object"
+    
+    test_instance = SimpleObject()
+    
+    # Create a ModelChoiceIteratorValue instance
+    from django.forms.models import ModelChoiceIteratorValue
+    iterator_value = ModelChoiceIteratorValue(1, test_instance)
+    
+    # Test hashability
+    try:
+        hash(iterator_value)
+        print("✓ ModelChoiceIteratorValue is hashable")
+    except TypeError as e:
+        print(f"✗ ModelChoiceIteratorValue is NOT hashable: {e}")
+        return False
+    
+    # Test dictionary key usage (the actual issue from the GitHub issue)
+    test_dict = {1: ['field1', 'field2']}
+    try:
+        result = iterator_value in test_dict
+        print(f"✓ ModelChoiceIteratorValue can be used as dictionary key: {result}")
+    except TypeError as e:
+        print(f"✗ ModelChoiceIteratorValue cannot be used as dictionary key: {e}")
+        return False
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_modelchoice_iterator_value_hashability()
+    if not success:
+        print("\nIssue reproduced successfully!")
+        sys.exit(1)
+    else:
+        print("\nNo issue found.")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..3005324530
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+"""Test edge cases for ModelChoiceIteratorValue hashability."""
+
+import os
+import sys
+
+# Add the Django project to the path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_edge_cases():
+    """Test various edge cases for ModelChoiceIteratorValue."""
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    print("Testing edge cases for ModelChoiceIteratorValue hashability...")
+    
+    # Test with different value types
+    test_cases = [
+        (1, "integer"),
+        ("string", "string"),
+        (None, "None"),
+        (3.14, "float"),
+        (True, "boolean"),
+        ((1, 2), "tuple"),
+        (frozenset([1, 2]), "frozenset"),
+    ]
+    
+    class SimpleObject:
+        def __str__(self):
+            return "Test Object"
+    
+    test_instance = SimpleObject()
+    
+    for value, value_type in test_cases:
+        try:
+            iterator_value = ModelChoiceIteratorValue(value, test_instance)
+            
+            # Test hashability
+            hash_result = hash(iterator_value)
+            print(f"✓ {value_type} value: hash = {hash_result}")
+            
+            # Test dictionary usage
+            test_dict = {value: ['field1', 'field2']}
+            result = iterator_value in test_dict
+            print(f"✓ {value_type} value in dict: {result}")
+            
+        except Exception as e:
+            print(f"✗ {value_type} value failed: {e}")
+            return False
+    
+    # Test that different instances with same value have same hash
+    value1 = ModelChoiceIteratorValue(42, test_instance)
+    value2 = ModelChoiceIteratorValue(42, SimpleObject())  # Different instance
+    value3 = ModelChoiceIteratorValue(43, test_instance)   # Different value
+    
+    if hash(value1) == hash(value2):
+        print("✓ Same values have same hash (even with different instances)")
+    else:
+        print("✗ Same values should have same hash")
+        return False
+        
+    if hash(value1) != hash(value3):
+        print("✓ Different values have different hashes")
+    else:
+        print("✗ Different values should have different hashes")
+        return False
+    
+    # Test set usage
+    try:
+        value_set = {value1, value2, value3}
+        print(f"✓ Can be used in sets: {len(value_set)} unique values")
+    except Exception as e:
+        print(f"✗ Cannot be used in sets: {e}")
+        return False
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_edge_cases()
+    if success:
+        print("\nAll edge case tests passed!")
+        sys.exit(0)
+    else:
+        print("\nSome edge case tests failed.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_github_issue_scenario.py b/test_github_issue_scenario.py
new file mode 100644
index 0000000000..29f9e3ecff
--- /dev/null
+++ b/test_github_issue_scenario.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+"""Test the exact scenario described in the GitHub issue."""
+
+import os
+import sys
+import json
+
+# Add the Django project to the path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django import forms
+from django.forms import Select
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+class CustomSelectWidget(Select):
+    """Custom widget that adds data-* attributes to options."""
+    
+    def __init__(self, show_fields=None, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.show_fields = show_fields or {}
+    
+    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
+        """Override create_option to add custom data attributes."""
+        context = super().create_option(name, value, label, selected, index, subindex, attrs)
+        
+        if not value:
+            return context
+        
+        # This is the exact code from the GitHub issue that was failing
+        if value in self.show_fields:  # This is a dict {1: ['first_name', 'last_name']}
+            context['attrs']['data-fields'] = json.dumps(self.show_fields[value])
+        
+        return context
+
+def test_github_issue_scenario():
+    """Test the exact scenario from the GitHub issue."""
+    print("Testing GitHub issue scenario...")
+    
+    # Create a custom widget with show_fields dict
+    show_fields = {1: ['first_name', 'last_name'], 2: ['email', 'phone']}
+    widget = CustomSelectWidget(show_fields=show_fields)
+    
+    # Create some ModelChoiceIteratorValue instances (like Django would)
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    # Simulate values that would come from a ModelChoiceField
+    values = [
+        ModelChoiceIteratorValue(1, object()),
+        ModelChoiceIteratorValue(2, object()),
+        ModelChoiceIteratorValue(3, object()),  # This one shouldn't be in show_fields
+    ]
+    
+    for i, value in enumerate(values):
+        try:
+            # This is where the error occurred in the original issue
+            option = widget.create_option(
+                name=f"test_field",
+                value=value,
+                label=f"Option {i+1}",
+                selected=False,
+                index=i
+            )
+            
+            if value in show_fields:
+                expected_fields = json.dumps(show_fields[value])
+                actual_fields = option['attrs'].get('data-fields', '')
+                if actual_fields == expected_fields:
+                    print(f"✓ Option {i+1}: Correctly added data-fields: {actual_fields}")
+                else:
+                    print(f"✗ Option {i+1}: Expected {expected_fields}, got {actual_fields}")
+                    return False
+            else:
+                if 'data-fields' not in option['attrs']:
+                    print(f"✓ Option {i+1}: No data-fields added (as expected)")
+                else:
+                    print(f"✗ Option {i+1}: Unexpected data-fields: {option['attrs']['data-fields']}")
+                    return False
+                    
+        except TypeError as e:
+            if "unhashable type" in str(e):
+                print(f"✗ Option {i+1}: Hashability error still exists: {e}")
+                return False
+            else:
+                print(f"✗ Option {i+1}: Unexpected error: {e}")
+                return False
+        except Exception as e:
+            print(f"✗ Option {i+1}: Unexpected error: {e}")
+            return False
+    
+    # Test with array (this should work as mentioned in the issue)
+    print("\nTesting with array (should work as mentioned in issue)...")
+    allowed_values = [1, 2]  # This is an array [1, 2]
+    
+    for i, value in enumerate(values):
+        try:
+            if value in allowed_values:  # This should work
+                print(f"✓ Array check for value {value}: {value in allowed_values}")
+            else:
+                print(f"✓ Array check for value {value}: {value in allowed_values} (not in array)")
+        except Exception as e:
+            print(f"✗ Array check failed for value {value}: {e}")
+            return False
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_github_issue_scenario()
+    if success:
+        print("\n✓ GitHub issue scenario test passed!")
+        sys.exit(0)
+    else:
+        print("\n✗ GitHub issue scenario test failed!")
+        sys.exit(1)
\ No newline at end of file