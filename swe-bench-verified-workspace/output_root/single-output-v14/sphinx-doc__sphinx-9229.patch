diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..b24a7fcf9
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+"""Script to reproduce the type alias documentation issue."""
+
+from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Signatures for the documentation purposes
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed, such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
+
+if __name__ == "__main__":
+    print("Type alias documentation test file created.")
\ No newline at end of file
diff --git a/setup.py b/setup.py
index b669afc00..0986baec3 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.14,<0.18',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..70da6f43a
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+"""Simple test to verify the typing object detection works."""
+
+from typing import Dict, Any
+
+# Test type alias
+ScaffoldOpts = Dict[str, Any]
+"""Test docstring."""
+
+def is_typing_object(obj):
+    """Check if object is from typing module."""
+    return (hasattr(obj, '__class__') and 
+            hasattr(obj.__class__, '__module__') and 
+            obj.__class__.__module__ == 'typing')
+
+# Test the detection
+print("ScaffoldOpts is typing object:", is_typing_object(ScaffoldOpts))
+print("ScaffoldOpts type:", type(ScaffoldOpts))
+print("ScaffoldOpts __class__.__module__:", ScaffoldOpts.__class__.__module__)
+
+# Test with regular class
+class MyClass:
+    pass
+
+print("MyClass is typing object:", is_typing_object(MyClass))
\ No newline at end of file
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index 1f4c98284..72d482fd0 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -1724,10 +1724,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:
     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
                     ) -> None:
         if self.doc_as_attr:
-            try:
-                more_content = StringList([_('alias of %s') % restify(self.object)], source='')
-            except AttributeError:
-                pass  # Invalid class object is passed.
+            # Check if object is from typing module (type aliases should preserve docstrings)
+            is_typing_object = (hasattr(self.object, '__class__') and 
+                               hasattr(self.object.__class__, '__module__') and 
+                               self.object.__class__.__module__ == 'typing')
+            if not is_typing_object:
+                try:
+                    more_content = StringList([_('alias of %s') % restify(self.object)], source='')
+                except AttributeError:
+                    pass  # Invalid class object is passed.
 
         super().add_content(more_content)
 
diff --git a/test_better_detection.py b/test_better_detection.py
new file mode 100644
index 000000000..31e337e09
--- /dev/null
+++ b/test_better_detection.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+"""Test script for better typing object detection."""
+
+from typing import Dict, Any, Union, Callable, TypeVar
+from pathlib import Path
+
+# Test various type aliases
+ScaffoldOpts = Dict[str, Any]
+FileContents = Union[str, None]
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+T = TypeVar('T')
+
+def is_typing_object(obj):
+    """Check if object is from typing module."""
+    # Check if object's class is from typing module
+    return hasattr(obj, '__class__') and hasattr(obj.__class__, '__module__') and obj.__class__.__module__ == 'typing'
+
+print("ScaffoldOpts is typing:", is_typing_object(ScaffoldOpts))
+print("FileContents is typing:", is_typing_object(FileContents))
+print("FileOp is typing:", is_typing_object(FileOp))
+print("T is typing:", is_typing_object(T))
+
+# Test with regular classes
+class MyClass:
+    pass
+
+print("MyClass is typing:", is_typing_object(MyClass))
\ No newline at end of file
diff --git a/test_detection.py b/test_detection.py
new file mode 100644
index 000000000..6fe667660
--- /dev/null
+++ b/test_detection.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+"""Test script to detect type alias types."""
+
+from typing import Dict, Any, Union, Callable, TypeVar
+from pathlib import Path
+
+# Test various type aliases
+ScaffoldOpts = Dict[str, Any]
+FileContents = Union[str, None]
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+# Test TypeVar
+T = TypeVar('T')
+
+# Test NewType (if available)
+try:
+    from typing import NewType
+    UserId = NewType('UserId', int)
+except ImportError:
+    UserId = None
+
+print("ScaffoldOpts type:", type(ScaffoldOpts))
+print("FileContents type:", type(FileContents)) 
+print("FileOp type:", type(FileOp))
+print("T type:", type(T))
+if UserId:
+    print("UserId type:", type(UserId))
+
+print("\nAll are typing types:", all(str(type(obj)).startswith('<class \'typing.') for obj in [ScaffoldOpts, FileContents, FileOp, T]))
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..69b67cee1
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+"""Test script to verify the fix for type alias docstrings."""
+
+import sys
+import os
+sys.path.insert(0, os.path.abspath('.'))
+
+from sphinx.ext.autodoc import ClassDocumenter
+from sphinx.application import Sphinx
+from sphinx.util.docutils import docutils_namespace
+from sphinx.util import logging
+from typing import Dict, Any
+
+# Create a simple test class to simulate the autodoc behavior
+class MockDirective:
+    def __init__(self):
+        self.state = MockState()
+
+class MockState:
+    def __init__(self):
+        self.document = MockDocument()
+
+class MockDocument:
+    def __init__(self):
+        self.settings = MockSettings()
+
+class MockSettings:
+    def __init__(self):
+        self.tab_width = 8
+
+class MockConfig:
+    def __init__(self):
+        self.autodoc_inherit_docstrings = False
+
+class MockEnv:
+    def __init__(self):
+        self.temp_data = {}
+
+# Test type alias with docstring
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+def test_type_alias_docstring():
+    """Test that type alias docstrings are preserved."""
+    # Create a mock documenter
+    directive = MockDirective()
+    config = MockConfig()
+    env = MockEnv()
+    
+    # Create a ClassDocumenter instance
+    documenter = ClassDocumenter(directive, 'ScaffoldOpts', options={})
+    documenter.object = ScaffoldOpts
+    documenter.modname = '__main__'
+    documenter.objpath = ['ScaffoldOpts']
+    documenter.config = config
+    documenter.env = env
+    
+    # Set doc_as_attr to True (this is what happens for type aliases)
+    documenter.doc_as_attr = True
+    
+    # Test the add_content method
+    more_content = None
+    documenter.add_content(more_content)
+    
+    # The docstring should be preserved, not replaced with "alias of"
+    print("Test completed. If no 'alias of' text was added, the fix works!")
+
+if __name__ == "__main__":
+    test_type_alias_docstring()
\ No newline at end of file
diff --git a/test_type_alias.py b/test_type_alias.py
new file mode 100644
index 000000000..db406873b
--- /dev/null
+++ b/test_type_alias.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+"""Test script to understand type alias behavior."""
+
+from typing import Dict, Any, Union
+
+# Test type alias
+ScaffoldOpts = Dict[str, Any]
+"""This is a docstring for ScaffoldOpts."""
+
+# Test regular class
+class MyClass:
+    """This is a docstring for MyClass."""
+    pass
+
+# Test class alias
+MyClassAlias = MyClass
+
+print("ScaffoldOpts type:", type(ScaffoldOpts))
+print("ScaffoldOpts __name__:", getattr(ScaffoldOpts, '__name__', 'No __name__'))
+print("ScaffoldOpts __doc__:", getattr(ScaffoldOpts, '__doc__', 'No __doc__'))
+print()
+
+print("MyClass type:", type(MyClass))
+print("MyClass __name__:", getattr(MyClass, '__name__', 'No __name__'))
+print("MyClass __doc__:", getattr(MyClass, '__doc__', 'No __doc__'))
+print()
+
+print("MyClassAlias type:", type(MyClassAlias))
+print("MyClassAlias __name__:", getattr(MyClassAlias, '__name__', 'No __name__'))
+print("MyClassAlias __doc__:", getattr(MyClassAlias, '__doc__', 'No __doc__'))
\ No newline at end of file
diff --git a/test_typevar_attrs.py b/test_typevar_attrs.py
new file mode 100644
index 000000000..393a4d317
--- /dev/null
+++ b/test_typevar_attrs.py
@@ -0,0 +1,12 @@
+#!/usr/bin/env python3
+"""Test script to check TypeVar attributes."""
+
+from typing import TypeVar
+
+T = TypeVar('T')
+
+print("T type:", type(T))
+print("T attributes:", dir(T))
+print("T has __module__:", hasattr(T, '__module__'))
+print("T __class__:", T.__class__)
+print("T __class__.__module__:", T.__class__.__module__)
\ No newline at end of file
diff --git a/test_typevar_module.py b/test_typevar_module.py
new file mode 100644
index 000000000..8142d55c8
--- /dev/null
+++ b/test_typevar_module.py
@@ -0,0 +1,9 @@
+#!/usr/bin/env python3
+"""Test script to check TypeVar __module__ attribute."""
+
+from typing import TypeVar
+
+T = TypeVar('T')
+
+print("T has __module__:", hasattr(T, '__module__'))
+print("T.__module__:", getattr(T, '__module__', 'NOT FOUND'))
\ No newline at end of file
diff --git a/test_typing_detection.py b/test_typing_detection.py
new file mode 100644
index 000000000..dd175e031
--- /dev/null
+++ b/test_typing_detection.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+"""Test script to detect typing objects."""
+
+from typing import Dict, Any, Union, Callable, TypeVar
+from pathlib import Path
+
+# Test various type aliases
+ScaffoldOpts = Dict[str, Any]
+FileContents = Union[str, None]
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+T = TypeVar('T')
+
+def is_typing_object(obj):
+    """Check if object is from typing module."""
+    return hasattr(obj, '__module__') and obj.__module__ == 'typing'
+
+print("ScaffoldOpts is typing:", is_typing_object(ScaffoldOpts))
+print("FileContents is typing:", is_typing_object(FileContents))
+print("FileOp is typing:", is_typing_object(FileOp))
+print("T is typing:", is_typing_object(T))
+
+# Test with regular classes
+class MyClass:
+    pass
+
+print("MyClass is typing:", is_typing_object(MyClass))
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index a363e187f..3b8bc12d0 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3