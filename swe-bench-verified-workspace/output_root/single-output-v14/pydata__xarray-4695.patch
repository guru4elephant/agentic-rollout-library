diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..1d6e663d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+import numpy as np
+from xarray import DataArray
+
+# Create test data arrays as described in the issue
+empty = np.zeros((2,2))
+D1 = DataArray(empty, dims=['dim1', 'dim2'],   coords={'dim1':['x', 'y'], 'dim2':['a', 'b']})
+D2 = DataArray(empty, dims=['dim1', 'method'], coords={'dim1':['x', 'y'], 'method':['a', 'b']})
+
+# Test the working case
+print("Testing D1 (dim2):")
+try:
+    result1 = D1.loc[dict(dim1='x', dim2='a')]
+    print("Success:", result1)
+except Exception as e:
+    print("Error:", e)
+
+# Test the failing case
+print("\nTesting D2 (method):")
+try:
+    result2 = D2.loc[dict(dim1='x', method='a')]
+    print("Success:", result2)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..c656d18a
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,51 @@
+import numpy as np
+from xarray import DataArray
+
+# Test 1: Basic case with method dimension
+print("Test 1: Basic case with method dimension")
+empty = np.zeros((2,2))
+D1 = DataArray(empty, dims=['dim1', 'method'], coords={'dim1':['x', 'y'], 'method':['a', 'b']})
+try:
+    result = D1.loc[dict(dim1='x', method='a')]
+    print("Success:", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test 2: Case with tolerance dimension
+print("\nTest 2: Case with tolerance dimension")
+D2 = DataArray(empty, dims=['dim1', 'tolerance'], coords={'dim1':['x', 'y'], 'tolerance':['a', 'b']})
+try:
+    result = D2.loc[dict(dim1='x', tolerance='a')]
+    print("Success:", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test 3: Case with both method and tolerance dimensions
+print("\nTest 3: Case with both method and tolerance dimensions")
+empty3 = np.zeros((2,2,2))
+D3 = DataArray(empty3, dims=['dim1', 'method', 'tolerance'], 
+               coords={'dim1':['x', 'y'], 'method':['a', 'b'], 'tolerance':['c', 'd']})
+try:
+    result = D3.loc[dict(dim1='x', method='a', tolerance='c')]
+    print("Success:", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test 4: Case where method is actually the pandas method parameter
+print("\nTest 4: Case where method is actually the pandas method parameter")
+D4 = DataArray([1, 2, 3, 4], dims=['x'], coords={'x':[1, 2, 3, 4]})
+try:
+    # This should use the pandas method parameter, not a dimension
+    result = D4.loc[dict(x=2.5, method='nearest')]
+    print("Success:", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test 5: Regular case without conflicts
+print("\nTest 5: Regular case without conflicts")
+D5 = DataArray(empty, dims=['dim1', 'dim2'], coords={'dim1':['x', 'y'], 'dim2':['a', 'b']})
+try:
+    result = D5.loc[dict(dim1='x', dim2='a')]
+    print("Success:", result.values)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_setitem.py b/test_setitem.py
new file mode 100644
index 00000000..cde59181
--- /dev/null
+++ b/test_setitem.py
@@ -0,0 +1,27 @@
+import numpy as np
+from xarray import DataArray
+
+# Test __setitem__ with method dimension
+print("Testing __setitem__ with method dimension")
+empty = np.zeros((2,2))
+D = DataArray(empty, dims=['dim1', 'method'], coords={'dim1':['x', 'y'], 'method':['a', 'b']})
+
+try:
+    # This should work without errors
+    D.loc[dict(dim1='x', method='a')] = 42
+    result = D.loc[dict(dim1='x', method='a')]
+    print("Success: set value to", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test __setitem__ with tolerance dimension
+print("\nTesting __setitem__ with tolerance dimension")
+D2 = DataArray(empty, dims=['dim1', 'tolerance'], coords={'dim1':['x', 'y'], 'tolerance':['a', 'b']})
+
+try:
+    # This should work without errors
+    D2.loc[dict(dim1='x', tolerance='a')] = 42
+    result = D2.loc[dict(dim1='x', tolerance='a')]
+    print("Success: set value to", result.values)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_setitem_direct.py b/test_setitem_direct.py
new file mode 100644
index 00000000..0e3ceb9f
--- /dev/null
+++ b/test_setitem_direct.py
@@ -0,0 +1,29 @@
+import numpy as np
+from xarray import DataArray
+
+# Test direct __setitem__ with method dimension
+print("Testing direct __setitem__ with method dimension")
+empty = np.zeros((2,2))
+D = DataArray(empty, dims=['dim1', 'method'], coords={'dim1':['x', 'y'], 'method':['a', 'b']})
+
+try:
+    # This should work without errors
+    pos_indexers, _ = D.xindexing.remap_label_indexers(D, dict(dim1='x', method='a'))
+    D[pos_indexers] = 42
+    result = D.loc[dict(dim1='x', method='a')]
+    print("Success: set value to", result.values)
+except Exception as e:
+    print("Error:", e)
+
+# Test with tolerance dimension
+print("\nTesting direct __setitem__ with tolerance dimension")
+D2 = DataArray(empty, dims=['dim1', 'tolerance'], coords={'dim1':['x', 'y'], 'tolerance':['a', 'b']})
+
+try:
+    # This should work without errors
+    pos_indexers, _ = D2.xindexing.remap_label_indexers(D2, dict(dim1='x', tolerance='a'))
+    D2[pos_indexers] = 42
+    result = D2.loc[dict(dim1='x', tolerance='a')]
+    print("Success: set value to", result.values)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py
index 32b24ef1..4e2e0db3 100644
--- a/xarray/core/dataarray.py
+++ b/xarray/core/dataarray.py
@@ -196,7 +196,36 @@ class _LocIndexer:
             # expand the indexer so we can handle Ellipsis
             labels = indexing.expanded_indexer(key, self.data_array.ndim)
             key = dict(zip(self.data_array.dims, labels))
-        return self.data_array.sel(**key)
+        
+        # Handle potential conflicts between dimension names and sel method parameters
+        # If key contains keys that are also sel method parameter names,
+        # we need to pass them as indexers instead of keyword arguments
+        indexers = {}
+        method = None
+        tolerance = None
+        drop = False
+        
+        for k, v in key.items():
+            if k == 'method' and 'method' in self.data_array.dims:
+                # 'method' is a dimension name, treat it as an indexer
+                indexers[k] = v
+            elif k == 'tolerance' and 'tolerance' in self.data_array.dims:
+                # 'tolerance' is a dimension name, treat it as an indexer
+                indexers[k] = v
+            elif k == 'method':
+                # 'method' is the pandas indexing method parameter
+                method = v
+            elif k == 'tolerance':
+                # 'tolerance' is the pandas indexing tolerance parameter
+                tolerance = v
+            elif k == 'drop':
+                # 'drop' is the drop parameter
+                drop = v
+            else:
+                # Regular dimension indexer
+                indexers[k] = v
+        
+        return self.data_array.sel(indexers=indexers, method=method, tolerance=tolerance, drop=drop)
 
     def __setitem__(self, key, value) -> None:
         if not utils.is_dict_like(key):
@@ -1196,11 +1225,33 @@ class DataArray(AbstractArray, DataWithCoords):
         DataArray.isel
 
         """
+        # Handle potential conflicts between dimension names and method parameters
+        # If indexers_kwargs contains keys that are also method parameter names,
+        # we need to separate them
+        actual_indexers_kwargs = {}
+        actual_method = method
+        actual_tolerance = tolerance
+        
+        # Check if any keyword arguments conflict with method parameters
+        if indexers_kwargs:
+            if 'method' in indexers_kwargs and 'method' in self.dims:
+                # 'method' is both a dimension name and a keyword argument
+                # Treat it as a dimension indexer, not a method parameter
+                if indexers is None:
+                    indexers = {}
+                indexers = dict(indexers, method=indexers_kwargs.pop('method'))
+            if 'tolerance' in indexers_kwargs and 'tolerance' in self.dims:
+                # 'tolerance' is both a dimension name and a keyword argument
+                # Treat it as a dimension indexer, not a tolerance parameter
+                if indexers is None:
+                    indexers = {}
+                indexers = dict(indexers, tolerance=indexers_kwargs.pop('tolerance'))
+        
         ds = self._to_temp_dataset().sel(
             indexers=indexers,
             drop=drop,
-            method=method,
-            tolerance=tolerance,
+            method=actual_method,
+            tolerance=actual_tolerance,
             **indexers_kwargs,
         )
         return self._from_temp_dataset(ds)
diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py
index dbac288c..4c5f77c0 100644
--- a/xarray/core/dataset.py
+++ b/xarray/core/dataset.py
@@ -2227,9 +2227,31 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):
         Dataset.isel
         DataArray.sel
         """
-        indexers = either_dict_or_kwargs(indexers, indexers_kwargs, "sel")
+        # Handle potential conflicts between dimension names and method parameters
+        # If indexers_kwargs contains keys that are also method parameter names,
+        # we need to separate them
+        actual_indexers_kwargs = dict(indexers_kwargs)
+        actual_method = method
+        actual_tolerance = tolerance
+        
+        # Check if any keyword arguments conflict with method parameters
+        if indexers_kwargs:
+            if 'method' in indexers_kwargs and 'method' in self.dims:
+                # 'method' is both a dimension name and a keyword argument
+                # Treat it as a dimension indexer, not a method parameter
+                if indexers is None:
+                    indexers = {}
+                indexers = dict(indexers, method=actual_indexers_kwargs.pop('method'))
+            if 'tolerance' in indexers_kwargs and 'tolerance' in self.dims:
+                # 'tolerance' is both a dimension name and a keyword argument
+                # Treat it as a dimension indexer, not a tolerance parameter
+                if indexers is None:
+                    indexers = {}
+                indexers = dict(indexers, tolerance=actual_indexers_kwargs.pop('tolerance'))
+        
+        indexers = either_dict_or_kwargs(indexers, actual_indexers_kwargs, "sel")
         pos_indexers, new_indexes = remap_label_indexers(
-            self, indexers=indexers, method=method, tolerance=tolerance
+            self, indexers=indexers, method=actual_method, tolerance=actual_tolerance
         )
         result = self.isel(indexers=pos_indexers, drop=drop)
         return result._overwrite_indexes(new_indexes)