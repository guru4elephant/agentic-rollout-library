diff --git a/reproduce_admin_issue.py b/reproduce_admin_issue.py
new file mode 100644
index 0000000000..b28ea83683
--- /dev/null
+++ b/reproduce_admin_issue.py
@@ -0,0 +1,188 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the UUIDField default value issue specifically with Django Admin inlines.
+This simulates the admin form processing that causes the issue.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models as described in the issue
+from django.db import models
+
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'testapp'
+
+def test_admin_inline_issue():
+    """Test the specific issue with admin inlines where UUID default is not used."""
+    from django import forms
+    from django.forms.models import inlineformset_factory
+    
+    print("Testing admin inline UUIDField issue...")
+    
+    # Create a Thing instance
+    thing = Thing(name="Test Thing")
+    print(f"Thing before save - id: {thing.id}, pkid: {thing.pkid}")
+    
+    # Save the thing
+    thing.save()
+    print(f"Thing after save - id: {thing.id}, pkid: {thing.pkid}")
+    
+    # Test inline formset - this simulates what admin does
+    SubThingFormSet = inlineformset_factory(
+        Thing, SubThing, form=forms.ModelForm, 
+        fields=['name'], extra=1
+    )
+    
+    # Create formset data that simulates admin POST data
+    # The key issue: when creating both parent and child together in admin
+    formset_data = {
+        'name': 'New Test Thing',  # Parent field
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # This simulates the admin form processing
+    form = forms.modelform_factory(Thing, fields=['name'])(formset_data)
+    formset = SubThingFormSet(formset_data, instance=None)  # No instance yet
+    
+    print(f"Parent form is valid: {form.is_valid()}")
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if form.is_valid() and formset.is_valid():
+        try:
+            # Save the parent first - this is where the issue occurs
+            thing = form.save(commit=False)
+            print(f"Thing after form save (before commit) - id: {thing.id}, pkid: {thing.pkid}")
+            
+            # The issue: when saving parent with inlines, the UUID default might not be set
+            thing.save()
+            print(f"Thing after commit - id: {thing.id}, pkid: {thing.pkid}")
+            
+            # Now set the instance and save the formset
+            formset.instance = thing
+            subthings = formset.save()
+            print(f"Successfully saved {len(subthings)} subthings")
+            for subthing in subthings:
+                print(f"SubThing: {subthing.name}, thing_id: {subthing.thing_id}")
+                
+        except Exception as e:
+            print(f"Error saving form or formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Form errors:", form.errors)
+        print("Formset errors:")
+        for form in formset:
+            print(f"  Form errors: {form.errors}")
+        print(f"Formset non-form errors: {formset.non_form_errors()}")
+
+def test_uuid_null_issue():
+    """Test the specific case where UUID becomes null - simulating the admin bug."""
+    from django import forms
+    from django.forms.models import inlineformset_factory
+    
+    print("\nTesting UUID null issue...")
+    
+    # Create formset factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, SubThing, form=forms.ModelForm, 
+        fields=['name'], extra=1
+    )
+    
+    # Simulate the case where UUID might become null
+    # Create formset data that might cause the issue
+    formset_data = {
+        'name': 'New Test Thing',
+        'subthings-TOTAL_FORMS': '1', 
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Create forms
+    ThingForm = forms.modelform_factory(Thing, fields=['name'])
+    form = ThingForm(formset_data)
+    formset = SubThingFormSet(formset_data, instance=None)
+    
+    if form.is_valid() and formset.is_valid():
+        thing = form.save(commit=False)
+        print(f"Thing before final save - id: {thing.id}")
+        
+        # Check if UUID is properly set
+        if thing.id is None:
+            print("ERROR: UUID is None! This is the bug.")
+            return False
+            
+        thing.save()
+        formset.instance = thing
+        formset.save()
+        print("Success - UUID was properly set")
+        return True
+    else:
+        print("Form validation failed")
+        return False
+
+if __name__ == '__main__':
+    from django.db import connection
+    
+    # Create the tables
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    test_admin_inline_issue()
+    test_uuid_null_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..748ad94595
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,123 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the UUIDField default value issue with Django Admin inlines.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models and admin classes as described in the issue
+from django.db import models
+from django.contrib import admin
+
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'testapp'
+
+def test_uuid_default_value():
+    """Test that UUID default value is properly set when using inlines."""
+    from django import forms
+    from django.forms.models import inlineformset_factory
+    
+    print("Testing UUIDField default value with inlines...")
+    
+    # Create a Thing instance
+    thing = Thing(name="Test Thing")
+    print(f"Thing before save - id: {thing.id}, pkid: {thing.pkid}")
+    
+    # Save the thing
+    thing.save()
+    print(f"Thing after save - id: {thing.id}, pkid: {thing.pkid}")
+    
+    # Test inline formset
+    SubThingFormSet = inlineformset_factory(
+        Thing, SubThing, form=forms.ModelForm, 
+        fields=['name'], extra=1
+    )
+    
+    # Create formset data
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    if formset.is_valid():
+        try:
+            subthings = formset.save()
+            print(f"Successfully saved {len(subthings)} subthings")
+            for subthing in subthings:
+                print(f"SubThing: {subthing.name}, thing_id: {subthing.thing_id}")
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:")
+        for form in formset:
+            print(f"  Form errors: {form.errors}")
+        print(f"Formset non-form errors: {formset.non_form_errors()}")
+
+if __name__ == '__main__':
+    from django.db import connection
+    
+    # Create the tables
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    test_uuid_default_value()
\ No newline at end of file
diff --git a/reproduce_uuid_issue.py b/reproduce_uuid_issue.py
new file mode 100644
index 0000000000..c355261f6e
--- /dev/null
+++ b/reproduce_uuid_issue.py
@@ -0,0 +1,155 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the specific UUIDField default value issue with Django Admin inlines.
+This specifically tests the case where the parent instance doesn't have a PK yet.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the models as described in the issue
+from django.db import models
+
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'testapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'testapp'
+
+def test_inline_formset_with_unsaved_parent():
+    """Test the specific case where parent instance is unsaved (no PK yet)."""
+    from django import forms
+    from django.forms.models import inlineformset_factory
+    
+    print("Testing inline formset with unsaved parent...")
+    
+    # Create an unsaved parent instance
+    thing = Thing(name="Test Thing")
+    print(f"Thing before save - id: {thing.id}, pkid: {thing.pkid}")
+    
+    # Create inline formset factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, SubThing, form=forms.ModelForm, 
+        fields=['name'], extra=1
+    )
+    
+    # Create formset with unsaved instance (simulating admin behavior)
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if formset.is_valid():
+        try:
+            # This should fail if there's a UUID issue
+            subthings = formset.save(commit=False)
+            print(f"Successfully created {len(subthings)} subthings (not committed)")
+            for subthing in subthings:
+                print(f"SubThing: {subthing.name}, thing_id: {subthing.thing_id}")
+                
+            # Now save the parent and see if the UUID gets properly set
+            thing.save()
+            print(f"Thing after save - id: {thing.id}, pkid: {thing.pkid}")
+            
+            # Now save the subthings
+            for subthing in subthings:
+                subthing.save()
+                print(f"SubThing saved: {subthing.name}, thing_id: {subthing.thing_id}")
+                
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:")
+        for form in formset:
+            print(f"  Form errors: {form.errors}")
+        print(f"Formset non-form errors: {formset.non_form_errors()}")
+
+def test_uuid_field_behavior():
+    """Test UUID field behavior specifically."""
+    print("\nTesting UUID field behavior...")
+    
+    # Test 1: Create instance without saving
+    thing1 = Thing(name="Thing 1")
+    print(f"Thing 1 before save - id: {thing1.id}")
+    
+    # Test 2: Create another instance without saving
+    thing2 = Thing(name="Thing 2") 
+    print(f"Thing 2 before save - id: {thing2.id}")
+    
+    # Test 3: Save first instance
+    thing1.save()
+    print(f"Thing 1 after save - id: {thing1.id}")
+    
+    # Test 4: Save second instance
+    thing2.save()
+    print(f"Thing 2 after save - id: {thing2.id}")
+    
+    # The UUIDs should be different and properly set
+    print(f"UUIDs are different: {thing1.id != thing2.id}")
+
+if __name__ == '__main__':
+    from django.db import connection
+    
+    # Create the tables
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    test_uuid_field_behavior()
+    test_inline_formset_with_unsaved_parent()
\ No newline at end of file
diff --git a/test_default_behavior.py b/test_default_behavior.py
new file mode 100644
index 0000000000..e658cdff43
--- /dev/null
+++ b/test_default_behavior.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+"""
+Test script to understand how field defaults work.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple model with UUIDField
+class TestModel(models.Model):
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_field_default():
+    """Test how UUIDField default works."""
+    from django.db import connection
+    
+    # Create the table
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Test 1: Create instance without saving
+    obj1 = TestModel(name="Test 1")
+    print(f"Object 1 before save - id: {obj1.id}")
+    
+    # Test 2: Create another instance without saving  
+    obj2 = TestModel(name="Test 2")
+    print(f"Object 2 before save - id: {obj2.id}")
+    
+    # Test 3: Save first instance
+    obj1.save()
+    print(f"Object 1 after save - id: {obj1.id}")
+    
+    # Test 4: Save second instance
+    obj2.save()
+    print(f"Object 2 after save - id: {obj2.id}")
+    
+    # Test 5: Check if UUIDs are different
+    print(f"UUIDs are different: {obj1.id != obj2.id}")
+    
+    # Test 6: Check the field's get_default method
+    field = TestModel._meta.get_field('id')
+    print(f"Field default: {field.default}")
+    print(f"Field has_default: {field.has_default()}")
+    print(f"Field get_default(): {field.get_default()}")
+    print(f"Field get_default() type: {type(field.get_default())}")
+
+if __name__ == '__main__':
+    test_field_default()
\ No newline at end of file