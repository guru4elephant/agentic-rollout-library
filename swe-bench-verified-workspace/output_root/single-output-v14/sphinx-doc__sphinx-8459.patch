diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 000000000..ad127617d
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from typing import Any, Dict
+from sphinx.util import inspect
+
+# Create the type alias
+JSONObject = Dict[str, Any]
+
+def sphinx_doc(data: JSONObject) -> JSONObject:
+    return {}
+
+# Test what inspect.signature returns with type aliases
+type_aliases = {
+    'JSONObject': 'types.JSONObject',
+}
+
+sig = inspect.signature(sphinx_doc, type_aliases=type_aliases)
+print("Signature with type aliases:")
+print(sig)
+
+# Check individual parameter annotations
+for param in sig.parameters.values():
+    if param.annotation is not param.empty:
+        print(f"Parameter {param.name}: {param.annotation} (type: {type(param.annotation)})")
+
+if sig.return_annotation is not sig.empty:
+    print(f"Return annotation: {sig.return_annotation} (type: {type(sig.return_annotation)})")
+
+# Test typing.stringify
+from sphinx.util.typing import stringify
+print("Stringify of parameter annotation:")
+for param in sig.parameters.values():
+    if param.annotation is not param.empty:
+        print(f"Stringify({param.annotation}) = {stringify(param.annotation)}")
+
+print("Stringify of return annotation:")
+if sig.return_annotation is not sig.empty:
+    print(f"Stringify({sig.return_annotation}) = {stringify(sig.return_annotation)}")
\ No newline at end of file
diff --git a/debug_types.py b/debug_types.py
new file mode 100644
index 000000000..841cfebcd
--- /dev/null
+++ b/debug_types.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from typing import Any, Dict
+from sphinx.util import inspect
+
+# Create the type alias
+JSONObject = Dict[str, Any]
+
+def sphinx_doc(data: JSONObject) -> JSONObject:
+    return {}
+
+# Test what inspect.signature returns with type aliases
+type_aliases = {
+    'JSONObject': 'types.JSONObject',
+}
+
+sig = inspect.signature(sphinx_doc, type_aliases=type_aliases)
+print("Signature with type aliases:")
+print(sig)
+
+# Check individual parameter annotations
+for param in sig.parameters.values():
+    if param.annotation is not param.empty:
+        print(f"Parameter {param.name}: {param.annotation} (type: {type(param.annotation)})")
+        print(f"  Hash: {hash(param.annotation)}")
+
+if sig.return_annotation is not sig.empty:
+    print(f"Return annotation: {sig.return_annotation} (type: {type(sig.return_annotation)})")
+    print(f"  Hash: {hash(sig.return_annotation)}")
+
+# Now try to import the type alias target
+alias_target = 'types.JSONObject'
+if '.' in alias_target:
+    module_name, type_name = alias_target.rsplit('.', 1)
+    print(f"Importing {module_name}.{type_name}")
+    module = __import__(module_name, fromlist=[type_name])
+    type_obj = getattr(module, type_name)
+    print(f"Imported type: {type_obj} (type: {type(type_obj)})")
+    print(f"  Hash: {hash(type_obj)}")
+    
+    # Compare with the annotation from signature
+    param_annotation = next(param for param in sig.parameters.values() if param.annotation is not param.empty).annotation
+    print(f"Same object? {param_annotation is type_obj}")
+    print(f"Equal objects? {param_annotation == type_obj}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..d52c3b1cf
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+import sys
+import os
+sys.path.insert(0, '/testbed')
+
+from typing import Any, Dict
+from sphinx.util import inspect
+from sphinx.util.typing import stringify
+
+# Create the type alias
+JSONObject = Dict[str, Any]
+
+def sphinx_doc(data: JSONObject) -> JSONObject:
+    """Does it work.
+    Args:
+        data: Does it args.
+    Returns:
+        Does it work in return.
+    """
+    return {}
+
+# Test the signature function with type aliases
+type_aliases = {
+    'JSONObject': 'types.JSONObject',
+}
+
+# Get the signature
+sig = inspect.signature(sphinx_doc, type_aliases=type_aliases)
+print("Signature with type aliases:")
+print(sig)
+
+# Stringify the signature
+sig_str = inspect.stringify_signature(sig)
+print("Stringified signature:")
+print(sig_str)
+
+# Test stringify_annotation directly
+print("Direct stringify of JSONObject:")
+print(stringify(JSONObject))
+
+# Test what happens when we get type hints directly
+import typing
+hints = typing.get_type_hints(sphinx_doc, None, type_aliases)
+print("Type hints with aliases:")
+print(hints)
\ No newline at end of file
diff --git a/setup.py b/setup.py
index ca08a6d4a..21cb67b8f 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py
index 70cbc3ba1..fa958afc9 100644
--- a/sphinx/ext/autodoc/typehints.py
+++ b/sphinx/ext/autodoc/typehints.py
@@ -27,12 +27,43 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,
         if callable(obj):
             annotations = app.env.temp_data.setdefault('annotations', {})
             annotation = annotations.setdefault(name, OrderedDict())
-            sig = inspect.signature(obj)
+            
+            # Get the signature with type aliases to resolve annotations
+            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)
+            
+            # Create a reverse mapping from type objects to alias names
+            reverse_aliases = {}
+            for alias_name, alias_target in app.config.autodoc_type_aliases.items():
+                # Import the target to get the actual type object
+                try:
+                    # Split module and name
+                    if '.' in alias_target:
+                        module_name, type_name = alias_target.rsplit('.', 1)
+                        module = __import__(module_name, fromlist=[type_name])
+                        type_obj = getattr(module, type_name)
+                        reverse_aliases[type_obj] = alias_name
+                    else:
+                        # Handle built-in types
+                        type_obj = __import__('builtins').__dict__.get(alias_target)
+                        if type_obj:
+                            reverse_aliases[type_obj] = alias_name
+                except (ImportError, AttributeError):
+                    pass
+            
             for param in sig.parameters.values():
                 if param.annotation is not param.empty:
-                    annotation[param.name] = typing.stringify(param.annotation)
+                    # Check if the annotation matches a type alias
+                    if param.annotation in reverse_aliases:
+                        annotation[param.name] = reverse_aliases[param.annotation]
+                    else:
+                        annotation[param.name] = typing.stringify(param.annotation)
+            
             if sig.return_annotation is not sig.empty:
-                annotation['return'] = typing.stringify(sig.return_annotation)
+                # Check if the return annotation matches a type alias
+                if sig.return_annotation in reverse_aliases:
+                    annotation['return'] = reverse_aliases[sig.return_annotation]
+                else:
+                    annotation['return'] = typing.stringify(sig.return_annotation)
     except (TypeError, ValueError):
         pass
 
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 000000000..19125b173
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from typing import Any, Dict
+from sphinx.ext.autodoc.typehints import record_typehints
+from sphinx.application import Sphinx
+from sphinx.environment import BuildEnvironment
+from sphinx.config import Config
+
+# Create a mock app and environment to simulate Sphinx behavior
+class MockApp:
+    def __init__(self):
+        self.config = MockConfig()
+        self.env = MockEnvironment()
+
+class MockConfig:
+    def __init__(self):
+        self.autodoc_type_aliases = {
+            'JSONObject': 'types.JSONObject',
+        }
+
+class MockEnvironment:
+    def __init__(self):
+        self.temp_data = {}
+
+# Create the type alias
+JSONObject = Dict[str, Any]
+
+def sphinx_doc(data: JSONObject) -> JSONObject:
+    """Does it work.
+    Args:
+        data: Does it args.
+    Returns:
+        Does it work in return.
+    """
+    return {}
+
+# Test the record_typehints function
+app = MockApp()
+record_typehints(app, 'function', 'test_module.sphinx_doc', sphinx_doc, {}, None, None)
+
+print("Annotations stored in environment:")
+print(app.env.temp_data.get('annotations', {}))
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index dbb705a3a..9f4fc3a32 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3