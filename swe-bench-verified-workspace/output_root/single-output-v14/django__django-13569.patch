diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0cfd62380f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Create models as described in the issue
+class Thing(models.Model):
+    class Meta:
+        app_label = 'test'
+
+class Related(models.Model):
+    thing = models.ForeignKey(Thing, on_delete=models.CASCADE, related_name='related_items')
+    
+    class Meta:
+        app_label = 'test'
+
+def test_issue():
+    from django.db import connection
+    
+    # Create tables
+    with connection.cursor() as cursor:
+        cursor.execute("CREATE TABLE test_thing (id INTEGER PRIMARY KEY AUTOINCREMENT);")
+        cursor.execute("CREATE TABLE test_related (id INTEGER PRIMARY KEY AUTOINCREMENT, thing_id INTEGER);")
+    
+    # Create test data
+    t = Thing.objects.create()
+    rs = [Related.objects.create(thing=t) for _ in range(2)]
+    
+    # Let's first check what fields are available on Thing
+    print("Available fields on Thing:", [f.name for f in Thing._meta.get_fields()])
+    
+    print("Test 1: order_by('rc') - should work correctly")
+    qs1 = Thing.objects.annotate(rc=Count('related')).order_by('rc').values('id', 'rc')
+    print("Query:", qs1.query)
+    print("Result:", list(qs1))
+    print()
+    
+    print("Test 2: order_by('related') - should break down grouping")
+    qs2 = Thing.objects.annotate(rc=Count('related')).order_by('related').values('id', 'rc')
+    print("Query:", qs2.query)
+    print("Result:", list(qs2))
+    print()
+    
+    print("Test 3: order_by('?') - should NOT break aggregation but currently does")
+    qs3 = Thing.objects.annotate(rc=Count('related')).order_by('?').values('id', 'rc')
+    print("Query:", qs3.query)
+    print("Result:", list(qs3))
+    print()
+    
+    # The issue: qs3 should return [{'id': 1, 'rc': 2}] but returns [{'id': 1, 'rc': 1}, {'id': 1, 'rc': 1}]
+    expected = [{'id': 1, 'rc': 2}]
+    actual = list(qs3)
+    
+    if actual == expected:
+        print("✓ SUCCESS: order_by('?') works correctly")
+        return True
+    else:
+        print("✗ FAILURE: order_by('?') breaks aggregation")
+        print(f"  Expected: {expected}")
+        print(f"  Actual: {actual}")
+        return False
+
+if __name__ == '__main__':
+    success = test_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file