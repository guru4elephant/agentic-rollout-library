diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..a227b2a9b0
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,18 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Comprehensive test of both x and y axis inversion fixes
+x = np.linspace(1000e2, 1, 100)
+y = np.exp(-np.linspace(0, 1, x.size))
+
+# Test all combinations
+for xscale in ('linear', 'log'):
+    for yscale in ('linear', 'log'):
+        fig, ax = plt.subplots()
+        ax.plot(x, y)
+        ax.set_xscale(xscale)
+        ax.set_yscale(yscale)
+        ax.set_xlim(x.max(), x.min())  # Invert x-axis
+        ax.set_ylim(y.max(), y.min())  # Invert y-axis
+        print(f"xscale: {xscale}, yscale: {yscale}, xlim: {ax.get_xlim()}, ylim: {ax.get_ylim()}")
+        plt.close(fig)
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..f8764b7376
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,23 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Reproduce the issue with more debugging
+y = np.linspace(1000e2, 1, 100)
+x = np.exp(-np.linspace(0, 1, y.size))
+
+for yscale in ('linear', 'log'):
+    fig, ax = plt.subplots()
+    ax.plot(x, y)
+    ax.set_yscale(yscale)
+    
+    print(f"\nBefore set_ylim - yscale: {yscale}")
+    print(f"viewLim.intervaly: {ax.viewLim.intervaly}")
+    
+    # Set the limits in reverse order
+    ax.set_ylim(y.max(), y.min())
+    
+    print(f"After set_ylim - yscale: {yscale}")
+    print(f"viewLim.intervaly: {ax.viewLim.intervaly}")
+    print(f"get_ylim(): {ax.get_ylim()}")
+    
+    plt.close(fig)
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 0000000000..851bb687ea
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,23 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Reproduce the issue with step-by-step debugging
+y = np.linspace(1000e2, 1, 100)
+x = np.exp(-np.linspace(0, 1, y.size))
+
+for yscale in ('linear', 'log'):
+    fig, ax = plt.subplots()
+    ax.plot(x, y)
+    
+    print(f"\n=== {yscale} scale ===")
+    print(f"Before set_yscale: viewLim.intervaly = {ax.viewLim.intervaly}")
+    
+    ax.set_yscale(yscale)
+    print(f"After set_yscale: viewLim.intervaly = {ax.viewLim.intervaly}")
+    
+    print(f"Before set_ylim: viewLim.intervaly = {ax.viewLim.intervaly}")
+    ax.set_ylim(y.max(), y.min())
+    print(f"After set_ylim: viewLim.intervaly = {ax.viewLim.intervaly}")
+    print(f"get_ylim(): {ax.get_ylim()}")
+    
+    plt.close(fig)
\ No newline at end of file
diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py
index da2dea6f57..18c8a82ab5 100644
--- a/lib/matplotlib/axes/_base.py
+++ b/lib/matplotlib/axes/_base.py
@@ -3264,8 +3264,17 @@ class _AxesBase(martist.Artist):
             cbook._warn_external(
                 f"Attempting to set identical left == right == {left} results "
                 f"in singular transformations; automatically expanding.")
-        left, right = self.xaxis.get_major_locator().nonsingular(left, right)
-        left, right = self.xaxis.limit_range_for_scale(left, right)
+        
+        # Check if user is explicitly setting inverted limits for log scale
+        # If so, preserve the inversion by avoiding nonsingular() call
+        if (self.get_xscale() == 'log' and left is not None and right is not None 
+            and left > right):
+            # For inverted log scale, we need to handle this specially
+            # to preserve the user's intended inversion
+            left, right = self.xaxis.limit_range_for_scale(left, right)
+        else:
+            left, right = self.xaxis.get_major_locator().nonsingular(left, right)
+            left, right = self.xaxis.limit_range_for_scale(left, right)
 
         self.viewLim.intervalx = (left, right)
         if auto is not None:
@@ -3644,8 +3653,17 @@ class _AxesBase(martist.Artist):
                 f"Attempting to set identical bottom == top == {bottom} "
                 f"results in singular transformations; automatically "
                 f"expanding.")
-        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
+        
+        # Check if user is explicitly setting inverted limits for log scale
+        # If so, preserve the inversion by avoiding nonsingular() call
+        if (self.get_yscale() == 'log' and bottom is not None and top is not None 
+            and bottom > top):
+            # For inverted log scale, we need to handle this specially
+            # to preserve the user's intended inversion
+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
+        else:
+            bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
 
         self.viewLim.intervaly = (bottom, top)
         if auto is not None:
diff --git a/linear_scale.png b/linear_scale.png
new file mode 100644
index 0000000000..76f2deee55
Binary files /dev/null and b/linear_scale.png differ
diff --git a/log_scale.png b/log_scale.png
new file mode 100644
index 0000000000..715b95f849
Binary files /dev/null and b/log_scale.png differ
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c4e9f47234
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,15 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Reproduce the issue described in the GitHub issue
+y = np.linspace(1000e2, 1, 100)
+x = np.exp(-np.linspace(0, 1, y.size))
+
+for yscale in ('linear', 'log'):
+    fig, ax = plt.subplots()
+    ax.plot(x, y)
+    ax.set_yscale(yscale)
+    ax.set_ylim(y.max(), y.min())
+    print(f"yscale: {yscale}, ylim: {ax.get_ylim()}")
+    plt.savefig(f'{yscale}_scale.png')
+    plt.close(fig)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..9f383ffd41
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,48 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Test edge cases to ensure the fix doesn't break anything
+y = np.linspace(1000e2, 1, 100)
+x = np.exp(-np.linspace(0, 1, y.size))
+
+# Test 1: Normal limits (not inverted)
+fig, ax = plt.subplots()
+ax.plot(x, y)
+ax.set_yscale('log')
+ax.set_ylim(y.min(), y.max())
+print(f"Test 1 - Normal limits: {ax.get_ylim()}")
+plt.close(fig)
+
+# Test 2: Inverted limits
+fig, ax = plt.subplots()
+ax.plot(x, y)
+ax.set_yscale('log')
+ax.set_ylim(y.max(), y.min())
+print(f"Test 2 - Inverted limits: {ax.get_ylim()}")
+plt.close(fig)
+
+# Test 3: Partial limits (only one specified)
+fig, ax = plt.subplots()
+ax.plot(x, y)
+ax.set_yscale('log')
+original_limits = ax.get_ylim()
+ax.set_ylim(top=y.min())  # Only set top
+print(f"Test 3 - Partial top: {ax.get_ylim()} (original: {original_limits})")
+plt.close(fig)
+
+# Test 4: Partial limits (only bottom specified)
+fig, ax = plt.subplots()
+ax.plot(x, y)
+ax.set_yscale('log')
+original_limits = ax.get_ylim()
+ax.set_ylim(bottom=y.max())  # Only set bottom
+print(f"Test 4 - Partial bottom: {ax.get_ylim()} (original: {original_limits})")
+plt.close(fig)
+
+# Test 5: Very small range
+fig, ax = plt.subplots()
+ax.plot(x, y)
+ax.set_yscale('log')
+ax.set_ylim(10, 1)  # Small inverted range
+print(f"Test 5 - Small inverted range: {ax.get_ylim()}")
+plt.close(fig)
\ No newline at end of file
diff --git a/test_xaxis_fix.py b/test_xaxis_fix.py
new file mode 100644
index 0000000000..b347d3d7a2
--- /dev/null
+++ b/test_xaxis_fix.py
@@ -0,0 +1,14 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+# Test x-axis inversion fix
+x = np.linspace(1000e2, 1, 100)
+y = np.exp(-np.linspace(0, 1, x.size))
+
+for xscale in ('linear', 'log'):
+    fig, ax = plt.subplots()
+    ax.plot(x, y)
+    ax.set_xscale(xscale)
+    ax.set_xlim(x.max(), x.min())
+    print(f"xscale: {xscale}, xlim: {ax.get_xlim()}")
+    plt.close(fig)
\ No newline at end of file