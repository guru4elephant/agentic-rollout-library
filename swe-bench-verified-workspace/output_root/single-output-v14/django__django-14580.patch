diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index e19c881cda..072a2efc14 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -273,7 +273,7 @@ class TupleSerializer(BaseSequenceSerializer):
 class TypeSerializer(BaseSerializer):
     def serialize(self):
         special_cases = [
-            (models.Model, "models.Model", []),
+            (models.Model, "models.Model", ["from django.db import models"]),
             (type(None), 'type(None)', []),
         ]
         for case, string, imports in special_cases:
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..16fe578019
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+import os
+import sys
+import tempfile
+import shutil
+import django
+from django.conf import settings
+
+def reproduce_issue():
+    # Create a temporary directory for our test app
+    temp_dir = tempfile.mkdtemp()
+    app_dir = os.path.join(temp_dir, 'app')
+    os.makedirs(app_dir)
+    
+    # Create __init__.py
+    with open(os.path.join(app_dir, '__init__.py'), 'w') as f:
+        f.write('')
+    
+    # Create models.py with the problematic content
+    models_content = '''from django.db import models
+
+class MyField(models.TextField):
+    pass
+
+class MyBaseModel(models.Model):
+    class Meta:
+        abstract = True
+
+class MyMixin:
+    pass
+
+class MyModel(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+'''
+    
+    with open(os.path.join(app_dir, 'models.py'), 'w') as f:
+        f.write(models_content)
+    
+    # Configure Django settings after creating the app structure
+    # Add the temp directory to Python path so Django can find the app
+    sys.path.insert(0, temp_dir)
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': ':memory:',
+                }
+            },
+            INSTALLED_APPS=[
+                'django.contrib.contenttypes',
+                'django.contrib.auth',
+                'app',
+            ],
+            USE_TZ=True,
+        )
+        django.setup()
+    
+    # Change to temp directory and run makemigrations
+    original_cwd = os.getcwd()
+    try:
+        os.chdir(temp_dir)
+        
+        # The app is already in INSTALLED_APPS from the settings configuration
+        
+        # Run makemigrations
+        from django.core.management import call_command
+        call_command('makemigrations', 'app', verbosity=2)
+        
+        # Check the generated migration file
+        migrations_dir = os.path.join(app_dir, 'migrations')
+        if os.path.exists(migrations_dir):
+            migration_files = [f for f in os.listdir(migrations_dir) if f.endswith('.py') and f != '__init__.py']
+            if migration_files:
+                migration_file = os.path.join(migrations_dir, migration_files[0])
+                print("Generated migration file:")
+                with open(migration_file, 'r') as f:
+                    content = f.read()
+                    print(content)
+                
+                # Try to import the migration to see if it works
+                try:
+                    # Add the temp directory to Python path
+                    sys.path.insert(0, temp_dir)
+                    migration_module_name = f'app.migrations.{migration_files[0][:-3]}'
+                    import importlib
+                    importlib.import_module(migration_module_name)
+                    print("SUCCESS: Migration imported without errors!")
+                except Exception as e:
+                    print(f"ERROR: Failed to import migration: {e}")
+                    return False
+                
+        return True
+        
+    finally:
+        os.chdir(original_cwd)
+        shutil.rmtree(temp_dir)
+
+if __name__ == '__main__':
+    reproduce_issue()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..22066cc091
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,145 @@
+#!/usr/bin/env python3
+import os
+import sys
+import tempfile
+import shutil
+import django
+from django.conf import settings
+
+def test_comprehensive():
+    # Create a temporary directory for our test app
+    temp_dir = tempfile.mkdtemp()
+    app_dir = os.path.join(temp_dir, 'app')
+    os.makedirs(app_dir)
+    
+    # Create __init__.py
+    with open(os.path.join(app_dir, '__init__.py'), 'w') as f:
+        f.write('')
+    
+    # Test case 1: models.Model in bases with custom mixin
+    models_content_1 = '''from django.db import models
+
+class MyField(models.TextField):
+    pass
+
+class MyBaseModel(models.Model):
+    class Meta:
+        abstract = True
+
+class MyMixin:
+    pass
+
+class MyModel(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+'''
+    
+    # Test case 2: Only models.Model in bases
+    models_content_2 = '''from django.db import models
+
+class SimpleModel(models.Model):
+    name = models.CharField(max_length=100)
+'''
+    
+    # Test case 3: Multiple custom bases with models.Model
+    models_content_3 = '''from django.db import models
+
+class Mixin1:
+    pass
+
+class Mixin2:
+    pass
+
+class ComplexModel(Mixin1, Mixin2, models.Model):
+    name = models.CharField(max_length=100)
+'''
+    
+    test_cases = [
+        ('test1', models_content_1),
+        ('test2', models_content_2), 
+        ('test3', models_content_3)
+    ]
+    
+    for test_name, models_content in test_cases:
+        print(f"\n=== Running {test_name} ===")
+        
+        # Write models.py
+        with open(os.path.join(app_dir, 'models.py'), 'w') as f:
+            f.write(models_content)
+        
+        # Configure Django settings
+        sys.path.insert(0, temp_dir)
+        if not settings.configured:
+            settings.configure(
+                DEBUG=True,
+                DATABASES={
+                    'default': {
+                        'ENGINE': 'django.db.backends.sqlite3',
+                        'NAME': ':memory:',
+                    }
+                },
+                INSTALLED_APPS=[
+                    'django.contrib.contenttypes',
+                    'django.contrib.auth',
+                    'app',
+                ],
+                USE_TZ=True,
+            )
+            django.setup()
+        
+        # Change to temp directory and run makemigrations
+        original_cwd = os.getcwd()
+        try:
+            os.chdir(temp_dir)
+            
+            # Run makemigrations
+            from django.core.management import call_command
+            call_command('makemigrations', 'app', verbosity=0)
+            
+            # Check the generated migration file
+            migrations_dir = os.path.join(app_dir, 'migrations')
+            if os.path.exists(migrations_dir):
+                migration_files = [f for f in os.listdir(migrations_dir) if f.endswith('.py') and f != '__init__.py']
+                if migration_files:
+                    migration_file = os.path.join(migrations_dir, migration_files[0])
+                    with open(migration_file, 'r') as f:
+                        content = f.read()
+                    
+                    # Check if models import is present
+                    if 'from django.db import models' in content or 'from django.db import migrations, models' in content:
+                        print(f"✓ {test_name}: models import found")
+                    else:
+                        print(f"✗ {test_name}: models import missing")
+                    
+                    # Try to import the migration to see if it works
+                    try:
+                        migration_module_name = f'app.migrations.{migration_files[0][:-3]}'
+                        import importlib
+                        importlib.import_module(migration_module_name)
+                        print(f"✓ {test_name}: Migration imported successfully")
+                    except Exception as e:
+                        print(f"✗ {test_name}: Failed to import migration: {e}")
+                        return False
+                    
+                    # Clean up for next test
+                    for f in os.listdir(migrations_dir):
+                        if f.endswith('.py') and f != '__init__.py':
+                            os.remove(os.path.join(migrations_dir, f))
+                else:
+                    print(f"✗ {test_name}: No migration file generated")
+                    return False
+            else:
+                print(f"✗ {test_name}: Migrations directory not created")
+                return False
+                
+        finally:
+            os.chdir(original_cwd)
+            # Clean up models.py for next test
+            if os.path.exists(os.path.join(app_dir, 'models.py')):
+                os.remove(os.path.join(app_dir, 'models.py'))
+    
+    shutil.rmtree(temp_dir)
+    print("\n=== All tests passed! ===")
+    return True
+
+if __name__ == '__main__':
+    test_comprehensive()
\ No newline at end of file
diff --git a/test_import_deduplication.py b/test_import_deduplication.py
new file mode 100644
index 0000000000..982f728505
--- /dev/null
+++ b/test_import_deduplication.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+import os
+import sys
+import tempfile
+import shutil
+import django
+from django.conf import settings
+
+def test_import_deduplication():
+    """Test that imports are properly deduplicated when models.Model is used multiple times"""
+    
+    # Create a temporary directory for our test app
+    temp_dir = tempfile.mkdtemp()
+    app_dir = os.path.join(temp_dir, 'app')
+    os.makedirs(app_dir)
+    
+    # Create __init__.py
+    with open(os.path.join(app_dir, '__init__.py'), 'w') as f:
+        f.write('')
+    
+    # Create models.py with multiple models that inherit from models.Model
+    models_content = '''from django.db import models
+
+class MyField(models.TextField):
+    pass
+
+class MyBaseModel(models.Model):
+    class Meta:
+        abstract = True
+
+class MyMixin:
+    pass
+
+class MyModel1(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+
+class MyModel2(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+
+class MyModel3(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+'''
+    
+    with open(os.path.join(app_dir, 'models.py'), 'w') as f:
+        f.write(models_content)
+    
+    # Configure Django settings after creating the app structure
+    sys.path.insert(0, temp_dir)
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': ':memory:',
+                }
+            },
+            INSTALLED_APPS=[
+                'django.contrib.contenttypes',
+                'django.contrib.auth',
+                'app',
+            ],
+            USE_TZ=True,
+        )
+        django.setup()
+    
+    # Change to temp directory and run makemigrations
+    original_cwd = os.getcwd()
+    try:
+        os.chdir(temp_dir)
+        
+        # Run makemigrations
+        from django.core.management import call_command
+        call_command('makemigrations', 'app', verbosity=0)
+        
+        # Check the generated migration file
+        migrations_dir = os.path.join(app_dir, 'migrations')
+        if os.path.exists(migrations_dir):
+            migration_files = [f for f in os.listdir(migrations_dir) if f.endswith('.py') and f != '__init__.py']
+            if migration_files:
+                migration_file = os.path.join(migrations_dir, migration_files[0])
+                with open(migration_file, 'r') as f:
+                    content = f.read()
+                
+                print("Generated migration file content:")
+                print(content)
+                
+                # Check if models import is present and properly formatted
+                if 'from django.db import migrations, models' in content:
+                    print("✓ Import is properly formatted as 'from django.db import migrations, models'")
+                elif 'from django.db import models' in content and 'from django.db import migrations' in content:
+                    print("✓ Both imports are present (may be on separate lines)")
+                else:
+                    print("✗ models import missing or improperly formatted")
+                    return False
+                
+                # Count how many times models import appears (should be exactly once)
+                models_import_count = content.count('from django.db import models')
+                combined_import_count = content.count('from django.db import migrations, models')
+                total_models_imports = models_import_count + combined_import_count
+                
+                if total_models_imports == 1:
+                    print("✓ models import appears exactly once (properly deduplicated)")
+                else:
+                    print(f"✗ models import appears {total_models_imports} times (should be exactly once)")
+                    return False
+                
+                # Try to import the migration to see if it works
+                try:
+                    migration_module_name = f'app.migrations.{migration_files[0][:-3]}'
+                    import importlib
+                    importlib.import_module(migration_module_name)
+                    print("✓ Migration imported successfully")
+                except Exception as e:
+                    print(f"✗ Failed to import migration: {e}")
+                    return False
+                
+                return True
+            else:
+                print("✗ No migration file generated")
+                return False
+        else:
+            print("✗ Migrations directory not created")
+            return False
+            
+    finally:
+        os.chdir(original_cwd)
+        shutil.rmtree(temp_dir)
+
+if __name__ == '__main__':
+    test_import_deduplication()
\ No newline at end of file
diff --git a/test_serializer_fix.py b/test_serializer_fix.py
new file mode 100644
index 0000000000..ca03425255
--- /dev/null
+++ b/test_serializer_fix.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import TypeSerializer
+
+def test_serializer():
+    print("Testing TypeSerializer with models.Model...")
+    
+    # Test models.Model serialization
+    serializer = TypeSerializer(models.Model)
+    result, imports = serializer.serialize()
+    
+    print(f"Result: {result}")
+    print(f"Imports: {imports}")
+    
+    # Check that the result is correct
+    assert result == "models.Model", f"Expected 'models.Model', got '{result}'"
+    
+    # Check that the import is included
+    expected_import = "from django.db import models"
+    assert expected_import in imports, f"Expected import '{expected_import}' not found in {imports}"
+    
+    print("✓ models.Model serialization test passed!")
+    
+    # Test other types to make sure we didn't break anything
+    print("\nTesting TypeSerializer with other types...")
+    
+    # Test None type
+    serializer = TypeSerializer(type(None))
+    result, imports = serializer.serialize()
+    assert result == "type(None)", f"Expected 'type(None)', got '{result}'"
+    assert len(imports) == 0, f"Expected no imports for type(None), got {imports}"
+    print("✓ type(None) serialization test passed!")
+    
+    # Test built-in type
+    serializer = TypeSerializer(int)
+    result, imports = serializer.serialize()
+    assert result == "int", f"Expected 'int', got '{result}'"
+    assert len(imports) == 0, f"Expected no imports for int, got {imports}"
+    print("✓ int serialization test passed!")
+    
+    # Test custom type from another module
+    import decimal
+    serializer = TypeSerializer(decimal.Decimal)
+    result, imports = serializer.serialize()
+    assert result == "decimal.Decimal", f"Expected 'decimal.Decimal', got '{result}'"
+    assert "import decimal" in imports, f"Expected 'import decimal' in {imports}"
+    print("✓ decimal.Decimal serialization test passed!")
+    
+    print("\n✓ All TypeSerializer tests passed!")
+
+if __name__ == '__main__':
+    test_serializer()
\ No newline at end of file