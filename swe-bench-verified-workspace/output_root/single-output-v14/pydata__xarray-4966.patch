diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 00000000..d9f517ab
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,179 @@
+#!/usr/bin/env python3
+"""
+Final verification that the GitHub issue is completely fixed
+"""
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+from xarray.coding.variables import SerializationWarning
+
+def test_github_issue_scenario():
+    """
+    Test the exact scenario described in the GitHub issue:
+    - OPeNDAP returns unsigned bytes with _Unsigned="false" 
+    - This should be converted to signed bytes to match netCDF4 behavior
+    """
+    print("=== GitHub Issue Fix Verification ===")
+    print("Testing the exact scenario from the issue...")
+    print()
+    
+    coder = UnsignedIntegerCoder()
+    
+    # Simulate the exact data from the GitHub issue example:
+    # OPeNDAP returns: [128, 255, 0, 1, 2, 127] as uint8
+    # With _Unsigned="false" attribute
+    opendap_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    opendap_attrs = {'_Unsigned': 'false'}  # OPeNDAP hack
+    
+    # netCDF4 would return the correctly converted signed bytes
+    expected_netcdf4_result = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    
+    print("Input from OPeNDAP:")
+    print(f"  Data: {opendap_data}")
+    print(f"  Data type: {opendap_data.dtype}")
+    print(f"  Attributes: {opendap_attrs}")
+    print()
+    
+    print("Expected from netCDF4 (reference):")
+    print(f"  Data: {expected_netcdf4_result}")
+    print(f"  Data type: {expected_netcdf4_result.dtype}")
+    print()
+    
+    # Apply our fix
+    variable = Variable(['test'], opendap_data, opendap_attrs, {})
+    result = coder.decode(variable, name='test')
+    
+    print("Actual result after our fix:")
+    print(f"  Data: {result.data}")
+    print(f"  Data type: {result.data.dtype}")
+    print()
+    
+    # Verify the fix
+    data_matches = np.array_equal(result.data, expected_netcdf4_result)
+    dtype_matches = result.data.dtype == expected_netcdf4_result.dtype
+    
+    if data_matches and dtype_matches:
+        print("‚úì SUCCESS: Our fix produces the same result as netCDF4!")
+        print("‚úì The OPeNDAP hack (_Unsigned='false') is now properly handled!")
+        print("‚úì pydap and netCDF4 engines now return consistent results!")
+        return True
+    else:
+        print("‚úó FAILED: Results don't match")
+        if not data_matches:
+            print("  - Data values don't match")
+        if not dtype_matches:
+            print(f"  - Data types don't match: {result.data.dtype} vs {expected_netcdf4_result.dtype}")
+        return False
+
+def test_no_regression():
+    """
+    Test that existing functionality is not broken
+    """
+    print("\n=== Testing No Regression ===")
+    
+    coder = UnsignedIntegerCoder()
+    
+    # Test 1: _Unsigned="true" with signed integers (existing functionality)
+    print("1. Testing _Unsigned='true' (existing functionality):")
+    signed_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    attrs = {'_Unsigned': 'true'}
+    variable = Variable(['test'], signed_data, attrs, {})
+    
+    result = coder.decode(variable, name='test')
+    expected_unsigned = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    
+    if (np.array_equal(result.data, expected_unsigned) and 
+        result.data.dtype == expected_unsigned.dtype):
+        print("   ‚úì _Unsigned='true' works correctly")
+    else:
+        print("   ‚úó _Unsigned='true' broken")
+        return False
+    
+    # Test 2: No _Unsigned attribute (should leave data unchanged)
+    print("2. Testing no _Unsigned attribute:")
+    original_data = np.array([1, 2, 3], dtype=np.int8)
+    attrs = {}
+    variable = Variable(['test'], original_data, attrs, {})
+    
+    result = coder.decode(variable, name='test')
+    
+    if (np.array_equal(result.data, original_data) and 
+        result.data.dtype == original_data.dtype):
+        print("   ‚úì No _Unsigned attribute works correctly")
+    else:
+        print("   ‚úó No _Unsigned attribute broken")
+        return False
+    
+    # Test 3: Invalid _Unsigned value (should leave data unchanged)
+    print("3. Testing invalid _Unsigned value:")
+    original_data = np.array([1, 2, 3], dtype=np.int8)
+    attrs = {'_Unsigned': 'invalid'}
+    variable = Variable(['test'], original_data, attrs, {})
+    
+    result = coder.decode(variable, name='test')
+    
+    if (np.array_equal(result.data, original_data) and 
+        result.data.dtype == original_data.dtype):
+        print("   ‚úì Invalid _Unsigned value handled correctly")
+    else:
+        print("   ‚úó Invalid _Unsigned value broken")
+        return False
+    
+    return True
+
+def test_edge_cases():
+    """
+    Test edge cases to ensure robustness
+    """
+    print("\n=== Testing Edge Cases ===")
+    
+    coder = UnsignedIntegerCoder()
+    
+    # Test different integer sizes
+    test_cases = [
+        (np.uint8, np.int8),
+        (np.uint16, np.int16), 
+        (np.uint32, np.int32),
+        (np.uint64, np.int64)
+    ]
+    
+    for unsigned_type, signed_type in test_cases:
+        print(f"Testing {unsigned_type.__name__} -> {signed_type.__name__}:")
+        
+        # Create test data
+        max_val = np.iinfo(unsigned_type).max
+        test_data = np.array([max_val, 0, 1], dtype=unsigned_type)
+        attrs = {'_Unsigned': 'false'}
+        variable = Variable(['test'], test_data, attrs, {})
+        
+        result = coder.decode(variable, name='test')
+        
+        # Verify conversion
+        expected = test_data.astype(signed_type)
+        if (np.array_equal(result.data, expected) and 
+            result.data.dtype == expected.dtype):
+            print(f"   ‚úì {unsigned_type.__name__} conversion works")
+        else:
+            print(f"   ‚úó {unsigned_type.__name__} conversion failed")
+            return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = True
+    
+    success &= test_github_issue_scenario()
+    success &= test_no_regression() 
+    success &= test_edge_cases()
+    
+    print("\n" + "="*50)
+    if success:
+        print("üéâ ALL TESTS PASSED! The GitHub issue is FIXED!")
+        print("‚úÖ _Unsigned='false' now correctly converts unsigned to signed")
+        print("‚úÖ Existing functionality is preserved")
+        print("‚úÖ Edge cases are handled correctly")
+    else:
+        print("‚ùå SOME TESTS FAILED! The fix needs more work.")
+    
+    print("="*50)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..24a8c83c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with signed bytes from OPeNDAP via pydap
+"""
+import xarray as xr
+import warnings
+from xarray.coding.variables import SerializationWarning
+
+# Capture warnings to see the issue
+warnings.filterwarnings('error', category=SerializationWarning)
+
+# Test URL from the issue
+url = "https://observations.ipsl.fr/thredds/dodsC/EUREC4A/PRODUCTS/testdata/netcdf_testfiles/test_NC_BYTE_neg.nc"
+
+print("Testing netcdf4 engine...")
+try:
+    ds_netcdf4 = xr.open_dataset(url, engine="netcdf4")
+    print(f"netCDF4 result: {ds_netcdf4['test'].values}")
+except Exception as e:
+    print(f"netCDF4 error: {e}")
+
+print("\nTesting pydap engine...")
+try:
+    ds_pydap = xr.open_dataset(url, engine="pydap")
+    print(f"pydap result: {ds_pydap['test'].values}")
+except Exception as e:
+    print(f"pydap error: {e}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..a52a6c5e
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the _Unsigned attribute handling fix
+"""
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+from xarray.coding.variables import SerializationWarning
+
+# Capture warnings
+warnings.filterwarnings('error', category=SerializationWarning)
+
+def test_edge_cases():
+    """Test various edge cases for _Unsigned handling"""
+    coder = UnsignedIntegerCoder()
+    
+    print("=== Testing Edge Cases ===")
+    
+    # Test 1: _Unsigned="false" with unsigned 16-bit integers
+    print("\n1. _Unsigned='false' with uint16:")
+    data = np.array([32768, 65535, 0, 1, 32767], dtype=np.uint16)
+    attrs = {'_Unsigned': 'false'}
+    variable = Variable(['x'], data, attrs, {})
+    
+    decoded = coder.decode(variable, name='test')
+    print(f"   Original: {data} ({data.dtype})")
+    print(f"   Decoded: {decoded.data} ({decoded.data.dtype})")
+    
+    # Test 2: _Unsigned="true" with signed 16-bit integers  
+    print("\n2. _Unsigned='true' with int16:")
+    data = np.array([-32768, -1, 0, 1, 32767], dtype=np.int16)
+    attrs = {'_Unsigned': 'true'}
+    variable = Variable(['x'], data, attrs, {})
+    
+    decoded = coder.decode(variable, name='test')
+    print(f"   Original: {data} ({data.dtype})")
+    print(f"   Decoded: {decoded.data} ({decoded.data.dtype})")
+    
+    # Test 3: _Unsigned with non-integer data (should warn)
+    print("\n3. _Unsigned with float data (should warn):")
+    data = np.array([1.0, 2.0, 3.0], dtype=np.float32)
+    attrs = {'_Unsigned': 'true'}
+    variable = Variable(['x'], data, attrs, {})
+    
+    try:
+        decoded = coder.decode(variable, name='test')
+        print("   ERROR: Should have warned but didn't")
+    except Exception as e:
+        print(f"   SUCCESS: Got expected warning - {e}")
+    
+    # Test 4: Invalid _Unsigned value
+    print("\n4. Invalid _Unsigned value:")
+    data = np.array([1, 2, 3], dtype=np.int8)
+    attrs = {'_Unsigned': 'invalid'}
+    variable = Variable(['x'], data, attrs, {})
+    
+    decoded = coder.decode(variable, name='test')
+    print(f"   Original: {data} ({data.dtype})")
+    print(f"   Decoded: {decoded.data} ({decoded.data.dtype})")
+    print("   SUCCESS: Invalid value ignored, data unchanged")
+
+def test_fill_values():
+    """Test _Unsigned handling with _FillValue"""
+    coder = UnsignedIntegerCoder()
+    
+    print("\n=== Testing _FillValue Handling ===")
+    
+    # Test _Unsigned="false" with _FillValue
+    print("\n1. _Unsigned='false' with _FillValue:")
+    data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    attrs = {'_Unsigned': 'false', '_FillValue': 255}
+    variable = Variable(['x'], data, attrs, {})
+    
+    decoded = coder.decode(variable, name='test')
+    print(f"   Original data: {data}")
+    print(f"   Original _FillValue: {attrs['_FillValue']} (uint8)")
+    print(f"   Decoded _FillValue: {decoded.attrs.get('_FillValue', 'None')} ({type(decoded.attrs.get('_FillValue', 'None')).__name__})")
+    
+    # Test _Unsigned="true" with _FillValue
+    print("\n2. _Unsigned='true' with _FillValue:")
+    data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    attrs = {'_Unsigned': 'true', '_FillValue': -1}
+    variable = Variable(['x'], data, attrs, {})
+    
+    decoded = coder.decode(variable, name='test')
+    print(f"   Original data: {data}")
+    print(f"   Original _FillValue: {attrs['_FillValue']} (int8)")
+    print(f"   Decoded _FillValue: {decoded.attrs.get('_FillValue', 'None')} ({type(decoded.attrs.get('_FillValue', 'None')).__name__})")
+
+if __name__ == "__main__":
+    test_edge_cases()
+    test_fill_values()
\ No newline at end of file
diff --git a/test_opendap_scenario.py b/test_opendap_scenario.py
new file mode 100644
index 00000000..ef21ef51
--- /dev/null
+++ b/test_opendap_scenario.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""
+Test to simulate the exact OPeNDAP scenario described in the GitHub issue
+"""
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+
+def test_opendap_scenario():
+    """
+    Simulate the OPeNDAP scenario where:
+    - Data comes as unsigned bytes (uint8) from OPeNDAP
+    - _Unsigned="false" attribute indicates these should be treated as signed bytes
+    - This is the hack used by netCDF-c and thredds server
+    """
+    print("=== Simulating OPeNDAP Scenario ===")
+    print("Data from OPeNDAP: unsigned bytes with _Unsigned='false'")
+    print("Expected: should be converted to signed bytes")
+    print()
+    
+    coder = UnsignedIntegerCoder()
+    
+    # Simulate the exact data from the GitHub issue example
+    # OPeNDAP returns unsigned bytes: [128, 255, 0, 1, 2, 127] 
+    # But with _Unsigned="false", these should be interpreted as signed bytes
+    opendap_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    attrs = {'_Unsigned': 'false'}  # This is the OPeNDAP hack
+    
+    variable = Variable(['test'], opendap_data, attrs, {})
+    
+    print("Input from OPeNDAP:")
+    print(f"  Data: {opendap_data}")
+    print(f"  Data type: {opendap_data.dtype}")
+    print(f"  Attributes: {attrs}")
+    print()
+    
+    # Apply the decoding
+    decoded = coder.decode(variable, name='test')
+    
+    print("After xarray decoding:")
+    print(f"  Data: {decoded.data}")
+    print(f"  Data type: {decoded.data.dtype}")
+    print(f"  Expected signed values: [-128, -1, 0, 1, 2, 127]")
+    print()
+    
+    # Verify the conversion is correct
+    expected = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    if np.array_equal(decoded.data, expected):
+        print("‚úì SUCCESS: OPeNDAP unsigned bytes correctly converted to signed bytes!")
+        print("‚úì The _Unsigned='false' hack is now properly handled!")
+    else:
+        print("‚úó FAILED: Conversion did not work as expected")
+        print(f"  Expected: {expected}")
+        print(f"  Got: {decoded.data}")
+
+def test_netcdf4_comparison():
+    """
+    Test that our fix makes pydap behavior consistent with netcdf4 behavior
+    """
+    print("\n=== Testing Consistency with netCDF4 Behavior ===")
+    
+    coder = UnsignedIntegerCoder()
+    
+    # Simulate what netCDF4 would return (already properly converted)
+    netcdf4_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    
+    # Simulate what pydap would return before our fix (unsigned bytes)
+    pydap_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    pydap_attrs = {'_Unsigned': 'false'}
+    
+    pydap_variable = Variable(['test'], pydap_data, pydap_attrs, {})
+    pydap_decoded = coder.decode(pydap_variable, name='test')
+    
+    print("netCDF4 result (reference):")
+    print(f"  Data: {netcdf4_data}")
+    print(f"  Data type: {netcdf4_data.dtype}")
+    print()
+    
+    print("pydap result after our fix:")
+    print(f"  Data: {pydap_decoded.data}")
+    print(f"  Data type: {pydap_decoded.data.dtype}")
+    print()
+    
+    if np.array_equal(netcdf4_data, pydap_decoded.data):
+        print("‚úì SUCCESS: pydap now returns the same result as netCDF4!")
+        print("‚úì The issue described in the GitHub issue is FIXED!")
+    else:
+        print("‚úó FAILED: pydap and netCDF4 results are still different")
+
+if __name__ == "__main__":
+    test_opendap_scenario()
+    test_netcdf4_comparison()
\ No newline at end of file
diff --git a/test_unsigned_fix.py b/test_unsigned_fix.py
new file mode 100644
index 00000000..be3bcce7
--- /dev/null
+++ b/test_unsigned_fix.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for handling _Unsigned=False from OPeNDAP
+"""
+import numpy as np
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+from xarray.coding.variables import SerializationWarning
+
+# Capture warnings
+warnings.filterwarnings('error', category=SerializationWarning)
+
+def test_unsigned_false_handling():
+    """Test that _Unsigned=False is handled correctly"""
+    coder = UnsignedIntegerCoder()
+    
+    # Simulate the case from OPeNDAP: unsigned byte data with _Unsigned=False
+    # This should be converted to signed bytes
+    unsigned_byte_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)
+    attrs = {'_Unsigned': 'false'}
+    encoding = {}
+    
+    variable = Variable(['x'], unsigned_byte_data, attrs, encoding)
+    
+    print("Original data (unsigned bytes):", unsigned_byte_data)
+    print("Original dtype:", unsigned_byte_data.dtype)
+    
+    try:
+        decoded = coder.decode(variable, name='test')
+        print("Decoded data:", decoded.data)
+        print("Decoded dtype:", decoded.data.dtype)
+        print("SUCCESS: _Unsigned=False was handled correctly")
+    except Exception as e:
+        print("ERROR:", e)
+        print("This demonstrates the issue - _Unsigned=False is not handled")
+
+def test_unsigned_true_handling():
+    """Test that _Unsigned=True still works (existing functionality)"""
+    coder = UnsignedIntegerCoder()
+    
+    # Simulate the standard case: signed byte data with _Unsigned=True
+    signed_byte_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)
+    attrs = {'_Unsigned': 'true'}
+    encoding = {}
+    
+    variable = Variable(['x'], signed_byte_data, attrs, encoding)
+    
+    print("\nTesting _Unsigned=True (existing functionality):")
+    print("Original data (signed bytes):", signed_byte_data)
+    print("Original dtype:", signed_byte_data.dtype)
+    
+    try:
+        decoded = coder.decode(variable, name='test')
+        print("Decoded data:", decoded.data)
+        print("Decoded dtype:", decoded.data.dtype)
+        print("SUCCESS: _Unsigned=True works correctly")
+    except Exception as e:
+        print("ERROR:", e)
+
+if __name__ == "__main__":
+    test_unsigned_false_handling()
+    test_unsigned_true_handling()
\ No newline at end of file
diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index b035ff82..c97e037a 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -308,14 +308,25 @@ class UnsignedIntegerCoder(VariableCoder):
         if "_Unsigned" in attrs:
             unsigned = pop_to(attrs, encoding, "_Unsigned")
 
-            if data.dtype.kind == "i":
+            if data.dtype.kind in "iu":
                 if unsigned == "true":
-                    unsigned_dtype = np.dtype("u%s" % data.dtype.itemsize)
-                    transform = partial(np.asarray, dtype=unsigned_dtype)
-                    data = lazy_elemwise_func(data, transform, unsigned_dtype)
-                    if "_FillValue" in attrs:
-                        new_fill = unsigned_dtype.type(attrs["_FillValue"])
-                        attrs["_FillValue"] = new_fill
+                    # Convert signed integers to unsigned
+                    if data.dtype.kind == "i":
+                        unsigned_dtype = np.dtype("u%s" % data.dtype.itemsize)
+                        transform = partial(np.asarray, dtype=unsigned_dtype)
+                        data = lazy_elemwise_func(data, transform, unsigned_dtype)
+                        if "_FillValue" in attrs:
+                            new_fill = unsigned_dtype.type(attrs["_FillValue"])
+                            attrs["_FillValue"] = new_fill
+                elif unsigned == "false":
+                    # Convert unsigned integers to signed (OPeNDAP hack)
+                    if data.dtype.kind == "u":
+                        signed_dtype = np.dtype("i%s" % data.dtype.itemsize)
+                        transform = partial(np.asarray, dtype=signed_dtype)
+                        data = lazy_elemwise_func(data, transform, signed_dtype)
+                        if "_FillValue" in attrs:
+                            new_fill = signed_dtype.type(attrs["_FillValue"])
+                            attrs["_FillValue"] = new_fill
             else:
                 warnings.warn(
                     "variable %r has _Unsigned attribute but is not "