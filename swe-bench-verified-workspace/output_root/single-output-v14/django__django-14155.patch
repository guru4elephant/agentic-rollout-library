diff --git a/debug_partial.py b/debug_partial.py
new file mode 100644
index 0000000000..83a512af93
--- /dev/null
+++ b/debug_partial.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+import functools
+
+# Create a simple function to use as a base
+def my_view(request, arg1, arg2=None):
+    return f"Hello {arg1} {arg2}"
+
+# Create a partial function
+partial_view = functools.partial(my_view, arg1="test", arg2="value")
+
+print("Partial function object:")
+print(partial_view)
+print()
+
+print("Partial function type:")
+print(type(partial_view))
+print()
+
+print("Partial function attributes:")
+print("func:", partial_view.func)
+print("args:", partial_view.args)
+print("keywords:", partial_view.keywords)
+print()
+
+print("Underlying function details:")
+print("func.__name__:", partial_view.func.__name__)
+print("func.__module__:", partial_view.func.__module__)
\ No newline at end of file
diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py
index 9b00e24509..782d27ac58 100644
--- a/django/urls/resolvers.py
+++ b/django/urls/resolvers.py
@@ -31,9 +31,15 @@ from .utils import get_callable
 
 class ResolverMatch:
     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):
-        self.func = func
-        self.args = args
-        self.kwargs = kwargs
+        # Handle functools.partial objects by unwrapping them
+        if isinstance(func, functools.partial):
+            self.func = func.func
+            self.args = func.args + args
+            self.kwargs = {**func.keywords, **kwargs}
+        else:
+            self.func = func
+            self.args = args
+            self.kwargs = kwargs
         self.url_name = url_name
         self.route = route
         self.tried = tried
@@ -45,12 +51,12 @@ class ResolverMatch:
         self.namespaces = [x for x in namespaces if x] if namespaces else []
         self.namespace = ':'.join(self.namespaces)
 
-        if not hasattr(func, '__name__'):
+        if not hasattr(self.func, '__name__'):
             # A class-based view
-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__
+            self._func_path = self.func.__class__.__module__ + '.' + self.func.__class__.__name__
         else:
             # A function-based view
-            self._func_path = func.__module__ + '.' + func.__name__
+            self._func_path = self.func.__module__ + '.' + self.func.__name__
 
         view_path = url_name or self._func_path
         self.view_name = ':'.join(self.namespaces + [view_path])
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e9d2d7daf6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+# Create a simple function to use as a base
+def my_view(request, arg1, arg2=None):
+    return f"Hello {arg1} {arg2}"
+
+# Create a partial function
+partial_view = functools.partial(my_view, arg1="test", arg2="value")
+
+# Create a ResolverMatch with the partial function
+resolver_match = ResolverMatch(
+    func=partial_view,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+print("ResolverMatch representation:")
+print(repr(resolver_match))
+print()
+
+print("Expected: Should show the underlying function and partial arguments")
+print("Actual: Shows functools.partial")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..5ac6ab756a
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+# Test case 1: Basic partial function
+def view1(request, arg1, arg2=None):
+    return f"View1: {arg1} {arg2}"
+
+partial1 = functools.partial(view1, arg1="test1", arg2="value1")
+rm1 = ResolverMatch(partial1, (), {}, None, None, None, None, None)
+print("Test 1 - Basic partial:")
+print(repr(rm1))
+print()
+
+# Test case 2: Partial with additional args/kwargs
+partial2 = functools.partial(view1, arg1="test2")
+rm2 = ResolverMatch(partial2, ("extra_arg",), {"arg2": "extra_value"}, None, None, None, None, None)
+print("Test 2 - Partial with additional args/kwargs:")
+print(repr(rm2))
+print()
+
+# Test case 3: Regular function (should work as before)
+def regular_view(request):
+    return "Regular view"
+rm3 = ResolverMatch(regular_view, (), {}, None, None, None, None, None)
+print("Test 3 - Regular function:")
+print(repr(rm3))
+print()
+
+# Test case 4: Class-based view (should work as before)
+class ClassView:
+    def __call__(self, request):
+        return "Class view"
+    
+rm4 = ResolverMatch(ClassView(), (), {}, None, None, None, None, None)
+print("Test 4 - Class-based view:")
+print(repr(rm4))
+print()
+
+# Test case 5: Partial with only args (no keywords)
+def view2(request, a, b):
+    return f"View2: {a} {b}"
+
+partial3 = functools.partial(view2, "arg_a")
+rm5 = ResolverMatch(partial3, ("arg_b",), {}, None, None, None, None, None)
+print("Test 5 - Partial with only args:")
+print(repr(rm5))
+print()
+
+# Test case 6: Partial with only keywords (no args)
+partial4 = functools.partial(view2, b="arg_b")
+rm6 = ResolverMatch(partial4, ("arg_a",), {}, None, None, None, None, None)
+print("Test 6 - Partial with only keywords:")
+print(repr(rm6))
\ No newline at end of file
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 0000000000..39d8d5f7d4
--- /dev/null
+++ b/test_final_verification.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2=None):
+    return f"Hello {arg1} {arg2}"
+
+# Test the exact scenario from the issue
+partial_view = functools.partial(my_view, arg1="test", arg2="value")
+resolver_match = ResolverMatch(
+    func=partial_view,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+print("Before fix: ResolverMatch(func=functools.partial, args=(), kwargs={}, ...)")
+print("After fix: ", repr(resolver_match))
+
+# Verify it's actually useful for debugging
+print("\nDebugging information:")
+print("- Underlying function:", resolver_match.func.__name__)
+print("- Partial args:", resolver_match.args)
+print("- Partial kwargs:", resolver_match.kwargs)
+print("- Function path:", resolver_match._func_path)
\ No newline at end of file
diff --git a/test_kwarg_conflicts.py b/test_kwarg_conflicts.py
new file mode 100644
index 0000000000..ba0db76727
--- /dev/null
+++ b/test_kwarg_conflicts.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+import os
+import sys
+import functools
+
+sys.path.insert(0, '/testbed')
+
+# Configure minimal Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf')
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+import django
+django.setup()
+
+from django.urls.resolvers import ResolverMatch
+
+def test_kwarg_override_behavior():
+    """Test that additional kwargs override partial keywords"""
+    def my_view(request, arg1, arg2=None, arg3=None):
+        return f"View: {arg1} {arg2} {arg3}"
+    
+    # Create partial with some arguments
+    partial_view = functools.partial(my_view, arg1="partial1", arg2="partial2")
+    
+    # Create ResolverMatch with additional kwargs that override partial keywords
+    rm = ResolverMatch(
+        func=partial_view,
+        args=(),
+        kwargs={"arg2": "override2", "arg3": "new3"},
+        url_name=None,
+        app_names=None,
+        namespaces=None,
+        route=None,
+        tried=None
+    )
+    
+    # Should show that arg2 was overridden and arg3 was added
+    repr_str = repr(rm)
+    print("Representation:", repr_str)
+    
+    # Check that the underlying function is shown
+    assert 'my_view' in repr_str
+    
+    # Check that partial arg1 is preserved
+    assert "'arg1': 'partial1'" in repr_str
+    
+    # Check that arg2 was overridden (should show "override2", not "partial2")
+    assert "'arg2': 'override2'" in repr_str
+    assert "'arg2': 'partial2'" not in repr_str
+    
+    # Check that new arg3 was added
+    assert "'arg3': 'new3'" in repr_str
+    
+    print("✓ Kwarg override test passed")
+
+if __name__ == '__main__':
+    test_kwarg_override_behavior()
+    print("Kwarg conflict test passed! ✓")
\ No newline at end of file
diff --git a/test_partial_fix.py b/test_partial_fix.py
new file mode 100644
index 0000000000..275ad674b7
--- /dev/null
+++ b/test_partial_fix.py
@@ -0,0 +1,127 @@
+#!/usr/bin/env python3
+import os
+import sys
+import functools
+
+# Add the testbed directory to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.test.utils import get_runner
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.urls.resolvers import ResolverMatch
+from django.test import SimpleTestCase
+
+class TestPartialFix(SimpleTestCase):
+    
+    def test_partial_function_representation(self):
+        """Test that ResolverMatch handles functools.partial correctly"""
+        def my_view(request, arg1, arg2=None):
+            return f"Hello {arg1} {arg2}"
+        
+        # Test basic partial function
+        partial_view = functools.partial(my_view, arg1="test", arg2="value")
+        resolver_match = ResolverMatch(
+            func=partial_view,
+            args=(),
+            kwargs={},
+            url_name=None,
+            app_names=None,
+            namespaces=None,
+            route=None,
+            tried=None
+        )
+        
+        # Should show the underlying function, not functools.partial
+        representation = repr(resolver_match)
+        self.assertIn('__main__.my_view', representation)
+        self.assertNotIn('functools.partial', representation)
+        self.assertIn("'arg1': 'test'", representation)
+        self.assertIn("'arg2': 'value'", representation)
+    
+    def test_partial_with_additional_args(self):
+        """Test partial function with additional args/kwargs"""
+        def my_view(request, a, b, c=None):
+            return f"View: {a} {b} {c}"
+        
+        partial_view = functools.partial(my_view, "partial_a", c="partial_c")
+        resolver_match = ResolverMatch(
+            func=partial_view,
+            args=("extra_b",),
+            kwargs={"c": "extra_c"},
+            url_name=None,
+            app_names=None,
+            namespaces=None,
+            route=None,
+            tried=None
+        )
+        
+        # Should merge partial and additional args/kwargs
+        representation = repr(resolver_match)
+        self.assertIn('__main__.my_view', representation)
+        self.assertIn("'partial_a', 'extra_b'", representation)  # Combined args
+        self.assertIn("'c': 'extra_c'", representation)  # kwargs should be overridden
+    
+    def test_regular_function_still_works(self):
+        """Test that regular functions still work as before"""
+        def regular_view(request):
+            return "Regular view"
+        
+        resolver_match = ResolverMatch(
+            func=regular_view,
+            args=(),
+            kwargs={},
+            url_name=None,
+            app_names=None,
+            namespaces=None,
+            route=None,
+            tried=None
+        )
+        
+        # Should work exactly as before
+        representation = repr(resolver_match)
+        self.assertIn('__main__.regular_view', representation)
+        self.assertNotIn('functools.partial', representation)
+    
+    def test_class_based_view_still_works(self):
+        """Test that class-based views still work as before"""
+        class ClassView:
+            def __call__(self, request):
+                return "Class view"
+        
+        resolver_match = ResolverMatch(
+            func=ClassView(),
+            args=(),
+            kwargs={},
+            url_name=None,
+            app_names=None,
+            namespaces=None,
+            route=None,
+            tried=None
+        )
+        
+        # Should work exactly as before
+        representation = repr(resolver_match)
+        self.assertIn('__main__.ClassView', representation)
+        self.assertNotIn('functools.partial', representation)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_resolver_match_basic.py b/test_resolver_match_basic.py
new file mode 100644
index 0000000000..9e61bb2ae2
--- /dev/null
+++ b/test_resolver_match_basic.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+import os
+import sys
+sys.path.insert(0, '/testbed')
+
+# Configure minimal Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf')
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+import django
+django.setup()
+
+from django.urls.resolvers import ResolverMatch
+
+def test_basic_functionality():
+    """Test that basic ResolverMatch functionality still works"""
+    def empty_view(request):
+        return "Empty"
+    
+    # Test basic function
+    rm = ResolverMatch(empty_view, ('arg1',), {'kwarg1': 'value1'}, 'test-view', ['app1'], ['ns1'], 'test-route', None)
+    
+    # Check basic attributes
+    assert rm.func == empty_view
+    assert rm.args == ('arg1',)
+    assert rm.kwargs == {'kwarg1': 'value1'}
+    assert rm.url_name == 'test-view'
+    assert rm.app_names == ['app1']
+    assert rm.namespaces == ['ns1']
+    assert rm.route == 'test-route'
+    
+    # Check __getitem__
+    assert rm[0] == empty_view
+    assert rm[1] == ('arg1',)
+    assert rm[2] == {'kwarg1': 'value1'}
+    
+    # Check __repr__ contains expected info
+    repr_str = repr(rm)
+    assert 'empty_view' in repr_str
+    assert "'arg1'" in repr_str
+    assert "'kwarg1': 'value1'" in repr_str
+    assert 'test-view' in repr_str
+    
+    print("✓ Basic functionality test passed")
+
+def test_class_based_view():
+    """Test that class-based views still work"""
+    class ClassView:
+        def __call__(self, request):
+            return "Class view"
+    
+    cv = ClassView()
+    rm = ResolverMatch(cv, (), {}, None, None, None, None, None)
+    
+    # Should show class name, not functools.partial
+    repr_str = repr(rm)
+    assert 'ClassView' in repr_str
+    assert 'functools.partial' not in repr_str
+    
+    print("✓ Class-based view test passed")
+
+def test_partial_function():
+    """Test that functools.partial is handled correctly"""
+    import functools
+    
+    def my_view(request, arg1, arg2=None):
+        return f"Hello {arg1} {arg2}"
+    
+    # Create partial function
+    partial_view = functools.partial(my_view, arg1="test", arg2="value")
+    rm = ResolverMatch(partial_view, (), {}, None, None, None, None, None)
+    
+    # Should show underlying function and partial arguments
+    repr_str = repr(rm)
+    assert 'my_view' in repr_str
+    assert 'functools.partial' not in repr_str
+    assert "'arg1': 'test'" in repr_str
+    assert "'arg2': 'value'" in repr_str
+    
+    print("✓ Partial function test passed")
+
+if __name__ == '__main__':
+    test_basic_functionality()
+    test_class_based_view()
+    test_partial_function()
+    print("All tests passed! ✓")
\ No newline at end of file