diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..93a367892f
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix for max_post_process_passes = 0
+"""
+
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+        STATIC_ROOT='/tmp/static',
+        INSTALLED_APPS=['django.contrib.staticfiles'],
+    )
+    django.setup()
+
+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage
+
+def test_max_post_process_passes_zero():
+    """Test that max_post_process_passes = 0 works without error"""
+    print("Testing max_post_process_passes = 0...")
+    
+    class ZeroPassStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = 0
+    
+    storage = ZeroPassStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    # This should not raise UnboundLocalError
+    paths = {}
+    try:
+        result = list(storage.post_process(paths))
+        print("✓ max_post_process_passes = 0 works correctly")
+        return True
+    except UnboundLocalError as e:
+        print(f"✗ UnboundLocalError still occurs: {e}")
+        return False
+    except Exception as e:
+        print(f"✗ Unexpected error: {e}")
+        return False
+
+def test_max_post_process_passes_normal():
+    """Test that normal max_post_process_passes still works"""
+    print("Testing normal max_post_process_passes...")
+    
+    class NormalStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = 5  # Default value
+    
+    storage = NormalStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    # This should work normally
+    paths = {}
+    try:
+        result = list(storage.post_process(paths))
+        print("✓ Normal max_post_process_passes works correctly")
+        return True
+    except Exception as e:
+        print(f"✗ Error with normal passes: {e}")
+        return False
+
+def test_max_post_process_passes_one():
+    """Test that max_post_process_passes = 1 works"""
+    print("Testing max_post_process_passes = 1...")
+    
+    class OnePassStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = 1
+    
+    storage = OnePassStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    # This should work
+    paths = {}
+    try:
+        result = list(storage.post_process(paths))
+        print("✓ max_post_process_passes = 1 works correctly")
+        return True
+    except Exception as e:
+        print(f"✗ Error with 1 pass: {e}")
+        return False
+
+if __name__ == '__main__':
+    print("Running comprehensive tests for max_post_process_passes fix...")
+    print()
+    
+    success = True
+    success &= test_max_post_process_passes_zero()
+    success &= test_max_post_process_passes_normal()
+    success &= test_max_post_process_passes_one()
+    
+    print()
+    if success:
+        print("✓ All tests passed! The fix is working correctly.")
+        exit(0)
+    else:
+        print("✗ Some tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/direct_test.py b/direct_test.py
new file mode 100644
index 0000000000..53dea53eb8
--- /dev/null
+++ b/direct_test.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+"""
+Direct test to reproduce the UnboundLocalError in post_process method
+"""
+
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+        STATIC_ROOT='/tmp/static',  # Temporary static root
+    )
+    django.setup()
+
+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage
+
+class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):
+    max_post_process_passes = 0
+
+def test_post_process_directly():
+    """Test the post_process method directly"""
+    print("Testing post_process method directly...")
+    
+    # Create storage instance
+    storage = MyManifestStaticFilesStorage()
+    
+    # Mock the necessary internal state to avoid file operations
+    storage._patterns = {}  # Empty patterns
+    storage.hashed_files = {}  # Empty hashed files
+    
+    # Create empty paths to trigger the problematic code path
+    paths = {}
+    
+    try:
+        # This should trigger the UnboundLocalError
+        result = list(storage.post_process(paths))
+        print("Success! No error occurred.")
+        print(f"Result: {result}")
+        return True
+    except UnboundLocalError as e:
+        print(f"Error reproduced: {e}")
+        print("This confirms the bug exists.")
+        return False
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        return False
+
+if __name__ == '__main__':
+    success = test_post_process_directly()
+    if not success:
+        exit(1)
\ No newline at end of file
diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py
index f957a667b2..720767aa9e 100644
--- a/django/contrib/staticfiles/storage.py
+++ b/django/contrib/staticfiles/storage.py
@@ -261,6 +261,7 @@ class HashedFilesMixin:
 
         paths = {path: paths[path] for path in adjustable_paths}
 
+        substitutions = False
         for i in range(self.max_post_process_passes):
             substitutions = False
             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):
diff --git a/edge_case_test.py b/edge_case_test.py
new file mode 100644
index 0000000000..0385aa698f
--- /dev/null
+++ b/edge_case_test.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+"""
+Edge case test to verify the fix handles various scenarios correctly
+"""
+
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+        STATIC_ROOT='/tmp/static',
+        INSTALLED_APPS=['django.contrib.staticfiles'],
+    )
+    django.setup()
+
+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage
+
+def test_edge_cases():
+    """Test various edge cases for max_post_process_passes"""
+    print("Testing edge cases...")
+    
+    # Test case 1: max_post_process_passes = 0 (the original issue)
+    print("1. Testing max_post_process_passes = 0...")
+    class ZeroPassStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = 0
+    
+    storage = ZeroPassStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    try:
+        result = list(storage.post_process({}))
+        print("   ✓ Passes = 0 works correctly")
+    except Exception as e:
+        print(f"   ✗ Failed: {e}")
+        return False
+    
+    # Test case 2: max_post_process_passes = 1
+    print("2. Testing max_post_process_passes = 1...")
+    class OnePassStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = 1
+    
+    storage = OnePassStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    try:
+        result = list(storage.post_process({}))
+        print("   ✓ Passes = 1 works correctly")
+    except Exception as e:
+        print(f"   ✗ Failed: {e}")
+        return False
+    
+    # Test case 3: max_post_process_passes = negative (should be handled by range())
+    print("3. Testing max_post_process_passes = -1...")
+    class NegativePassStorage(ManifestStaticFilesStorage):
+        max_post_process_passes = -1
+    
+    storage = NegativePassStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    try:
+        result = list(storage.post_process({}))
+        print("   ✓ Passes = -1 works correctly (range() handles negative)")
+    except Exception as e:
+        print(f"   ✗ Failed: {e}")
+        return False
+    
+    # Test case 4: Default value (5)
+    print("4. Testing default max_post_process_passes = 5...")
+    storage = ManifestStaticFilesStorage()
+    storage._patterns = {}
+    storage.hashed_files = {}
+    
+    try:
+        result = list(storage.post_process({}))
+        print("   ✓ Default passes = 5 works correctly")
+    except Exception as e:
+        print(f"   ✗ Failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == '__main__':
+    print("Running edge case tests for max_post_process_passes fix...")
+    print()
+    
+    success = test_edge_cases()
+    
+    print()
+    if success:
+        print("✓ All edge case tests passed! The fix is robust.")
+        exit(0)
+    else:
+        print("✗ Some edge case tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..59d2d69a3c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the ManifestStaticFilesStorage crash with max_post_process_passes = 0
+"""
+
+import os
+import tempfile
+import shutil
+import django
+from django.conf import settings
+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+        STATICFILES_DIRS=[],
+    )
+    django.setup()
+
+class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):
+    max_post_process_passes = 0
+
+def test_reproduce_issue():
+    """Test that reproduces the UnboundLocalError"""
+    print("Creating test environment...")
+    
+    # Create a temporary directory for static files
+    temp_dir = tempfile.mkdtemp()
+    
+    try:
+        # Create a simple static file
+        static_dir = os.path.join(temp_dir, 'static')
+        os.makedirs(static_dir)
+        
+        test_file = os.path.join(static_dir, 'test.txt')
+        with open(test_file, 'w') as f:
+            f.write('Hello, World!')
+        
+        # Create storage instance
+        storage = MyManifestStaticFilesStorage(location=static_dir)
+        storage.base_location = static_dir
+        
+        print("Testing post_process with max_post_process_passes = 0...")
+        
+        # This should trigger the UnboundLocalError
+        paths = {'test.txt': (None, None)}
+        result = list(storage.post_process(paths))
+        
+        print("Success! No error occurred.")
+        print(f"Result: {result}")
+        
+    except UnboundLocalError as e:
+        print(f"Error reproduced: {e}")
+        print("This confirms the bug exists.")
+        return False
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        return False
+    finally:
+        # Clean up
+        shutil.rmtree(temp_dir)
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_reproduce_issue()
+    if not success:
+        exit(1)
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..62d4cfe8e1
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the ManifestStaticFilesStorage crash with max_post_process_passes = 0
+"""
+
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        STATIC_URL='/static/',
+    )
+    django.setup()
+
+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage
+
+class MyManifestStaticFilesStorage(ManifestStaticFilesStorage):
+    max_post_process_passes = 0
+
+def test_reproduce_issue():
+    """Test that reproduces the UnboundLocalError"""
+    print("Creating storage instance with max_post_process_passes = 0...")
+    
+    # Create storage instance
+    storage = MyManifestStaticFilesStorage()
+    
+    print("Testing post_process with empty paths...")
+    
+    # This should trigger the UnboundLocalError when max_post_process_passes = 0
+    # because the loop on line 264 never runs, so substitutions is never defined
+    paths = {}
+    try:
+        result = list(storage.post_process(paths))
+        print("Success! No error occurred.")
+        print(f"Result: {result}")
+        return True
+    except UnboundLocalError as e:
+        print(f"Error reproduced: {e}")
+        print("This confirms the bug exists.")
+        return False
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        return False
+
+if __name__ == '__main__':
+    success = test_reproduce_issue()
+    if not success:
+        exit(1)
\ No newline at end of file