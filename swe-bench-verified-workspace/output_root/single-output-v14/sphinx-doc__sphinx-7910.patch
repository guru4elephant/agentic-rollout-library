diff --git a/debug_method.py b/debug_method.py
new file mode 100644
index 000000000..2dc2a51fe
--- /dev/null
+++ b/debug_method.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand method attributes for decorated methods.
+"""
+
+import functools
+import inspect
+
+def decorator(func):
+    """A decorator that uses functools.wraps."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    return wrapper
+
+def bad_decorator(func):
+    """A decorator that doesn't preserve context properly."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.__doc__ = func.__doc__
+    return wrapper
+
+class TestClass:
+    """Test class with decorated methods."""
+    
+    @decorator
+    def __init__(self):
+        """Decorated __init__ with functools.wraps."""
+        pass
+    
+    @bad_decorator
+    def method(self):
+        """Decorated method without proper context."""
+        pass
+
+def analyze_method(method, name):
+    print(f"\n=== Analyzing {name} ===")
+    print(f"Method: {method}")
+    print(f"Type: {type(method)}")
+    print(f"__qualname__: {getattr(method, '__qualname__', 'N/A')}")
+    print(f"__name__: {getattr(method, '__name__', 'N/A')}")
+    print(f"__module__: {getattr(method, '__module__', 'N/A')}")
+    print(f"hasattr __globals__: {hasattr(method, '__globals__')}")
+    
+    if hasattr(method, '__globals__'):
+        print(f"__globals__ keys: {list(method.__globals__.keys())[:10]}")  # First 10 keys
+    
+    print(f"inspect.ismethod: {inspect.ismethod(method)}")
+    print(f"inspect.isfunction: {inspect.isfunction(method)}")
+    print(f"inspect.isroutine: {inspect.isroutine(method)}")
+    
+    # Try to get the class from the method
+    if hasattr(method, '__self__'):
+        print(f"__self__: {method.__self__}")
+        print(f"type(__self__): {type(method.__self__)}")
+    
+    # Try to find the class by looking at the qualname
+    qualname = getattr(method, '__qualname__', '')
+    if '.' in qualname:
+        parts = qualname.split('.')
+        print(f"Qualname parts: {parts}")
+        
+        # Try to import the module and get the class
+        module_name = getattr(method, '__module__', None)
+        if module_name:
+            try:
+                module = __import__(module_name, fromlist=['*'])
+                print(f"Imported module: {module}")
+                
+                # Try to get the class from the last part that looks like a class
+                for part in reversed(parts):
+                    if hasattr(module, part) and inspect.isclass(getattr(module, part)):
+                        cls = getattr(module, part)
+                        print(f"Found class {part}: {cls}")
+                        break
+                else:
+                    print("No class found in module")
+            except ImportError:
+                print(f"Could not import module {module_name}")
+
+# Test the methods
+analyze_method(TestClass.__init__, "TestClass.__init__ (decorated)")
+analyze_method(TestClass.method, "TestClass.method (badly decorated)")
+
+# Also test the original undecorated methods if possible
+print("\n=== Testing original methods ===")
+try:
+    # Get the original method from the class __dict__
+    orig_init = TestClass.__dict__['__init__']
+    analyze_method(orig_init, "Original __init__ from __dict__")
+except KeyError:
+    print("Could not get original __init__ from __dict__")
\ No newline at end of file
diff --git a/debug_skip_member.py b/debug_skip_member.py
new file mode 100644
index 000000000..eead927d2
--- /dev/null
+++ b/debug_skip_member.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the _skip_member behavior.
+"""
+
+import functools
+from sphinx.ext.napoleon import _skip_member
+
+class MockApp:
+    def __init__(self):
+        self.config = MockConfig()
+
+class MockConfig:
+    def __init__(self):
+        self.napoleon_include_init_with_doc = True
+        self.napoleon_include_special_with_doc = False
+        self.napoleon_include_private_with_doc = False
+
+def broken_decorator(func):
+    """A decorator that breaks method context."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.__doc__ = func.__doc__
+    wrapper.__module__ = func.__module__
+    return wrapper
+
+class TestClass:
+    @broken_decorator
+    def __init__(self):
+        """Test __init__."""
+        pass
+
+# Monkey patch _skip_member to add debug output
+original_skip_member = _skip_member
+
+def debug_skip_member(app, what, name, obj, skip, options):
+    print(f"\n=== _skip_member called ===")
+    print(f"what: {what}")
+    print(f"name: {name}")
+    print(f"obj: {obj}")
+    print(f"obj.__qualname__: {getattr(obj, '__qualname__', 'N/A')}")
+    print(f"obj.__module__: {getattr(obj, '__module__', 'N/A')}")
+    print(f"hasattr(obj, '__globals__'): {hasattr(obj, '__globals__')}")
+    
+    # Let's also debug what happens in our fix
+    print("\n=== Debugging our fix ===")
+    qualname = getattr(obj, '__qualname__', '')
+    print(f"qualname: {qualname}")
+    cls_path, _, _ = qualname.rpartition('.')
+    print(f"cls_path: {cls_path}")
+    
+    # Strategy 1
+    if cls_path:
+        try:
+            if '.' in cls_path:
+                import importlib
+                import functools
+                mod = importlib.import_module(obj.__module__)
+                mod_path = cls_path.split('.')
+                cls = functools.reduce(getattr, mod_path, mod)
+                print(f"Strategy 1 (nested): cls = {cls}")
+            else:
+                cls = obj.__globals__[cls_path]
+                print(f"Strategy 1 (simple): cls = {cls}")
+        except Exception as e:
+            print(f"Strategy 1 failed: {e}")
+            cls = None
+    else:
+        cls = None
+        print("Strategy 1: No cls_path")
+    
+    # Strategy 2
+    if cls is None:
+        try:
+            import importlib
+            mod = importlib.import_module(obj.__module__)
+            qualname_parts = qualname.split('.')
+            print(f"Strategy 2: qualname_parts = {qualname_parts}")
+            for part in qualname_parts:
+                if hasattr(mod, part) and isinstance(getattr(mod, part), type):
+                    cls = getattr(mod, part)
+                    print(f"Strategy 2 found: cls = {cls}")
+                    break
+            if cls is None:
+                print("Strategy 2: No class found")
+        except Exception as e:
+            print(f"Strategy 2 failed: {e}")
+    
+    # Strategy 3
+    if cls is None and hasattr(obj, '__self__'):
+        print(f"Strategy 3: obj.__self__ = {obj.__self__}")
+        if isinstance(obj.__self__, type):
+            cls = obj.__self__
+            print(f"Strategy 3 found: cls = {cls}")
+        else:
+            print("Strategy 3: obj.__self__ is not a class")
+    
+    print(f"Final cls: {cls}")
+    if cls is not None:
+        cls_is_owner = (hasattr(cls, name) and name in cls.__dict__)
+        print(f"cls_is_owner: {cls_is_owner}")
+    else:
+        print("No cls found")
+    
+    result = original_skip_member(app, what, name, obj, skip, options)
+    print(f"Final Result: {result}")
+    return result
+
+# Replace the function
+import sphinx.ext.napoleon
+sphinx.ext.napoleon._skip_member = debug_skip_member
+
+# Test
+app = MockApp()
+result = debug_skip_member(app, 'class', '__init__', TestClass.__init__, False, None)
+print(f"\nFinal result: {result}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..802304c59
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with decorated __init__ methods not showing up in docs.
+"""
+
+import functools
+
+def decorator(func):
+    """A simple decorator that preserves docstring."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    # Simulate a decorator that might break __globals__
+    # by not properly preserving the original function context
+    return wrapper
+
+def problematic_decorator(func):
+    """A decorator that might break __globals__ access."""
+    # This doesn't use functools.wraps properly
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.__doc__ = func.__doc__  # Manually preserve docstring
+    return wrapper
+
+class TestClass:
+    """A test class with decorated __init__."""
+    
+    @decorator
+    def __init__(self):
+        """This __init__ should be documented but won't be due to the bug."""
+        pass
+
+class ProblematicClass:
+    """A test class with problematic decorated __init__."""
+    
+    @problematic_decorator
+    def __init__(self):
+        """This __init__ should be documented but might not be due to the bug."""
+        pass
+
+# Test the issue
+def test_class_method(method, class_name):
+    print(f"\nTesting {class_name}.__init__:")
+    print(f"obj.__doc__: {method.__doc__}")
+    print(f"obj.__qualname__: {method.__qualname__}")
+    print(f"hasattr(obj, '__globals__'): {hasattr(method, '__globals__')}")
+
+    if hasattr(method, '__globals__'):
+        print(f"obj.__globals__ keys: {list(method.__globals__.keys())}")
+        
+        # Try to reproduce the problematic code from napoleon
+        qualname = getattr(method, '__qualname__', '')
+        cls_path, _, _ = qualname.rpartition('.')
+        print(f"cls_path: {cls_path}")
+        
+        if cls_path:
+            try:
+                cls = method.__globals__[cls_path]
+                print(f"cls found: {cls}")
+            except Exception as e:
+                print(f"Error accessing __globals__[{cls_path}]: {e}")
+
+test_class_method(TestClass.__init__, "TestClass")
+test_class_method(ProblematicClass.__init__, "ProblematicClass")
\ No newline at end of file
diff --git a/setup.py b/setup.py
index a404f1fa5..2c6848797 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/napoleon/__init__.py b/sphinx/ext/napoleon/__init__.py
index 10b1ff3a3..94fe90c46 100644
--- a/sphinx/ext/napoleon/__init__.py
+++ b/sphinx/ext/napoleon/__init__.py
@@ -426,6 +426,9 @@ def _skip_member(app: Sphinx, what: str, name: str, obj: Any,
     if name != '__weakref__' and has_doc and is_member:
         cls_is_owner = False
         if what == 'class' or what == 'exception':
+            cls = None
+            
+            # Strategy 1: Try to get class from __qualname__ (original approach)
             qualname = getattr(obj, '__qualname__', '')
             cls_path, _, _ = qualname.rpartition('.')
             if cls_path:
@@ -440,10 +443,31 @@ def _skip_member(app: Sphinx, what: str, name: str, obj: Any,
                     else:
                         cls = obj.__globals__[cls_path]
                 except Exception:
-                    cls_is_owner = False
-                else:
-                    cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore
-                                    name in cls.__dict__)
+                    cls = None
+            
+            # Strategy 2: If Strategy 1 failed, try to find class by name in module
+            if cls is None:
+                try:
+                    import importlib
+                    mod = importlib.import_module(obj.__module__)
+                    # Look for a class with the same name as the method's owner
+                    # This works for simple cases where class name is in qualname parts
+                    qualname_parts = qualname.split('.')
+                    for part in qualname_parts:
+                        if hasattr(mod, part) and isinstance(getattr(mod, part), type):
+                            cls = getattr(mod, part)
+                            break
+                except Exception:
+                    cls = None
+            
+            # Strategy 3: If still not found, try to get class from method attributes
+            if cls is None and hasattr(obj, '__self__'):
+                # For bound methods, __self__ might be the class
+                if isinstance(obj.__self__, type):
+                    cls = obj.__self__
+            
+            if cls is not None:
+                cls_is_owner = (hasattr(cls, name) and name in cls.__dict__)
             else:
                 cls_is_owner = False
 
diff --git a/test_napoleon_fix.py b/test_napoleon_fix.py
new file mode 100644
index 000000000..44d515f84
--- /dev/null
+++ b/test_napoleon_fix.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the napoleon fix for decorated __init__ methods.
+"""
+
+import functools
+from sphinx.ext.napoleon import _skip_member
+
+# Mock app object with config
+class MockApp:
+    def __init__(self):
+        self.config = MockConfig()
+
+class MockConfig:
+    def __init__(self):
+        self.napoleon_include_init_with_doc = True
+        self.napoleon_include_special_with_doc = False
+        self.napoleon_include_private_with_doc = False
+
+def decorator(func):
+    """A decorator that uses functools.wraps."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    return wrapper
+
+def bad_decorator(func):
+    """A decorator that doesn't preserve context properly."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.__doc__ = func.__doc__
+    return wrapper
+
+class TestClass:
+    """Test class with decorated __init__."""
+    
+    @decorator
+    def __init__(self):
+        """This __init__ should be documented."""
+        pass
+
+class ProblematicClass:
+    """Test class with problematic decorated __init__."""
+    
+    @bad_decorator
+    def __init__(self):
+        """This __init__ should be documented but was broken before the fix."""
+        pass
+
+# Create mock app
+app = MockApp()
+
+# Test the _skip_member function
+def test_skip_member(obj, class_name):
+    print(f"\n=== Testing {class_name}.__init__ ===")
+    result = _skip_member(app, 'class', '__init__', obj, False, None)
+    print(f"_skip_member result: {result}")
+    print(f"Method will be {'SKIPPED' if result else 'INCLUDED'} in documentation")
+    return result
+
+# Test both cases
+test_skip_member(TestClass.__init__, "TestClass")
+test_skip_member(ProblematicClass.__init__, "ProblematicClass")
+
+# Also test with the original undecorated method if possible
+print("\n=== Testing original method from __dict__ ===")
+try:
+    orig_init = ProblematicClass.__dict__['__init__']
+    test_skip_member(orig_init, "Original ProblematicClass.__init__")
+except KeyError:
+    print("Could not get original method from __dict__")
\ No newline at end of file
diff --git a/test_real_scenario.py b/test_real_scenario.py
new file mode 100644
index 000000000..995d276ee
--- /dev/null
+++ b/test_real_scenario.py
@@ -0,0 +1,85 @@
+#!/usr/bin/env python3
+"""
+Test script that simulates a more realistic Sphinx scenario.
+"""
+
+import functools
+from sphinx.ext.napoleon import _skip_member
+
+# Create a more realistic mock app
+class MockApp:
+    def __init__(self):
+        self.config = MockConfig()
+
+class MockConfig:
+    def __init__(self):
+        # Test different configurations
+        self.napoleon_include_init_with_doc = True
+        self.napoleon_include_special_with_doc = False
+        self.napoleon_include_private_with_doc = False
+
+def tensorpack_like_decorator(func):
+    """Simulate a decorator similar to what might be used in tensorpack."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        # Some complex logic that might affect the method context
+        return func(*args, **kwargs)
+    return wrapper
+
+def broken_decorator(func):
+    """A decorator that breaks method context like in the original issue."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    # Manually copy some attributes but not all
+    wrapper.__doc__ = func.__doc__
+    wrapper.__module__ = func.__module__
+    # Note: we don't set __qualname__ properly, which causes the original issue
+    return wrapper
+
+class DistributedTrainerReplicated:
+    """Simulate the class from the original issue."""
+    
+    @tensorpack_like_decorator
+    def __init__(self):
+        """This __init__ should be documented with proper decorator."""
+        pass
+
+class BrokenDistributedTrainer:
+    """Simulate the problematic case from the original issue."""
+    
+    @broken_decorator
+    def __init__(self):
+        """This __init__ should be documented but was broken before the fix."""
+        pass
+
+# Test the scenarios
+app = MockApp()
+
+print("=== Testing DistributedTrainerReplicated (proper decorator) ===")
+result1 = _skip_member(app, 'class', '__init__', DistributedTrainerReplicated.__init__, False, None)
+print(f"Result: {result1} - Method will be {'SKIPPED' if result1 else 'INCLUDED'}")
+
+print("\n=== Testing BrokenDistributedTrainer (broken decorator) ===")
+result2 = _skip_member(app, 'class', '__init__', BrokenDistributedTrainer.__init__, False, None)
+print(f"Result: {result2} - Method will be {'SKIPPED' if result2 else 'INCLUDED'}")
+
+# Test with include_init_with_doc = False to see if skipping works
+app.config.napoleon_include_init_with_doc = False
+print("\n=== Testing with napoleon_include_init_with_doc = False ===")
+result3 = _skip_member(app, 'class', '__init__', DistributedTrainerReplicated.__init__, False, None)
+print(f"Result: {result3} - Method will be {'SKIPPED' if result3 else 'INCLUDED'}")
+
+# The key test: both decorated __init__ methods should be treated the same way
+print("\n=== Key Test: Both decorated methods should behave similarly ===")
+app.config.napoleon_include_init_with_doc = True
+result4 = _skip_member(app, 'class', '__init__', DistributedTrainerReplicated.__init__, False, None)
+result5 = _skip_member(app, 'class', '__init__', BrokenDistributedTrainer.__init__, False, None)
+
+print(f"Proper decorator result: {result4}")
+print(f"Broken decorator result: {result5}")
+print(f"Both methods treated equally: {result4 == result5}")
+
+if result4 == result5:
+    print("✅ SUCCESS: The fix works! Both decorated methods are treated the same.")
+else:
+    print("❌ FAILURE: The methods are treated differently - the fix may not be complete.")
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index ccfd60f84..c5ac3713f 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3