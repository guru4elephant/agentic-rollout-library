diff --git a/django/core/files/locks.py b/django/core/files/locks.py
index c46b00b905..4938347ea7 100644
--- a/django/core/files/locks.py
+++ b/django/core/files/locks.py
@@ -107,9 +107,15 @@ else:
             return True
     else:
         def lock(f, flags):
-            ret = fcntl.flock(_fd(f), flags)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), flags)
+                return True
+            except OSError:
+                return False
 
         def unlock(f):
-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), fcntl.LOCK_UN)
+                return True
+            except OSError:
+                return False
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..6261a5efea
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test for the locks fix.
+"""
+import os
+import tempfile
+from django.core.files import locks
+
+def test_comprehensive():
+    """Comprehensive test of all lock functionality"""
+    print("Running comprehensive lock tests...")
+    
+    # Test 1: Basic functionality
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test locking and unlocking
+        with open(temp_file_path, 'r+') as f:
+            # Lock the file
+            lock_result = locks.lock(f, locks.LOCK_EX)
+            print(f"Lock result: {lock_result}")
+            assert lock_result == True, "Lock should return True on success"
+            
+            # Unlock the file
+            unlock_result = locks.unlock(f)
+            print(f"Unlock result: {unlock_result}")
+            assert unlock_result == True, "Unlock should return True on success"
+        
+        # Test non-blocking lock behavior
+        with open(temp_file_path, 'r+') as f1:
+            # Lock the file first
+            result = locks.lock(f1, locks.LOCK_EX)
+            assert result == True
+            
+            # Try non-blocking lock from another handle (should fail)
+            with open(temp_file_path, 'r+') as f2:
+                result = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)
+                print(f"Non-blocking lock result: {result}")
+                assert result == False, "Non-blocking lock should return False when file is already locked"
+            
+            # Unlock the first file
+            result = locks.unlock(f1)
+            assert result == True
+        
+        print("✅ All comprehensive tests passed!")
+        
+    except Exception as e:
+        print(f"❌ Test failed: {e}")
+        raise
+    finally:
+        # Clean up
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dcb3df88ea
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the bug in django/core/files/locks.py posix implementation.
+"""
+import os
+import tempfile
+from django.core.files import locks
+
+def test_lock_behavior():
+    """Test the current lock behavior"""
+    print("Testing current lock implementation...")
+    
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test locking with blocking flag
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_EX)
+            print(f"Blocking lock result: {result}")
+            # This should return True but currently returns False
+            
+        # Test locking with non-blocking flag
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock result: {result}")
+            # This should return True but currently returns False
+            
+        # Test unlocking
+        with open(temp_file_path, 'r+') as f:
+            result = locks.unlock(f)
+            print(f"Unlock result: {result}")
+            # This should return True but currently returns False
+            
+    finally:
+        # Clean up
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_lock_behavior()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..349a6334c4
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the locks fix.
+"""
+import os
+import tempfile
+import fcntl
+from django.core.files import locks
+
+def test_edge_cases():
+    """Test edge cases for lock behavior"""
+    print("Testing edge cases...")
+    
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Normal locking/unlocking
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_EX)
+            print(f"Normal lock result: {result}")
+            assert result == True, "Normal lock should return True"
+            
+            result = locks.unlock(f)
+            print(f"Normal unlock result: {result}")
+            assert result == True, "Normal unlock should return True"
+        
+        # Test 2: Non-blocking lock on already locked file
+        with open(temp_file_path, 'r+') as f1:
+            # Lock the file first
+            result = locks.lock(f1, locks.LOCK_EX)
+            assert result == True, "First lock should succeed"
+            
+            # Try to lock the same file non-blocking from another handle
+            with open(temp_file_path, 'r+') as f2:
+                result = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)
+                print(f"Non-blocking lock on locked file result: {result}")
+                # This should fail and return False
+                assert result == False, "Non-blocking lock on locked file should return False"
+            
+            # Unlock the first file
+            result = locks.unlock(f1)
+            assert result == True, "Unlock should return True"
+        
+        # Test 3: Unlocking an unlocked file
+        with open(temp_file_path, 'r+') as f:
+            result = locks.unlock(f)
+            print(f"Unlock on unlocked file result: {result}")
+            # This should succeed and return True
+            assert result == True, "Unlock on unlocked file should return True"
+            
+        print("All edge case tests passed!")
+        
+    except Exception as e:
+        print(f"Test failed: {e}")
+        raise
+    finally:
+        # Clean up
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file