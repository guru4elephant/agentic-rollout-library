diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..67ee5ced6d
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test.db',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'test'
+
+def setup_database():
+    """Create the database tables"""
+    from django.core.management import execute_from_command_line
+    import sys
+    
+    # Create migrations
+    from django.db import connection
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE IF NOT EXISTS test_testmodel (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                name VARCHAR(100) NOT NULL,
+                value INTEGER NOT NULL DEFAULT 0
+            )
+        """)
+
+def test_bulk_update_comprehensive():
+    print("Testing comprehensive bulk_update() behavior...")
+    
+    # Test with empty list
+    result_empty = TestModel.objects.bulk_update([], ['value'])
+    print(f"bulk_update([]) returned: {result_empty} (type: {type(result_empty)})")
+    assert result_empty == 0, f"Expected 0, got {result_empty}"
+    
+    # Create test objects
+    obj1 = TestModel(name='test1', value=1)
+    obj2 = TestModel(name='test2', value=2)
+    obj3 = TestModel(name='test3', value=3)
+    
+    # Save them first
+    obj1.save()
+    obj2.save()
+    obj3.save()
+    
+    print(f"Created objects with IDs: {obj1.id}, {obj2.id}, {obj3.id}")
+    
+    # Test bulk_update with actual data
+    obj1.value = 100
+    obj2.value = 200
+    obj3.value = 300
+    
+    result_bulk_update = TestModel.objects.bulk_update([obj1, obj2, obj3], ['value'])
+    print(f"bulk_update([obj1, obj2, obj3]) returned: {result_bulk_update} (type: {type(result_bulk_update)})")
+    
+    # Verify the objects were updated
+    obj1_refreshed = TestModel.objects.get(id=obj1.id)
+    obj2_refreshed = TestModel.objects.get(id=obj2.id)
+    obj3_refreshed = TestModel.objects.get(id=obj3.id)
+    
+    print(f"Updated values: {obj1_refreshed.value}, {obj2_refreshed.value}, {obj3_refreshed.value}")
+    assert obj1_refreshed.value == 100
+    assert obj2_refreshed.value == 200
+    assert obj3_refreshed.value == 300
+    
+    # Test with batch size (should still return correct total)
+    obj1.value = 1000
+    obj2.value = 2000
+    obj3.value = 3000
+    
+    result_batch = TestModel.objects.bulk_update([obj1, obj2, obj3], ['value'], batch_size=2)
+    print(f"bulk_update with batch_size=2 returned: {result_batch}")
+    
+    # Test regular update for comparison
+    result_regular = TestModel.objects.filter(name='test1').update(value=9999)
+    print(f"Regular update() returned: {result_regular} (type: {type(result_regular)})")
+    
+    print("All tests passed!")
+
+if __name__ == '__main__':
+    setup_database()
+    test_bulk_update_comprehensive()
\ No newline at end of file
diff --git a/django/db/models/query.py b/django/db/models/query.py
index 387deca527..09d5d5fe91 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -541,7 +541,7 @@ class QuerySet:
         if any(f.primary_key for f in fields):
             raise ValueError('bulk_update() cannot be used with primary key fields.')
         if not objs:
-            return
+            return 0
         # PK is used twice in the resulting update query, once in the filter
         # and once in the WHEN. Each field will also have one CAST.
         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)
@@ -564,8 +564,10 @@ class QuerySet:
                 update_kwargs[field.attname] = case_statement
             updates.append(([obj.pk for obj in batch_objs], update_kwargs))
         with transaction.atomic(using=self.db, savepoint=False):
+            rows = 0
             for pks, update_kwargs in updates:
-                self.filter(pk__in=pks).update(**update_kwargs)
+                rows += self.filter(pk__in=pks).update(**update_kwargs)
+            return rows
     bulk_update.alters_data = True
 
     def get_or_create(self, defaults=None, **kwargs):
diff --git a/edge_case_test.py b/edge_case_test.py
new file mode 100644
index 0000000000..c071dfeff0
--- /dev/null
+++ b/edge_case_test.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_edge.db',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'test'
+
+def setup_database():
+    """Create the database tables"""
+    from django.db import connection
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE IF NOT EXISTS test_testmodel (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                name VARCHAR(100) NOT NULL,
+                value INTEGER NOT NULL DEFAULT 0
+            )
+        """)
+
+def test_edge_cases():
+    print("Testing edge cases for bulk_update()...")
+    
+    setup_database()
+    
+    # Test 1: Empty list
+    result = TestModel.objects.bulk_update([], ['value'])
+    assert result == 0, f"Expected 0, got {result}"
+    print("✓ Empty list returns 0")
+    
+    # Test 2: Single object
+    obj = TestModel(name='single', value=1)
+    obj.save()
+    
+    obj.value = 999
+    result = TestModel.objects.bulk_update([obj], ['value'])
+    assert result == 1, f"Expected 1, got {result}"
+    print("✓ Single object returns 1")
+    
+    # Test 3: Multiple objects with same values (should still update)
+    obj1 = TestModel(name='multi1', value=10)
+    obj2 = TestModel(name='multi2', value=20)
+    obj1.save()
+    obj2.save()
+    
+    obj1.value = 100  # Changed
+    obj2.value = 20   # Same as before
+    result = TestModel.objects.bulk_update([obj1, obj2], ['value'])
+    assert result == 2, f"Expected 2, got {result}"  # Should update both rows
+    print("✓ Multiple objects with some unchanged values returns correct count")
+    
+    # Test 4: Verify the values were actually updated
+    obj1_refreshed = TestModel.objects.get(id=obj1.id)
+    obj2_refreshed = TestModel.objects.get(id=obj2.id)
+    assert obj1_refreshed.value == 100
+    assert obj2_refreshed.value == 20  # Should remain unchanged
+    print("✓ Values correctly updated in database")
+    
+    # Test 5: Very large batch (should still work with our accumulation)
+    # Create 10 objects
+    objects = []
+    for i in range(10):
+        obj = TestModel(name=f'batch{i}', value=i)
+        obj.save()
+        objects.append(obj)
+    
+    # Update all of them
+    for obj in objects:
+        obj.value += 100
+    
+    result = TestModel.objects.bulk_update(objects, ['value'], batch_size=3)
+    assert result == 10, f"Expected 10, got {result}"
+    print("✓ Large batch with batch_size returns correct total count")
+    
+    print("All edge case tests passed!")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..3bc1003c4d
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'test'
+
+def create_table():
+    """Create the test table manually"""
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE test_testmodel (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                name VARCHAR(100) NOT NULL,
+                value INTEGER NOT NULL DEFAULT 0
+            )
+        """)
+
+def test_bulk_update_return_value():
+    """Test that bulk_update now returns the number of rows matched"""
+    print("=== Testing bulk_update return value fix ===")
+    
+    create_table()
+    
+    # Test 1: Empty list should return 0
+    result = TestModel.objects.bulk_update([], ['value'])
+    assert result == 0, f"Empty list should return 0, got {result}"
+    print("✓ Empty list returns 0")
+    
+    # Test 2: Single object
+    obj = TestModel(name='test1', value=1)
+    obj.save()
+    
+    obj.value = 100
+    result = TestModel.objects.bulk_update([obj], ['value'])
+    assert result == 1, f"Single object should return 1, got {result}"
+    print("✓ Single object returns 1")
+    
+    # Test 3: Multiple objects
+    obj2 = TestModel(name='test2', value=2)
+    obj3 = TestModel(name='test3', value=3)
+    obj2.save()
+    obj3.save()
+    
+    obj2.value = 200
+    obj3.value = 300
+    result = TestModel.objects.bulk_update([obj2, obj3], ['value'])
+    assert result == 2, f"Two objects should return 2, got {result}"
+    print("✓ Multiple objects return correct count")
+    
+    # Test 4: Verify values were actually updated
+    refreshed = TestModel.objects.get(id=obj.id)
+    assert refreshed.value == 100, "Value not updated correctly"
+    print("✓ Values correctly updated in database")
+    
+    # Test 5: Batch processing
+    obj.value = 1000
+    obj2.value = 2000  
+    obj3.value = 3000
+    result = TestModel.objects.bulk_update([obj, obj2, obj3], ['value'], batch_size=2)
+    assert result == 3, f"Batch processing should return 3, got {result}"
+    print("✓ Batch processing returns correct total count")
+    
+    # Test 6: Return type should be int
+    result = TestModel.objects.bulk_update([], ['value'])
+    assert isinstance(result, int), f"Return type should be int, got {type(result)}"
+    print("✓ Return type is int")
+    
+    # Test 7: Compare with regular update
+    result_regular = TestModel.objects.filter(name='test1').update(value=9999)
+    result_bulk = TestModel.objects.bulk_update([], ['value'])
+    assert isinstance(result_regular, int) and isinstance(result_bulk, int), "Both should return int"
+    print("✓ Both update() and bulk_update() return int")
+    
+    print("\n=== All tests passed! ===")
+    print("The bulk_update() method now correctly returns the number of rows matched,")
+    print("making it consistent with the update() method behavior.")
+
+if __name__ == '__main__':
+    test_bulk_update_return_value()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f470c65490
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create database tables
+def create_tables():
+    from django.core.management import execute_from_command_line
+    # Use Django's built-in table creation
+    import sys
+    old_argv = sys.argv
+    sys.argv = ['manage.py', 'migrate', '--run-syncdb']
+    execute_from_command_line(sys.argv)
+    sys.argv = old_argv
+
+# Test the current behavior
+def test_bulk_update_return_value():
+    # Create some test objects
+    obj1 = TestModel.objects.create(name='test1', value=1)
+    obj2 = TestModel.objects.create(name='test2', value=2)
+    obj3 = TestModel.objects.create(name='test3', value=3)
+    
+    # Test regular update method
+    result_update = TestModel.objects.filter(name='test1').update(value=10)
+    print(f"Regular update() returned: {result_update}")
+    
+    # Test bulk_update method
+    obj1.value = 100
+    obj2.value = 200
+    obj3.value = 300
+    
+    result_bulk_update = TestModel.objects.bulk_update([obj1, obj2, obj3], ['value'])
+    print(f"bulk_update() returned: {result_bulk_update}")
+    print(f"Type of bulk_update return: {type(result_bulk_update)}")
+    
+    # Test with empty list
+    result_empty = TestModel.objects.bulk_update([], ['value'])
+    print(f"bulk_update([]) returned: {result_empty}")
+
+if __name__ == '__main__':
+    create_tables()
+    test_bulk_update_return_value()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..c6b4c7e328
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_bulk_update_return_value():
+    print("Testing current bulk_update() behavior...")
+    
+    # Test with empty list first (this should work without tables)
+    result_empty = TestModel.objects.bulk_update([], ['value'])
+    print(f"bulk_update([]) returned: {result_empty}")
+    print(f"Type: {type(result_empty)}")
+    
+    # Test that regular update returns a number (to understand expected behavior)
+    try:
+        # This will fail due to no table, but we can see the method signature
+        result_update = TestModel.objects.update(value=10)
+        print(f"Regular update() returned: {result_update}")
+    except Exception as e:
+        print(f"Regular update failed (expected): {e}")
+
+if __name__ == '__main__':
+    test_bulk_update_return_value()
\ No newline at end of file
diff --git a/test.db b/test.db
new file mode 100644
index 0000000000..6512fdc0d7
Binary files /dev/null and b/test.db differ
diff --git a/test_edge.db b/test_edge.db
new file mode 100644
index 0000000000..c7bb99e96e
Binary files /dev/null and b/test_edge.db differ