diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py
index b192df4fbf..eb0322c351 100644
--- a/django/db/models/fields/related_descriptors.py
+++ b/django/db/models/fields/related_descriptors.py
@@ -145,6 +145,11 @@ class ForwardManyToOneDescriptor:
             }
         else:
             query = {"%s__in" % self.field.related_query_name(): instances}
+            
+        # If queryset is sliced, clone it first to make it filterable
+        if getattr(queryset.query, 'is_sliced', False):
+            queryset = queryset._chain()
+            
         queryset = queryset.filter(**query)
 
         # Since we're going to assign directly in the cache,
@@ -719,6 +724,11 @@ def create_reverse_many_to_one_manager(superclass, rel):
             instance_attr = self.field.get_foreign_related_value
             instances_dict = {instance_attr(inst): inst for inst in instances}
             query = {"%s__in" % self.field.name: instances}
+            
+            # If queryset is sliced, clone it first to make it filterable
+            if getattr(queryset.query, 'is_sliced', False):
+                queryset = queryset._chain()
+                
             queryset = queryset.filter(**query)
 
             # Since we just bypassed this class' get_queryset(), we must manage
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..cc6fe776d1
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Prefetch
+
+# Create simple models to reproduce the issue
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Post(models.Model):
+    title = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Category)
+    schema_editor.create_model(Post)
+
+# Create test data
+category1 = Category.objects.create(name="Category 1")
+category2 = Category.objects.create(name="Category 2")
+
+for i in range(5):
+    Post.objects.create(title=f"Post {i} - Cat 1", category=category1)
+    Post.objects.create(title=f"Post {i} - Cat 2", category=category2)
+
+print("Test data created successfully")
+
+# Try to reproduce the issue
+try:
+    print("Trying to prefetch with sliced queryset...")
+    categories = Category.objects.prefetch_related(Prefetch(
+        'post_set',
+        queryset=Post.objects.all()[:3],  # This should cause the error
+        to_attr='example_posts',
+    ))
+    
+    # Force evaluation to trigger the prefetch
+    list(categories)
+    print("SUCCESS: Prefetch with slice worked!")
+    
+except Exception as e:
+    print(f"ERROR: {type(e).__name__}: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file