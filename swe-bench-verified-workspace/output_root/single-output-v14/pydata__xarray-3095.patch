diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..61ec63a4
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,48 @@
+import xarray
+
+# Create the dataset as described in the issue
+ds = xarray.Dataset(
+    coords={'x': ['foo'], 'y': ('x', ['bar'])},
+    data_vars={'z': ('x', ['baz'])}
+)
+
+print("Original dataset:")
+print(ds)
+print("\nOriginal dataset dtypes:")
+print(f"x coordinate dtype: {ds.coords['x'].dtype}")
+print(f"y coordinate dtype: {ds.coords['y'].dtype}")
+print(f"z data variable dtype: {ds.data_vars['z'].dtype}")
+
+# Test shallow copy
+ds_shallow_copy = ds.copy()
+print("\nShallow copy:")
+print(ds_shallow_copy)
+print("\nShallow copy dtypes:")
+print(f"x coordinate dtype: {ds_shallow_copy.coords['x'].dtype}")
+print(f"y coordinate dtype: {ds_shallow_copy.coords['y'].dtype}")
+print(f"z data variable dtype: {ds_shallow_copy.data_vars['z'].dtype}")
+
+# Test deep copy
+ds_deep_copy = ds.copy(deep=True)
+print("\nDeep copy:")
+print(ds_deep_copy)
+print("\nDeep copy dtypes:")
+print(f"x coordinate dtype: {ds_deep_copy.coords['x'].dtype}")
+print(f"y coordinate dtype: {ds_deep_copy.coords['y'].dtype}")
+print(f"z data variable dtype: {ds_deep_copy.data_vars['z'].dtype}")
+
+# Test DataArray copy
+da = ds.z
+print("\nOriginal DataArray:")
+print(da)
+print(f"DataArray x coordinate dtype: {da.coords['x'].dtype}")
+
+da_shallow_copy = da.copy()
+print("\nDataArray shallow copy:")
+print(da_shallow_copy)
+print(f"DataArray shallow copy x coordinate dtype: {da_shallow_copy.coords['x'].dtype}")
+
+da_deep_copy = da.copy(deep=True)
+print("\nDataArray deep copy:")
+print(da_deep_copy)
+print(f"DataArray deep copy x coordinate dtype: {da_deep_copy.coords['x'].dtype}")
\ No newline at end of file
diff --git a/test_copy_deepcopy.py b/test_copy_deepcopy.py
new file mode 100644
index 00000000..4f4f7918
--- /dev/null
+++ b/test_copy_deepcopy.py
@@ -0,0 +1,34 @@
+import xarray
+import copy
+
+# Create the dataset as described in the issue
+ds = xarray.Dataset(
+    coords={'x': ['foo'], 'y': ('x', ['bar'])},
+    data_vars={'z': ('x', ['baz'])}
+)
+
+print("Original dataset:")
+print(ds)
+print(f"x coordinate dtype: {ds.coords['x'].dtype}")
+
+# Test copy.copy()
+ds_copy = copy.copy(ds)
+print("\ncopy.copy():")
+print(ds_copy)
+print(f"x coordinate dtype: {ds_copy.coords['x'].dtype}")
+
+# Test copy.deepcopy()
+ds_deepcopy = copy.deepcopy(ds)
+print("\ncopy.deepcopy():")
+print(ds_deepcopy)
+print(f"x coordinate dtype: {ds_deepcopy.coords['x'].dtype}")
+
+# Test DataArray with copy operations
+da = ds.z
+print(f"\nOriginal DataArray x coordinate dtype: {da.coords['x'].dtype}")
+
+da_copy = copy.copy(da)
+print(f"copy.copy() DataArray x coordinate dtype: {da_copy.coords['x'].dtype}")
+
+da_deepcopy = copy.deepcopy(da)
+print(f"copy.deepcopy() DataArray x coordinate dtype: {da_deepcopy.coords['x'].dtype}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..67ce8a1d
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,56 @@
+import xarray
+import numpy as np
+
+print("Testing edge cases for copy operations...")
+
+# Test 1: Regular numeric data
+print("\n1. Testing numeric data:")
+ds_numeric = xarray.Dataset(
+    coords={'x': [1, 2, 3]},
+    data_vars={'z': ('x', [4, 5, 6])}
+)
+print(f"Original: {ds_numeric.coords['x'].dtype}")
+ds_numeric_copy = ds_numeric.copy(deep=True)
+print(f"Deep copy: {ds_numeric_copy.coords['x'].dtype}")
+
+# Test 2: Float data
+print("\n2. Testing float data:")
+ds_float = xarray.Dataset(
+    coords={'x': [1.1, 2.2, 3.3]},
+    data_vars={'z': ('x', [4.4, 5.5, 6.6])}
+)
+print(f"Original: {ds_float.coords['x'].dtype}")
+ds_float_copy = ds_float.copy(deep=True)
+print(f"Deep copy: {ds_float_copy.coords['x'].dtype}")
+
+# Test 3: Object data (should remain object)
+print("\n3. Testing object data:")
+ds_object = xarray.Dataset(
+    coords={'x': [1, 'a', 3.0]},  # mixed types become object
+    data_vars={'z': ('x', [4, 5, 6])}
+)
+print(f"Original: {ds_object.coords['x'].dtype}")
+ds_object_copy = ds_object.copy(deep=True)
+print(f"Deep copy: {ds_object_copy.coords['x'].dtype}")
+
+# Test 4: Longer unicode strings
+print("\n4. Testing longer unicode strings:")
+ds_long_unicode = xarray.Dataset(
+    coords={'x': ['hello', 'world']},
+    data_vars={'z': ('x', [1, 2])}
+)
+print(f"Original: {ds_long_unicode.coords['x'].dtype}")
+ds_long_unicode_copy = ds_long_unicode.copy(deep=True)
+print(f"Deep copy: {ds_long_unicode_copy.coords['x'].dtype}")
+
+# Test 5: Empty unicode array
+print("\n5. Testing empty unicode array:")
+ds_empty = xarray.Dataset(
+    coords={'x': []},
+    data_vars={'z': ('x', [])}
+)
+print(f"Original: {ds_empty.coords['x'].dtype}")
+ds_empty_copy = ds_empty.copy(deep=True)
+print(f"Deep copy: {ds_empty_copy.coords['x'].dtype}")
+
+print("\nAll edge case tests completed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 00000000..acfacb05
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,63 @@
+"""
+Test to verify the fix for the GitHub issue:
+REGRESSION: copy(deep=True) casts unicode indices to object
+"""
+import xarray
+import copy
+
+def test_unicode_copy_regression():
+    """Test that unicode indices are preserved during copy operations."""
+    
+    # Create the exact dataset from the GitHub issue
+    ds = xarray.Dataset(
+        coords={'x': ['foo'], 'y': ('x', ['bar'])},
+        data_vars={'z': ('x', ['baz'])}
+    )
+    
+    print("Original dataset:")
+    print(ds)
+    print(f"x coordinate dtype: {ds.coords['x'].dtype}")
+    print(f"y coordinate dtype: {ds.coords['y'].dtype}")
+    print(f"z data variable dtype: {ds.data_vars['z'].dtype}")
+    
+    # Test 1: Dataset.copy(deep=True) - should preserve unicode dtype
+    ds_deep_copy = ds.copy(deep=True)
+    print("\nDataset.copy(deep=True):")
+    print(ds_deep_copy)
+    print(f"x coordinate dtype: {ds_deep_copy.coords['x'].dtype}")
+    assert ds_deep_copy.coords['x'].dtype == '<U3', f"Expected <U3, got {ds_deep_copy.coords['x'].dtype}"
+    
+    # Test 2: Dataset.copy(deep=False) - should preserve unicode dtype
+    ds_shallow_copy = ds.copy(deep=False)
+    print("\nDataset.copy(deep=False):")
+    print(ds_shallow_copy)
+    print(f"x coordinate dtype: {ds_shallow_copy.coords['x'].dtype}")
+    assert ds_shallow_copy.coords['x'].dtype == '<U3', f"Expected <U3, got {ds_shallow_copy.coords['x'].dtype}"
+    
+    # Test 3: DataArray.copy() - should preserve unicode dtype in coordinates
+    da = ds.z
+    print(f"\nOriginal DataArray x coordinate dtype: {da.coords['x'].dtype}")
+    
+    da_copy = da.copy()
+    print(f"DataArray.copy() x coordinate dtype: {da_copy.coords['x'].dtype}")
+    assert da_copy.coords['x'].dtype == '<U3', f"Expected <U3, got {da_copy.coords['x'].dtype}"
+    
+    # Test 4: DataArray.copy(deep=True) - should preserve unicode dtype in coordinates
+    da_deep_copy = da.copy(deep=True)
+    print(f"DataArray.copy(deep=True) x coordinate dtype: {da_deep_copy.coords['x'].dtype}")
+    assert da_deep_copy.coords['x'].dtype == '<U3', f"Expected <U3, got {da_deep_copy.coords['x'].dtype}"
+    
+    # Test 5: copy.copy() - should preserve unicode dtype
+    ds_copy = copy.copy(ds)
+    print(f"\ncopy.copy() x coordinate dtype: {ds_copy.coords['x'].dtype}")
+    assert ds_copy.coords['x'].dtype == '<U3', f"Expected <U3, got {ds_copy.coords['x'].dtype}"
+    
+    # Test 6: copy.deepcopy() - should preserve unicode dtype
+    ds_deepcopy = copy.deepcopy(ds)
+    print(f"copy.deepcopy() x coordinate dtype: {ds_deepcopy.coords['x'].dtype}")
+    assert ds_deepcopy.coords['x'].dtype == '<U3', f"Expected <U3, got {ds_deepcopy.coords['x'].dtype}"
+    
+    print("\nâœ… All tests passed! Unicode dtype is preserved in all copy operations.")
+
+if __name__ == "__main__":
+    test_unicode_copy_regression()
\ No newline at end of file
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 379be8f5..4d404636 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -809,7 +809,7 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,
                     data = data.copy()
                 elif not isinstance(data, PandasIndexAdapter):
                     # pandas.Index is immutable
-                    data = np.array(data)
+                    data = np.array(data, dtype=self.dtype)
         else:
             data = as_compatible_data(data)
             if self.shape != data.shape:
@@ -1947,7 +1947,7 @@ class IndexVariable(Variable):
                 # point, which doesn't have a copy method, so make a deep copy
                 # of the underlying `pandas.MultiIndex` and create a new
                 # `PandasIndexAdapter` instance with it.
-                data = PandasIndexAdapter(self._data.array.copy(deep=True))
+                data = PandasIndexAdapter(self._data.array.copy(deep=True), dtype=self.dtype)
             else:
                 data = self._data
         else: