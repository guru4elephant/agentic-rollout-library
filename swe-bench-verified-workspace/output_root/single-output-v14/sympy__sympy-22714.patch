diff --git a/debug_comparison.py b/debug_comparison.py
new file mode 100644
index 0000000000..680eac3418
--- /dev/null
+++ b/debug_comparison.py
@@ -0,0 +1,27 @@
+import sympy as sp
+
+print("Debugging comparison behavior...")
+
+with sp.evaluate(False):
+    int1 = sp.Integer(1)
+    int2 = sp.Integer(2)
+    
+    im1 = sp.im(int1)
+    im2 = sp.im(int2)
+    
+    print(f"im(1): {im1}")
+    print(f"im(2): {im2}")
+    print(f"im(1) != 0: {im1 != 0}")
+    print(f"im(2) != 0: {im2 != 0}")
+    print(f"type(im(1) != 0): {type(im1 != 0)}")
+    print(f"bool(im(1) != 0): {bool(im1 != 0)}")
+    
+    # Test if we can force evaluation
+    print(f"im(1).equals(0): {im1.equals(0)}")
+    print(f"im(2).equals(0): {im2.equals(0)}")
+    
+    # Test with explicit evaluation
+    print(f"sp.Eq(im(1), 0): {sp.Eq(im1, 0)}")
+    print(f"sp.Eq(im(2), 0): {sp.Eq(im2, 0)}")
+    print(f"sp.Eq(im(1), 0).simplify(): {sp.Eq(im1, 0).simplify()}")
+    print(f"sp.Eq(im(2), 0).simplify(): {sp.Eq(im2, 0).simplify()}")
\ No newline at end of file
diff --git a/debug_context.py b/debug_context.py
new file mode 100644
index 0000000000..658b3bd6e6
--- /dev/null
+++ b/debug_context.py
@@ -0,0 +1,34 @@
+import sympy as sp
+
+print("Debugging context manager behavior...")
+
+# Let's see what the context manager actually does
+print("\n1. Checking evaluate context manager:")
+print(f"Global evaluate setting: {sp.core.parameters.global_parameters.evaluate}")
+with sp.evaluate(False):
+    print(f"Inside context: {sp.core.parameters.global_parameters.evaluate}")
+    # Let's see what happens when we create Integer objects
+    int1 = sp.Integer(1)
+    int2 = sp.Integer(2)
+    print(f"Integer(1): {int1}, type: {type(int1)}")
+    print(f"Integer(2): {int2}, type: {type(int2)}")
+    print(f"int1.is_number: {int1.is_number}")
+    print(f"int2.is_number: {int2.is_number}")
+    print(f"im(int1): {sp.im(int1)}")
+    print(f"im(int2): {sp.im(int2)}")
+    
+    # Let's try to manually create Point2D
+    try:
+        p = sp.Point2D(int1, int2)
+        print(f"Manual Point2D: {p}")
+    except Exception as e:
+        print(f"Manual Point2D error: {e}")
+        
+    # Let's see what S() returns
+    try:
+        s_result = sp.S('Integer(1)')
+        print(f"S('Integer(1)'): {s_result}, type: {type(s_result)}")
+    except Exception as e:
+        print(f"S('Integer(1)') error: {e}")
+
+print(f"Outside context: {sp.core.parameters.global_parameters.evaluate}")
\ No newline at end of file
diff --git a/debug_im.py b/debug_im.py
new file mode 100644
index 0000000000..6bfb816ca0
--- /dev/null
+++ b/debug_im.py
@@ -0,0 +1,39 @@
+import sympy as sp
+
+print("Debugging im() function behavior...")
+
+# Test im() with evaluate=True
+print("\n1. With evaluate=True:")
+with sp.evaluate(True):
+    int1 = sp.Integer(1)
+    int2 = sp.Integer(2)
+    print(f"im(1): {sp.im(int1)}, type: {type(sp.im(int1))}")
+    print(f"im(2): {sp.im(int2)}, type: {type(sp.im(int2))}")
+    print(f"im(1) == 0: {sp.im(int1) == 0}")
+    print(f"im(2) == 0: {sp.im(int2) == 0}")
+
+# Test im() with evaluate=False
+print("\n2. With evaluate=False:")
+with sp.evaluate(False):
+    int1 = sp.Integer(1)
+    int2 = sp.Integer(2)
+    print(f"im(1): {sp.im(int1)}, type: {type(sp.im(int1))}")
+    print(f"im(2): {sp.im(int2)}, type: {type(sp.im(int2))}")
+    print(f"im(1) == 0: {sp.im(int1) == 0}")
+    print(f"im(2) == 0: {sp.im(int2) == 0}")
+    
+    # Check if im(1) is considered non-zero
+    print(f"bool(im(1)): {bool(sp.im(int1))}")
+    print(f"im(1).is_zero: {sp.im(int1).is_zero}")
+
+# Test the actual condition from point.py
+print("\n3. Testing the condition from point.py:")
+with sp.evaluate(False):
+    coords = [sp.Integer(1), sp.Integer(2)]
+    print(f"coords: {coords}")
+    for a in coords:
+        print(f"a: {a}, a.is_number: {a.is_number}, im(a): {sp.im(a)}, bool(im(a)): {bool(sp.im(a))}")
+        print(f"a.is_number and im(a): {a.is_number and sp.im(a)}")
+    
+    result = any(a.is_number and sp.im(a) for a in coords)
+    print(f"any(a.is_number and im(a) for a in coords): {result}")
\ No newline at end of file
diff --git a/debug_point.py b/debug_point.py
new file mode 100644
index 0000000000..a6d931bab9
--- /dev/null
+++ b/debug_point.py
@@ -0,0 +1,43 @@
+import sympy as sp
+
+print("Debugging Point2D creation...")
+
+# Test with evaluate=True (default)
+print("\n1. With evaluate=True:")
+p1 = sp.Point2D(sp.Integer(1), sp.Integer(2))
+print(f"Point: {p1}")
+print(f"Coordinates: {p1.args}")
+
+# Test with explicit evaluate=False
+print("\n2. With explicit evaluate=False:")
+p2 = sp.Point2D(sp.Integer(1), sp.Integer(2), evaluate=False)
+print(f"Point: {p2}")
+print(f"Coordinates: {p2.args}")
+
+# Test what happens when we parse the string with evaluate=False
+print("\n3. Parsing string with evaluate=False:")
+try:
+    result = sp.S('Point2D(Integer(1),Integer(2))', evaluate=False)
+    print(f"Result: {result}")
+    print(f"Coordinates: {result.args}")
+except Exception as e:
+    print(f"Error: {e}")
+
+# Test what happens in the context manager
+print("\n4. In evaluate(False) context:")
+try:
+    with sp.evaluate(False):
+        result = sp.S('Point2D(Integer(1),Integer(2))')
+        print(f"Result: {result}")
+        print(f"Coordinates: {result.args}")
+except Exception as e:
+    print(f"Error: {e}")
+    
+# Let's also check what Integer(1) and Integer(2) look like when not evaluated
+print("\n5. Checking Integer objects:")
+int1 = sp.Integer(1)
+int2 = sp.Integer(2)
+print(f"Integer(1): {int1}, is_number: {int1.is_number}")
+print(f"Integer(2): {int2}, is_number: {int2.is_number}")
+print(f"im(Integer(1)): {sp.im(int1)}")
+print(f"im(Integer(2)): {sp.im(int2)}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dd4311b7e9
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+import sympy as sp
+
+print("Testing the issue with evaluate(False) and Point2D...")
+
+# This should work without evaluate(False)
+print("\n1. Testing without evaluate(False):")
+result1 = sp.S('Point2D(Integer(1),Integer(2))')
+print(f"Result: {result1}")
+
+# This should also work with explicit evaluate=False
+print("\n2. Testing with explicit evaluate=False:")
+result2 = sp.S('Point2D(Integer(1),Integer(2))', evaluate=False)
+print(f"Result: {result2}")
+
+# This should fail according to the issue
+print("\n3. Testing with evaluate(False) context:")
+try:
+    with sp.evaluate(False):
+        result3 = sp.S('Point2D(Integer(1),Integer(2))')
+        print(f"Result: {result3}")
+except Exception as e:
+    print(f"Error: {e}")
+    print(f"Error type: {type(e)}")
\ No newline at end of file
diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py
index 73c20334d0..f2cec356f7 100644
--- a/sympy/geometry/point.py
+++ b/sympy/geometry/point.py
@@ -152,7 +152,7 @@ def __new__(cls, *args, **kwargs):
                         'warn' or 'ignore'.'''))
         if any(coords[dim:]):
             raise ValueError('Nonzero coordinates cannot be removed.')
-        if any(a.is_number and im(a) for a in coords):
+        if any(a.is_number and not im(a).equals(0) for a in coords):
             raise ValueError('Imaginary coordinates are not permitted.')
         if not all(isinstance(a, Expr) for a in coords):
             raise TypeError('Coordinates must be valid SymPy expressions.')
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d8939d386d
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,66 @@
+import sympy as sp
+
+print("Testing edge cases for Point2D with evaluate(False)...")
+
+# Test 1: Real coordinates (should work)
+print("\n1. Testing real coordinates:")
+with sp.evaluate(False):
+    try:
+        p1 = sp.S('Point2D(Integer(1),Integer(2))')
+        print(f"✓ Point2D(1, 2): {p1}")
+    except Exception as e:
+        print(f"✗ Point2D(1, 2) failed: {e}")
+
+# Test 2: Complex coordinates (should still fail appropriately)
+print("\n2. Testing complex coordinates (should fail):")
+with sp.evaluate(False):
+    try:
+        p2 = sp.S('Point2D(I,Integer(2))')
+        print(f"✗ Point2D(I, 2) should have failed but got: {p2}")
+    except ValueError as e:
+        print(f"✓ Point2D(I, 2) correctly failed: {e}")
+    except Exception as e:
+        print(f"✗ Point2D(I, 2) failed with unexpected error: {e}")
+
+# Test 3: Mixed coordinates
+print("\n3. Testing mixed coordinates:")
+with sp.evaluate(False):
+    try:
+        p3 = sp.S('Point2D(1+0*I,Integer(2))')
+        print(f"✓ Point2D(1+0*I, 2): {p3}")
+    except Exception as e:
+        print(f"✗ Point2D(1+0*I, 2) failed: {e}")
+
+# Test 4: With evaluate=True (should work as before)
+print("\n4. Testing with evaluate=True:")
+with sp.evaluate(True):
+    try:
+        p4 = sp.S('Point2D(Integer(1),Integer(2))')
+        print(f"✓ Point2D(1, 2) with evaluate=True: {p4}")
+    except Exception as e:
+        print(f"✗ Point2D(1, 2) with evaluate=True failed: {e}")
+
+# Test 5: Direct constructor with evaluate=False
+print("\n5. Testing direct constructor with evaluate=False:")
+try:
+    p5 = sp.Point2D(sp.Integer(1), sp.Integer(2), evaluate=False)
+    print(f"✓ Point2D(1, 2, evaluate=False): {p5}")
+except Exception as e:
+    print(f"✗ Point2D(1, 2, evaluate=False) failed: {e}")
+
+# Test 6: Test that normal behavior still works
+print("\n6. Testing normal behavior:")
+try:
+    p6 = sp.Point2D(1, 2)
+    print(f"✓ Point2D(1, 2) normal: {p6}")
+except Exception as e:
+    print(f"✗ Point2D(1, 2) normal failed: {e}")
+
+# Test 7: Test Point3D as well
+print("\n7. Testing Point3D:")
+with sp.evaluate(False):
+    try:
+        p7 = sp.S('Point3D(Integer(1),Integer(2),Integer(3))')
+        print(f"✓ Point3D(1, 2, 3): {p7}")
+    except Exception as e:
+        print(f"✗ Point3D(1, 2, 3) failed: {e}")
\ No newline at end of file