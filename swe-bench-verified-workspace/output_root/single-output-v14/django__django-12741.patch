diff --git a/django/core/management/commands/flush.py b/django/core/management/commands/flush.py
index e8ed3967f7..bc8021cf4e 100644
--- a/django/core/management/commands/flush.py
+++ b/django/core/management/commands/flush.py
@@ -60,7 +60,7 @@ Are you sure you want to do this?
 
         if confirm == 'yes':
             try:
-                connection.ops.execute_sql_flush(database, sql_list)
+                connection.ops.execute_sql_flush(sql_list)
             except Exception as exc:
                 raise CommandError(
                     "Database %s couldn't be flushed. Possible reasons:\n"
diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py
index 70ac07ae09..f07580c18b 100644
--- a/django/db/backends/base/operations.py
+++ b/django/db/backends/base/operations.py
@@ -400,9 +400,9 @@ class BaseDatabaseOperations:
         """
         raise NotImplementedError('subclasses of BaseDatabaseOperations must provide a sql_flush() method')
 
-    def execute_sql_flush(self, using, sql_list):
+    def execute_sql_flush(self, sql_list):
         """Execute a list of SQL statements to flush the database."""
-        with transaction.atomic(using=using, savepoint=self.connection.features.can_rollback_ddl):
+        with transaction.atomic(using=self.connection.alias, savepoint=self.connection.features.can_rollback_ddl):
             with self.connection.cursor() as cursor:
                 for sql in sql_list:
                     cursor.execute(sql)
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..926a70c713
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,144 @@
+#!/usr/bin/env python3
+
+"""
+Final comprehensive test to verify the execute_sql_flush signature simplification
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import connections
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+from django.core.management.commands.flush import Command
+
+def test_signature_simplification():
+    """Test that the signature has been simplified correctly"""
+    print("=== Testing Signature Simplification ===\n")
+    
+    # Test 1: Method signature should only accept sql_list parameter
+    import inspect
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    sig = inspect.signature(ops.execute_sql_flush)
+    params = list(sig.parameters.keys())
+    
+    if params == ['sql_list']:
+        print("‚úì Method signature simplified correctly")
+    else:
+        print(f"‚úó Method signature incorrect. Expected ['sql_list'], got {params}")
+        return False
+    
+    # Test 2: Method should work with new signature
+    try:
+        ops.execute_sql_flush(["SELECT 1;"])
+        print("‚úì Method works with new signature")
+    except Exception as e:
+        print(f"‚úó Method failed with new signature: {e}")
+        return False
+    
+    # Test 3: Method should fail with old signature (using parameter)
+    try:
+        ops.execute_sql_flush("default", ["SELECT 1;"])
+        print("‚úó Method should have failed with old signature")
+        return False
+    except TypeError as e:
+        if "takes 2 positional arguments but 3 were given" in str(e):
+            print("‚úì Method correctly rejects old signature")
+        else:
+            print(f"‚úó Unexpected error with old signature: {e}")
+            return False
+    
+    return True
+
+def test_internal_usage():
+    """Test that internal Django usage still works"""
+    print("\n=== Testing Internal Usage ===\n")
+    
+    try:
+        # Test that flush command can be instantiated
+        cmd = Command()
+        print("‚úì Flush command can be instantiated")
+        
+        # Test that the method can be called
+        connection = connections['default']
+        sql_list = connection.ops.sql_flush(no_style(), [], reset_sequences=True)
+        connection.ops.execute_sql_flush(sql_list)
+        print("‚úì Internal usage works correctly")
+        
+        return True
+    except Exception as e:
+        print(f"‚úó Internal usage failed: {e}")
+        return False
+
+def test_github_issue_requirements():
+    """Test that the GitHub issue requirements are met"""
+    print("\n=== Testing GitHub Issue Requirements ===\n")
+    
+    # Requirement 1: Signature should be simplified from:
+    # def execute_sql_flush(self, using, sql_list):
+    # to:
+    # def execute_sql_flush(self, sql_list):
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # Check that 'using' parameter is no longer needed
+    try:
+        ops.execute_sql_flush(["SELECT 1;"])
+        print("‚úì 'using' parameter successfully removed")
+    except Exception as e:
+        print(f"‚úó Failed to remove 'using' parameter: {e}")
+        return False
+    
+    # Requirement 2: 'using' should be inferred from self.connection.alias
+    # This is verified by the fact that the method works without the using parameter
+    # and internally uses self.connection.alias
+    
+    print("‚úì 'using' parameter inferred from self.connection.alias")
+    
+    return True
+
+if __name__ == "__main__":
+    print("Final Comprehensive Test for execute_sql_flush Simplification\n")
+    
+    success = True
+    success &= test_signature_simplification()
+    success &= test_internal_usage()
+    success &= test_github_issue_requirements()
+    
+    print("\n" + "="*60)
+    if success:
+        print("üéâ ALL TESTS PASSED! The GitHub issue has been successfully resolved.")
+        print("\nSummary of changes:")
+        print("1. ‚úì Method signature simplified from execute_sql_flush(self, using, sql_list) to execute_sql_flush(self, sql_list)")
+        print("2. ‚úì 'using' parameter removed and inferred from self.connection.alias")
+        print("3. ‚úì All internal calls updated to use new signature")
+        print("4. ‚úì Backward compatibility maintained for internal Django usage")
+        sys.exit(0)
+    else:
+        print("‚ùå SOME TESTS FAILED! Please review the implementation.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f064219b14
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+
+"""
+Script to reproduce the current execute_sql_flush usage pattern
+and demonstrate the proposed simplification.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import connections
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_current_usage():
+    """Test the current execute_sql_flush usage pattern"""
+    print("Testing current execute_sql_flush usage...")
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # Current signature: execute_sql_flush(self, using, sql_list)
+    # Current usage pattern as shown in the codebase:
+    try:
+        # This is how it's currently called in the codebase
+        sql_list = ["SELECT 1;"]  # Simple test SQL
+        ops.execute_sql_flush(connection.alias, sql_list)
+        print("‚úì Current usage pattern works")
+    except Exception as e:
+        print(f"‚úó Current usage pattern failed: {e}")
+        return False
+    
+    return True
+
+def test_proposed_simplification():
+    """Test what the proposed simplified signature would look like"""
+    print("\nTesting proposed simplification...")
+    
+    # The proposed change would allow calling it like this:
+    # ops.execute_sql_flush(sql_list)  # No 'using' parameter needed
+    
+    print("The proposed change would simplify the method signature from:")
+    print("  def execute_sql_flush(self, using, sql_list):")
+    print("to:")
+    print("  def execute_sql_flush(self, sql_list):")
+    print()
+    print("And internal usage would change from:")
+    print("  with transaction.atomic(using=using, ...)")
+    print("to:")
+    print("  with transaction.atomic(using=self.connection.alias, ...)")
+    
+    return True
+
+if __name__ == "__main__":
+    print("=== Django execute_sql_flush Signature Simplification ===")
+    
+    success = test_current_usage()
+    test_proposed_simplification()
+    
+    if success:
+        print("\n‚úì Reproduction script completed successfully")
+        print("The current implementation works, ready for simplification")
+    else:
+        print("\n‚úó Reproduction script failed")
+        sys.exit(1)
\ No newline at end of file
diff --git a/run_django_tests.py b/run_django_tests.py
new file mode 100644
index 0000000000..665c5fa8a2
--- /dev/null
+++ b/run_django_tests.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+
+"""
+Script to run Django tests with proper settings configuration
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings for testing
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+# Now we can import and run the specific test
+from django.test.utils import get_runner
+
+def run_specific_test():
+    TestRunner = get_runner(settings)
+    test_runner = TestRunner(verbosity=2)
+    
+    # Run the specific test method
+    failures = test_runner.run_tests([
+        'tests.backends.base.test_operations.SqlFlushTests.test_execute_sql_flush_statements'
+    ])
+    
+    return failures == 0
+
+if __name__ == "__main__":
+    print("Running specific Django test...")
+    success = run_specific_test()
+    
+    if success:
+        print("‚úì Test passed!")
+        sys.exit(0)
+    else:
+        print("‚úó Test failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..b14aa919c7
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+
+"""
+Simple test to verify the execute_sql_flush changes work
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import connections
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_execute_sql_flush():
+    """Test the execute_sql_flush method directly"""
+    print("Testing execute_sql_flush method...")
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # Test the new signature
+    try:
+        # This should work with the new signature
+        sql_list = ["SELECT 1;"]  # Simple test SQL
+        ops.execute_sql_flush(sql_list)
+        print("‚úì execute_sql_flush with new signature works")
+        return True
+    except Exception as e:
+        print(f"‚úó execute_sql_flush failed: {e}")
+        return False
+
+def test_method_signature():
+    """Test that the method signature is correct"""
+    print("Testing method signature...")
+    
+    import inspect
+    from django.db.backends.base.operations import BaseDatabaseOperations
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # Get the method signature
+    sig = inspect.signature(ops.execute_sql_flush)
+    params = list(sig.parameters.keys())
+    
+    # Should only have 'sql_list' parameter (self is implicit for instance methods)
+    expected_params = ['sql_list']
+    
+    if params == expected_params:
+        print(f"‚úì Method signature is correct: {params}")
+        return True
+    else:
+        print(f"‚úó Method signature is incorrect. Expected {expected_params}, got {params}")
+        return False
+
+def test_flush_command():
+    """Test that the flush command can be imported and instantiated"""
+    print("Testing flush command...")
+    
+    try:
+        from django.core.management.commands.flush import Command
+        cmd = Command()
+        print("‚úì Flush command can be instantiated")
+        return True
+    except Exception as e:
+        print(f"‚úó Flush command failed: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("=== Simple Test for execute_sql_flush Changes ===\n")
+    
+    success = True
+    
+    success &= test_method_signature()
+    print()
+    
+    success &= test_execute_sql_flush()
+    print()
+    
+    success &= test_flush_command()
+    print()
+    
+    if success:
+        print("‚úì All simple tests passed!")
+        sys.exit(0)
+    else:
+        print("‚úó Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..3ebe5bd5a8
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+
+"""
+Test script to verify that the execute_sql_flush signature simplification works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import connections
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_new_signature():
+    """Test the new simplified execute_sql_flush signature"""
+    print("Testing new execute_sql_flush signature...")
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # New signature: execute_sql_flush(self, sql_list)
+    # Should work without the 'using' parameter
+    try:
+        sql_list = ["SELECT 1;"]  # Simple test SQL
+        ops.execute_sql_flush(sql_list)
+        print("‚úì New signature works correctly")
+        return True
+    except Exception as e:
+        print(f"‚úó New signature failed: {e}")
+        return False
+
+def test_old_signature_fails():
+    """Test that the old signature with 'using' parameter now fails"""
+    print("Testing that old signature fails...")
+    
+    connection = connections['default']
+    ops = BaseDatabaseOperations(connection)
+    
+    # Old signature: execute_sql_flush(self, using, sql_list)
+    # Should now fail since we removed the 'using' parameter
+    try:
+        sql_list = ["SELECT 1;"]  # Simple test SQL
+        ops.execute_sql_flush(connection.alias, sql_list)
+        print("‚úó Old signature still works (unexpected)")
+        return False
+    except TypeError as e:
+        if "takes 2 positional arguments but 3 were given" in str(e):
+            print("‚úì Old signature correctly fails with TypeError")
+            return True
+        else:
+            print(f"‚úó Unexpected error: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó Unexpected error: {e}")
+        return False
+
+def test_internal_usage():
+    """Test that the internal usage within Django still works"""
+    print("Testing internal Django usage...")
+    
+    from django.core.management.commands.flush import Command
+    
+    try:
+        # Create a flush command instance
+        cmd = Command()
+        cmd.style = no_style()
+        
+        # This should work with the new signature
+        print("‚úì Flush command should work with new signature")
+        return True
+    except Exception as e:
+        print(f"‚úó Internal usage failed: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("=== Testing execute_sql_flush Signature Simplification ===\n")
+    
+    success = True
+    
+    # Test 1: New signature works
+    success &= test_new_signature()
+    print()
+    
+    # Test 2: Old signature fails
+    success &= test_old_signature_fails()
+    print()
+    
+    # Test 3: Internal usage works
+    success &= test_internal_usage()
+    print()
+    
+    if success:
+        print("‚úì All tests passed! The signature simplification is working correctly.")
+        sys.exit(0)
+    else:
+        print("‚úó Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py
index 0485fe8465..b0ffe958c8 100644
--- a/tests/backends/base/test_operations.py
+++ b/tests/backends/base/test_operations.py
@@ -172,7 +172,7 @@ class SqlFlushTests(TransactionTestCase):
             reset_sequences=True,
             allow_cascade=True,
         )
-        connection.ops.execute_sql_flush(connection.alias, sql_list)
+        connection.ops.execute_sql_flush(sql_list)
 
         with transaction.atomic():
             self.assertIs(Author.objects.exists(), False)
diff --git a/tests/backends/tests.py b/tests/backends/tests.py
index d6c2331378..40fc6de7fc 100644
--- a/tests/backends/tests.py
+++ b/tests/backends/tests.py
@@ -162,7 +162,7 @@ class LongNameTest(TransactionTestCase):
             VLM_m2m._meta.db_table,
         ]
         sql_list = connection.ops.sql_flush(no_style(), tables, reset_sequences=True)
-        connection.ops.execute_sql_flush(connection.alias, sql_list)
+        connection.ops.execute_sql_flush(sql_list)
 
 
 class SequenceResetTest(TestCase):