diff --git a/debug_find_common.py b/debug_find_common.py
new file mode 100644
index 000000000..be7e13ed1
--- /dev/null
+++ b/debug_find_common.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+
+"""Debug what happens in _find_common when min_lines=0"""
+
+import tempfile
+import os
+from pylint.checkers.similar import SimilarChecker
+
+def debug_find_common():
+    """Debug the _find_common method with min_lines=0"""
+    
+    # Create some duplicate code to test
+    code_with_duplicates = '''
+def func1():
+    print("Hello")
+    print("World")
+    return 42
+
+def func2():
+    print("Hello")
+    print("World")
+    return 42
+'''
+    
+    # Create temporary files with duplicate code
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f1:
+        f1.write(code_with_duplicates)
+        f1.flush()
+        file1 = f1.name
+    
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f2:
+        f2.write(code_with_duplicates)
+        f2.flush()
+        file2 = f2.name
+    
+    try:
+        # Create checker with min-similarity-lines=0 by calling __init__ properly
+        checker = SimilarChecker()
+        checker.min_lines = 0  # Set min_lines directly since we can't easily mock config
+        
+        # Process the files
+        with open(file1, 'r') as f:
+            checker.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker.append_stream(file2, f)
+        
+        # Get the linesets
+        lineset1 = checker.linesets[0]
+        lineset2 = checker.linesets[1]
+        
+        print(f"min_lines: {checker.min_lines}")
+        print(f"lineset1 stripped lines: {len(lineset1.stripped_lines)}")
+        print(f"lineset2 stripped lines: {len(lineset2.stripped_lines)}")
+        
+        # Test hash_lineset directly
+        from pylint.checkers.similar import hash_lineset
+        hash_to_index_1, index_to_lines_1 = hash_lineset(lineset1, checker.min_lines)
+        hash_to_index_2, index_to_lines_2 = hash_lineset(lineset2, checker.min_lines)
+        
+        print(f"hash_to_index_1: {hash_to_index_1}")
+        print(f"hash_to_index_2: {hash_to_index_2}")
+        print(f"hash_to_index_1 keys: {list(hash_to_index_1.keys())}")
+        print(f"hash_to_index_2 keys: {list(hash_to_index_2.keys())}")
+        
+        # Test the intersection
+        hash_1 = frozenset(hash_to_index_1.keys())
+        hash_2 = frozenset(hash_to_index_2.keys())
+        common_hashes = hash_1 & hash_2
+        
+        print(f"hash_1: {hash_1}")
+        print(f"hash_2: {hash_2}")
+        print(f"common_hashes: {common_hashes}")
+        
+        # Now call _find_common and see what it returns
+        similarities = list(checker._find_common(lineset1, lineset2))
+        print(f"Similarities found: {len(similarities)}")
+        for sim in similarities:
+            print(f"  - {sim.cmn_lines_nb} similar lines")
+            
+    finally:
+        # Clean up
+        os.unlink(file1)
+        os.unlink(file2)
+
+if __name__ == "__main__":
+    debug_find_common()
\ No newline at end of file
diff --git a/pylint/checkers/similar.py b/pylint/checkers/similar.py
index c65b1c893..16a30f04f 100644
--- a/pylint/checkers/similar.py
+++ b/pylint/checkers/similar.py
@@ -471,6 +471,9 @@ class Similar:
         Last regroups all successive couples in a bigger one. It allows to take into account common chunk of lines that have more
         than the minimal number of successive lines required.
         """
+        # If min_lines is 0, duplicate code checking is disabled
+        if self.min_lines == 0:
+            return
         hash_to_index_1: HashToIndex_T
         hash_to_index_2: HashToIndex_T
         index_to_lines_1: IndexToLines_T
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..16bd6f198
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+
+"""Script to reproduce the min-similarity-lines=0 issue"""
+
+import tempfile
+import os
+from pylint.checkers.similar import SimilarChecker
+from pylint import config
+
+def test_min_similarity_lines_zero():
+    """Test that min-similarity-lines=0 should disable duplicate code checking"""
+    
+    # Create some duplicate code to test
+    code_with_duplicates = '''
+def func1():
+    print("Hello")
+    print("World")
+    return 42
+
+def func2():
+    print("Hello")
+    print("World")
+    return 42
+'''
+    
+    # Create temporary files with duplicate code
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f1:
+        f1.write(code_with_duplicates)
+        f1.flush()
+        file1 = f1.name
+    
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f2:
+        f2.write(code_with_duplicates)
+        f2.flush()
+        file2 = f2.name
+    
+    try:
+        # Create checker with min-similarity-lines=0
+        checker = SimilarChecker()
+        checker.min_lines = 0  # Set min_lines directly to test the fix
+        
+        # Process the files
+        with open(file1, 'r') as f:
+            checker.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker.append_stream(file2, f)
+        
+        # Check if any similarities are found (should be 0 if disabled)
+        similarities = list(checker._iter_sims())
+        print(f"Found {len(similarities)} similarities with min-similarity-lines=0")
+        
+        if len(similarities) > 0:
+            print("BUG: Similarities found when min-similarity-lines=0 (should be disabled)")
+            for sim in similarities:
+                print(f"  - {sim.cmn_lines_nb} similar lines")
+            return False
+        else:
+            print("OK: No similarities found when min-similarity-lines=0")
+            return True
+            
+    finally:
+        # Clean up
+        os.unlink(file1)
+        os.unlink(file2)
+
+if __name__ == "__main__":
+    test_min_similarity_lines_zero()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..eaaf05dfa
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+
+"""Test edge cases for the min-similarity-lines fix"""
+
+import tempfile
+import os
+from pylint.checkers.similar import SimilarChecker
+
+def test_edge_cases():
+    """Test various edge cases for min-similarity-lines"""
+    
+    # Create some duplicate code to test
+    code_with_duplicates = '''
+def func1():
+    print("Hello")
+    print("World")
+    return 42
+
+def func2():
+    print("Hello")
+    print("World")
+    return 42
+'''
+    
+    # Create temporary files with duplicate code
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f1:
+        f1.write(code_with_duplicates)
+        f1.flush()
+        file1 = f1.name
+    
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f2:
+        f2.write(code_with_duplicates)
+        f2.flush()
+        file2 = f2.name
+    
+    try:
+        # Test case 1: min_lines = 0 (should disable checking)
+        print("Test case 1: min_lines = 0")
+        checker1 = SimilarChecker()
+        checker1.min_lines = 0
+        
+        with open(file1, 'r') as f:
+            checker1.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker1.append_stream(file2, f)
+        
+        similarities1 = list(checker1._iter_sims())
+        print(f"  Found {len(similarities1)} similarities (should be 0)")
+        
+        # Test case 2: min_lines = 1 (should find similarities)
+        print("Test case 2: min_lines = 1")
+        checker2 = SimilarChecker()
+        checker2.min_lines = 1
+        
+        with open(file1, 'r') as f:
+            checker2.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker2.append_stream(file2, f)
+        
+        similarities2 = list(checker2._iter_sims())
+        print(f"  Found {len(similarities2)} similarities (should be > 0)")
+        
+        # Test case 3: min_lines = 10 (should find no similarities since our duplicates are only 8 lines)
+        print("Test case 3: min_lines = 10")
+        checker3 = SimilarChecker()
+        checker3.min_lines = 10
+        
+        with open(file1, 'r') as f:
+            checker3.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker3.append_stream(file2, f)
+        
+        similarities3 = list(checker3._iter_sims())
+        print(f"  Found {len(similarities3)} similarities (should be 0)")
+        
+        # Summary
+        success = (len(similarities1) == 0 and 
+                  len(similarities2) > 0 and 
+                  len(similarities3) == 0)
+        
+        if success:
+            print("SUCCESS: All edge cases passed!")
+            return True
+        else:
+            print("FAIL: Some edge cases failed!")
+            return False
+            
+    finally:
+        # Clean up
+        os.unlink(file1)
+        os.unlink(file2)
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..eb83aefaa
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+
+"""Test the fix for min-similarity-lines=0"""
+
+import tempfile
+import os
+from pylint.checkers.similar import SimilarChecker
+
+def test_fix():
+    """Test that the fix works"""
+    
+    # Create some duplicate code to test
+    code_with_duplicates = '''
+def func1():
+    print("Hello")
+    print("World")
+    return 42
+
+def func2():
+    print("Hello")
+    print("World")
+    return 42
+'''
+    
+    # Create temporary files with duplicate code
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f1:
+        f1.write(code_with_duplicates)
+        f1.flush()
+        file1 = f1.name
+    
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f2:
+        f2.write(code_with_duplicates)
+        f2.flush()
+        file2 = f2.name
+    
+    try:
+        # Create checker with min-similarity-lines=0
+        checker = SimilarChecker()
+        checker.min_lines = 0
+        
+        # Process the files
+        with open(file1, 'r') as f:
+            checker.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker.append_stream(file2, f)
+        
+        # Test _iter_sims directly
+        similarities = list(checker._iter_sims())
+        print(f"_iter_sims found {len(similarities)} similarities")
+        
+        # Test _compute_sims
+        computed_similarities = checker._compute_sims()
+        print(f"_compute_sims found {len(computed_similarities)} similarities")
+        
+        if len(computed_similarities) == 0:
+            print("SUCCESS: Fix works! No similarities found when min_lines=0")
+            return True
+        else:
+            print("FAIL: Similarities still found when min_lines=0")
+            for num, couples in computed_similarities:
+                print(f"  - {num} similar lines in {len(couples)} files")
+            return False
+            
+    finally:
+        # Clean up
+        os.unlink(file1)
+        os.unlink(file2)
+
+if __name__ == "__main__":
+    test_fix()
\ No newline at end of file
diff --git a/test_hash_lineset.py b/test_hash_lineset.py
new file mode 100644
index 000000000..dee0767fa
--- /dev/null
+++ b/test_hash_lineset.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+"""Test what happens when min_common_lines=0 in hash_lineset"""
+
+from pylint.checkers.similar import hash_lineset, LineSet
+
+def test_hash_lineset_zero():
+    """Test hash_lineset with min_common_lines=0"""
+    
+    # Create a simple lineset
+    lines = ["print('hello')", "print('world')"]
+    lineset = LineSet("test.py", lines, False, False, False, False)
+    
+    # Test with min_common_lines=0
+    hash2index, index2lines = hash_lineset(lineset, 0)
+    
+    print(f"hash2index: {hash2index}")
+    print(f"index2lines: {index2lines}")
+    print(f"hash2index keys: {list(hash2index.keys())}")
+    print(f"hash2index values: {list(hash2index.values())}")
+
+if __name__ == "__main__":
+    test_hash_lineset_zero()
\ No newline at end of file
diff --git a/test_normal_functionality.py b/test_normal_functionality.py
new file mode 100644
index 000000000..ffd03f23e
--- /dev/null
+++ b/test_normal_functionality.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+
+"""Test that normal functionality still works with positive min-similarity-lines values"""
+
+import tempfile
+import os
+from pylint.checkers.similar import SimilarChecker
+
+def test_normal_functionality():
+    """Test that duplicate code checking works with positive min-similarity-lines"""
+    
+    # Create some duplicate code to test
+    code_with_duplicates = '''
+def func1():
+    print("Hello")
+    print("World")
+    return 42
+
+def func2():
+    print("Hello")
+    print("World")
+    return 42
+'''
+    
+    # Create temporary files with duplicate code
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f1:
+        f1.write(code_with_duplicates)
+        f1.flush()
+        file1 = f1.name
+    
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f2:
+        f2.write(code_with_duplicates)
+        f2.flush()
+        file2 = f2.name
+    
+    try:
+        # Test with default min-similarity-lines (4)
+        checker = SimilarChecker()
+        checker.min_lines = 4  # Default value
+        
+        # Process the files
+        with open(file1, 'r') as f:
+            checker.append_stream(file1, f)
+        with open(file2, 'r') as f:
+            checker.append_stream(file2, f)
+        
+        # Check if similarities are found (should be found with default value)
+        similarities = list(checker._iter_sims())
+        print(f"With min_lines=4, found {len(similarities)} similarities")
+        
+        if len(similarities) > 0:
+            print("SUCCESS: Normal functionality works - similarities found with min_lines=4")
+            for sim in similarities:
+                print(f"  - {sim.cmn_lines_nb} similar lines")
+            return True
+        else:
+            print("FAIL: No similarities found with min_lines=4 (normal functionality broken)")
+            return False
+            
+    finally:
+        # Clean up
+        os.unlink(file1)
+        os.unlink(file2)
+
+if __name__ == "__main__":
+    test_normal_functionality()
\ No newline at end of file