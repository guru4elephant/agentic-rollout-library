diff --git a/debug_dot_issue.py b/debug_dot_issue.py
new file mode 100644
index 00000000..d99b5a98
--- /dev/null
+++ b/debug_dot_issue.py
@@ -0,0 +1,26 @@
+import numpy as np
+import xarray as xr
+
+# Test the dot product behavior with boolean arrays
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))
+mask = dta.notnull()
+
+print("Mask:", mask.values)
+print("Weights:", wgt.values)
+print("Mask dtype:", mask.dtype)
+print("Weights dtype:", wgt.dtype)
+
+# Test dot product directly
+dot_result = xr.dot(mask, wgt)
+print("Dot result:", dot_result.values)
+print("Dot result dtype:", dot_result.dtype)
+
+# Test dot product with converted weights
+wgt_numeric = wgt * 1
+print("Numeric weights:", wgt_numeric.values)
+print("Numeric weights dtype:", wgt_numeric.dtype)
+
+dot_result_numeric = xr.dot(mask, wgt_numeric)
+print("Numeric dot result:", dot_result_numeric.values)
+print("Numeric dot result dtype:", dot_result_numeric.dtype)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..086b0fab
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+import numpy as np
+import xarray as xr
+
+# Reproduce the issue from the GitHub issue
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=np.bool))
+
+print("Data array:", dta.values)
+print("Weights array:", wgt.values)
+print("Weights dtype:", wgt.dtype)
+
+result = dta.weighted(wgt).mean()
+print("Weighted mean result:", result.values)
+
+# Expected result should be 1.0
+expected = 1.0
+print("Expected result:", expected)
+print("Result matches expected:", np.isclose(result.values, expected))
+
+# Let's also check what the sum_of_weights returns
+sum_of_weights = dta.weighted(wgt).sum_of_weights()
+print("Sum of weights:", sum_of_weights.values)
+print("Sum of weights dtype:", sum_of_weights.dtype)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..85156934
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,48 @@
+import numpy as np
+import xarray as xr
+
+print("Testing edge cases for boolean weights fix:")
+
+# Test 1: Original issue case
+print("\n1. Original issue case:")
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: 1.0")
+
+# Test 2: All weights True
+print("\n2. All weights True:")
+dta = xr.DataArray([1., 2., 3.])
+wgt = xr.DataArray(np.array([1, 1, 1], dtype=bool))
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: 2.0")
+
+# Test 3: All weights False
+print("\n3. All weights False:")
+dta = xr.DataArray([1., 2., 3.])
+wgt = xr.DataArray(np.array([0, 0, 0], dtype=bool))
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: nan (should be handled by existing logic)")
+
+# Test 4: Mixed numeric and boolean weights
+print("\n4. Numeric weights (should work as before):")
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray([1, 1, 0])
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: 1.0")
+
+# Test 5: Float weights (should work as before)
+print("\n5. Float weights (should work as before):")
+dta = xr.DataArray([1., 1., 1.])
+wgt = xr.DataArray([1.0, 1.0, 0.0])
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: 1.0")
+
+# Test 6: With NaN values in data
+print("\n6. With NaN values in data:")
+dta = xr.DataArray([1., np.nan, 1.])
+wgt = xr.DataArray(np.array([1, 1, 0], dtype=bool))
+result = dta.weighted(wgt).mean()
+print(f"Result: {result.values}, Expected: 1.0")
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/xarray/core/weighted.py b/xarray/core/weighted.py
index 996d2e4c..6fdfeb9f 100644
--- a/xarray/core/weighted.py
+++ b/xarray/core/weighted.py
@@ -141,8 +141,13 @@ class Weighted:
 
         # we need to mask data values that are nan; else the weights are wrong
         mask = da.notnull()
+        
+        # Convert boolean weights to numeric type to avoid boolean dot product results
+        weights = self.weights
+        if weights.dtype == bool:
+            weights = weights * 1
 
-        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)
+        sum_of_weights = self._reduce(mask, weights, dim=dim, skipna=False)
 
         # 0-weights are not valid
         valid_weights = sum_of_weights != 0.0