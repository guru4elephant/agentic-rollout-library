diff --git a/classes.dot b/classes.dot
new file mode 100644
index 000000000..b9fbf89ba
--- /dev/null
+++ b/classes.dot
@@ -0,0 +1,5 @@
+digraph "classes" {
+charset="utf-8"
+rankdir=BT
+"0" [label="{C|a : NoneType\l|}", shape="record"];
+}
diff --git a/debug_assignattr.py b/debug_assignattr.py
new file mode 100644
index 000000000..4c8a39b05
--- /dev/null
+++ b/debug_assignattr.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""Script to debug AssignAttr node information."""
+
+import astroid
+from pylint.pyreverse.inspector import Linker
+
+code = """
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+"""
+
+# Parse the code
+module = astroid.parse(code)
+
+# Create a linker and process the module
+linker = Linker(None, inherited_interfaces=0, tag=False)
+linker.visit(module)
+
+# Check the class node
+class_node = module.body[0]
+
+# Find the AssignAttr node
+for attr_name, assignattrs in class_node.instance_attrs.items():
+    print(f"Attribute: {attr_name}")
+    for assignattr in assignattrs:
+        print(f"  AssignAttr: {assignattr}")
+        print(f"  AssignAttr type: {type(assignattr)}")
+        print(f"  AssignAttr parent: {assignattr.parent}")
+        print(f"  AssignAttr frame: {assignattr.frame()}")
+        print(f"  AssignAttr expr: {assignattr.expr}")
+        print(f"  AssignAttr attrname: {assignattr.attrname}")
+        
+        # Check if this is an assignment from a function parameter
+        if (isinstance(assignattr.parent, astroid.node_classes.Assign) and 
+            isinstance(assignattr.parent.value, astroid.node_classes.Name)):
+            param_name = assignattr.parent.value.name
+            print(f"  Assignment from parameter: {param_name}")
+            
+            # Find the function parameter
+            method_node = assignattr.frame()
+            if isinstance(method_node, astroid.node_classes.FunctionDef):
+                for i, arg in enumerate(method_node.args.args):
+                    if arg.name == param_name:
+                        print(f"    Found parameter: {arg.name}")
+                        # Check for type annotation
+                        if hasattr(method_node.args, 'annotations') and i < len(method_node.args.annotations):
+                            annotation = method_node.args.annotations[i]
+                            print(f"    Parameter annotation: {annotation}")
+                            if annotation is not None:
+                                try:
+                                    inferred = list(annotation.infer())
+                                    print(f"    Annotation inferred: {inferred}")
+                                except Exception as e:
+                                    print(f"    Annotation inference error: {e}")
\ No newline at end of file
diff --git a/debug_assignment.py b/debug_assignment.py
new file mode 100644
index 000000000..22e04db51
--- /dev/null
+++ b/debug_assignment.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Script to debug assignment relationships."""
+
+import astroid
+
+code = """
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+"""
+
+# Parse the code
+module = astroid.parse(code)
+
+# Find the class and method
+class_node = module.body[0]
+method_node = class_node.body[0]
+
+# Find the assignment statement
+assignment = method_node.body[0]
+print("Assignment:", assignment)
+print("Assignment targets:", assignment.targets)
+print("Assignment value:", assignment.value)
+
+# Check if the value is a Name node that refers to a function parameter
+if isinstance(assignment.value, astroid.node_classes.Name):
+    print("Value is a Name node:", assignment.value.name)
+    # Find the function parameter
+    for arg in method_node.args.args:
+        if arg.name == assignment.value.name:
+            print(f"Found parameter: {arg.name}")
+            # Check for type annotation
+            if hasattr(method_node.args, 'annotations'):
+                param_index = method_node.args.args.index(arg)
+                if param_index < len(method_node.args.annotations):
+                    annotation = method_node.args.annotations[param_index]
+                    print(f"Parameter annotation: {annotation}")
+                    if annotation is not None:
+                        try:
+                            inferred = list(annotation.infer())
+                            print(f"Annotation inferred: {inferred}")
+                        except Exception as e:
+                            print(f"Annotation inference error: {e}")
\ No newline at end of file
diff --git a/debug_astroid.py b/debug_astroid.py
new file mode 100644
index 000000000..3a0e9e261
--- /dev/null
+++ b/debug_astroid.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+"""Script to debug astroid parsing of type hints."""
+
+import astroid
+
+code = """
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+"""
+
+# Parse the code
+module = astroid.parse(code)
+
+# Find the class and method
+class_node = module.body[0]
+method_node = class_node.body[0]
+
+print("Class:", class_node.name)
+print("Method:", method_node.name)
+
+# Check function arguments
+print("Function args:", method_node.args)
+print("Args annotations:", getattr(method_node.args, 'annotations', None))
+print("Posonlyargs annotations:", getattr(method_node.args, 'posonlyargs_annotations', None))
+print("Kwonlyargs annotations:", getattr(method_node.args, 'kwonlyargs_annotations', None))
+
+for i, arg in enumerate(method_node.args.args):
+    print(f"Argument {i}: {arg.name}")
+    # Check if this argument has an annotation
+    if hasattr(method_node.args, 'annotations') and i < len(method_node.args.annotations):
+        annotation = method_node.args.annotations[i]
+        print(f"  Annotation: {annotation}")
+        print(f"  Annotation type: {type(annotation)}")
+        if annotation is not None:
+            try:
+                print(f"  Annotation inferred: {list(annotation.infer())}")
+            except Exception as e:
+                print(f"  Annotation inference error: {e}")
+    else:
+        print(f"  No annotation found")
+    if arg.name in method_node.locals:
+        print(f"  Local type: {method_node.locals[arg.name]}")
+
+# Check default values
+if method_node.args.defaults:
+    for i, default in enumerate(method_node.args.defaults):
+        arg_name = method_node.args.args[i + 1].name  # +1 to skip self
+        print(f"Default for {arg_name}: {default}")
+        print(f"Default inferred: {list(default.infer())}")
+
+# Check instance attributes
+print("\nInstance attributes:")
+for attr_name, attr_nodes in class_node.instance_attrs.items():
+    print(f"  {attr_name}: {attr_nodes}")
+    for attr_node in attr_nodes:
+        print(f"    Type: {type(attr_node)}")
+        try:
+            inferred = list(attr_node.infer())
+            print(f"    Inferred: {inferred}")
+        except Exception as e:
+            print(f"    Inference error: {e}")
\ No newline at end of file
diff --git a/debug_flow.py b/debug_flow.py
new file mode 100644
index 000000000..85c1206b0
--- /dev/null
+++ b/debug_flow.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+"""Script to debug the flow of type information in pyreverse."""
+
+import astroid
+from pylint.pyreverse.inspector import Linker
+
+code = """
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+"""
+
+# Parse the code
+module = astroid.parse(code)
+
+# Create a linker and process the module
+linker = Linker(None, inherited_interfaces=0, tag=False)
+linker.visit(module)
+
+# Check the class node
+class_node = module.body[0]
+print("Class:", class_node.name)
+print("Instance attrs type:", class_node.instance_attrs_type)
+print("Locals type:", class_node.locals_type)
+
+# Check the method node
+method_node = class_node.body[0]
+print("Method:", method_node.name)
+print("Method locals type:", method_node.locals_type)
+
+# Check function arguments
+print("Function args annotations:", method_node.args.annotations)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..68f0c0818
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,11 @@
+#!/usr/bin/env python3
+"""Script to reproduce the pyreverse type hints issue."""
+
+class C(object):
+    def __init__(self, a: str = None):
+        self.a = a
+
+if __name__ == "__main__":
+    # Create a simple test case
+    c = C("test")
+    print(f"c.a = {c.a}")
\ No newline at end of file