diff --git a/debug_filterable.py b/debug_filterable.py
new file mode 100644
index 0000000000..7c69f88b70
--- /dev/null
+++ b/debug_filterable.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils import timezone
+
+# Create the models from the issue
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+    
+    class Meta:
+        app_label = "testapp"
+        verbose_name = "product meta data type"
+        verbose_name_plural = "product meta data types"
+    
+    def __str__(self):
+        return self.label
+
+# Create a model instance
+brand_metadata = ProductMetaDataType(label="Brand", filterable=False)
+
+# Debug the filterable attribute
+print(f"Has filterable attribute: {hasattr(brand_metadata, 'filterable')}")
+print(f"Filterable value: {getattr(brand_metadata, 'filterable', 'NOT FOUND')}")
+print(f"Filterable type: {type(getattr(brand_metadata, 'filterable', None))}")
+print(f"Is filterable False: {getattr(brand_metadata, 'filterable', True) == False}")
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ce18098fd2..2e6a4fe00f 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1124,7 +1124,8 @@ class Query(BaseExpression):
 
     def check_filterable(self, expression):
         """Raise an error if expression cannot be used in a WHERE clause."""
-        if not getattr(expression, 'filterable', True):
+        # Only check filterable attribute on BaseExpression instances
+        if isinstance(expression, BaseExpression) and not expression.filterable:
             raise NotSupportedError(
                 expression.__class__.__name__ + ' is disallowed in the filter '
                 'clause.'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5c13b7bb07
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils import timezone
+
+# Create the models from the issue
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+    
+    class Meta:
+        app_label = "testapp"
+        verbose_name = "product meta data type"
+        verbose_name_plural = "product meta data types"
+    
+    def __str__(self):
+        return self.label
+
+class Product(models.Model):
+    name = models.CharField(max_length=255)
+    
+    class Meta:
+        app_label = "testapp"
+
+class ProductMetaData(models.Model):
+    product = models.ForeignKey(Product, null=False, blank=False, on_delete=models.CASCADE)
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE)
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    
+    class Meta:
+        app_label = "testapp"
+        verbose_name = "product meta data"
+        verbose_name_plural = "product meta datas"
+
+# Try to reproduce the issue without creating database tables
+try:
+    # Create a model instance (this simulates the issue without DB setup)
+    brand_metadata = ProductMetaDataType(label="Brand", filterable=False)
+    
+    # This should trigger the error when trying to build the query
+    from django.db.models.sql.query import Query
+    query = Query(ProductMetaData)
+    query.build_filter(('metadata_type', brand_metadata))
+    print("SUCCESS: No error occurred!")
+    
+except Exception as e:
+    print(f"ERROR: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..106b239ba9
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,113 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils import timezone
+from django.db.models.expressions import BaseExpression
+
+# Test 1: Model with filterable field (original issue)
+class TestModel1(models.Model):
+    name = models.CharField(max_length=255)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "testapp"
+
+# Test 2: Model with filterable field set to True
+class TestModel2(models.Model):
+    name = models.CharField(max_length=255)
+    filterable = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = "testapp"
+
+# Test 3: Model without filterable field
+class TestModel3(models.Model):
+    name = models.CharField(max_length=255)
+    other_field = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "testapp"
+
+# Test 4: Test with actual expressions
+from django.db.models import F, Value
+
+print("Testing various scenarios...")
+
+# Test 1: Model instance with filterable=False field
+try:
+    instance1 = TestModel1(name="Test", filterable=False)
+    from django.db.models.sql.query import Query
+    query = Query(TestModel1)
+    query.build_filter(('name', instance1))
+    print("✓ Test 1 PASSED: Model with filterable=False field works")
+except Exception as e:
+    print(f"✗ Test 1 FAILED: {e}")
+
+# Test 2: Model instance with filterable=True field  
+try:
+    instance2 = TestModel2(name="Test", filterable=True)
+    query = Query(TestModel2)
+    query.build_filter(('name', instance2))
+    print("✓ Test 2 PASSED: Model with filterable=True field works")
+except Exception as e:
+    print(f"✗ Test 2 FAILED: {e}")
+
+# Test 3: Model instance without filterable field
+try:
+    instance3 = TestModel3(name="Test", other_field=False)
+    query = Query(TestModel3)
+    query.build_filter(('name', instance3))
+    print("✓ Test 3 PASSED: Model without filterable field works")
+except Exception as e:
+    print(f"✗ Test 3 FAILED: {e}")
+
+# Test 4: Regular expressions should still work
+try:
+    query = Query(TestModel1)
+    # This should work - F expressions are filterable
+    query.build_filter(('name', F('name')))
+    print("✓ Test 4 PASSED: F expressions work")
+except Exception as e:
+    print(f"✗ Test 4 FAILED: {e}")
+
+# Test 5: Test that non-filterable expressions still raise errors
+try:
+    from django.db.models.expressions import RawSQL
+    # Create a non-filterable expression
+    class NonFilterableExpression(BaseExpression):
+        filterable = False
+        
+    non_filterable = NonFilterableExpression()
+    query = Query(TestModel1)
+    query.build_filter(('name', non_filterable))
+    print("✗ Test 5 FAILED: Non-filterable expression should have raised error")
+except Exception as e:
+    if "disallowed in the filter clause" in str(e):
+        print("✓ Test 5 PASSED: Non-filterable expressions properly raise error")
+    else:
+        print(f"✗ Test 5 FAILED: Unexpected error: {e}")
+
+print("All tests completed!")
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..de046cfea5
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import F, Q
+from django.db.models.expressions import BaseExpression
+
+# Test basic model functionality
+class TestModel(models.Model):
+    name = models.CharField(max_length=255)
+    age = models.IntegerField()
+    
+    class Meta:
+        app_label = "testapp"
+
+# Test 1: Basic filtering still works
+try:
+    from django.db.models.sql.query import Query
+    query = Query(TestModel)
+    # Basic filter with value
+    query.build_filter(('name', 'test'))
+    print("✓ Basic filtering with string value works")
+except Exception as e:
+    print(f"✗ Basic filtering failed: {e}")
+
+# Test 2: F expressions still work
+try:
+    query = Query(TestModel)
+    query.build_filter(('age', F('age')))
+    print("✓ F expressions work")
+except Exception as e:
+    print(f"✗ F expressions failed: {e}")
+
+# Test 3: Q objects still work  
+try:
+    query = Query(TestModel)
+    q_obj = Q(name='test')
+    query.build_filter(q_obj)
+    print("✓ Q objects work")
+except Exception as e:
+    print(f"✗ Q objects failed: {e}")
+
+# Test 4: Test with actual non-filterable expressions
+try:
+    # Create a non-filterable expression
+    class NonFilterableExpression(BaseExpression):
+        filterable = False
+        
+    non_filterable = NonFilterableExpression()
+    query = Query(TestModel)
+    query.build_filter(('name', non_filterable))
+    print("✗ Non-filterable expression should have raised error")
+except Exception as e:
+    if "disallowed in the filter clause" in str(e):
+        print("✓ Non-filterable expressions properly raise error")
+    else:
+        print(f"✗ Unexpected error with non-filterable: {e}")
+
+print("All existing functionality tests completed!")
\ No newline at end of file