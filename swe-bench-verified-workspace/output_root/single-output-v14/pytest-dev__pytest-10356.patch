diff --git a/debug_marks.py b/debug_marks.py
new file mode 100644
index 000000000..daf15b5ff
--- /dev/null
+++ b/debug_marks.py
@@ -0,0 +1,25 @@
+import pytest
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        pass
+
+# Let's see what happens during collection
+print("Foo pytestmark:", getattr(Foo, 'pytestmark', []))
+print("Bar pytestmark:", getattr(Bar, 'pytestmark', []))
+print("TestDings pytestmark:", getattr(TestDings, 'pytestmark', []))
+
+# Now let's see what get_unpacked_marks returns
+from _pytest.mark.structures import get_unpacked_marks
+
+print("Foo get_unpacked_marks:", list(get_unpacked_marks(Foo)))
+print("Bar get_unpacked_marks:", list(get_unpacked_marks(Bar)))
+print("TestDings get_unpacked_marks:", list(get_unpacked_marks(TestDings)))
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..1c2099896
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,52 @@
+import itertools
+import pytest
+
+class BaseMeta(type):
+    @property
+    def pytestmark(self):
+        return (
+            getattr(self, "_pytestmark", []) +
+            list(itertools.chain.from_iterable(getattr(x, "_pytestmark", []) for x in self.__mro__))
+        )
+
+    @pytestmark.setter
+    def pytestmark(self, value):
+        self._pytestmark = value
+
+
+class Base(object):
+    # Without this metaclass, foo and bar markers override each other, and test_dings
+    # will only have one marker
+    # With the metaclass, test_dings will have both
+    __metaclass__ = BaseMeta
+
+@pytest.mark.foo
+class Foo(Base):
+    pass
+
+
+@pytest.mark.bar
+class Bar(Base):
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both markers, foo and bar.
+        # In practice markers are resolved using MRO (so foo wins), unless the
+        # metaclass is applied
+        pass
+
+if __name__ == "__main__":
+    # Check what markers are applied to the test
+    test_obj = TestDings()
+    test_method = test_obj.test_dings
+    
+    # Get markers using pytest's internal mechanism
+    print("TestDings MRO:", TestDings.__mro__)
+    print("TestDings pytestmark:", getattr(TestDings, 'pytestmark', []))
+    print("Foo pytestmark:", getattr(Foo, 'pytestmark', []))
+    print("Bar pytestmark:", getattr(Bar, 'pytestmark', []))
+    
+    # Let's also try to run pytest to see what happens
+    import sys
+    sys.exit(pytest.main([__file__, "-v"]))
\ No newline at end of file
diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py
index 800a25c92..ec657053e 100644
--- a/src/_pytest/mark/structures.py
+++ b/src/_pytest/mark/structures.py
@@ -360,7 +360,25 @@ def get_unpacked_marks(obj: object) -> Iterable[Mark]:
     mark_list = getattr(obj, "pytestmark", [])
     if not isinstance(mark_list, list):
         mark_list = [mark_list]
-    return normalize_mark_list(mark_list)
+    
+    # For classes, also collect marks from parent classes in MRO order
+    if isinstance(obj, type):
+        # Traverse MRO (Method Resolution Order) to collect marks from all parent classes
+        for base_cls in obj.__mro__[1:]:  # Skip the class itself (first in MRO)
+            base_marks = getattr(base_cls, "pytestmark", [])
+            if not isinstance(base_marks, list):
+                base_marks = [base_marks]
+            mark_list.extend(base_marks)
+    
+    # Deduplicate marks by name, keeping the first occurrence (following MRO order)
+    seen_names = set()
+    deduplicated_marks = []
+    for mark in normalize_mark_list(mark_list):
+        if mark.name not in seen_names:
+            seen_names.add(mark.name)
+            deduplicated_marks.append(mark)
+    
+    return deduplicated_marks
 
 
 def normalize_mark_list(
diff --git a/test_markers.py b/test_markers.py
new file mode 100644
index 000000000..bbbf0a1ef
--- /dev/null
+++ b/test_markers.py
@@ -0,0 +1,31 @@
+import pytest
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both foo and bar markers
+        pass
+
+def test_show_markers():
+    # Collect the test item and check its markers
+    import _pytest.python
+    from _pytest.mark.structures import get_unpacked_marks
+    
+    # Create a test item
+    test_obj = TestDings()
+    test_method = test_obj.test_dings
+    
+    print("TestDings MRO:", TestDings.__mro__)
+    print("TestDings pytestmark:", getattr(TestDings, 'pytestmark', []))
+    print("TestDings get_unpacked_marks:", list(get_unpacked_marks(TestDings)))
+    
+    # Let's also check what happens during pytest collection
+    import sys
+    sys.exit(pytest.main([__file__, '-v', '--collect-only']))
\ No newline at end of file
diff --git a/test_mro_fix.py b/test_mro_fix.py
new file mode 100644
index 000000000..fab3c6075
--- /dev/null
+++ b/test_mro_fix.py
@@ -0,0 +1,99 @@
+import pytest
+
+# Test case 1: Basic multiple inheritance
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestBasic(Foo, Bar):
+    def test_basic(self):
+        pass
+
+# Test case 2: Deep inheritance chain
+@pytest.mark.a
+class A:
+    pass
+
+@pytest.mark.b
+class B(A):
+    pass
+
+@pytest.mark.c
+class C(B):
+    pass
+
+class TestDeep(C):
+    def test_deep(self):
+        pass
+
+# Test case 3: Diamond inheritance
+@pytest.mark.base
+class Base:
+    pass
+
+@pytest.mark.left
+class Left(Base):
+    pass
+
+@pytest.mark.right
+class Right(Base):
+    pass
+
+class TestDiamond(Left, Right):
+    def test_diamond(self):
+        pass
+
+# Test case 4: Overriding markers (should use the first one in MRO)
+@pytest.mark.original
+class Original:
+    pass
+
+@pytest.mark.override
+class Override(Original):
+    pass
+
+class TestOverride(Override):
+    def test_override(self):
+        pass
+
+def test_marker_inheritance():
+    """Test that markers are correctly inherited through MRO"""
+    from _pytest.mark.structures import get_unpacked_marks
+    
+    # Test basic multiple inheritance
+    basic_marks = list(get_unpacked_marks(TestBasic))
+    basic_mark_names = {m.name for m in basic_marks}
+    assert 'foo' in basic_mark_names
+    assert 'bar' in basic_mark_names
+    assert len(basic_marks) == 2  # Should have exactly 2 marks
+    
+    # Test deep inheritance
+    deep_marks = list(get_unpacked_marks(TestDeep))
+    deep_mark_names = {m.name for m in deep_marks}
+    assert 'a' in deep_mark_names
+    assert 'b' in deep_mark_names
+    assert 'c' in deep_mark_names
+    assert len(deep_marks) == 3  # Should have exactly 3 marks
+    
+    # Test diamond inheritance
+    diamond_marks = list(get_unpacked_marks(TestDiamond))
+    diamond_mark_names = {m.name for m in diamond_marks}
+    assert 'base' in diamond_mark_names
+    assert 'left' in diamond_mark_names
+    assert 'right' in diamond_mark_names
+    assert len(diamond_marks) == 3  # Should have exactly 3 marks
+    
+    # Test marker override (should use first occurrence in MRO)
+    override_marks = list(get_unpacked_marks(TestOverride))
+    override_mark_names = {m.name for m in override_marks}
+    assert 'override' in override_mark_names  # Should use the closest one
+    assert 'original' not in override_mark_names  # Should be overridden
+    assert len(override_marks) == 1  # Should have exactly 1 mark
+
+if __name__ == "__main__":
+    test_marker_inheritance()
+    print("All tests passed!")
\ No newline at end of file