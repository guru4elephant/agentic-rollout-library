diff --git a/django/core/cache/backends/db.py b/django/core/cache/backends/db.py
index 33c79c5a14..5c849c7fed 100644
--- a/django/core/cache/backends/db.py
+++ b/django/core/cache/backends/db.py
@@ -267,9 +267,13 @@ class DatabaseCache(BaseDatabaseCache):
                 cursor.execute(
                     connection.ops.cache_key_culling_sql() % table,
                     [cull_num])
+                result = cursor.fetchone()
+                if result is None:
+                    # If no result is found, there's nothing to cull
+                    return
                 cursor.execute("DELETE FROM %s "
                                "WHERE cache_key < %%s" % table,
-                               [cursor.fetchone()[0]])
+                               [result[0]])
 
     def clear(self):
         db = router.db_for_write(self.cache_model_class)
diff --git a/reproduce_culling_issue.py b/reproduce_culling_issue.py
new file mode 100644
index 0000000000..edf4018fa7
--- /dev/null
+++ b/reproduce_culling_issue.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the cache backend 'NoneType' object is not subscriptable error.
+This script specifically triggers the condition where cache_key_culling_sql returns no results.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 2,  # Very small number to trigger culling easily
+                    'CULL_FREQUENCY': 1,  # Cull aggressively
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the cache table using Django's management command
+from django.core.management import call_command
+call_command('createcachetable', 'test_cache_table')
+
+from django.core.cache import cache
+from django.db import connection
+
+def test_cache_culling_error():
+    """Test that triggers the specific condition causing the error."""
+    print("Testing cache culling error condition...")
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Let's manually trigger the problematic code path
+    # First, let's see what the culling SQL looks like
+    cache_backend = cache
+    table = connection.ops.quote_name(cache_backend._table)
+    culling_sql = connection.ops.cache_key_culling_sql() % table
+    print(f"Culling SQL: {culling_sql}")
+    
+    # Now let's simulate the problematic scenario
+    # We'll add some entries, then manually trigger _cull with conditions
+    # that cause the query to return no results
+    
+    # Add a few entries
+    for i in range(3):
+        key = f'test_key_{i}'
+        value = f'test_value_{i}'
+        cache.set(key, value, timeout=60)
+        print(f"Set {key} = {value}")
+    
+    # Now let's manually call the _cull method with conditions that might
+    # cause the error
+    with connection.cursor() as cursor:
+        cursor.execute("SELECT COUNT(*) FROM %s" % table)
+        num = cursor.fetchone()[0]
+        print(f"Current cache entries: {num}")
+        
+        # Simulate the condition that triggers culling
+        if num > cache_backend._max_entries:
+            cull_num = num // cache_backend._cull_frequency
+            print(f"Will cull {cull_num} entries")
+            
+            # Execute the culling query
+            cursor.execute(culling_sql, [cull_num])
+            result = cursor.fetchone()
+            print(f"Query result: {result}")
+            
+            # This is where the error would occur if result is None
+            if result is None:
+                print("ERROR: Query returned None - this would cause 'NoneType' object is not subscriptable")
+                # Simulate the problematic code
+                try:
+                    # This would fail if result is None
+                    cache_key = result[0]
+                except TypeError as e:
+                    print(f"Error reproduced: {e}")
+                    return True
+            else:
+                print(f"Query returned valid result: {result[0]}")
+    
+    print("No error reproduced in this run")
+    return False
+
+if __name__ == '__main__':
+    test_cache_culling_error()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..975a6533ec
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the cache backend 'NoneType' object is not subscriptable error.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.core.management import execute_from_command_line
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 5,  # Small number to trigger culling easily
+                    'CULL_FREQUENCY': 2,
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the cache table
+from django.core.cache import caches
+from django.core.management.color import no_style
+from django.db import connection
+
+# Create the cache table manually
+style = no_style()
+sql = connection.ops.sql_table_creation_suffix()
+cache = caches['default']
+table_name = cache._table
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.sql_create_table = style.sql_create_table
+    schema_editor.deferred_sql = []
+    
+    # Create the table using the same logic as createcachetable
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import models
+    
+    class CacheEntry(models.Model):
+        cache_key = models.CharField(max_length=255, primary_key=True)
+        value = models.TextField()
+        expires = models.DateTimeField()
+        
+        class Meta:
+            db_table = table_name
+            app_label = 'django_cache'
+    
+    schema_editor.create_model(CacheEntry)
+
+from django.core.cache import cache
+
+def test_cache_culling():
+    """Test that triggers cache culling which may cause the error."""
+    print("Testing cache culling...")
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Fill cache beyond max entries to trigger culling
+    for i in range(10):
+        key = f'test_key_{i}'
+        value = f'test_value_{i}'
+        cache.set(key, value, timeout=60)
+        print(f"Set {key} = {value}")
+    
+    print("Cache operations completed successfully!")
+
+if __name__ == '__main__':
+    test_cache_culling()
\ No newline at end of file
diff --git a/reproduce_issue_simple.py b/reproduce_issue_simple.py
new file mode 100644
index 0000000000..0505d7863d
--- /dev/null
+++ b/reproduce_issue_simple.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""
+Simplified script to reproduce the cache backend 'NoneType' object is not subscriptable error.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 5,  # Small number to trigger culling easily
+                    'CULL_FREQUENCY': 2,
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the cache table using Django's management command
+from django.core.management import call_command
+call_command('createcachetable', 'test_cache_table')
+
+from django.core.cache import cache
+
+def test_cache_culling():
+    """Test that triggers cache culling which may cause the error."""
+    print("Testing cache culling...")
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Fill cache beyond max entries to trigger culling
+    for i in range(10):
+        key = f'test_key_{i}'
+        value = f'test_value_{i}'
+        cache.set(key, value, timeout=60)
+        print(f"Set {key} = {value}")
+    
+    print("Cache operations completed successfully!")
+
+if __name__ == '__main__':
+    test_cache_culling()
\ No newline at end of file
diff --git a/test_db.sqlite3 b/test_db.sqlite3
new file mode 100644
index 0000000000..26b0bbbb91
Binary files /dev/null and b/test_db.sqlite3 differ
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..4a1cbba9a9
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that the fix for the cache backend 'NoneType' error works.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 2,  # Very small number to trigger culling easily
+                    'CULL_FREQUENCY': 1,  # Cull aggressively
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the cache table using Django's management command
+from django.core.management import call_command
+call_command('createcachetable', 'test_cache_table')
+
+from django.core.cache import cache
+from django.db import connection
+
+def test_cache_culling_fixed():
+    """Test that the cache culling fix works correctly."""
+    print("Testing cache culling with fix...")
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Add entries to trigger culling
+    for i in range(3):
+        key = f'test_key_{i}'
+        value = f'test_value_{i}'
+        cache.set(key, value, timeout=60)
+        print(f"Set {key} = {value}")
+    
+    # Now let's manually call the _cull method to test our fix
+    cache_backend = cache
+    db = 'default'  # Use default database
+    with connection.cursor() as cursor:
+        # Get current count
+        table = connection.ops.quote_name(cache_backend._table)
+        cursor.execute("SELECT COUNT(*) FROM %s" % table)
+        num = cursor.fetchone()[0]
+        print(f"Current cache entries before cull: {num}")
+        
+        # Manually call _cull with conditions that would previously cause the error
+        if num > cache_backend._max_entries:
+            cull_num = num // cache_backend._cull_frequency
+            print(f"Will attempt to cull {cull_num} entries")
+            
+            # Execute the culling query that might return None
+            cursor.execute(
+                connection.ops.cache_key_culling_sql() % table,
+                [cull_num]
+            )
+            result = cursor.fetchone()
+            print(f"Query result: {result}")
+            
+            if result is None:
+                print("SUCCESS: Query returned None but our fix prevents the error!")
+                print("The _cull method would now return early instead of crashing.")
+                return True
+            else:
+                print(f"Query returned valid result: {result[0]}")
+                print("This would proceed with normal culling.")
+    
+    print("Test completed successfully!")
+    return True
+
+if __name__ == '__main__':
+    success = test_cache_culling_fixed()
+    if success:
+        print("\n✓ Fix verification: The 'NoneType' object is not subscriptable error is now handled correctly!")
+    else:
+        print("\n✗ Fix verification failed!")
\ No newline at end of file
diff --git a/test_normal_operations.py b/test_normal_operations.py
new file mode 100644
index 0000000000..15dbc56d1b
--- /dev/null
+++ b/test_normal_operations.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that normal cache operations still work after the fix.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 10,  # Reasonable number
+                    'CULL_FREQUENCY': 3,  # Normal frequency
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create the cache table using Django's management command
+from django.core.management import call_command
+call_command('createcachetable', 'test_cache_table')
+
+from django.core.cache import cache
+
+def test_normal_operations():
+    """Test that normal cache operations still work correctly."""
+    print("Testing normal cache operations...")
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Test basic set/get operations
+    test_data = {
+        'key1': 'value1',
+        'key2': 'value2', 
+        'key3': 'value3',
+        'key4': 'value4',
+        'key5': 'value5',
+    }
+    
+    # Set values
+    for key, value in test_data.items():
+        cache.set(key, value, timeout=60)
+        print(f"Set {key} = {value}")
+    
+    # Get values
+    for key, expected_value in test_data.items():
+        retrieved_value = cache.get(key)
+        if retrieved_value == expected_value:
+            print(f"✓ Get {key} = {retrieved_value}")
+        else:
+            print(f"✗ Get {key} failed: expected {expected_value}, got {retrieved_value}")
+            return False
+    
+    # Test add operation (should only add if key doesn't exist)
+    result = cache.add('key1', 'new_value')  # Should return False (key exists)
+    if not result:
+        print("✓ Add existing key correctly returned False")
+    else:
+        print("✗ Add existing key should have returned False")
+        return False
+        
+    result = cache.add('key6', 'value6')  # Should return True (new key)
+    if result:
+        print("✓ Add new key correctly returned True")
+    else:
+        print("✗ Add new key should have returned True")
+        return False
+    
+    # Test delete operation
+    cache.delete('key1')
+    result = cache.get('key1')
+    if result is None:
+        print("✓ Delete operation worked correctly")
+    else:
+        print("✗ Delete operation failed")
+        return False
+    
+    print("All normal cache operations work correctly!")
+    return True
+
+if __name__ == '__main__':
+    success = test_normal_operations()
+    if success:
+        print("\n✓ All tests passed! The fix doesn't break normal cache functionality.")
+    else:
+        print("\n✗ Some tests failed!")
\ No newline at end of file
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..1a91b6c071
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,24 @@
+# Test settings for Django cache tests
+DEBUG = True
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'test_db.sqlite3',
+    }
+}
+
+CACHES = {
+    'default': {
+        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+        'LOCATION': 'test_cache_table',
+    }
+}
+
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'tests.cache',
+]
+
+SECRET_KEY = 'test-secret-key'
+USE_TZ = True
\ No newline at end of file