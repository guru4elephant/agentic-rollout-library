diff --git a/debug_is_zero.py b/debug_is_zero.py
new file mode 100644
index 0000000000..dfa7317350
--- /dev/null
+++ b/debug_is_zero.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy import I, S
+
+# Test the expression components
+e = -2*I + (1 + I)**2
+arg1 = (1 + I)**2
+arg2 = -2*I
+
+print("Testing arg1:", arg1)
+print("arg1.is_real:", arg1.is_real)
+print("arg1.is_imaginary:", arg1.is_imaginary)
+print("(S.ImaginaryUnit * arg1):", S.ImaginaryUnit * arg1)
+print("(S.ImaginaryUnit * arg1).is_real:", (S.ImaginaryUnit * arg1).is_real)
+print("arg1.is_zero:", arg1.is_zero)
+
+print("\nTesting arg2:", arg2)
+print("arg2.is_real:", arg2.is_real)
+print("arg2.is_imaginary:", arg2.is_imaginary)
+print("(S.ImaginaryUnit * arg2):", S.ImaginaryUnit * arg2)
+print("(S.ImaginaryUnit * arg2).is_real:", (S.ImaginaryUnit * arg2).is_real)
+print("arg2.is_zero:", arg2.is_zero)
+
+# Test the simplified version
+simplified = e.simplify()
+print(f"\nSimplified: {simplified}")
+print(f"Simplified.is_zero: {simplified.is_zero}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..6e93451240
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+from sympy import I, simplify
+
+# Reproduce the issue described in the GitHub issue
+e = -2*I + (1 + I)**2
+print(f"Expression: {e}")
+print(f"e.is_zero: {e.is_zero}")
+print(f"simplify(e): {simplify(e)}")
+print(f"simplify(e).is_zero: {simplify(e).is_zero}")
+
+# Let's analyze the expression components
+print(f"\nAnalysis:")
+print(f"Type of e: {type(e)}")
+print(f"e.args: {e.args}")
+for i, arg in enumerate(e.args):
+    print(f"arg[{i}]: {arg}, type: {type(arg)}, is_real: {arg.is_real}, is_imaginary: {arg.is_imaginary}, is_zero: {arg.is_zero}")
+    
+# The issue: e.is_zero should be True, but it returns False
+# After simplification, we can see the expression is actually zero
\ No newline at end of file
diff --git a/sympy/core/add.py b/sympy/core/add.py
index 83a5f2aedc..b0b0cb7297 100644
--- a/sympy/core/add.py
+++ b/sympy/core/add.py
@@ -558,10 +558,7 @@ def _eval_is_zero(self):
             return None
         b = self.func(*nz)
         if b.is_zero:
-            if not im_or_z and not im:
-                return True
-            if im and not im_or_z:
-                return False
+            return True
         if b.is_zero is False:
             return False
 
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..5895d0e199
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+
+from sympy import I, S, simplify
+
+def test_case(expr, description):
+    print(f"\n=== {description} ===")
+    print(f"Expression: {expr}")
+    print(f"is_zero: {expr.is_zero}")
+    print(f"simplify(): {simplify(expr)}")
+    print(f"simplify().is_zero: {simplify(expr).is_zero}")
+
+# Test the original issue
+test_case(-2*I + (1 + I)**2, "Original issue")
+
+# Test other complex expressions that should be zero
+test_case(I + (-I), "I + (-I)")
+test_case(2*I + (-2*I), "2*I + (-2*I)")
+test_case((1 + I) + (-1 - I), "(1 + I) + (-1 - I)")
+
+# Test complex expressions that should NOT be zero
+test_case(I + I, "I + I")
+test_case(2*I + 3*I, "2*I + 3*I")
+test_case((1 + I) + (2 + 2*I), "(1 + I) + (2 + 2*I)")
+
+# Test mixed real and imaginary expressions
+test_case(1 + I - 1 - I, "1 + I - 1 - I")
+test_case(2 + 3*I - 2 - 3*I, "2 + 3*I - 2 - 3*I")
+
+# Test purely real expressions
+test_case(S(1) - S(1), "1 - 1")
+test_case(S(2) + S(3) - S(5), "2 + 3 - 5")
+test_case(S(1) + S(2), "1 + 2")
+
+# Test expressions with uncertainty
+from sympy import Symbol
+x = Symbol('x')
+test_case(x - x, "x - x")
+test_case(x + I - x - I, "x + I - x - I")
+
+print("\n=== Summary ===")
+print("All expressions should match their simplified versions for is_zero")
\ No newline at end of file
diff --git a/test_matrix_rank.py b/test_matrix_rank.py
new file mode 100644
index 0000000000..2dac510cf8
--- /dev/null
+++ b/test_matrix_rank.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+from sympy import I, Matrix
+
+# Test the matrix rank issue mentioned in the GitHub issue
+# The issue was that is_zero returning False incorrectly affected matrix rank determination
+
+# Create a matrix with the problematic expression
+expr = -2*I + (1 + I)**2
+print(f"Expression: {expr}")
+print(f"is_zero: {expr.is_zero}")
+
+# Create a simple matrix that would use this expression
+# If is_zero is incorrect, it could affect rank calculation
+M = Matrix([
+    [1, expr],
+    [expr, 1]
+])
+
+print(f"\nMatrix M:")
+print(M)
+print(f"Matrix rank: {M.rank()}")
+
+# The rank should be 2 if expr is non-zero, or potentially lower if expr is zero
+# But since expr is actually zero, let's see what happens
+print(f"\nSince expr is actually zero, let's simplify and check:")
+M_simplified = M.applyfunc(lambda x: x.simplify())
+print(f"Simplified matrix:")
+print(M_simplified)
+print(f"Simplified matrix rank: {M_simplified.rank()}")
+
+print("\nThe key point is that is_zero should return the correct value")
+print("so that matrix operations work correctly!")
\ No newline at end of file
diff --git a/trace_algorithm.py b/trace_algorithm.py
new file mode 100644
index 0000000000..a37e0066aa
--- /dev/null
+++ b/trace_algorithm.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+
+from sympy import I, S
+
+# Simulate the _eval_is_zero algorithm
+e = -2*I + (1 + I)**2
+args = e.args
+
+print("Tracing _eval_is_zero algorithm:")
+print(f"args: {args}")
+
+nz = []
+z = 0
+im_or_z = False
+im = False
+
+for i, a in enumerate(args):
+    print(f"\nProcessing arg[{i}]: {a}")
+    print(f"a.is_real: {a.is_real}")
+    
+    if a.is_real:
+        print(f"  a.is_zero: {a.is_zero}")
+        if a.is_zero:
+            z += 1
+            print(f"  z increased to {z}")
+        elif a.is_zero is False:
+            nz.append(a)
+            print(f"  added to nz: {nz}")
+        else:
+            print("  returning None (uncertain)")
+            exit()
+    elif a.is_imaginary:
+        im = True
+        print(f"  im set to {im}")
+    elif (S.ImaginaryUnit*a).is_real:
+        im_or_z = True
+        print(f"  im_or_z set to {im_or_z}")
+    else:
+        print("  returning None (uncertain)")
+        exit()
+
+print(f"\nAfter loop:")
+print(f"z: {z}")
+print(f"nz: {nz}")
+print(f"im_or_z: {im_or_z}")
+print(f"im: {im}")
+
+if z == len(args):
+    print("All args are zero -> returning True")
+elif len(nz) == len(args):
+    print("All args are non-zero -> returning None")
+
+b = e.func(*nz)
+print(f"\nb = e.func(*nz) = {b}")
+print(f"b.is_zero: {b.is_zero}")
+
+if b.is_zero:
+    print("b.is_zero is True -> returning True")
+elif b.is_zero is False:
+    print("b.is_zero is False -> returning False")
+else:
+    print("b.is_zero is None -> returning None")
\ No newline at end of file