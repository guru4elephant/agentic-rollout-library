diff --git a/debug_headers.py b/debug_headers.py
new file mode 100644
index 00000000..1fdb662c
--- /dev/null
+++ b/debug_headers.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python
+"""
+Debug header processing to understand what's happening.
+"""
+import requests
+from requests.models import PreparedRequest
+
+def debug_header_processing():
+    print("Debugging header processing...")
+    
+    # Test 1: Create a prepared request manually
+    print("\n1. Testing manual header preparation")
+    pr = PreparedRequest()
+    headers = {'Test-Header': None, 'Valid-Header': 'valid'}
+    print(f"Input headers: {headers}")
+    
+    pr.prepare_headers(headers)
+    print(f"Prepared headers: {dict(pr.headers)}")
+    
+    # Test 2: Test with session
+    print("\n2. Testing session header preparation")
+    session = requests.Session()
+    session.headers['Session-Header'] = None
+    session.headers['Valid-Session-Header'] = 'session-value'
+    print(f"Session headers: {dict(session.headers)}")
+    
+    # Create a request to see what headers get prepared
+    req = requests.Request('GET', 'http://example.com', headers={'Request-Header': None, 'Valid-Request-Header': 'request-value'})
+    prepped = session.prepare_request(req)
+    print(f"Final prepared headers: {dict(prepped.headers)}")
+
+if __name__ == "__main__":
+    debug_header_processing()
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 00000000..33401518
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python
+"""
+Debug test to understand what's happening with headers.
+"""
+import requests
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def debug_test():
+    print("Debugging header behavior...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8890), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Check default headers
+        print("\n1. Testing default session headers")
+        session = requests.Session()
+        print(f"Default session headers: {dict(session.headers)}")
+        
+        response = session.get('http://localhost:8890/test')
+        captured = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured}")
+        
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Add a specific header and set others to None
+        print("\n2. Testing specific scenario")
+        session2 = requests.Session()
+        session2.headers['Accept-Encoding'] = None
+        session2.headers['Custom-Header'] = 'custom-value'
+        print(f"Session headers before request: {dict(session2.headers)}")
+        
+        response2 = session2.get('http://localhost:8890/test')
+        captured2 = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured2}")
+        
+        # Check if Custom-Header is present and Accept-Encoding is not
+        if 'Custom-Header' in captured2 and captured2['Custom-Header'] == 'custom-value' and 'Accept-Encoding' not in captured2:
+            print("✅ SUCCESS: Custom header sent, None header filtered")
+        else:
+            print("❌ ISSUE: Header filtering not working correctly")
+            
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    debug_test()
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 00000000..3104dc06
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+"""
+Detailed debug to understand header processing.
+"""
+import requests
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        print(f"Server received headers: {self.captured_headers}")
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def detailed_debug():
+    print("Detailed debugging of header processing...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8891), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Basic request without session
+        print("\n1. Testing basic request without session")
+        response = requests.get('http://localhost:8891/test')
+        print(f"Response status: {response.status_code}")
+        
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Session with no modifications
+        print("\n2. Testing session with no modifications")
+        session = requests.Session()
+        print(f"Session headers: {dict(session.headers)}")
+        response2 = session.get('http://localhost:8891/test')
+        print(f"Response status: {response2.status_code}")
+        
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 3: Session with None header
+        print("\n3. Testing session with None header")
+        session3 = requests.Session()
+        session3.headers['Accept-Encoding'] = None
+        print(f"Session headers after setting to None: {dict(session3.headers)}")
+        response3 = session3.get('http://localhost:8891/test')
+        print(f"Response status: {response3.status_code}")
+        
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    detailed_debug()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..f1a5c54c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+"""
+Script to reproduce the issue where setting session header to None
+sends "None" as the value instead of removing the header.
+"""
+import requests
+
+def test_session_header_none():
+    print("Testing session header behavior when set to None...")
+    
+    # Create a session
+    session = requests.Session()
+    
+    print(f"Original headers: {dict(session.headers)}")
+    
+    # Try to remove Accept-Encoding by setting to None (this should not work)
+    session.headers['Accept-Encoding'] = None
+    print(f"After setting Accept-Encoding to None: {dict(session.headers)}")
+    
+    # Check if the header contains the string "None"
+    if 'Accept-Encoding' in session.headers and session.headers['Accept-Encoding'] == 'None':
+        print("❌ ISSUE REPRODUCED: Header value is 'None' instead of being removed")
+        return False
+    elif 'Accept-Encoding' not in session.headers:
+        print("✅ Header was properly removed")
+        return True
+    else:
+        print(f"❓ Unexpected behavior: {session.headers['Accept-Encoding']}")
+        return False
+
+def test_working_alternative():
+    print("\nTesting working alternative (using del)...")
+    
+    # Create a session
+    session = requests.Session()
+    
+    print(f"Original headers: {dict(session.headers)}")
+    
+    # Remove Accept-Encoding using del (this should work)
+    del session.headers['Accept-Encoding']
+    print(f"After deleting Accept-Encoding: {dict(session.headers)}")
+    
+    if 'Accept-Encoding' not in session.headers:
+        print("✅ Header was properly removed using del")
+        return True
+    else:
+        print("❌ del didn't work as expected")
+        return False
+
+if __name__ == "__main__":
+    print("=" * 60)
+    issue_reproduced = test_session_header_none()
+    print("=" * 60)
+    alternative_works = test_working_alternative()
+    print("=" * 60)
+    
+    if issue_reproduced is False:
+        print("Issue successfully reproduced!")
+    else:
+        print("Issue was not reproduced (maybe already fixed?)")
\ No newline at end of file
diff --git a/requests/models.py b/requests/models.py
index cd232e68..d803cae5 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -391,7 +391,9 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
         """Prepares the given HTTP headers."""
 
         if headers:
-            self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())
+            # Filter out headers with None values
+            filtered_headers = ((to_native_string(name), value) for name, value in headers.items() if value is not None)
+            self.headers = CaseInsensitiveDict(filtered_headers)
         else:
             self.headers = CaseInsensitiveDict()
 
diff --git a/test_backward_compatibility.py b/test_backward_compatibility.py
new file mode 100644
index 00000000..5aa71cc7
--- /dev/null
+++ b/test_backward_compatibility.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python
+"""
+Test backward compatibility - ensure request headers with None still work.
+"""
+import requests
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def test_backward_compatibility():
+    print("Testing backward compatibility...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8893), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Request headers with None values (should be filtered by merge_setting)
+        print("\n1. Testing request headers with None values")
+        session = requests.Session()
+        response = session.get('http://localhost:8893/test', headers={'Test-Header': None, 'Another-Header': 'value'})
+        captured = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured}")
+        
+        # Test-Header should be filtered out, Another-Header should remain
+        if 'Test-Header' not in captured and 'Another-Header' in captured and captured['Another-Header'] == 'value':
+            print("✅ SUCCESS: Request None headers properly filtered, other headers preserved")
+        else:
+            print("❌ ISSUE: Request header filtering not working correctly")
+            return False
+            
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Mixed session and request headers with None
+        print("\n2. Testing mixed session and request headers with None")
+        session2 = requests.Session()
+        session2.headers['Session-Header'] = None  # Should be filtered by prepare_headers
+        response2 = session2.get('http://localhost:8893/test', headers={'Request-Header': None, 'Valid-Header': 'valid'})
+        captured2 = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured2}")
+        
+        # None headers should be filtered out, valid headers should remain
+        none_headers_present = any(header in captured2 for header in ['Session-Header', 'Request-Header'])
+        if not none_headers_present and 'Valid-Header' in captured2 and captured2['Valid-Header'] == 'valid':
+            print("✅ SUCCESS: All None headers properly filtered, valid headers preserved")
+            return True
+        else:
+            print("❌ ISSUE: Mixed header filtering not working correctly")
+            return False
+            
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    success = test_backward_compatibility()
+    if success:
+        print("\n🎉 Backward compatibility maintained!")
+    else:
+        print("\n💥 Backward compatibility issues!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..f9097945
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python
+"""
+Test edge cases for the None header fix.
+"""
+import requests
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def test_edge_cases():
+    print("Testing edge cases for None header handling...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8889), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Multiple None headers
+        print("\n1. Testing multiple headers set to None")
+        session = requests.Session()
+        session.headers['Accept-Encoding'] = None
+        session.headers['User-Agent'] = None
+        session.headers['Custom-Header'] = None
+        session.headers['Keep-Alive'] = 'timeout=5'  # This should still be sent
+        
+        response = session.get('http://localhost:8889/test')
+        captured = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured}")
+        
+        # None headers should not be sent
+        none_headers_present = any(header in captured for header in ['Accept-Encoding', 'User-Agent', 'Custom-Header'])
+        if not none_headers_present and 'Keep-Alive' in captured:
+            print("✅ SUCCESS: None headers filtered out, valid headers preserved")
+        else:
+            print("❌ ISSUE: None headers not properly filtered")
+            return False
+        
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Empty string vs None
+        print("\n2. Testing empty string vs None")
+        session2 = requests.Session()
+        session2.headers['Empty-Header'] = ''  # Empty string should be sent
+        session2.headers['None-Header'] = None  # None should not be sent
+        
+        response2 = session2.get('http://localhost:8889/test')
+        captured2 = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured2}")
+        
+        if 'Empty-Header' in captured2 and captured2['Empty-Header'] == '' and 'None-Header' not in captured2:
+            print("✅ SUCCESS: Empty string sent, None filtered out")
+        else:
+            print("❌ ISSUE: Empty string/None not handled correctly")
+            return False
+            
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 3: Request headers with None (should work as before)
+        print("\n3. Testing request headers with None (backward compatibility)")
+        session3 = requests.Session()
+        
+        # Request with None header should still work (this tests merge_setting function)
+        response3 = session3.get('http://localhost:8889/test', headers={'Test-Header': None})
+        captured3 = dict(HeaderCaptureHandler.captured_headers)
+        print(f"Captured headers: {captured3}")
+        
+        if 'Test-Header' not in captured3:
+            print("✅ SUCCESS: Request None headers properly filtered")
+            return True
+        else:
+            print("❌ ISSUE: Request None headers not filtered")
+            return False
+            
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    success = test_edge_cases()
+    if success:
+        print("\n🎉 All edge cases handled correctly!")
+    else:
+        print("\n💥 Some edge cases failed!")
\ No newline at end of file
diff --git a/test_http_request.py b/test_http_request.py
new file mode 100644
index 00000000..8f520392
--- /dev/null
+++ b/test_http_request.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python
+"""
+Test script to actually send HTTP requests and check what headers are sent
+when session headers are set to None.
+"""
+import requests
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def test_none_header_behavior():
+    print("Testing what headers are actually sent in HTTP requests...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8888), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Setting header to None in session
+        print("\n1. Testing session.headers['Accept-Encoding'] = None")
+        session = requests.Session()
+        session.headers['Accept-Encoding'] = None
+        
+        # Send request
+        response = session.get('http://localhost:8888/test')
+        print(f"Captured headers: {dict(HeaderCaptureHandler.captured_headers)}")
+        
+        # Check if Accept-Encoding header was sent
+        if 'Accept-Encoding' in HeaderCaptureHandler.captured_headers:
+            accept_encoding_value = HeaderCaptureHandler.captured_headers['Accept-Encoding']
+            print(f"Accept-Encoding header value: '{accept_encoding_value}'")
+            if accept_encoding_value == 'None':
+                print("❌ ISSUE: Accept-Encoding header sent with value 'None'")
+                return False
+            else:
+                print(f"❓ Unexpected Accept-Encoding value: '{accept_encoding_value}'")
+                return False
+        else:
+            print("✅ SUCCESS: Accept-Encoding header was not sent (properly removed)")
+            
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Using del to remove header (should work)
+        print("\n2. Testing del session.headers['Accept-Encoding']")
+        session2 = requests.Session()
+        del session2.headers['Accept-Encoding']
+        
+        # Send request
+        response2 = session2.get('http://localhost:8888/test')
+        print(f"Captured headers: {dict(HeaderCaptureHandler.captured_headers)}")
+        
+        if 'Accept-Encoding' not in HeaderCaptureHandler.captured_headers:
+            print("✅ SUCCESS: Accept-Encoding header was not sent (properly removed with del)")
+            return True
+        else:
+            print("❌ del didn't work as expected")
+            return False
+            
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    success = test_none_header_behavior()
+    if success:
+        print("\n🎉 Fix is working correctly!")
+    else:
+        print("\n💥 Issue still exists!")
\ No newline at end of file
diff --git a/test_raw_http.py b/test_raw_http.py
new file mode 100644
index 00000000..ee92a738
--- /dev/null
+++ b/test_raw_http.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python
+"""
+Test raw HTTP connection to see if Accept-Encoding: identity is added automatically.
+"""
+import http.client
+from http.server import BaseHTTPRequestHandler, HTTPServer
+from threading import Thread
+import time
+
+class HeaderCaptureHandler(BaseHTTPRequestHandler):
+    captured_headers = {}
+    
+    def do_GET(self):
+        # Capture all headers
+        self.captured_headers = dict(self.headers)
+        print(f"Server received headers: {self.captured_headers}")
+        
+        # Send response
+        self.send_response(200)
+        self.send_header('Content-type', 'text/plain')
+        self.end_headers()
+        self.wfile.write(b'OK')
+        
+    def log_message(self, format, *args):
+        # Suppress server logs
+        pass
+
+def test_raw_http():
+    print("Testing raw HTTP connection behavior...")
+    
+    # Start a simple HTTP server to capture headers
+    server = HTTPServer(('localhost', 8892), HeaderCaptureHandler)
+    server_thread = Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    # Give server time to start
+    time.sleep(0.1)
+    
+    try:
+        # Test 1: Raw HTTP connection without Accept-Encoding header
+        print("\n1. Testing raw HTTP connection without Accept-Encoding")
+        conn = http.client.HTTPConnection('localhost', 8892)
+        conn.request("GET", "/test")
+        response = conn.getresponse()
+        print(f"Response status: {response.status}")
+        conn.close()
+        
+        # Reset captured headers
+        HeaderCaptureHandler.captured_headers = {}
+        
+        # Test 2: Raw HTTP connection with explicit Accept-Encoding: None
+        print("\n2. Testing raw HTTP connection with explicit Accept-Encoding: None")
+        conn2 = http.client.HTTPConnection('localhost', 8892)
+        conn2.request("GET", "/test", headers={'Accept-Encoding': None})
+        response2 = conn2.getresponse()
+        print(f"Response status: {response2.status}")
+        conn2.close()
+        
+    finally:
+        server.shutdown()
+        server.server_close()
+
+if __name__ == "__main__":
+    test_raw_http()
\ No newline at end of file