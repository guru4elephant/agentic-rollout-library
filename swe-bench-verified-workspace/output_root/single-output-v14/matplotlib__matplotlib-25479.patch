diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py
index 58ce4c03fa..e0d2d74f7c 100644
--- a/lib/matplotlib/pyplot.py
+++ b/lib/matplotlib/pyplot.py
@@ -2278,13 +2278,17 @@ def set_cmap(cmap: Colormap | str) -> None:
     matplotlib.cm.register_cmap
     matplotlib.cm.get_cmap
     """
-    cmap = get_cmap(cmap)
+    # Store the original name before resolving to colormap object
+    original_name = cmap if isinstance(cmap, str) else None
+    cmap_obj = get_cmap(cmap)
 
-    rc('image', cmap=cmap.name)
+    # Use the original name if it was a string, otherwise use the colormap's name
+    rc_name = original_name if original_name is not None else cmap_obj.name
+    rc('image', cmap=rc_name)
     im = gci()
 
     if im is not None:
-        im.set_cmap(cmap)
+        im.set_cmap(cmap_obj)
 
 
 @_copy_docstring_and_deprecators(matplotlib.image.imread)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..3c79581f29
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,36 @@
+from matplotlib import cm
+from matplotlib.colors import LinearSegmentedColormap
+import matplotlib.pyplot as plt
+import matplotlib
+
+# Create a colormap with one name
+my_cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],
+                [2.3e-03, 1.3e-03, 1.8e-02],
+                [3.3e-03, 2.3e-03, 2.4e-02]]
+my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', my_cmap_data)
+
+# Register it with a different name
+cm.register_cmap(name='my_cmap_name', cmap=my_cmap)
+
+print("Colormap created with name:", my_cmap.name)
+print("Registered with name: my_cmap_name")
+
+# Try to use the registered colormap
+try:
+    plt.set_cmap('my_cmap_name')  # This should work
+    print("set_cmap('my_cmap_name') succeeded")
+    
+    # This should fail according to the issue
+    plt.imshow([[1, 1], [2, 2]])
+    print("imshow succeeded - issue may be fixed or not reproduced")
+    
+except ValueError as e:
+    print("Error occurred:", str(e))
+    print("This reproduces the issue!")
+
+# Test direct lookup
+try:
+    retrieved_cmap = cm.get_cmap('my_cmap_name')
+    print("Direct lookup succeeded, retrieved cmap name:", retrieved_cmap.name)
+except Exception as e:
+    print("Direct lookup failed:", str(e))
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..e607c0569d
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,61 @@
+from matplotlib import cm
+from matplotlib.colors import LinearSegmentedColormap
+import matplotlib.pyplot as plt
+import matplotlib
+
+def test_unregistered_colormap_object():
+    """Test that using an unregistered colormap object works correctly"""
+    print("Test: Unregistered colormap object")
+    
+    # Create a colormap but don't register it
+    my_cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],
+                    [2.3e-03, 1.3e-03, 1.8e-02],
+                    [3.3e-03, 2.3e-03, 2.4e-02]]
+    my_cmap = LinearSegmentedColormap.from_list('unregistered_name', my_cmap_data)
+
+    # Set using colormap object directly
+    plt.set_cmap(my_cmap)
+    
+    # Check that rc parameter is set to the colormap's name
+    assert matplotlib.rcParams['image.cmap'] == 'unregistered_name'
+    print("✓ rc parameter set correctly")
+    
+    # The colormap should work when passed directly to imshow
+    plt.figure()
+    img = plt.imshow([[1, 1], [2, 2]], cmap=my_cmap)
+    plt.close()
+    
+    assert img.get_cmap().name == 'unregistered_name'
+    print("✓ imshow with direct colormap works")
+    
+    # However, using the default rc colormap should fail since it's not registered
+    try:
+        plt.figure()
+        img = plt.imshow([[1, 1], [2, 2]])  # This should fail
+        plt.close()
+        print("✗ Expected failure but didn't get one")
+    except ValueError as e:
+        print("✓ Expected failure occurred:", str(e)[:100] + "...")
+    
+    print("✓ Passed")
+
+def test_none_cmap():
+    """Test that None works correctly"""
+    print("Test: None cmap")
+    
+    # Reset to default
+    plt.set_cmap('viridis')
+    
+    # Set using None should use default
+    plt.set_cmap(None)
+    
+    # Check that rc parameter is set to default
+    default_cmap = matplotlib.rcParams['image.cmap']
+    assert matplotlib.rcParams['image.cmap'] == default_cmap
+    print("✓ rc parameter set to default")
+    print("✓ Passed")
+
+if __name__ == "__main__":
+    test_unregistered_colormap_object()
+    test_none_cmap()
+    print("All edge case tests passed!")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..4b44f2306d
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,98 @@
+from matplotlib import cm
+from matplotlib.colors import LinearSegmentedColormap
+import matplotlib.pyplot as plt
+import matplotlib
+
+def test_case_1():
+    """Test the original issue: different registered name vs colormap name"""
+    print("Test Case 1: Different registered name vs colormap name")
+    
+    # Create a colormap with one name
+    my_cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],
+                    [2.3e-03, 1.3e-03, 1.8e-02],
+                    [3.3e-03, 2.3e-03, 2.4e-02]]
+    my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', my_cmap_data)
+
+    # Register it with a different name
+    cm.register_cmap(name='my_cmap_name', cmap=my_cmap)
+
+    # Test that set_cmap works with the registered name
+    plt.set_cmap('my_cmap_name')
+    
+    # This should work now (previously failed)
+    plt.figure()
+    img = plt.imshow([[1, 1], [2, 2]])
+    plt.close()
+    
+    # Check that the image uses the correct colormap
+    assert img.get_cmap().name == 'some_cmap_name'
+    print("✓ Passed")
+
+def test_case_2():
+    """Test using colormap object directly"""
+    print("Test Case 2: Using colormap object directly")
+    
+    # Create a colormap
+    my_cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],
+                    [2.3e-03, 1.3e-03, 1.8e-02],
+                    [3.3e-03, 2.3e-03, 2.4e-02]]
+    my_cmap = LinearSegmentedColormap.from_list('direct_cmap_name', my_cmap_data)
+
+    # Set using colormap object directly
+    plt.set_cmap(my_cmap)
+    
+    # Check that rc parameter is set to the colormap's name
+    assert matplotlib.rcParams['image.cmap'] == 'direct_cmap_name'
+    
+    # When using colormap object directly, imshow should work because it gets the colormap object
+    plt.figure()
+    img = plt.imshow([[1, 1], [2, 2]], cmap=my_cmap)  # Pass colormap directly to avoid the rc lookup issue
+    plt.close()
+    
+    # Check that the image uses the correct colormap
+    assert img.get_cmap().name == 'direct_cmap_name'
+    print("✓ Passed")
+
+def test_case_3():
+    """Test using built-in colormap name"""
+    print("Test Case 3: Using built-in colormap name")
+    
+    # Set using built-in colormap name
+    plt.set_cmap('viridis')
+    
+    # Check that rc parameter is set correctly
+    assert matplotlib.rcParams['image.cmap'] == 'viridis'
+    
+    # This should work
+    plt.figure()
+    img = plt.imshow([[1, 1], [2, 2]], cmap='viridis')  # Pass colormap name directly
+    plt.close()
+    
+    # Check that the image uses the correct colormap
+    assert img.get_cmap().name == 'viridis'
+    print("✓ Passed")
+
+def test_case_4():
+    """Test rc parameter is set correctly"""
+    print("Test Case 4: rc parameter is set correctly")
+    
+    # Create and register colormap with different name
+    my_cmap_data = [[1.5e-03, 4.7e-04, 1.4e-02],
+                    [2.3e-03, 1.3e-03, 1.8e-02],
+                    [3.3e-03, 2.3e-03, 2.4e-02]]
+    my_cmap = LinearSegmentedColormap.from_list('original_name', my_cmap_data)
+    cm.register_cmap(name='registered_name', cmap=my_cmap)
+
+    # Set using registered name
+    plt.set_cmap('registered_name')
+    
+    # Check that rc parameter is set to the registered name, not the original name
+    assert matplotlib.rcParams['image.cmap'] == 'registered_name'
+    print("✓ Passed")
+
+if __name__ == "__main__":
+    test_case_1()
+    test_case_2()
+    test_case_3()
+    test_case_4()
+    print("All tests passed!")
\ No newline at end of file