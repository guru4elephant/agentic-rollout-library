diff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py
index 3903e4c98c..9dfe15d245 100644
--- a/django/contrib/admin/views/autocomplete.py
+++ b/django/contrib/admin/views/autocomplete.py
@@ -26,12 +26,17 @@ class AutocompleteJsonView(BaseListView):
         context = self.get_context_data()
         return JsonResponse({
             'results': [
-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}
-                for obj in context['object_list']
+                self.serialize_result(obj, to_field_name) for obj in context['object_list']
             ],
             'pagination': {'more': context['page_obj'].has_next()},
         })
 
+    def serialize_result(self, obj, to_field_name):
+        """
+        Convert an object to a dictionary representing a single result.
+        """
+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}
+
     def get_paginator(self, *args, **kwargs):
         """Use the ModelAdmin's paginator."""
         return self.model_admin.get_paginator(self.request, *args, **kwargs)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..faca2fe387
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the autocomplete functionality and test the proposed changes.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+def test_refactored_implementation():
+    """Test the refactored implementation with serialize_result method."""
+    print("Testing refactored AutocompleteJsonView implementation...")
+    
+    # Create a simple test to check the structure
+    view = AutocompleteJsonView()
+    
+    # Check if serialize_result method exists (it should now)
+    if not hasattr(view, 'serialize_result'):
+        print("serialize_result method doesn't exist!")
+        return False
+    
+    # Test the serialize_result method
+    class TestObj:
+        def __init__(self, id, name):
+            self.id = id
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    test_obj = TestObj(123, "test object")
+    result = view.serialize_result(test_obj, 'id')
+    
+    expected = {'id': '123', 'text': 'test object'}
+    if result != expected:
+        print(f"Expected {expected}, but got {result}")
+        return False
+    
+    print("serialize_result method works correctly!")
+    return True
+
+if __name__ == '__main__':
+    success = test_refactored_implementation()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_complete_solution.py b/test_complete_solution.py
new file mode 100644
index 0000000000..30eddd10a2
--- /dev/null
+++ b/test_complete_solution.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python3
+"""
+Complete test demonstrating the solution as described in the GitHub issue.
+This shows how easy it is to customize autocomplete responses with the new serialize_result method.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+from django.http import JsonResponse
+
+# Example from the GitHub issue - before the refactoring would require overriding get()
+class OldWayCustomAutocompleteJsonView(AutocompleteJsonView):
+    def get(self, request, *args, **kwargs):
+        # This is the old way - having to override the entire get method
+        self.term, self.model_admin, self.source_field, to_field_name = self.process_request(request)
+        if not self.has_perm(request):
+            raise PermissionDenied
+        self.object_list = self.get_queryset()
+        context = self.get_context_data()
+        return JsonResponse({
+            'results': [
+                {'id': str(getattr(obj, to_field_name)), 'text': str(obj), 'notes': obj.notes}
+                for obj in context['object_list']
+            ],
+            'pagination': {'more': context['page_obj'].has_next()},
+        })
+
+# Example from the GitHub issue - after the refactoring (our solution)
+class NewWayCustomAutocompleteJsonView(AutocompleteJsonView):
+    def serialize_result(self, obj, to_field_name):
+        """Override to add custom fields to the autocomplete response."""
+        base_result = super().serialize_result(obj, to_field_name)
+        # Add custom fields - this is the elegant solution described in the issue
+        notes = getattr(obj, 'notes', None)
+        base_result['notes'] = notes if notes is not None else 'No notes available'
+        return base_result
+
+def test_complete_solution():
+    """Test the complete solution as described in the GitHub issue."""
+    print("Testing complete solution from GitHub issue...")
+    
+    # Create test objects with notes (simulating a real model)
+    class TestObject:
+        def __init__(self, id, name, notes=None):
+            self.id = id
+            self.name = name
+            self.notes = notes
+        
+        def __str__(self):
+            return self.name
+    
+    # Test the new way (our solution)
+    custom_view = NewWayCustomAutocompleteJsonView()
+    
+    # Test object with notes
+    test_obj1 = TestObject(1, "Test Object 1", "These are some notes")
+    result1 = custom_view.serialize_result(test_obj1, 'id')
+    expected1 = {'id': '1', 'text': 'Test Object 1', 'notes': 'These are some notes'}
+    
+    if result1 != expected1:
+        print(f"FAIL: Expected {expected1}, but got {result1}")
+        return False
+    
+    # Test object without notes
+    test_obj2 = TestObject(2, "Test Object 2")
+    result2 = custom_view.serialize_result(test_obj2, 'id')
+    expected2 = {'id': '2', 'text': 'Test Object 2', 'notes': 'No notes available'}
+    
+    if result2 != expected2:
+        print(f"FAIL: Expected {expected2}, but got {result2}")
+        return False
+    
+    # Verify that the base functionality still works
+    base_view = AutocompleteJsonView()
+    result3 = base_view.serialize_result(test_obj1, 'id')
+    expected3 = {'id': '1', 'text': 'Test Object 1'}
+    
+    if result3 != expected3:
+        print(f"FAIL: Base functionality broken. Expected {expected3}, but got {result3}")
+        return False
+    
+    print("✓ Complete solution works perfectly!")
+    print("✓ Custom autocomplete responses can now be easily extended")
+    print("✓ Base functionality remains unchanged")
+    print("✓ Maintenance overhead is significantly reduced")
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_complete_solution()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_customization.py b/test_customization.py
new file mode 100644
index 0000000000..723abdf99b
--- /dev/null
+++ b/test_customization.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Test script to demonstrate how to customize autocomplete responses using the new serialize_result method.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+class CustomAutocompleteJsonView(AutocompleteJsonView):
+    """Custom autocomplete view that adds extra fields to the response."""
+    
+    def serialize_result(self, obj, to_field_name):
+        """Override to add custom fields to the autocomplete response."""
+        base_result = super().serialize_result(obj, to_field_name)
+        # Add custom fields - in a real scenario, this could be any attribute
+        base_result['custom_field'] = f"custom_{obj.id}"
+        return base_result
+
+def test_customization():
+    """Test that custom autocomplete views can easily add extra fields."""
+    print("Testing custom AutocompleteJsonView implementation...")
+    
+    # Create custom view instance
+    custom_view = CustomAutocompleteJsonView()
+    
+    # Test the custom serialize_result method
+    class TestObj:
+        def __init__(self, id, name):
+            self.id = id
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    test_obj = TestObj(123, "test object")
+    result = custom_view.serialize_result(test_obj, 'id')
+    
+    expected = {'id': '123', 'text': 'test object', 'custom_field': 'custom_123'}
+    if result != expected:
+        print(f"Expected {expected}, but got {result}")
+        return False
+    
+    print("Custom serialize_result method works correctly!")
+    return True
+
+if __name__ == '__main__':
+    success = test_customization()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..242799095d
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python3
+"""
+Test script to verify edge cases for the AutocompleteJsonView serialize_result method.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+def test_edge_cases():
+    """Test edge cases for the serialize_result method."""
+    print("Testing edge cases for AutocompleteJsonView...")
+    
+    view = AutocompleteJsonView()
+    
+    # Test with None values
+    class MockObject:
+        def __init__(self, id=None, name=None):
+            self.id = id
+            self.name = name
+        
+        def __str__(self):
+            return str(self.name) if self.name else "None"
+    
+    # Test with None id
+    test_obj1 = MockObject(None, "Test Object")
+    result1 = view.serialize_result(test_obj1, 'id')
+    expected1 = {'id': 'None', 'text': 'Test Object'}
+    
+    if result1 != expected1:
+        print(f"FAIL: Expected {expected1}, but got {result1}")
+        return False
+    
+    # Test with None name
+    test_obj2 = MockObject(123, None)
+    result2 = view.serialize_result(test_obj2, 'id')
+    expected2 = {'id': '123', 'text': 'None'}
+    
+    if result2 != expected2:
+        print(f"FAIL: Expected {expected2}, but got {result2}")
+        return False
+    
+    # Test with numeric values
+    test_obj3 = MockObject(123.45, "Float ID")
+    result3 = view.serialize_result(test_obj3, 'id')
+    expected3 = {'id': '123.45', 'text': 'Float ID'}
+    
+    if result3 != expected3:
+        print(f"FAIL: Expected {expected3}, but got {result3}")
+        return False
+    
+    # Test with boolean values
+    test_obj4 = MockObject(True, "Boolean ID")
+    result4 = view.serialize_result(test_obj4, 'id')
+    expected4 = {'id': 'True', 'text': 'Boolean ID'}
+    
+    if result4 != expected4:
+        print(f"FAIL: Expected {expected4}, but got {result4}")
+        return False
+    
+    print("✓ All edge cases handled correctly!")
+    return True
+
+if __name__ == '__main__':
+    success = test_edge_cases()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..b0d7250c97
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that existing AutocompleteJsonView functionality still works after our changes.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+from django.test import RequestFactory
+
+def test_existing_functionality():
+    """Test that the existing autocomplete functionality still works."""
+    print("Testing existing AutocompleteJsonView functionality...")
+    
+    # Create a mock object similar to what would be returned from a queryset
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    # Test the serialize_result method directly
+    view = AutocompleteJsonView()
+    test_obj = MockObject(123, "Test Object")
+    
+    # Test with 'pk' as to_field_name (common case)
+    result = view.serialize_result(test_obj, 'pk')
+    expected = {'id': '123', 'text': 'Test Object'}
+    
+    if result != expected:
+        print(f"FAIL: Expected {expected}, but got {result}")
+        return False
+    
+    # Test with a different field name
+    class MockObjectWithCustomField:
+        def __init__(self, custom_id, name):
+            self.custom_id = custom_id
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    test_obj2 = MockObjectWithCustomField("abc123", "Custom Field Object")
+    result2 = view.serialize_result(test_obj2, 'custom_id')
+    expected2 = {'id': 'abc123', 'text': 'Custom Field Object'}
+    
+    if result2 != expected2:
+        print(f"FAIL: Expected {expected2}, but got {result2}")
+        return False
+    
+    print("✓ Existing functionality works correctly!")
+    return True
+
+if __name__ == '__main__':
+    success = test_existing_functionality()
+    sys.exit(0 if success else 1)
\ No newline at end of file