diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..5f30b868aa
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,76 @@
+from django.core.management.base import BaseCommand, CommandError
+
+class TestCommand(BaseCommand):
+    def add_arguments(self, parser):
+        subparsers = parser.add_subparsers(required=True, dest='command')
+        
+        # Create subcommand
+        create = subparsers.add_parser("create")
+        create.add_argument("name", help="Name of the item to create")
+        create.add_argument("--force", action="store_true", help="Force creation")
+        
+        # Delete subcommand
+        delete = subparsers.add_parser("delete")
+        delete.add_argument("name", help="Name of the item to delete")
+        delete.add_argument("--confirm", action="store_true", help="Confirm deletion")
+    
+    def handle(self, *args, **options):
+        pass
+
+def test_scenarios():
+    cmd = TestCommand()
+    
+    print("=== Testing various error scenarios ===")
+    
+    # Test 1: No arguments at all
+    print("\n1. No arguments:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        parser.parse_args([])
+    except Exception as e:
+        print(f"   Error: {e}")
+    
+    # Test 2: Missing subcommand argument
+    print("\n2. Missing subcommand:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        parser.parse_args(["--help"])
+    except Exception as e:
+        print(f"   Error: {e}")
+    
+    # Test 3: Missing required argument for create subcommand
+    print("\n3. Missing 'name' for create:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        parser.parse_args(["create"])
+    except Exception as e:
+        print(f"   Error: {e}")
+    
+    # Test 4: Missing required argument for delete subcommand
+    print("\n4. Missing 'name' for delete:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        parser.parse_args(["delete"])
+    except Exception as e:
+        print(f"   Error: {e}")
+    
+    # Test 5: Valid command (should not raise error)
+    print("\n5. Valid create command:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        result = parser.parse_args(["create", "testitem"])
+        print(f"   Success: {result}")
+    except Exception as e:
+        print(f"   Error: {e}")
+    
+    # Test 6: Valid delete command
+    print("\n6. Valid delete command:")
+    try:
+        parser = cmd.create_parser("test", "test")
+        result = parser.parse_args(["delete", "testitem", "--confirm"])
+        print(f"   Success: {result}")
+    except Exception as e:
+        print(f"   Error: {e}")
+
+if __name__ == "__main__":
+    test_scenarios()
\ No newline at end of file
diff --git a/django/core/management/base.py b/django/core/management/base.py
index abc6f79a15..aa0e707065 100644
--- a/django/core/management/base.py
+++ b/django/core/management/base.py
@@ -71,6 +71,32 @@ class CommandParser(ArgumentParser):
         else:
             raise CommandError("Error: %s" % message)
 
+    def add_subparsers(self, **kwargs):
+        # Ensure subparsers inherit our special arguments
+        if 'parser_class' not in kwargs:
+            kwargs['parser_class'] = type(self)
+        action = super().add_subparsers(**kwargs)
+        
+        # Store a reference to our special attributes so they can be passed to subparsers
+        original_add_parser = action.add_parser
+        
+        def add_parser_with_attrs(name, **kwargs):
+            # Pass through our special arguments to subparsers
+            if not hasattr(self, 'missing_args_message') or not hasattr(self, 'called_from_command_line'):
+                return original_add_parser(name, **kwargs)
+                
+            # Copy our special attributes to the subparser
+            subparser_kwargs = kwargs.copy()
+            if 'missing_args_message' not in subparser_kwargs:
+                subparser_kwargs['missing_args_message'] = self.missing_args_message
+            if 'called_from_command_line' not in subparser_kwargs:
+                subparser_kwargs['called_from_command_line'] = self.called_from_command_line
+            
+            return original_add_parser(name, **subparser_kwargs)
+        
+        action.add_parser = add_parser_with_attrs
+        return action
+
 
 def handle_default_options(options):
     """
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..acefb548f0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+from django.core.management.base import BaseCommand, CommandError
+
+class Command(BaseCommand):
+    def add_arguments(self, parser):
+        subparsers = parser.add_subparsers(required=True)
+        create = subparsers.add_parser("create")
+        create.add_argument("name")
+    
+    def handle(self, *args, **options):
+        pass
+
+if __name__ == "__main__":
+    # Test case 1: Missing subparser name (should show usage message)
+    print("Test case 1: Missing subparser name")
+    try:
+        cmd = Command()
+        parser = cmd.create_parser("cheeses", "cheeses")
+        parser.parse_args([])  # No arguments provided
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    print("\nTest case 2: Missing name argument to create (should show stacktrace)")
+    # Test case 2: Missing name argument to create (should show stacktrace)
+    try:
+        cmd = Command()
+        parser = cmd.create_parser("cheeses", "cheeses")
+        parser.parse_args(["create"])  # Missing name argument
+    except Exception as e:
+        print(f"Error: {e}")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..f2cf23cf6e
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python
+"""
+Test script that reproduces the exact issue described in the GitHub issue.
+This should demonstrate that subparsers now retain proper error formatting.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-secret-key',
+    INSTALLED_APPS=[],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    USE_TZ=True,
+)
+django.setup()
+
+from django.core.management.base import BaseCommand, CommandError
+
+class Command(BaseCommand):
+    def add_arguments(self, parser):
+        subparsers = parser.add_subparsers(required=True)
+        create = subparsers.add_parser("create")
+        create.add_argument("name")
+    
+    def handle(self, *args, **options):
+        pass
+
+def test_github_issue_scenarios():
+    """Test the exact scenarios described in the GitHub issue"""
+    cmd = Command()
+    
+    print("=== Testing GitHub Issue Scenarios ===")
+    
+    # Test case 1: Missing the required subparser name argument 
+    # This should give the usage message (was already working)
+    print("\n1. Missing subparser name (should show usage message):")
+    try:
+        parser = cmd.create_parser("cheeses", "cheeses")
+        parser.parse_args([])
+    except CommandError as e:
+        print(f"   CommandError: {e}")
+    except Exception as e:
+        print(f"   Unexpected error: {e}")
+    
+    # Test case 2: Missing the name argument to create
+    # This was giving a stacktrace, but should now give a proper error message
+    print("\n2. Missing name argument to create (should show proper error, not stacktrace):")
+    try:
+        parser = cmd.create_parser("cheeses", "cheeses")
+        parser.parse_args(["create"])
+    except CommandError as e:
+        print(f"   CommandError: {e}")
+    except Exception as e:
+        print(f"   Unexpected error: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    test_github_issue_scenarios()
+    print("\n=== Test completed ===")
\ No newline at end of file