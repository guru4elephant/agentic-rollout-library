diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..fc868cc5fc
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+from sympy.polys.domains import QQ, AlgebraicField
+
+# Create the expression
+z = expand((x-1)*(y-1))
+print("Original expression:", z)
+
+# Create polynomial with extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(z, x, y, domain=K)
+print("\nPoly with extension:")
+print("Poly:", poly_ext)
+print("Domain:", poly_ext.domain)
+print("Internal rep:", poly_ext.rep)
+
+# Let's trace through the dmp_ext_factor function step by step
+print("\n--- Tracing dmp_ext_factor ---")
+
+f = poly_ext.rep
+u = 1  # number of variables minus 1 (since we have x, y)
+K = poly_ext.domain
+
+print("f:", f)
+print("u:", u)
+print("K:", K)
+
+# Step 1: Get leading coefficient and make monic
+from sympy.polys.densebasic import dmp_ground_LC, dmp_ground_monic
+lc = dmp_ground_LC(f, u, K)
+print("\nStep 1 - LC and monic:")
+print("lc:", lc)
+f_monic = dmp_ground_monic(f, u, K)
+print("f_monic:", f_monic)
+
+# Step 2: Get square-free part
+from sympy.polys.sqfreetools import dmp_sqf_part
+f_sqf = dmp_sqf_part(f_monic, u, K)
+print("\nStep 2 - Square-free part:")
+print("f_sqf:", f_sqf)
+
+# Step 3: Get square-free norm
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f_sqf, u, K)
+print("\nStep 3 - Square-free norm:")
+print("s:", s)
+print("g:", g)
+print("r:", r)
+
+# Step 4: Factor the norm in the base domain
+from sympy.polys.factortools import dmp_factor_list_include
+factors_norm = dmp_factor_list_include(r, u, K.dom)
+print("\nStep 4 - Factors of norm:")
+print("factors_norm:", factors_norm)
+
+# Step 5: Check if only one factor
+print("\nStep 5 - Check if single factor:")
+print("len(factors_norm):", len(factors_norm))
+print("factors_norm == 1:", len(factors_norm) == 1)
+
+if len(factors_norm) == 1:
+    print("Returning early with single factor!")
+else:
+    print("Continuing with multiple factors...")
\ No newline at end of file
diff --git a/debug_factor.py b/debug_factor.py
new file mode 100644
index 0000000000..9cb823ec28
--- /dev/null
+++ b/debug_factor.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+
+# Create the expression
+z = expand((x-1)*(y-1))
+print("Original expression:", z)
+
+# Convert to polynomial with and without extension
+from sympy.polys.polytools import Poly
+
+# Without extension
+poly_normal = Poly(z, x, y)
+print("\nPoly without extension:")
+print("Poly:", poly_normal)
+print("Domain:", poly_normal.domain)
+print("Factor list:", poly_normal.factor_list())
+
+# With extension
+poly_ext = Poly(z, x, y, extension=[I])
+print("\nPoly with extension=[I]:")
+print("Poly:", poly_ext)
+print("Domain:", poly_ext.domain)
+print("Factor list:", poly_ext.factor_list())
+
+# Let's also try different extension approaches
+print("\n--- Testing different approaches ---")
+
+# Test 1: Extension as AlgebraicField
+from sympy.polys.domains import QQ, AlgebraicField
+K = QQ.algebraic_field(I)
+poly_alg = Poly(z, x, y, domain=K)
+print("\nPoly with AlgebraicField domain:")
+print("Poly:", poly_alg)
+print("Domain:", poly_alg.domain)
+print("Factor list:", poly_alg.factor_list())
+
+# Test 2: Manual factorization in different domains
+print("\nManual factorization tests:")
+from sympy.polys.factortools import dup_factor_list
+
+# Get the internal representation
+rep_normal = poly_normal.rep
+rep_ext = poly_ext.rep
+
+print("Normal rep:", rep_normal)
+print("Extension rep:", rep_ext)
+
+try:
+    factors_normal = dup_factor_list(rep_normal, poly_normal.domain)
+    print("Normal factors:", factors_normal)
+except Exception as e:
+    print("Normal factors error:", e)
+
+try:
+    factors_ext = dup_factor_list(rep_ext, poly_ext.domain)
+    print("Extension factors:", factors_ext)
+except Exception as e:
+    print("Extension factors error:", e)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..90b6445cf6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+
+# Reproduce the issue from the GitHub issue
+z = expand((x-1)*(y-1))
+print("Original expression:")
+print("z =", z)
+print()
+
+# Test normal factorization
+result_normal = factor(z)
+print("Normal factorization:")
+print("factor(z) =", result_normal)
+print()
+
+# Test factorization with extension
+result_extension = factor(z, extension=[I])
+print("Factorization with extension=[I]:")
+print("factor(z, extension=[I]) =", result_extension)
+print()
+
+# Check if they're equal
+print("Are they equal?", result_normal == result_extension)
+print()
+
+# Additional test cases
+print("Additional test cases:")
+test_cases = [
+    expand((x-1)*(y-1)),
+    expand((x-2)*(y-3)),
+    expand((x-I)*(y+I)),
+    expand((x-1)*(y-1)*(z-1))
+]
+
+for i, expr in enumerate(test_cases):
+    normal = factor(expr)
+    ext = factor(expr, extension=[I])
+    print(f"Test {i+1}:")
+    print(f"  Expression: {expr}")
+    print(f"  Normal: {normal}")
+    print(f"  Extension: {ext}")
+    print(f"  Equal: {normal == ext}")
+    print()
\ No newline at end of file
diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py
index c6a5f9f063..88b119651a 100644
--- a/sympy/polys/factortools.py
+++ b/sympy/polys/factortools.py
@@ -1152,7 +1152,26 @@ def dmp_ext_factor(f, u, K):
     factors = dmp_factor_list_include(r, u, K.dom)
 
     if len(factors) == 1:
-        factors = [f]
+        # For multivariate polynomials, even if the norm has only one factor,
+        # we should still attempt to factor the original polynomial properly
+        # by using the standard factorization methods instead of the norm approach
+        if u == 0:
+            # Univariate case: original logic
+            factors = [f]
+        else:
+            # Multivariate case: use standard factorization in the algebraic field
+            # Convert to the base domain, factor there, then convert back
+            f_base = dmp_convert(f, u, K, K.dom)
+            factors_base = dmp_factor_list_include(f_base, u, K.dom)
+            
+            # Convert factors back to algebraic field
+            factors = []
+            for factor, multiplicity in factors_base:
+                h = dmp_convert(factor, u, K.dom, K)
+                factors.append((h, multiplicity))
+            
+            # Extract just the factors (without multiplicities) for trial division
+            factors = [factor for factor, multiplicity in factors]
     else:
         H = dmp_raise([K.one, s*K.unit], u, 0, K)
 
diff --git a/test_debug_norm.py b/test_debug_norm.py
new file mode 100644
index 0000000000..f3d5b197ea
--- /dev/null
+++ b/test_debug_norm.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.domains import QQ, AlgebraicField
+
+# Create the expression
+z = expand((x-1)*(y-1))
+print("Original expression:", z)
+
+# Create polynomial with extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(z, x, y, domain=K)
+print("\nPoly with extension:")
+print("Poly:", poly_ext)
+print("Domain:", poly_ext.domain)
+
+# Let's manually check what factors we should get
+# The polynomial should factor as (x-1)*(y-1)
+
+# Test if (x-1) divides the polynomial
+poly_x_minus_1 = Poly(x-1, x, y, domain=K)
+print("\nTesting division by (x-1):")
+q, r = poly_ext.div(poly_x_minus_1)
+print("Quotient:", q)
+print("Remainder:", r)
+print("Divisible:", r == 0)
+
+# Test if (y-1) divides the polynomial  
+poly_y_minus_1 = Poly(y-1, x, y, domain=K)
+print("\nTesting division by (y-1):")
+q, r = poly_ext.div(poly_y_minus_1)
+print("Quotient:", q)
+print("Remainder:", r)
+print("Divisible:", r == 0)
+
+# Test if both factors work together
+print("\nTesting complete factorization:")
+# First divide by (x-1)
+q1, r1 = poly_ext.div(poly_x_minus_1)
+print("After dividing by (x-1):")
+print("Quotient:", q1)
+print("Remainder:", r1)
+
+# Then divide the quotient by (y-1)
+q2, r2 = q1.div(poly_y_minus_1)
+print("After dividing quotient by (y-1):")
+print("Quotient:", q2)
+print("Remainder:", r2)
+print("Fully factorable:", r1 == 0 and r2 == 0)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..dd5773c93d
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+from sympy.polys.domains import QQ, AlgebraicField
+
+# Create the expression
+z = expand((x-1)*(y-1))
+print("Original expression:", z)
+
+# Create polynomial with extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(z, x, y, domain=K)
+
+# Let's manually test what the correct behavior should be
+f = poly_ext.rep
+u = 1
+K = poly_ext.domain
+
+# Get the square-free norm
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f, u, K)
+
+print("Square-free norm r:", r)
+print("Type of r:", type(r))
+
+# The norm r should be factored properly to get the factors
+from sympy.polys.factortools import dmp_factor_list_include
+factors_norm = dmp_factor_list_include(r, u, K.dom)
+print("Factors of norm:", factors_norm)
+
+# The issue is that even if the norm has only one factor, 
+# the original multivariate polynomial might still factor
+# Let's see what happens if we continue with the full algorithm
+
+if len(factors_norm) == 1:
+    print("\nNorm has only one factor, but let's try trial division anyway")
+    from sympy.polys.factortools import dmp_trial_division
+    # Try trial division with the single factor
+    H = dmp_raise([K.one, s*K.unit], u, 0, K)
+    
+    # Convert the factor to the algebraic field
+    factor, _ = factors_norm[0]
+    h = dmp_convert(factor, u, K.dom, K)
+    
+    # Try to get gcd and compose
+    from sympy.polys.euclidtools import dmp_inner_gcd
+    h, _, g = dmp_inner_gcd(h, g, u, K)
+    h = dmp_compose(h, H, u, K)
+    
+    # Now try trial division
+    factors = [h]
+    result = dmp_trial_division(f, factors, u, K)
+    print("Trial division result:", result)
+else:
+    print("Norm has multiple factors, proceeding normally")
\ No newline at end of file
diff --git a/test_norm_computation.py b/test_norm_computation.py
new file mode 100644
index 0000000000..aa2d6fa7bd
--- /dev/null
+++ b/test_norm_computation.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.domains import QQ, AlgebraicField
+
+# Create the polynomial
+poly = Poly(x*y - x - y + 1, x, y)
+print("Original polynomial:", poly)
+
+# With extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(x*y - x - y + 1, x, y, domain=K)
+print("\nWith extension:")
+print("Poly:", poly_ext)
+
+# Let's manually compute what the square-free norm should be
+# The square-free norm algorithm is designed for univariate polynomials
+# over algebraic fields, but it's being applied to multivariate polynomials
+
+# For a multivariate polynomial f(x,y) over QQ<I>, the norm is computed as:
+# r = Resultant(g, h) where g is the minimal polynomial of I and h is f injected
+
+# Let's see what this looks like
+from sympy.polys.densebasic import dmp_inject
+from sympy.polys.euclidtools import dmp_resultant
+
+# Get the minimal polynomial of I (which is x^2 + 1)
+min_poly = K.mod.rep
+print("\nMinimal polynomial of I:", min_poly)
+
+# Inject the polynomial f into the base domain
+f_injected, _ = dmp_inject(poly_ext.rep, 1, K, front=True)
+print("Injected f:", f_injected)
+
+# Compute the resultant
+r = dmp_resultant(min_poly, f_injected, 2, K.dom)  # u+1 = 2
+print("Resultant (norm):", r)
+
+# Now factor this norm in the base domain QQ
+from sympy.polys.factortools import dmp_factor_list_include
+factors = dmp_factor_list_include(r, 1, K.dom)  # u = 1
+print("Factors of norm:", factors)
+
+# The issue is that if this norm has only one factor, the algorithm assumes
+# the original polynomial is irreducible, but this is wrong for multivariate case
\ No newline at end of file
diff --git a/test_simple_case.py b/test_simple_case.py
new file mode 100644
index 0000000000..8b3494fde8
--- /dev/null
+++ b/test_simple_case.py
@@ -0,0 +1,31 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.domains import QQ, AlgebraicField
+
+# Let's create a simpler test case to understand the issue
+# Create polynomial: (x-1)*(y-1) = x*y - x - y + 1
+poly = Poly(x*y - x - y + 1, x, y)
+
+print("Original polynomial:", poly)
+print("Normal factorization:", poly.factor_list())
+
+# Now with extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(x*y - x - y + 1, x, y, domain=K)
+print("\nWith extension:")
+print("Poly:", poly_ext)
+print("Factorization:", poly_ext.factor_list())
+
+# Let's see what happens if we manually try to factor
+# The issue might be in the conversion from algebraic numbers back to polynomials
+factors = poly_ext.factor_list()
+print("\nRaw factors:", factors)
+
+# Check if we can convert the factors back to proper form
+if factors[0] == 1:  # leading coefficient
+    for factor, multiplicity in factors[1]:
+        print(f"Factor: {factor}, Multiplicity: {multiplicity}")
+        print(f"Factor as expr: {factor.as_expr()}")
\ No newline at end of file
diff --git a/test_sqf_norm.py b/test_sqf_norm.py
new file mode 100644
index 0000000000..f8a49737d1
--- /dev/null
+++ b/test_sqf_norm.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import x, y, I
+from sympy.polys.polytools import Poly
+from sympy.polys.domains import QQ, AlgebraicField
+from sympy.polys.sqfreetools import dmp_sqf_norm
+
+# Create the expression
+z = expand((x-1)*(y-1))
+print("Original expression:", z)
+
+# Create polynomial with extension
+K = QQ.algebraic_field(I)
+poly_ext = Poly(z, x, y, domain=K)
+print("\nPoly with extension:")
+print("Poly:", poly_ext)
+
+# Get the internal representation
+f = poly_ext.rep
+u = 1  # number of variables minus 1
+
+print("\nInternal representation:")
+print("f:", f)
+print("u:", u)
+
+# Get square-free part first
+from sympy.polys.sqfreetools import dmp_sqf_part
+f_sqf = dmp_sqf_part(f, u, K)
+print("\nSquare-free part:")
+print("f_sqf:", f_sqf)
+
+# Now compute the square-free norm
+s, g, r = dmp_sqf_norm(f_sqf, u, K)
+print("\nSquare-free norm results:")
+print("s:", s)
+print("g:", g)
+print("r:", r)
+
+# The norm r should be factored in the base domain
+from sympy.polys.factortools import dmp_factor_list_include
+factors_norm = dmp_factor_list_include(r, u, K.dom)
+print("\nFactors of norm in base domain:")
+print("factors_norm:", factors_norm)
+
+# Let's see what the norm polynomial looks like
+# Convert r back to a Poly to understand it
+try:
+    from sympy.polys.polyclasses import DMP
+    if isinstance(r, DMP):
+        # Try to convert back to Poly
+        poly_r = Poly(r.as_expr(), x, y, domain=K.dom)
+        print("\nNorm polynomial:")
+        print("poly_r:", poly_r)
+        print("Factor list of norm:", poly_r.factor_list())
+except Exception as e:
+    print("Error converting norm:", e)
\ No newline at end of file