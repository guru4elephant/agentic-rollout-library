diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..2476fb3c31
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the resolve_lookup_value fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.where import WhereNode
+
+def test_comprehensive():
+    """Test comprehensive scenarios for resolve_lookup_value."""
+    
+    # Create a mock query object
+    query = Query(None, WhereNode)
+    
+    print("Testing resolve_lookup_value fix...")
+    
+    # Test 1: Basic list preservation
+    input_list = [1, 2, 3]
+    result = query.resolve_lookup_value(input_list, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    assert result == [1, 2, 3], f"Expected [1, 2, 3], got {result}"
+    print("âœ“ Basic list preservation test passed")
+    
+    # Test 2: Basic tuple preservation
+    input_tuple = (4, 5, 6)
+    result = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    assert result == (4, 5, 6), f"Expected (4, 5, 6), got {result}"
+    print("âœ“ Basic tuple preservation test passed")
+    
+    # Test 3: Empty collections
+    empty_list = []
+    result = query.resolve_lookup_value(empty_list, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    assert result == [], f"Expected [], got {result}"
+    print("âœ“ Empty list test passed")
+    
+    empty_tuple = ()
+    result = query.resolve_lookup_value(empty_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    assert result == (), f"Expected (), got {result}"
+    print("âœ“ Empty tuple test passed")
+    
+    # Test 4: Single element collections
+    single_list = [42]
+    result = query.resolve_lookup_value(single_list, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    assert result == [42], f"Expected [42], got {result}"
+    print("âœ“ Single element list test passed")
+    
+    single_tuple = (42,)
+    result = query.resolve_lookup_value(single_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    assert result == (42,), f"Expected (42,), got {result}"
+    print("âœ“ Single element tuple test passed")
+    
+    # Test 5: Nested collections (should preserve outer type only)
+    nested_list = [[1, 2], [3, 4]]
+    result = query.resolve_lookup_value(nested_list, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    assert result == [[1, 2], [3, 4]], f"Expected [[1, 2], [3, 4]], got {result}"
+    print("âœ“ Nested list test passed")
+    
+    nested_tuple = ((1, 2), (3, 4))
+    result = query.resolve_lookup_value(nested_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    assert result == ((1, 2), (3, 4)), f"Expected ((1, 2), (3, 4)), got {result}"
+    print("âœ“ Nested tuple test passed")
+    
+    # Test 6: Mixed types in collections
+    mixed_list = [1, "hello", 3.14, True]
+    result = query.resolve_lookup_value(mixed_list, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    assert result == [1, "hello", 3.14, True], f"Expected [1, 'hello', 3.14, True], got {result}"
+    print("âœ“ Mixed type list test passed")
+    
+    mixed_tuple = (1, "hello", 3.14, True)
+    result = query.resolve_lookup_value(mixed_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    assert result == (1, "hello", 3.14, True), f"Expected (1, 'hello', 3.14, True), got {result}"
+    print("âœ“ Mixed type tuple test passed")
+    
+    # Test 7: Non-iterable values (should pass through unchanged)
+    non_iterable = 42
+    result = query.resolve_lookup_value(non_iterable, can_reuse=None, allow_joins=True, simple_col=False)
+    assert result == 42, f"Expected 42, got {result}"
+    print("âœ“ Non-iterable value test passed")
+    
+    non_iterable_str = "hello"
+    result = query.resolve_lookup_value(non_iterable_str, can_reuse=None, allow_joins=True, simple_col=False)
+    assert result == "hello", f"Expected 'hello', got {result}"
+    print("âœ“ Non-iterable string test passed")
+    
+    print("\nðŸŽ‰ All comprehensive tests passed! The fix is working correctly.")
+
+if __name__ == '__main__':
+    test_comprehensive()
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ea51912e8b..ad598e833d 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1073,7 +1073,8 @@ class Query(BaseExpression):
                         ))
                 else:
                     resolved_values.append(sub_value)
-            value = tuple(resolved_values)
+            # Preserve the original iterable type
+            value = type(value)(resolved_values)
         return value
 
     def solve_lookup_type(self, lookup):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..42c7eed83c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where resolve_lookup_value coerces list to tuple.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.datastructures import Empty
+from django.db.models import Q
+from django.db.models.sql.where import WhereNode
+
+def test_resolve_lookup_value():
+    """Test that resolve_lookup_value preserves the input iterable type."""
+    
+    # Create a mock query object with a simple model and WhereNode class
+    query = Query(None, WhereNode)
+    
+    # Test with list input
+    input_list = [1, 2, 3]
+    result = query.resolve_lookup_value(input_list, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"Input type: {type(input_list)}")
+    print(f"Output type: {type(result)}")
+    print(f"Input: {input_list}")
+    print(f"Output: {result}")
+    
+    # Check if type is preserved
+    if type(result) == type(input_list):
+        print("âœ“ SUCCESS: Type is preserved")
+    else:
+        print("âœ— FAILURE: Type is not preserved")
+        print(f"Expected: {type(input_list)}, Got: {type(result)}")
+    
+    # Test with tuple input
+    input_tuple = (4, 5, 6)
+    result_tuple = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nInput type: {type(input_tuple)}")
+    print(f"Output type: {type(result_tuple)}")
+    print(f"Input: {input_tuple}")
+    print(f"Output: {result_tuple}")
+    
+    # Check if type is preserved
+    if type(result_tuple) == type(input_tuple):
+        print("âœ“ SUCCESS: Type is preserved")
+    else:
+        print("âœ— FAILURE: Type is not preserved")
+        print(f"Expected: {type(input_tuple)}, Got: {type(result_tuple)}")
+
+if __name__ == '__main__':
+    test_resolve_lookup_value()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..9ef4f53665
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the resolve_lookup_value fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.where import WhereNode
+
+def test_edge_cases():
+    """Test edge cases for resolve_lookup_value."""
+    
+    # Create a mock query object
+    query = Query(None, WhereNode)
+    
+    # Test with empty list
+    empty_list = []
+    result = query.resolve_lookup_value(empty_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Empty list: {type(result)} - {result}")
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    
+    # Test with empty tuple
+    empty_tuple = ()
+    result = query.resolve_lookup_value(empty_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Empty tuple: {type(result)} - {result}")
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    
+    # Test with single element list
+    single_list = [42]
+    result = query.resolve_lookup_value(single_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Single element list: {type(result)} - {result}")
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    
+    # Test with single element tuple
+    single_tuple = (42,)
+    result = query.resolve_lookup_value(single_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Single element tuple: {type(result)} - {result}")
+    assert type(result) == tuple, f"Expected tuple, got {type(result)}"
+    
+    # Test with nested lists (should not be affected)
+    nested_list = [[1, 2], [3, 4]]
+    result = query.resolve_lookup_value(nested_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Nested list: {type(result)} - {result}")
+    assert type(result) == list, f"Expected list, got {type(result)}"
+    
+    print("All edge case tests passed!")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_pickle_scenario.py b/test_pickle_scenario.py
new file mode 100644
index 0000000000..6d877a55e1
--- /dev/null
+++ b/test_pickle_scenario.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate that the fix addresses the PickledField scenario mentioned in the GitHub issue.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models.sql.query import Query
+from django.db.models.sql.where import WhereNode
+
+def test_pickle_scenario():
+    """
+    Test that demonstrates the fix for the PickledField scenario.
+    
+    The GitHub issue mentions that ORM field types like PickledField
+    are dependent on matching input types. This test verifies that
+    the exact type is preserved.
+    """
+    
+    # Create a mock query object
+    query = Query(None, WhereNode)
+    
+    print("Testing PickledField scenario...")
+    
+    # Simulate a scenario where exact type matching matters
+    # (like in PickledField where list vs tuple might be significant)
+    
+    # Test with a list that should remain a list
+    input_data = [1, 2, 3, {'nested': 'data'}]
+    result = query.resolve_lookup_value(input_data, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"Input type: {type(input_data)}")
+    print(f"Output type: {type(result)}")
+    print(f"Input: {input_data}")
+    print(f"Output: {result}")
+    
+    # The key test: type should be preserved exactly
+    assert type(result) == type(input_data), f"Type not preserved! Expected {type(input_data)}, got {type(result)}"
+    assert result == input_data, f"Content not preserved! Expected {input_data}, got {result}"
+    
+    # Test with a tuple that should remain a tuple
+    input_data_tuple = (1, 2, 3, {'nested': 'data'})
+    result_tuple = query.resolve_lookup_value(input_data_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nInput type: {type(input_data_tuple)}")
+    print(f"Output type: {type(result_tuple)}")
+    print(f"Input: {input_data_tuple}")
+    print(f"Output: {result_tuple}")
+    
+    # The key test: type should be preserved exactly
+    assert type(result_tuple) == type(input_data_tuple), f"Type not preserved! Expected {type(input_data_tuple)}, got {type(result_tuple)}"
+    assert result_tuple == input_data_tuple, f"Content not preserved! Expected {input_data_tuple}, got {result_tuple}"
+    
+    print("\nâœ“ PickledField scenario test passed!")
+    print("âœ“ The fix ensures that exact type matching is preserved for ORM field types")
+    print("âœ“ This addresses the GitHub issue where list inputs were being coerced to tuples")
+
+if __name__ == '__main__':
+    test_pickle_scenario()
\ No newline at end of file