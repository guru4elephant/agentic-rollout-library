diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..2c7a8c00
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+import requests
+import os
+import sys
+
+# Test proxy authentication issue
+print("Python version:", sys.version)
+print("Requests version:", requests.__version__)
+
+# Create a simple test to reproduce the issue
+# We'll use a proxy that requires authentication
+# Note: This is just a test script to understand the behavior
+
+# Test with a proxy URL that has authentication
+proxy_url = "http://user:pass@proxy.example.com:8080"
+url = "https://example.org/"
+
+# Create proxies dict
+proxies = {
+    "http": proxy_url,
+    "https": proxy_url
+}
+
+try:
+    # This should trigger the proxy authentication
+    r = requests.get(url, proxies=proxies, timeout=5)
+    print("Status code:", r.status_code)
+except Exception as e:
+    print("Error:", e)
+    print("Error type:", type(e))
\ No newline at end of file
diff --git a/test_auth_encoding.py b/test_auth_encoding.py
new file mode 100644
index 00000000..a39765f4
--- /dev/null
+++ b/test_auth_encoding.py
@@ -0,0 +1,38 @@
+from base64 import b64encode
+from requests.auth import _basic_auth_str
+from requests._internal_utils import to_native_string
+
+# Test basic authentication encoding
+username = "user"
+password = "pass"
+
+print("Testing basic auth encoding:")
+print("Username:", repr(username))
+print("Password:", repr(password))
+
+# Test the b64encode directly
+auth_bytes = b':'.join([username.encode('latin1'), password.encode('latin1')])
+b64_encoded = b64encode(auth_bytes)
+print("b64encode result:", repr(b64_encoded))
+print("b64encode stripped:", repr(b64_encoded.strip()))
+
+# Test to_native_string
+native_str = to_native_string(b64_encoded.strip())
+print("to_native_string result:", repr(native_str))
+
+# Test the full _basic_auth_str function
+auth_str = _basic_auth_str(username, password)
+print("_basic_auth_str result:", repr(auth_str))
+
+# Test edge cases
+test_cases = [
+    ("user", "pass"),
+    ("", "pass"),  # Empty username
+    ("user", ""),  # Empty password
+    ("", ""),      # Both empty
+]
+
+print("\nTesting edge cases:")
+for user, pwd in test_cases:
+    auth = _basic_auth_str(user, pwd)
+    print(f"  ({repr(user)}, {repr(pwd)}) -> {repr(auth)}")
\ No newline at end of file
diff --git a/test_special_chars.py b/test_special_chars.py
new file mode 100644
index 00000000..1fddf855
--- /dev/null
+++ b/test_special_chars.py
@@ -0,0 +1,42 @@
+from requests.compat import urlparse, unquote
+from requests.utils import get_auth_from_url
+from requests.auth import _basic_auth_str
+
+# Test with special characters that might cause issues in Python 3.8.12
+test_cases = [
+    "http://user:pass@proxy.example.com:8080",
+    "http://user@domain.com:pass@proxy.example.com:8080",  # @ in username
+    "http://user:pass@word@proxy.example.com:8080",      # @ in password
+    "http://user:pass%40word@proxy.example.com:8080",    # URL-encoded @ in password
+    "http://user%40domain.com:pass@proxy.example.com:8080",  # URL-encoded @ in username
+    "http://user:pass%3Aword@proxy.example.com:8080",    # URL-encoded : in password
+    "http://user%3Adomain.com:pass@proxy.example.com:8080",  # URL-encoded : in username
+]
+
+print("Testing URL parsing with special characters:")
+for proxy_url in test_cases:
+    print(f"\nTesting: {proxy_url}")
+    try:
+        parsed = urlparse(proxy_url)
+        print(f"  Parsed URL: {parsed}")
+        print(f"  Username: {repr(parsed.username)}")
+        print(f"  Password: {repr(parsed.password)}")
+        
+        auth = get_auth_from_url(proxy_url)
+        print(f"  Auth from URL: {auth}")
+        
+        if auth[0] or auth[1]:
+            auth_str = _basic_auth_str(auth[0], auth[1])
+            print(f"  Auth string: {repr(auth_str)}")
+        else:
+            print("  No authentication credentials")
+            
+    except Exception as e:
+        print(f"  Error: {e}")
+        print(f"  Error type: {type(e)}")
+
+# Test URL decoding behavior
+print("\n\nTesting URL decoding behavior:")
+test_encoded = "user%40domain.com:pass%40word"
+print(f"Original: {test_encoded}")
+print(f"Unquoted: {unquote(test_encoded)}")
\ No newline at end of file
diff --git a/test_url_parsing.py b/test_url_parsing.py
new file mode 100644
index 00000000..c422f935
--- /dev/null
+++ b/test_url_parsing.py
@@ -0,0 +1,31 @@
+from requests.compat import urlparse
+from requests.utils import get_auth_from_url
+
+# Test URL parsing with authentication
+proxy_url = "http://user:pass@proxy.example.com:8080"
+
+print("Testing URL parsing:")
+parsed = urlparse(proxy_url)
+print("Parsed URL:", parsed)
+print("Username:", parsed.username)
+print("Password:", parsed.password)
+
+print("\nTesting get_auth_from_url:")
+auth = get_auth_from_url(proxy_url)
+print("Auth tuple:", auth)
+
+# Test edge cases
+test_urls = [
+    "http://user@proxy.example.com:8080",  # Only username
+    "http://:pass@proxy.example.com:8080", # Only password
+    "http://proxy.example.com:8080",       # No auth
+    "http://user:pass@proxy.example.com",  # No port
+]
+
+print("\nTesting various URL formats:")
+for test_url in test_urls:
+    parsed = urlparse(test_url)
+    auth = get_auth_from_url(test_url)
+    print(f"URL: {test_url}")
+    print(f"  Parsed: {parsed}")
+    print(f"  Auth: {auth}")
\ No newline at end of file