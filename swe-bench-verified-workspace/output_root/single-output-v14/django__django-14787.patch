diff --git a/django/utils/decorators.py b/django/utils/decorators.py
index 5c9a5d01c7..634bccaf4e 100644
--- a/django/utils/decorators.py
+++ b/django/utils/decorators.py
@@ -38,6 +38,8 @@ def _multi_decorate(decorators, method):
         # 'func'. Also, wrap method.__get__() in a function because new
         # attributes can't be set on bound method objects, only on functions.
         bound_method = partial(method.__get__(self, type(self)))
+        # Preserve function attributes from the original method
+        update_wrapper(bound_method, method)
         for dec in decorators:
             bound_method = dec(bound_method)
         return bound_method(*args, **kwargs)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..97341e0776
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+import logging
+from functools import wraps
+from django.utils.decorators import method_decorator
+
+# Set up logging
+logging.basicConfig(level=logging.DEBUG)
+
+def logger(func):
+    @wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            logging.debug(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+
+# Test the issue
+try:
+    test_instance = Test()
+    result = test_instance.hello_world()
+    print(f"Result: {result}")
+except Exception as e:
+    print(f"Error: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_complex_scenario.py b/test_complex_scenario.py
new file mode 100644
index 0000000000..3989f5c57d
--- /dev/null
+++ b/test_complex_scenario.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+import logging
+from functools import wraps
+from django.utils.decorators import method_decorator
+
+# Set up logging
+logging.basicConfig(level=logging.DEBUG)
+
+def logger(func):
+    """A decorator that logs function calls"""
+    @wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            logging.debug(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+def timer(func):
+    """A decorator that adds timing functionality"""
+    @wraps(func)
+    def inner(*args, **kwargs):
+        import time
+        start = time.time()
+        result = func(*args, **kwargs)
+        end = time.time()
+        logging.debug(f"{func.__name__} took {end - start:.6f} seconds")
+        return result
+    return inner
+
+def add_attribute(attr_name, attr_value):
+    """A decorator factory that adds attributes to functions"""
+    def decorator(func):
+        setattr(func, attr_name, attr_value)
+        return func
+    return decorator
+
+class TestClass:
+    @method_decorator(logger)
+    @method_decorator(timer)
+    @method_decorator(add_attribute('version', '1.0'))
+    def complex_method(self, x, y=10):
+        """A complex method with multiple decorators"""
+        return x * y
+
+def test_complex_scenario():
+    """Test that the fix works with multiple decorators and complex scenarios"""
+    test_instance = TestClass()
+    
+    # Test that the method works
+    result = test_instance.complex_method(5)
+    assert result == 50, f"Expected 50, got {result}"
+    
+    # Test that the method has the correct attributes
+    method = test_instance.complex_method
+    assert hasattr(method, '__name__'), "Method should have __name__ attribute"
+    assert method.__name__ == 'complex_method', f"Expected 'complex_method', got {method.__name__}"
+    
+    assert hasattr(method, '__doc__'), "Method should have __doc__ attribute"
+    assert method.__doc__ == "A complex method with multiple decorators", f"Unexpected docstring: {method.__doc__}"
+    
+    assert hasattr(method, 'version'), "Method should have 'version' attribute from decorator"
+    assert method.version == '1.0', f"Expected '1.0', got {method.version}"
+    
+    assert hasattr(method, '__module__'), "Method should have __module__ attribute"
+    
+    print("All complex scenario tests passed!")
+
+if __name__ == "__main__":
+    test_complex_scenario()
+    print("Complex scenario test completed successfully!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..ef39e86c1c
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+import logging
+from functools import wraps
+from django.utils.decorators import method_decorator
+
+# Set up logging
+logging.basicConfig(level=logging.DEBUG)
+
+def logger(func):
+    @wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # Test multiple function attributes
+            logging.debug(f"Function name: {func.__name__}")
+            logging.debug(f"Function module: {func.__module__}")
+            logging.debug(f"Function doc: {func.__doc__}")
+            logging.debug(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        """A test method that returns hello"""
+        return "hello"
+    
+    @method_decorator(logger)
+    def method_with_args(self, arg1, arg2):
+        """A test method with arguments"""
+        return f"{arg1} {arg2}"
+
+# Test basic functionality
+print("Testing basic functionality:")
+test_instance = Test()
+result = test_instance.hello_world()
+print(f"Result: {result}")
+
+# Test method with arguments
+print("\nTesting method with arguments:")
+result = test_instance.method_with_args("hello", "world")
+print(f"Result: {result}")
+
+# Test multiple decorators
+def simple_decorator(func):
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        print(f"Simple decorator: {func.__name__}")
+        return func(*args, **kwargs)
+    return wrapper
+
+class MultipleDecorators:
+    @method_decorator(logger)
+    @method_decorator(simple_decorator)
+    def decorated_method(self):
+        """Method with multiple decorators"""
+        return "decorated result"
+
+print("\nTesting multiple decorators:")
+multi_instance = MultipleDecorators()
+result = multi_instance.decorated_method()
+print(f"Result: {result}")
\ No newline at end of file
diff --git a/test_wrapper_attributes.py b/test_wrapper_attributes.py
new file mode 100644
index 0000000000..e770078101
--- /dev/null
+++ b/test_wrapper_attributes.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+import logging
+from functools import wraps
+from django.utils.decorators import method_decorator
+
+# Set up logging
+logging.basicConfig(level=logging.DEBUG)
+
+def logger(func):
+    """A decorator that expects func to have __name__ attribute"""
+    @wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # This will fail if func doesn't have __name__ attribute
+            logging.debug(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        """A test method that returns hello"""
+        return "hello"
+
+def test_function_attributes():
+    """Test that the wrapped function preserves all function attributes"""
+    test_instance = Test()
+    
+    # Test that the method works
+    result = test_instance.hello_world()
+    assert result == "hello", f"Expected 'hello', got {result}"
+    
+    # Test that the method has the correct attributes
+    method = test_instance.hello_world
+    assert hasattr(method, '__name__'), "Method should have __name__ attribute"
+    assert method.__name__ == 'hello_world', f"Expected 'hello_world', got {method.__name__}"
+    
+    assert hasattr(method, '__doc__'), "Method should have __doc__ attribute"
+    assert method.__doc__ == "A test method that returns hello", f"Unexpected docstring: {method.__doc__}"
+    
+    assert hasattr(method, '__module__'), "Method should have __module__ attribute"
+    
+    print("All function attribute tests passed!")
+
+if __name__ == "__main__":
+    test_function_attributes()
+    print("Test completed successfully!")
\ No newline at end of file