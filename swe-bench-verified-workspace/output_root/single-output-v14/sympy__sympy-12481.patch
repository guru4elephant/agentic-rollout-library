diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..940d98ef8d
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+print("=== FINAL TEST: Verifying the original issue is fixed ===")
+
+# The original issue: Permutation([[0,1],[0,1]]) should work and be identity
+print("\n1. Original issue test:")
+try:
+    p = Permutation([[0, 1], [0, 1]])
+    print("✓ SUCCESS: Permutation([[0,1],[0,1]]) =", p)
+    print("  Array form:", p.array_form)
+    print("  Expected: [0, 1] (identity permutation)")
+    
+    # Verify it's actually the identity
+    identity = Permutation([0, 1])
+    if p == identity:
+        print("  ✓ CONFIRMED: It is indeed the identity permutation!")
+    else:
+        print("  ✗ ERROR: Expected identity but got something else")
+        
+except Exception as e:
+    print("✗ FAILED:", e)
+
+# Test additional non-disjoint cycle cases
+print("\n2. Additional non-disjoint cycle tests:")
+
+# Test case 1: (0 1)(1 2) = (0 1 2)
+try:
+    p1 = Permutation([[0, 1], [1, 2]])
+    print("✓ Permutation([[0,1],[1,2]]) =", p1)
+    print("  Array form:", p1.array_form)
+    print("  Expected: [1, 2, 0] (0->1->2->0)")
+except Exception as e:
+    print("✗ FAILED:", e)
+
+# Test case 2: (0 1)(0 1)(0 1) = (0 1) (three swaps = one swap)
+try:
+    p2 = Permutation([[0, 1], [0, 1], [0, 1]])
+    print("✓ Permutation([[0,1],[0,1],[0,1]]) =", p2)
+    print("  Array form:", p2.array_form)
+    print("  Expected: [1, 0] (single swap)")
+except Exception as e:
+    print("✗ FAILED:", e)
+
+# Test case 3: Mixed disjoint and non-disjoint
+try:
+    p3 = Permutation([[0, 1], [0, 1], [2, 3]])
+    print("✓ Permutation([[0,1],[0,1],[2,3]]) =", p3)
+    print("  Array form:", p3.array_form)
+    print("  Expected: [0, 1, 3, 2] (identity on 0,1, swap 2,3)")
+except Exception as e:
+    print("✗ FAILED:", e)
+
+print("\n3. Verification that validation still works:")
+
+# Should still fail: duplicate elements within a single cycle
+try:
+    p_bad = Permutation([[0, 1, 0]])
+    print("✗ ERROR: Should have failed but got:", p_bad)
+except ValueError:
+    print("✓ SUCCESS: Validation correctly prevents duplicate elements within a cycle")
+
+print("\n=== TEST COMPLETE ===")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b7f6175c79
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+# Test case from the issue
+try:
+    p = Permutation([[0,1],[0,1]])
+    print("Success:", p)
+except ValueError as e:
+    print("Error:", e)
+
+# Additional test cases
+try:
+    p2 = Permutation([[0,1],[1,2]])
+    print("Success:", p2)
+except ValueError as e:
+    print("Error:", e)
+
+try:
+    p3 = Permutation([[0,1],[0,1],[2,3]])
+    print("Success:", p3)
+except ValueError as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..d20073266e 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -12,6 +12,47 @@
 from mpmath.libmp.libintmath import ifac
 
 
+def _compose_cycles(cycles):
+    """
+    Compose multiple cycles (even with overlapping elements) and return
+    the resulting permutation in array form.
+    
+    Cycles are applied from left to right: the first cycle is applied first,
+    then the second, and so on.
+    
+    Examples
+    ========
+    
+    >>> _compose_cycles([[0, 1], [0, 1]])
+    [0, 1, 2]
+    >>> _compose_cycles([[0, 1], [1, 2]])
+    [2, 0, 1]
+    """
+    # Find the maximum element across all cycles to determine the size
+    max_element = max(flatten(cycles)) if cycles else 0
+    size = max_element + 1
+    
+    # Start with the identity permutation
+    result = list(range(size))
+    
+    # Apply each cycle from left to right
+    for cycle in cycles:
+        # Create a temporary copy to apply the cycle
+        temp = result[:]
+        
+        # Apply the current cycle to the result
+        n = len(cycle)
+        for i in range(n):
+            # The cycle (a b c ...) maps a->b, b->c, ..., last->first
+            from_idx = cycle[i]
+            to_idx = cycle[(i + 1) % n]
+            temp[from_idx] = result[to_idx]
+        
+        result = temp
+    
+    return result
+
+
 def _af_rmul(a, b):
     """
     Return the product b*a; input and output are array forms. The ith value
@@ -894,14 +935,17 @@ def __new__(cls, *args, **kwargs):
         # for convenience in case one wants to enter permutations where
         # counting starts from 1.
 
-        temp = flatten(args)
-        if has_dups(temp):
-            if is_cycle:
-                raise ValueError('there were repeated elements; to resolve '
-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))
-            else:
+        # Check for duplicates within individual cycles, but allow duplicates across cycles
+        if is_cycle:
+            for cycle in args:
+                if has_dups(cycle):
+                    raise ValueError('All elements must be unique in a cycle.')
+            temp = set(flatten(args))
+        else:
+            temp = flatten(args)
+            if has_dups(temp):
                 raise ValueError('there were repeated elements.')
-        temp = set(temp)
+            temp = set(temp)
 
         if not is_cycle and \
                 any(i not in temp for i in range(len(temp))):
@@ -911,10 +955,7 @@ def __new__(cls, *args, **kwargs):
         if is_cycle:
             # it's not necessarily canonical so we won't store
             # it -- use the array form instead
-            c = Cycle()
-            for ci in args:
-                c = c(*ci)
-            aform = c.list()
+            aform = _compose_cycles(args)
         else:
             aform = list(args)
         if size and size > len(aform):
diff --git a/test_basic_functionality.py b/test_basic_functionality.py
new file mode 100644
index 0000000000..703f68f8f9
--- /dev/null
+++ b/test_basic_functionality.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+print("Testing basic permutation functionality:")
+
+# Test 1: Basic permutation creation
+print("\n1. Basic permutation creation:")
+p1 = Permutation([0, 1, 2])
+print("Permutation([0, 1, 2]):", p1)
+print("Array form:", p1.array_form)
+
+# Test 2: Cycle notation
+print("\n2. Cycle notation:")
+p2 = Permutation([[0, 1]])
+print("Permutation([[0, 1]]):", p2)
+print("Array form:", p2.array_form)
+
+# Test 3: Disjoint cycles
+print("\n3. Disjoint cycles:")
+p3 = Permutation([[0, 1], [2, 3]])
+print("Permutation([[0, 1], [2, 3]]):", p3)
+print("Array form:", p3.array_form)
+
+# Test 4: Permutation multiplication
+print("\n4. Permutation multiplication:")
+p4 = Permutation([1, 0, 2])
+p5 = Permutation([0, 2, 1])
+p6 = p4 * p5
+print("Permutation([1, 0, 2]) * Permutation([0, 2, 1]):", p6)
+print("Array form:", p6.array_form)
+
+# Test 5: Permutation inversion
+print("\n5. Permutation inversion:")
+p7 = Permutation([1, 2, 0])
+p8 = p7**-1
+print("Inverse of Permutation([1, 2, 0]):", p8)
+print("Array form:", p8.array_form)
+
+# Test 6: Identity permutation
+print("\n6. Identity permutation:")
+p9 = Permutation([])
+print("Permutation([]):", p9)
+print("Array form:", p9.array_form)
+
+print("\nBasic functionality tests completed!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..aef7c5adca
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+print("Testing edge cases for non-disjoint cycles:")
+
+# Test 1: Multiple overlapping cycles
+print("\n1. Multiple overlapping cycles:")
+p1 = Permutation([[0, 1], [1, 2], [2, 3]])
+print("Permutation([[0, 1], [1, 2], [2, 3]]):", p1)
+print("Array form:", p1.array_form)
+print("Expected: [3, 0, 1, 2] (0->3->2->1->0)")
+
+# Test 2: Three cycles with the same elements
+print("\n2. Three cycles with same elements:")
+p2 = Permutation([[0, 1], [0, 1], [0, 1]])
+print("Permutation([[0, 1], [0, 1], [0, 1]]):", p2)
+print("Array form:", p2.array_form)
+print("Expected: [1, 0] (three swaps = one swap)")
+
+# Test 3: Mixed disjoint and non-disjoint cycles
+print("\n3. Mixed disjoint and non-disjoint cycles:")
+p3 = Permutation([[0, 1], [0, 1], [2, 3], [4, 5]])
+print("Permutation([[0, 1], [0, 1], [2, 3], [4, 5]]):", p3)
+print("Array form:", p3.array_form)
+print("Expected: [0, 1, 3, 2, 5, 4] (identity on 0,1, swap 2,3, swap 4,5)")
+
+# Test 4: Single element cycles (should be identity)
+print("\n4. Single element cycles:")
+p4 = Permutation([[0], [1], [2]])
+print("Permutation([[0], [1], [2]]):", p4)
+print("Array form:", p4.array_form)
+print("Expected: [0, 1, 2] (identity)")
+
+# Test 5: Empty cycles
+print("\n5. Empty cycles:")
+p5 = Permutation([])
+print("Permutation([]):", p5)
+print("Array form:", p5.array_form)
+print("Expected: [] (empty permutation)")
+
+print("\nAll edge case tests completed!")
\ No newline at end of file
diff --git a/test_results.py b/test_results.py
new file mode 100644
index 0000000000..eb0d732a29
--- /dev/null
+++ b/test_results.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+# Test case from the issue: Permutation([[0,1],[0,1]]) should be identity
+p1 = Permutation([[0,1],[0,1]])
+print("Permutation([[0,1],[0,1]]):", p1)
+print("Array form:", p1.array_form)
+print("Expected: [0, 1] (identity)")
+print()
+
+# Test case: Permutation([[0,1],[1,2]]) should be (0 1 2)
+p2 = Permutation([[0,1],[1,2]])
+print("Permutation([[0,1],[1,2]]):", p2)
+print("Array form:", p2.array_form)
+print("Expected: [2, 0, 1] (0->2->1->0)")
+print()
+
+# Test case: Permutation([[0,1],[0,1],[2,3]]) should be (2 3)
+p3 = Permutation([[0,1],[0,1],[2,3]])
+print("Permutation([[0,1],[0,1],[2,3]]):", p3)
+print("Array form:", p3.array_form)
+print("Expected: [0, 1, 3, 2] (identity on 0,1 and swap 2,3)")
+print()
+
+# Test that disjoint cycles still work
+p4 = Permutation([[0,1],[2,3]])
+print("Permutation([[0,1],[2,3]]):", p4)
+print("Array form:", p4.array_form)
+print("Expected: [1, 0, 3, 2] (swap 0,1 and swap 2,3)")
+print()
+
+# Test edge case: empty cycles
+p5 = Permutation([])
+print("Permutation([]):", p5)
+print("Array form:", p5.array_form)
+print("Expected: [] (empty permutation)")
\ No newline at end of file
diff --git a/test_validation.py b/test_validation.py
new file mode 100644
index 0000000000..08a6dbda68
--- /dev/null
+++ b/test_validation.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+print("Testing validation for invalid cycles:")
+
+# Test 1: Duplicate elements within a single cycle (should fail)
+print("\n1. Duplicate elements within a single cycle:")
+try:
+    p1 = Permutation([[0, 1, 0]])
+    print("ERROR: Should have failed but got:", p1)
+except ValueError as e:
+    print("SUCCESS: Correctly failed with:", e)
+
+# Test 2: Duplicate elements within a single cycle (different case)
+print("\n2. Another duplicate elements within a single cycle:")
+try:
+    p2 = Permutation([[0, 1, 1]])
+    print("ERROR: Should have failed but got:", p2)
+except ValueError as e:
+    print("SUCCESS: Correctly failed with:", e)
+
+# Test 3: Valid non-disjoint cycles (should succeed)
+print("\n3. Valid non-disjoint cycles:")
+try:
+    p3 = Permutation([[0, 1], [0, 1]])
+    print("SUCCESS: Valid non-disjoint cycles work:", p3)
+except ValueError as e:
+    print("ERROR: Should have succeeded but failed with:", e)
+
+# Test 4: Valid disjoint cycles (should succeed)
+print("\n4. Valid disjoint cycles:")
+try:
+    p4 = Permutation([[0, 1], [2, 3]])
+    print("SUCCESS: Valid disjoint cycles work:", p4)
+except ValueError as e:
+    print("ERROR: Should have succeeded but failed with:", e)
+
+print("\nValidation tests completed!")
\ No newline at end of file