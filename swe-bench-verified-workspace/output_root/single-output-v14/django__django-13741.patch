diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py
index b9eb33329f..9a6614a809 100644
--- a/django/contrib/auth/forms.py
+++ b/django/contrib/auth/forms.py
@@ -56,6 +56,7 @@ class ReadOnlyPasswordHashField(forms.Field):
 
     def __init__(self, *args, **kwargs):
         kwargs.setdefault("required", False)
+        kwargs.setdefault("disabled", True)
         super().__init__(*args, **kwargs)
 
     def bound_data(self, data, initial):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..62b74364c4
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.auth.forms import UserChangeForm, ReadOnlyPasswordHashField
+from django.contrib.auth.models import User
+
+def test_readonly_password_hash_field():
+    print("Testing ReadOnlyPasswordHashField...")
+    
+    # Create a field instance
+    field = ReadOnlyPasswordHashField()
+    
+    # Check if disabled attribute is set
+    print(f"Field disabled attribute: {getattr(field, 'disabled', 'NOT SET')}")
+    
+    # Test the bound_data method behavior
+    initial_value = "test_initial_value"
+    submitted_data = "tampered_value"
+    
+    result = field.bound_data(submitted_data, initial_value)
+    print(f"bound_data('{submitted_data}', '{initial_value}') = '{result}'")
+    
+    # Test has_changed method
+    changed = field.has_changed(initial_value, submitted_data)
+    print(f"has_changed('{initial_value}', '{submitted_data}') = {changed}")
+
+def test_user_change_form():
+    print("\nTesting UserChangeForm...")
+    
+    # Create form without instance to avoid database operations
+    form = UserChangeForm()
+    
+    # Check the password field
+    password_field = form.fields['password']
+    print(f"Password field disabled attribute: {getattr(password_field, 'disabled', 'NOT SET')}")
+    
+    # Test the clean_password method
+    form.initial = {'password': 'initial_password_hash'}
+    cleaned_password = form.clean_password()
+    print(f"clean_password() returns: '{cleaned_password}'")
+
+if __name__ == '__main__':
+    test_readonly_password_hash_field()
+    # Skip UserChangeForm test for now to avoid database setup issues
+    # test_user_change_form()
\ No newline at end of file
diff --git a/run_auth_tests.py b/run_auth_tests.py
new file mode 100644
index 0000000000..ea77bb91fc
--- /dev/null
+++ b/run_auth_tests.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings for testing
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sites',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.test.utils import get_runner
+from django.conf import settings
+
+def run_tests():
+    """Run the auth form tests"""
+    TestRunner = get_runner(settings)
+    test_runner = TestRunner(verbosity=2)
+    failures = test_runner.run_tests(['tests.auth_tests.test_forms'])
+    return failures
+
+if __name__ == '__main__':
+    failures = run_tests()
+    sys.exit(bool(failures))
\ No newline at end of file
diff --git a/test_disabled_behavior.py b/test_disabled_behavior.py
new file mode 100644
index 0000000000..c9bfe25a2a
--- /dev/null
+++ b/test_disabled_behavior.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.contrib.auth.forms import ReadOnlyPasswordHashField
+
+def test_disabled_field_behavior():
+    """Test that disabled fields ignore submitted data and use initial data"""
+    print("Testing disabled field behavior...")
+    
+    # Create a disabled field
+    field = ReadOnlyPasswordHashField()
+    print(f"Field disabled: {field.disabled}")
+    
+    # Test with different scenarios
+    test_cases = [
+        ("initial_hash", "tampered_hash"),
+        ("", "malicious_hash"),
+        (None, "some_hash"),
+    ]
+    
+    for initial, submitted in test_cases:
+        result = field.bound_data(submitted, initial)
+        print(f"bound_data('{submitted}', '{initial}') = '{result}'")
+        
+        changed = field.has_changed(initial, submitted)
+        print(f"has_changed('{initial}', '{submitted}') = {changed}")
+        print()
+
+def test_field_construction():
+    """Test that the field can be constructed with different parameters"""
+    print("Testing field construction...")
+    
+    # Test default construction
+    field1 = ReadOnlyPasswordHashField()
+    print(f"Default field - disabled: {field1.disabled}, required: {field1.required}")
+    
+    # Test explicitly setting disabled to False (should override default)
+    field2 = ReadOnlyPasswordHashField(disabled=False)
+    print(f"Explicit disabled=False - disabled: {field2.disabled}, required: {field2.required}")
+    
+    # Test explicitly setting disabled to True
+    field3 = ReadOnlyPasswordHashField(disabled=True)
+    print(f"Explicit disabled=True - disabled: {field3.disabled}, required: {field3.required}")
+    
+    # Test with required parameter
+    field4 = ReadOnlyPasswordHashField(required=True)
+    print(f"Required=True - disabled: {field4.disabled}, required: {field4.required}")
+
+if __name__ == '__main__':
+    test_disabled_field_behavior()
+    test_field_construction()
\ No newline at end of file
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 0000000000..308a6a641e
--- /dev/null
+++ b/test_final_verification.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField, UserChangeForm
+from django.contrib.auth.models import User
+
+def test_readonly_password_hash_field_disabled():
+    """Test that ReadOnlyPasswordHashField has disabled=True by default"""
+    print("Testing ReadOnlyPasswordHashField disabled attribute...")
+    
+    field = ReadOnlyPasswordHashField()
+    assert field.disabled == True, f"Expected disabled=True, got {field.disabled}"
+    print("✓ ReadOnlyPasswordHashField has disabled=True by default")
+    
+    # Test that we can still override it
+    field_override = ReadOnlyPasswordHashField(disabled=False)
+    assert field_override.disabled == False, f"Expected disabled=False, got {field_override.disabled}"
+    print("✓ Can override disabled parameter")
+
+def test_field_behavior():
+    """Test that the field behaves correctly when disabled"""
+    print("\nTesting field behavior...")
+    
+    field = ReadOnlyPasswordHashField()
+    initial_value = "pbkdf2_sha256$260000$abc123$hashedpassword123"
+    submitted_value = "tampered_password_value"
+    
+    # Test bound_data - should return initial value regardless of submitted data
+    result = field.bound_data(submitted_value, initial_value)
+    assert result == initial_value, f"Expected '{initial_value}', got '{result}'"
+    print("✓ bound_data() returns initial value")
+    
+    # Test has_changed - should always return False for disabled fields
+    changed = field.has_changed(initial_value, submitted_value)
+    assert changed == False, f"Expected False, got {changed}"
+    print("✓ has_changed() returns False")
+
+def test_user_change_form_integration():
+    """Test that UserChangeForm works with the disabled password field"""
+    print("\nTesting UserChangeForm integration...")
+    
+    # Create a form instance
+    form = UserChangeForm()
+    
+    # Check that the password field is disabled
+    password_field = form.fields['password']
+    assert hasattr(password_field, 'disabled'), "Password field should have disabled attribute"
+    print("✓ Password field has disabled attribute")
+    
+    # The field should be disabled (our fix)
+    assert password_field.disabled == True, f"Expected disabled=True, got {password_field.disabled}"
+    print("✓ Password field is disabled")
+    
+    # Test the clean_password method still works
+    form.initial = {'password': 'test_initial_password_hash'}
+    cleaned_password = form.clean_password()
+    assert cleaned_password == 'test_initial_password_hash', f"Expected 'test_initial_password_hash', got '{cleaned_password}'"
+    print("✓ clean_password() method works correctly")
+
+def main():
+    """Run all tests"""
+    try:
+        test_readonly_password_hash_field_disabled()
+        test_field_behavior()
+        test_user_change_form_integration()
+        print("\n🎉 All tests passed! The fix is working correctly.")
+        return 0
+    except AssertionError as e:
+        print(f"\n❌ Test failed: {e}")
+        return 1
+    except Exception as e:
+        print(f"\n💥 Unexpected error: {e}")
+        return 1
+
+if __name__ == '__main__':
+    sys.exit(main())
\ No newline at end of file
diff --git a/test_github_issue_fix.py b/test_github_issue_fix.py
new file mode 100644
index 0000000000..29ebd1d283
--- /dev/null
+++ b/test_github_issue_fix.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate that the GitHub issue is fixed:
+"Set disabled prop on ReadOnlyPasswordHashField"
+
+This test shows that:
+1. ReadOnlyPasswordHashField now has disabled=True by default
+2. The field ignores tampered submitted data and uses initial data
+3. The HTML disabled attribute prevents user editing
+4. The clean_password method in UserChangeForm can potentially be removed
+   (though we keep it for backward compatibility)
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField, UserChangeForm
+
+def test_github_issue_fix():
+    """Test that addresses the specific GitHub issue"""
+    print("🔧 Testing GitHub Issue Fix: Set disabled prop on ReadOnlyPasswordHashField")
+    print("=" * 70)
+    
+    # Test 1: ReadOnlyPasswordHashField has disabled=True by default
+    print("\n1. Testing ReadOnlyPasswordHashField disabled property:")
+    field = ReadOnlyPasswordHashField()
+    assert field.disabled == True, f"Field should be disabled by default, got {field.disabled}"
+    print("   ✓ Field has disabled=True by default")
+    
+    # Test 2: Field ignores tampered submitted data
+    print("\n2. Testing field ignores tampered data:")
+    initial_password = "pbkdf2_sha256$260000$abc123$securehashedpassword"
+    tampered_password = "malicious_password_attempt"
+    
+    result = field.bound_data(tampered_password, initial_password)
+    assert result == initial_password, f"Field should return initial value, got {result}"
+    print("   ✓ Field ignores tampered data and returns initial value")
+    
+    # Test 3: Field reports no changes (has_changed returns False)
+    changed = field.has_changed(initial_password, tampered_password)
+    assert changed == False, f"Field should report no changes, got {changed}"
+    print("   ✓ Field correctly reports no changes occurred")
+    
+    # Test 4: UserChangeForm password field is disabled
+    print("\n3. Testing UserChangeForm integration:")
+    form = UserChangeForm()
+    password_field = form.fields['password']
+    assert password_field.disabled == True, f"Password field should be disabled, got {password_field.disabled}"
+    print("   ✓ UserChangeForm password field is disabled")
+    
+    # Test 5: clean_password method still works (backward compatibility)
+    form.initial = {'password': 'initial_hashed_password'}
+    cleaned = form.clean_password()
+    assert cleaned == 'initial_hashed_password', f"clean_password should return initial value, got {cleaned}"
+    print("   ✓ clean_password method works (backward compatibility)")
+    
+    print("\n" + "=" * 70)
+    print("🎉 SUCCESS: GitHub issue is fully addressed!")
+    print("\nThe ReadOnlyPasswordHashField now:")
+    print("  • Has disabled=True by default")
+    print("  • Ignores tampered submitted data")
+    print("  • Uses the HTML disabled attribute to prevent user editing")
+    print("  • Makes the clean_password method in UserChangeForm redundant")
+    print("  • Removes the potential pitfall mentioned in the issue")
+    
+    return True
+
+def test_backward_compatibility():
+    """Test that existing code still works"""
+    print("\n🧪 Testing backward compatibility:")
+    
+    # Can still explicitly set disabled=False if needed
+    field = ReadOnlyPasswordHashField(disabled=False)
+    assert field.disabled == False, "Should be able to override disabled parameter"
+    print("   ✓ Can still set disabled=False explicitly")
+    
+    # Required parameter still works
+    field = ReadOnlyPasswordHashField(required=True)
+    assert field.required == True, "Required parameter should work"
+    assert field.disabled == True, "Disabled should still be True by default"
+    print("   ✓ Other parameters (required) work correctly")
+    
+    print("   ✓ Backward compatibility maintained")
+
+if __name__ == '__main__':
+    try:
+        success = test_github_issue_fix()
+        test_backward_compatibility()
+        if success:
+            print("\n✅ All tests passed! The fix is complete and working.")
+            sys.exit(0)
+        else:
+            print("\n❌ Tests failed!")
+            sys.exit(1)
+    except Exception as e:
+        print(f"\n💥 Error during testing: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
\ No newline at end of file