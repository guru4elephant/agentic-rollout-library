diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..8445ad97
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,15 @@
+import xarray as xr
+
+good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])
+
+class HasValues(object):
+    values = 5
+    
+good_indexed.loc[{'dim_0': 0}] = set()
+bad_indexed.loc[{'dim_0': 0}] = HasValues()
+
+print("good_indexed.values:", good_indexed.values)
+print("bad_indexed.values:", bad_indexed.values)
+
+# Expected: bad_indexed.values should be array([<__main__.HasValues instance>], dtype=object)
+# Current incorrect behavior: bad_indexed.values => array([array(5)], dtype=object)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..a28bf4ce
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,65 @@
+import xarray as xr
+import pandas as pd
+import numpy as np
+
+# Test 1: Original issue - objects with values property should not be coerced
+print("Test 1: Objects with values property")
+good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])
+
+class HasValues(object):
+    values = 5
+    
+good_indexed.loc[{'dim_0': 0}] = set()
+bad_indexed.loc[{'dim_0': 0}] = HasValues()
+
+print("good_indexed.values:", good_indexed.values)
+print("bad_indexed.values:", bad_indexed.values)
+print("Type of bad_indexed.values[0]:", type(bad_indexed.values[0]))
+print()
+
+# Test 2: Pandas objects should still work correctly
+print("Test 2: Pandas objects")
+series = pd.Series([1])
+df = pd.DataFrame({'a': [1], 'b': [4]})
+
+da_series = xr.DataArray([None])
+da_df = xr.DataArray([None])
+
+da_series.loc[{'dim_0': 0}] = series
+da_df.loc[{'dim_0': 0}] = df
+
+print("da_series.values:", da_series.values)
+print("da_df.values:", da_df.values)
+print("Type of da_series.values[0]:", type(da_series.values[0]))
+print("Type of da_df.values[0]:", type(da_df.values[0]))
+print()
+
+# Test 3: Xarray objects should still work correctly
+print("Test 3: Xarray objects")
+other_da = xr.DataArray([10])
+ds = xr.Dataset({'var': ('x', [1])})
+
+da_other = xr.DataArray([None])
+da_ds = xr.DataArray([None])
+
+da_other.loc[{'dim_0': 0}] = other_da
+da_ds.loc[{'dim_0': 0}] = ds
+
+print("da_other.values:", da_other.values)
+print("da_ds.values:", da_ds.values)
+print("Type of da_other.values[0]:", type(da_other.values[0]))
+print("Type of da_ds.values[0]:", type(da_ds.values[0]))
+print()
+
+# Test 4: Regular numpy arrays and scalars should still work
+print("Test 4: Regular numpy arrays and scalars")
+da_numpy = xr.DataArray([None])
+da_scalar = xr.DataArray([None])
+
+da_numpy.loc[{'dim_0': 0}] = np.array([1])
+da_scalar.loc[{'dim_0': 0}] = 42
+
+print("da_numpy.values:", da_numpy.values)
+print("da_scalar.values:", da_scalar.values)
+print("Type of da_numpy.values[0]:", type(da_numpy.values[0]))
+print("Type of da_scalar.values[0]:", type(da_scalar.values[0]))
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..7ea7b06e
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,61 @@
+import xarray as xr
+import pandas as pd
+import numpy as np
+
+print("=== Testing edge cases for objects with .values property ===")
+
+# Test case 1: Object with .values property that should NOT be coerced
+class ModelResult:
+    """Simulates lmfit.ModelResult object mentioned in the issue"""
+    def __init__(self, fit_value):
+        self.values = fit_value  # This should NOT be extracted
+        self.params = {"a": 1, "b": 2}
+        
+    def __repr__(self):
+        return f"ModelResult(values={self.values})"
+
+# Test case 2: Object with .values property that should NOT be coerced  
+class CustomObject:
+    values = "should not be coerced"
+    
+    def __repr__(self):
+        return f"CustomObject({self.values})"
+
+# Test case 3: Object without .values property (should work as before)
+class RegularObject:
+    def __init__(self, value):
+        self.value = value
+        
+    def __repr__(self):
+        return f"RegularObject({self.value})"
+
+# Create DataArrays
+da1 = xr.DataArray([None])
+da2 = xr.DataArray([None]) 
+da3 = xr.DataArray([None])
+
+# Assign objects
+model_result = ModelResult(42)
+custom_obj = CustomObject()
+regular_obj = RegularObject("test")
+
+da1.loc[{'dim_0': 0}] = model_result
+da2.loc[{'dim_0': 0}] = custom_obj
+da3.loc[{'dim_0': 0}] = regular_obj
+
+print("da1.values:", da1.values)
+print("Type:", type(da1.values[0]))
+print("da1.values[0].values:", da1.values[0].values)  # Should still be accessible
+
+print("\nda2.values:", da2.values)  
+print("Type:", type(da2.values[0]))
+print("da2.values[0].values:", da2.values[0].values)  # Should still be accessible
+
+print("\nda3.values:", da3.values)
+print("Type:", type(da3.values[0]))
+print("da3.values[0].value:", da3.values[0].value)  # Should still be accessible
+
+print("\n=== Verification: All objects should preserve their original types ===")
+print("ModelResult preserved:", isinstance(da1.values[0], ModelResult))
+print("CustomObject preserved:", isinstance(da2.values[0], CustomObject)) 
+print("RegularObject preserved:", isinstance(da3.values[0], RegularObject))
\ No newline at end of file
diff --git a/test_simple.py b/test_simple.py
new file mode 100644
index 00000000..ab4eb5d4
--- /dev/null
+++ b/test_simple.py
@@ -0,0 +1,52 @@
+import xarray as xr
+import pandas as pd
+import numpy as np
+
+print("=== Test 1: Original issue - objects with values property should not be coerced ===")
+# Create DataArrays with object dtype to store arbitrary objects
+da1 = xr.DataArray([None])
+da2 = xr.DataArray([None])
+
+class HasValues(object):
+    values = 5
+    
+# Assign different types of objects
+da1.loc[{'dim_0': 0}] = set()  # This should work
+da2.loc[{'dim_0': 0}] = HasValues()  # This was broken before
+
+print("da1.values:", da1.values)
+print("da2.values:", da2.values)
+print("Type of da2.values[0]:", type(da2.values[0]))
+print("da2.values[0].values:", da2.values[0].values)  # Should still be accessible
+print()
+
+print("=== Test 2: Direct as_compatible_data function test ===")
+from xarray.core.variable import as_compatible_data
+
+# Test with regular object
+obj = HasValues()
+result = as_compatible_data(obj)
+print("as_compatible_data(HasValues()):", result)
+print("Type:", type(result))
+
+# Test with pandas Series
+series = pd.Series([1, 2, 3])
+result = as_compatible_data(series)
+print("as_compatible_data(pd.Series):", result)
+print("Type:", type(result))
+
+# Test with xarray DataArray
+xr_da = xr.DataArray([1, 2, 3])
+result = as_compatible_data(xr_da)
+print("as_compatible_data(xr.DataArray):", result)
+print("Type:", type(result))
+print()
+
+print("=== Test 3: Edge case - object without values property ===")
+class NoValues(object):
+    pass
+
+obj_no_values = NoValues()
+result = as_compatible_data(obj_no_values)
+print("as_compatible_data(NoValues()):", result)
+print("Type:", type(result))
\ No newline at end of file
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 45553eb9..a15c08fa 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -218,7 +218,13 @@ def as_compatible_data(data, fastpath=False):
         data = np.timedelta64(getattr(data, "value", data), "ns")
 
     # we don't want nested self-described arrays
-    data = getattr(data, "values", data)
+    # Only extract .values from pandas/xarray objects, not arbitrary objects
+    if hasattr(data, "values") and (
+        isinstance(data, (pd.Series, pd.DataFrame, xr.DataArray, xr.Dataset))
+    ):
+        data = data.values
+    else:
+        data = data
 
     if isinstance(data, np.ma.MaskedArray):
         mask = np.ma.getmaskarray(data)