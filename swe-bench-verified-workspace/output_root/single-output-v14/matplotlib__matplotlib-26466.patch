diff --git a/after_fix.png b/after_fix.png
new file mode 100644
index 0000000000..c608e7a1eb
Binary files /dev/null and b/after_fix.png differ
diff --git a/before_fix.png b/before_fix.png
new file mode 100644
index 0000000000..c608e7a1eb
Binary files /dev/null and b/before_fix.png differ
diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py
index d4922fc517..8625d9a86f 100644
--- a/lib/matplotlib/text.py
+++ b/lib/matplotlib/text.py
@@ -1456,7 +1456,11 @@ class _AnnotationBase:
                  xycoords='data',
                  annotation_clip=None):
 
-        self.xy = xy
+        # Make a copy of xy to avoid modifying the original array if it's mutable
+        if hasattr(xy, 'copy'):
+            self.xy = xy.copy()
+        else:
+            self.xy = xy
         self.xycoords = xycoords
         self.set_annotation_clip(annotation_clip)
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e00948c9ff
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,36 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+# this annotation is messed by later changing the array passed as xy kwarg
+ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3  # <-- this updates the arrow position
+
+xy_0 = np.array((1, 1))
+xy_f = np.array((4, 1))
+# using a copy of the array helps spotting where the problem is
+ax.annotate('', xy=xy_0.copy(), xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3
+
+plt.savefig('before_fix.png')
+plt.close()
+
+# Let's also check if the annotation's xy property is actually being modified
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+print(f"Before modification - annotation xy: {ann.xy}")
+xy_0[1] = 3
+print(f"After modification - annotation xy: {ann.xy}")
+print(f"xy_0 array: {xy_0}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..b01e3121f5
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,88 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def test_numpy_array_with_copy_method():
+    """Test that objects with copy method are properly handled"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Create a custom class with copy method
+    class CustomArray:
+        def __init__(self, data):
+            self.data = np.array(data)
+        
+        def copy(self):
+            return CustomArray(self.data.copy())
+        
+        def __getitem__(self, index):
+            return self.data[index]
+        
+        def __setitem__(self, index, value):
+            self.data[index] = value
+    
+    xy_0 = CustomArray([-4, 1])
+    xy_f = [-1, 1]
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Store original values
+    original_xy = ann.xy.copy()
+    
+    # Modify original object
+    xy_0[0] = 999
+    xy_0[1] = 888
+    
+    # Check that annotation xy didn't change (compare the underlying data)
+    assert np.array_equal(ann.xy.data, original_xy.data), f"Annotation xy changed: {ann.xy.data} != {original_xy.data}"
+    print("✓ Custom array with copy method test passed")
+
+def test_regular_object_no_copy_method():
+    """Test that objects without copy method work as before"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Create a regular object without copy method
+    class RegularObject:
+        def __init__(self, data):
+            self.data = data
+    
+    xy_0 = RegularObject([-4, 1])
+    xy_f = [-1, 1]
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # The annotation should store the object as-is
+    assert ann.xy == xy_0, f"Annotation xy should be the same object: {ann.xy} != {xy_0}"
+    print("✓ Regular object without copy method test passed")
+
+def test_numpy_array_different_dtypes():
+    """Test that numpy arrays with different dtypes work correctly"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Test with different numpy array dtypes
+    xy_0_int = np.array([-4, 1], dtype=int)
+    xy_0_float = np.array([-4.5, 1.2], dtype=float)
+    xy_f = [-1, 1]
+    
+    ann1 = ax.annotate('', xy=xy_0_int, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    ann2 = ax.annotate('', xy=xy_0_float, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Store original values
+    original_xy1 = ann1.xy.copy()
+    original_xy2 = ann2.xy.copy()
+    
+    # Modify original arrays
+    xy_0_int[0] = 999
+    xy_0_int[1] = 888
+    xy_0_float[0] = 999.5
+    xy_0_float[1] = 888.2
+    
+    # Check that annotation xy didn't change
+    assert np.array_equal(ann1.xy, original_xy1), f"Annotation xy changed: {ann1.xy} != {original_xy1}"
+    assert np.array_equal(ann2.xy, original_xy2), f"Annotation xy changed: {ann2.xy} != {original_xy2}"
+    print("✓ Numpy array different dtypes test passed")
+
+if __name__ == "__main__":
+    test_numpy_array_with_copy_method()
+    test_regular_object_no_copy_method()
+    test_numpy_array_different_dtypes()
+    print("All edge case tests passed!")
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..d6ac76d220
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,87 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+def test_xy_array_copy():
+    """Test that xy parameter is properly copied when it's a numpy array"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Test with numpy array
+    xy_0 = np.array((-4, 1))
+    xy_f = np.array((-1, 1))
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Store original values
+    original_xy = ann.xy.copy()
+    
+    # Modify original array
+    xy_0[0] = 999
+    xy_0[1] = 888
+    
+    # Check that annotation xy didn't change
+    assert np.array_equal(ann.xy, original_xy), f"Annotation xy changed: {ann.xy} != {original_xy}"
+    print("✓ xy array copy test passed")
+
+def test_xy_list_no_copy():
+    """Test that regular lists are not copied (should work as before)"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Test with regular list
+    xy_0 = [-4, 1]
+    xy_f = [-1, 1]
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Store original values
+    original_xy = ann.xy.copy()
+    
+    # Modify original list
+    xy_0[0] = 999
+    xy_0[1] = 888
+    
+    # Check that annotation xy didn't change (should be converted to array during processing)
+    assert np.array_equal(ann.xy, original_xy), f"Annotation xy changed: {ann.xy} != {original_xy}"
+    print("✓ xy list no copy test passed")
+
+def test_xy_tuple_no_copy():
+    """Test that tuples work correctly (should work as before)"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Test with tuple
+    xy_0 = (-4, 1)
+    xy_f = (-1, 1)
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Tuples are immutable, so we can't modify them
+    # Just verify the annotation has the correct values
+    assert np.array_equal(np.array(ann.xy), np.array(xy_0)), f"Annotation xy incorrect: {ann.xy} != {xy_0}"
+    print("✓ xy tuple test passed")
+
+def test_xytext_array():
+    """Test that xytext parameter works correctly (should not have the same issue)"""
+    fig = plt.figure("test")
+    ax = fig.add_axes([0.13, 0.15, .8, .8])
+    
+    # Test with numpy array for xytext
+    xy_0 = (-4, 1)
+    xy_f = np.array((-1, 1))
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Store original position
+    original_position = ann.get_position()
+    
+    # Modify original array
+    xy_f[0] = 999
+    xy_f[1] = 888
+    
+    # Check that annotation position didn't change
+    assert np.array_equal(ann.get_position(), original_position), f"Annotation position changed: {ann.get_position()} != {original_position}"
+    print("✓ xytext array test passed")
+
+if __name__ == "__main__":
+    test_xy_array_copy()
+    test_xy_list_no_copy()
+    test_xy_tuple_no_copy()
+    test_xytext_array()
+    print("All tests passed!")
\ No newline at end of file
diff --git a/test_xytext_issue.py b/test_xytext_issue.py
new file mode 100644
index 0000000000..8f8fdc3051
--- /dev/null
+++ b/test_xytext_issue.py
@@ -0,0 +1,15 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+print(f"Before modification - annotation xytext position: {ann.get_position()}")
+xy_f[1] = 3
+print(f"After modification - annotation xytext position: {ann.get_position()}")
+print(f"xy_f array: {xy_f}")
\ No newline at end of file