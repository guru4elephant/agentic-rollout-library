diff --git a/debug_hnf.py b/debug_hnf.py
new file mode 100644
index 0000000000..0500f9406c
--- /dev/null
+++ b/debug_hnf.py
@@ -0,0 +1,26 @@
+from sympy import Matrix
+from sympy.polys.matrices.normalforms import _hermite_normal_form
+from sympy.polys.matrices import DomainMatrix
+from sympy.polys.domains import QQ
+
+# Create the problematic matrix
+matrix = Matrix([[0, 5], [0, 8], [1, 12]])
+print("Input matrix:")
+print(matrix)
+
+# Convert to DomainMatrix
+dm = DomainMatrix.from_Matrix(matrix)
+print("DomainMatrix:")
+print(dm)
+
+# Apply HNF
+hnf_result = _hermite_normal_form(dm)
+print("HNF result:")
+print(hnf_result.to_Matrix())
+
+# Check the shape
+print("Input shape:", dm.shape)
+print("HNF result shape:", hnf_result.shape)
+
+# Let's also check the rank
+print("Matrix rank:", dm.convert_to(QQ).rank())
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..cb9b73b2ca
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,36 @@
+from sympy import Matrix
+from sympy.matrices.normalforms import hermite_normal_form
+
+# Create the matrix manually without numpy
+matrix = Matrix([[5, 8, 12], [0, 0, 1]])
+print("Original matrix:")
+print(matrix)
+
+# Apply flips and transposes manually
+# np.flip(matrix) is equivalent to matrix[::-1, :] for rows flip
+flipped = Matrix([[0, 0, 1], [5, 8, 12]])
+print("Flipped matrix:")
+print(flipped)
+
+# Transpose
+matrix_transposed = flipped.T
+print("Transposed matrix:")
+print(matrix_transposed)
+
+# Apply HNF
+hnf_result = hermite_normal_form(matrix_transposed)
+print("HNF result:")
+print(hnf_result)
+
+# Apply the final flip and transpose
+# np.flip(hnf_result.T).T is equivalent to hnf_result[::-1, :] for rows flip
+final_result = hnf_result[::-1, :]
+print("Final result:")
+print(final_result)
+
+# Expected result
+expected = Matrix([[5, 8, 0], [0, 0, 1]])
+print("Expected result:")
+print(expected)
+
+print("Are they equal?", final_result == expected)
\ No newline at end of file
diff --git a/trace_hnf.py b/trace_hnf.py
new file mode 100644
index 0000000000..344a91f0f7
--- /dev/null
+++ b/trace_hnf.py
@@ -0,0 +1,59 @@
+from sympy.polys.matrices.normalforms import _gcdex
+from sympy.polys.matrices.normalforms import add_columns
+from sympy.polys.domains import ZZ
+
+# Let's trace the HNF algorithm manually for our matrix
+# Matrix: [[0, 5], [0, 8], [1, 12]]
+# Shape: (3, 2)
+
+A = [[0, 5], [0, 8], [1, 12]]
+m, n = 3, 2
+rows = min(m, n)  # 2
+
+print("Initial matrix:")
+for row in A:
+    print(row)
+
+k = n  # k = 2
+
+# Process rows from bottom to top
+for i in range(m - 1, m - 1 - rows, -1):  # i = 2, 1
+    k -= 1  # k = 1, then k = 0
+    print(f"\nProcessing row {i}, k = {k}")
+    
+    # Process columns from k-1 down to 0
+    for j in range(k - 1, -1, -1):
+        if A[i][j] != 0:
+            print(f"  Processing column {j}, A[{i}][{j}] = {A[i][j]}")
+            u, v, d = _gcdex(A[i][k], A[i][j])
+            r, s = A[i][k] // d, A[i][j] // d
+            print(f"    u={u}, v={v}, d={d}, r={r}, s={s}")
+            add_columns(A, k, j, u, v, -s, r)
+            print(f"    After add_columns:")
+            for row_idx, row in enumerate(A):
+                print(f"      Row {row_idx}: {row}")
+    
+    b = A[i][k]
+    print(f"  b = A[{i}][{k}] = {b}")
+    
+    if b < 0:
+        add_columns(A, k, k, -1, 0, -1, 0)
+        b = -b
+    
+    if b == 0:
+        k += 1
+        print(f"  b == 0, k increased to {k}")
+    else:
+        print(f"  b != 0, reducing entries to the right")
+        for j in range(k + 1, n):
+            q = A[i][j] // b
+            print(f"    j={j}, q = A[{i}][{j}] // {b} = {q}")
+            add_columns(A, j, k, 1, -q, 0, 1)
+            print(f"    After add_columns:")
+            for row_idx, row in enumerate(A):
+                print(f"      Row {row_idx}: {row}")
+
+print(f"\nFinal k value: {k}")
+print("Final matrix:")
+for row in A:
+    print(row)
\ No newline at end of file