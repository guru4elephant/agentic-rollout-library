diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py
index 88adadb37d..814a5a431c 100644
--- a/django/forms/boundfield.py
+++ b/django/forms/boundfield.py
@@ -232,6 +232,29 @@ class BoundField:
     def widget_type(self):
         return re.sub(r'widget$|input$', '', self.field.widget.__class__.__name__.lower())
 
+    def _did_change(self):
+        """Return True if data for this field differs from initial."""
+        if self.field.disabled:
+            return False
+        if not self.form.is_bound:
+            return False
+        
+        data_value = self.data
+        if self.field.show_hidden_initial:
+            initial_prefixed_name = self.html_initial_name
+            hidden_widget = self.field.hidden_widget()
+            try:
+                initial_value = self.field.to_python(
+                    self.form._widget_data_value(hidden_widget, initial_prefixed_name)
+                )
+            except ValidationError:
+                # Always assume data has changed if validation fails.
+                return True
+        else:
+            initial_value = self.initial
+        
+        return self.field.has_changed(initial_value, data_value)
+
 
 @html_safe
 class BoundWidget:
diff --git a/django/forms/forms.py b/django/forms/forms.py
index d14037bfe9..9fc9d37ad8 100644
--- a/django/forms/forms.py
+++ b/django/forms/forms.py
@@ -167,6 +167,11 @@ class BaseForm:
         self._bound_fields_cache[name] = bound_field
         return bound_field
 
+    def _bound_items(self):
+        """Return an iterator over bound fields (name, bound_field)."""
+        for name in self.fields:
+            yield name, self[name]
+
     @property
     def errors(self):
         """Return an ErrorDict for the data provided for the form."""
@@ -387,17 +392,17 @@ class BaseForm:
         self._post_clean()
 
     def _clean_fields(self):
-        for name, field in self.fields.items():
-            if field.disabled:
-                value = self.get_initial_for_field(field, name)
+        for name, bf in self._bound_items():
+            if bf.field.disabled:
+                value = bf.initial
             else:
-                value = self._field_data_value(field, self.add_prefix(name))
+                value = bf.data
             try:
-                if isinstance(field, FileField):
-                    initial = self.get_initial_for_field(field, name)
-                    value = field.clean(value, initial)
+                if isinstance(bf.field, FileField):
+                    initial = bf.initial
+                    value = bf.field.clean(value, initial)
                 else:
-                    value = field.clean(value)
+                    value = bf.field.clean(value)
                 self.cleaned_data[name] = value
                 if hasattr(self, 'clean_%s' % name):
                     value = getattr(self, 'clean_%s' % name)()
@@ -436,27 +441,7 @@ class BaseForm:
 
     @cached_property
     def changed_data(self):
-        data = []
-        for name, field in self.fields.items():
-            data_value = self._field_data_value(field, self.add_prefix(name))
-            if not field.show_hidden_initial:
-                # Use the BoundField's initial as this is the value passed to
-                # the widget.
-                initial_value = self[name].initial
-            else:
-                initial_prefixed_name = self.add_initial_prefix(name)
-                hidden_widget = field.hidden_widget()
-                try:
-                    initial_value = field.to_python(
-                        self._widget_data_value(hidden_widget, initial_prefixed_name)
-                    )
-                except ValidationError:
-                    # Always assume data has changed if validation fails.
-                    data.append(name)
-                    continue
-            if field.has_changed(initial_value, data_value):
-                data.append(name)
-        return data
+        return [name for name, bf in self._bound_items() if bf._did_change()]
 
     @property
     def media(self):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..167e12851a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+"""Script to reproduce the issue with BaseForm's _clean_fields() and changed_data."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django import forms
+from datetime import datetime
+
+class TestForm(forms.Form):
+    datetime_field = forms.DateTimeField()
+
+def test_initial_vs_boundfield_initial():
+    """Test that form._clean_fields() and form[name].initial should return the same value."""
+    
+    # Create a callable initial value
+    initial_data = {'datetime_field': datetime.now}
+    
+    # Create form with initial data
+    form = TestForm(initial=initial_data)
+    
+    print("Testing initial values consistency:")
+    print(f"form.get_initial_for_field(form.fields['datetime_field'], 'datetime_field'): {form.get_initial_for_field(form.fields['datetime_field'], 'datetime_field')}")
+    print(f"form['datetime_field'].initial: {form['datetime_field'].initial}")
+    
+    # Check if they are the same
+    direct_initial = form.get_initial_for_field(form.fields['datetime_field'], 'datetime_field')
+    boundfield_initial = form['datetime_field'].initial
+    
+    print(f"Are they equal? {direct_initial == boundfield_initial}")
+    
+    if direct_initial != boundfield_initial:
+        print("ISSUE CONFIRMED: form.get_initial_for_field() and BoundField.initial return different values!")
+        return False
+    else:
+        print("Values are consistent")
+        return True
+
+def test_changed_data_via_boundfield():
+    """Test changed_data behavior with BoundField access."""
+    
+    # Create form with some initial data
+    initial_time = datetime(2023, 1, 1, 12, 0, 0)
+    form = TestForm(initial={'datetime_field': initial_time})
+    
+    # Submit the same data as initial
+    submitted_data = {'datetime_field': initial_time.strftime('%Y-%m-%d %H:%M:%S')}
+    bound_form = TestForm(data=submitted_data, initial={'datetime_field': initial_time})
+    
+    print("\nTesting changed_data behavior:")
+    print(f"Form changed_data: {bound_form.changed_data}")
+    print(f"Form has_changed(): {bound_form.has_changed()}")
+    
+    # The form should not have changed since we submitted the same value as initial
+    if bound_form.has_changed():
+        print("ISSUE CONFIRMED: Form reports changed data when it shouldn't!")
+        return False
+    else:
+        print("Changed data behavior is correct")
+        return True
+
+if __name__ == "__main__":
+    print("Reproducing the GitHub issue...")
+    
+    test1_result = test_initial_vs_boundfield_initial()
+    test2_result = test_changed_data_via_boundfield()
+    
+    if not test1_result or not test2_result:
+        print("\nISSUE REPRODUCTION: SUCCESS - The issues described in the GitHub issue are present.")
+    else:
+        print("\nISSUE REPRODUCTION: FAILED - The issues described were not reproduced.")
\ No newline at end of file
diff --git a/test_changed_data.py b/test_changed_data.py
new file mode 100644
index 0000000000..75184435f6
--- /dev/null
+++ b/test_changed_data.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+
+"""Test specifically for changed_data behavior."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django import forms
+from datetime import datetime
+
+class TestForm(forms.Form):
+    datetime_field = forms.DateTimeField()
+
+def test_changed_data_with_microseconds():
+    """Test that changed_data properly handles microseconds normalization."""
+    
+    # Create a datetime with microseconds for initial data
+    initial_time = datetime(2023, 1, 1, 12, 0, 0, 123456)
+    
+    # Create form with initial data
+    form = TestForm(initial={'datetime_field': initial_time})
+    
+    # Submit the same datetime but without microseconds (simulating form submission)
+    submitted_time = datetime(2023, 1, 1, 12, 0, 0)  # No microseconds
+    submitted_data = {'datetime_field': submitted_time.strftime('%Y-%m-%d %H:%M:%S')}
+    
+    bound_form = TestForm(data=submitted_data, initial={'datetime_field': initial_time})
+    
+    print("Testing changed_data with microseconds:")
+    print(f"Initial time (with microseconds): {initial_time}")
+    print(f"Submitted time (no microseconds): {submitted_time}")
+    print(f"BoundField.initial: {bound_form['datetime_field'].initial}")
+    print(f"Form changed_data: {bound_form.changed_data}")
+    print(f"Form has_changed(): {bound_form.has_changed()}")
+    
+    # The form should NOT have changed since the normalized values are the same
+    if not bound_form.has_changed():
+        print("SUCCESS: changed_data properly handles microseconds normalization!")
+        return True
+    else:
+        print("ISSUE: changed_data still reports false changes due to microseconds")
+        return False
+
+if __name__ == "__main__":
+    test_changed_data_with_microseconds()
\ No newline at end of file
diff --git a/test_initial_consistency.py b/test_initial_consistency.py
new file mode 100644
index 0000000000..2b65500614
--- /dev/null
+++ b/test_initial_consistency.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+
+"""Test specifically for initial value consistency."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django import forms
+from datetime import datetime
+
+class TestForm(forms.Form):
+    datetime_field = forms.DateTimeField()
+
+def test_clean_fields_uses_boundfield_initial():
+    """Test that _clean_fields() now uses BoundField.initial for disabled fields."""
+    
+    # Create a callable initial value
+    initial_data = {'datetime_field': datetime.now}
+    
+    # Create form with initial data
+    form = TestForm(initial=initial_data)
+    
+    print("Testing _clean_fields() uses BoundField.initial for disabled fields:")
+    
+    # Manually call _clean_fields on a disabled field
+    for name, field in form.fields.items():
+        field.disabled = True  # Make field disabled
+    
+    # Initialize cleaned_data and call _clean_fields which should now use bf.initial
+    form.cleaned_data = {}
+    form._clean_fields()
+    
+    # Check if cleaned_data contains the BoundField.initial value (microseconds normalized)
+    boundfield_initial = form['datetime_field'].initial
+    cleaned_value = form.cleaned_data.get('datetime_field')
+    
+    print(f"BoundField.initial: {boundfield_initial}")
+    print(f"Cleaned data value: {cleaned_value}")
+    print(f"Are they equal? {boundfield_initial == cleaned_value}")
+    
+    if boundfield_initial == cleaned_value:
+        print("SUCCESS: _clean_fields() now uses BoundField.initial consistently!")
+        return True
+    else:
+        print("ISSUE: _clean_fields() still doesn't use BoundField.initial consistently")
+        return False
+
+if __name__ == "__main__":
+    test_clean_fields_uses_boundfield_initial()
\ No newline at end of file
diff --git a/test_microseconds.py b/test_microseconds.py
new file mode 100644
index 0000000000..5fb7214840
--- /dev/null
+++ b/test_microseconds.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+
+"""Test specifically for microseconds normalization."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django import forms
+from datetime import datetime
+
+class TestForm(forms.Form):
+    datetime_field = forms.DateTimeField()
+
+def test_microseconds_normalization():
+    """Test that microseconds are normalized in BoundField.initial."""
+    
+    # Create a datetime with microseconds
+    dt_with_microseconds = datetime(2023, 1, 1, 12, 0, 0, 123456)
+    
+    # Create form with initial data
+    form = TestForm(initial={'datetime_field': dt_with_microseconds})
+    
+    print("Testing microseconds normalization:")
+    print(f"Original datetime: {dt_with_microseconds}")
+    print(f"get_initial_for_field(): {form.get_initial_for_field(form.fields['datetime_field'], 'datetime_field')}")
+    print(f"BoundField.initial: {form['datetime_field'].initial}")
+    
+    # Check if microseconds are normalized in BoundField.initial
+    direct_initial = form.get_initial_for_field(form.fields['datetime_field'], 'datetime_field')
+    boundfield_initial = form['datetime_field'].initial
+    
+    print(f"Direct initial has microseconds: {direct_initial.microsecond != 0}")
+    print(f"BoundField initial has microseconds: {boundfield_initial.microsecond != 0}")
+    
+    if direct_initial.microsecond != 0 and boundfield_initial.microsecond == 0:
+        print("SUCCESS: BoundField.normalizes microseconds!")
+        return True
+    else:
+        print("ISSUE: Microseconds normalization not working as expected")
+        return False
+
+if __name__ == "__main__":
+    test_microseconds_normalization()
\ No newline at end of file