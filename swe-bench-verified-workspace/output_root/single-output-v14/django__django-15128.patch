diff --git a/app/__init__.py b/app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index aaf35ee37c..6e4b52981f 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -235,6 +235,9 @@ class Query(BaseExpression):
         self._filtered_relations = {}
 
         self.explain_info = None
+        
+        # Temporary storage for rhs aliases during combine operations
+        self._combine_rhs_aliases = None
 
     @property
     def output_field(self):
@@ -575,6 +578,9 @@ class Query(BaseExpression):
         # Work out how to relabel the rhs aliases, if necessary.
         change_map = {}
         conjunction = (connector == AND)
+        
+        # Store rhs aliases for use in table_alias to avoid conflicts
+        self._combine_rhs_aliases = set(rhs.alias_map.keys())
 
         # Determine which existing joins can be reused. When combining the
         # query with AND we must recreate all joins for m2m filters. When
@@ -745,13 +751,16 @@ class Query(BaseExpression):
             for model, values in seen.items():
                 callback(target, model, values)
 
-    def table_alias(self, table_name, create=False, filtered_relation=None):
+    def table_alias(self, table_name, create=False, filtered_relation=None, combine_rhs_aliases=None):
         """
         Return a table alias for the given table_name and whether this is a
         new alias or not.
 
         If 'create' is true, a new alias is always created. Otherwise, the
         most recently created alias for the table (if one exists) is reused.
+
+        If 'combine_rhs_aliases' is provided, it should be a set of aliases
+        from the rhs query that should be avoided when generating new aliases.
         """
         alias_list = self.table_map.get(table_name)
         if not create and alias_list:
@@ -761,7 +770,18 @@ class Query(BaseExpression):
 
         # Create a new alias for this table.
         if alias_list:
-            alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)
+            # Generate a new alias that doesn't conflict with rhs aliases if provided
+            rhs_aliases = combine_rhs_aliases or (self._combine_rhs_aliases if hasattr(self, '_combine_rhs_aliases') else None)
+            if rhs_aliases is not None:
+                # Start from the next available number and find one that doesn't conflict
+                next_num = len(self.alias_map) + 1
+                while True:
+                    alias = '%s%d' % (self.alias_prefix, next_num)
+                    if alias not in rhs_aliases:
+                        break
+                    next_num += 1
+            else:
+                alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)
             alias_list.append(alias)
         else:
             # The first occurrence of a table uses the table name directly.
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..027b15c4c0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the Query.change_aliases AssertionError issue.
+Based on the GitHub issue description.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'app',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models as described in the issue
+class Baz(models.Model):
+    class Meta:
+        app_label = 'app'
+
+class Qux(models.Model):
+    bazes = models.ManyToManyField("app.Baz", related_name="quxes")
+    
+    class Meta:
+        app_label = 'app'
+
+class Foo(models.Model):
+    qux = models.ForeignKey("app.Qux", on_delete=models.CASCADE, related_name="foos")
+    
+    class Meta:
+        app_label = 'app'
+
+class Bar(models.Model):
+    foo = models.ForeignKey("app.Foo", on_delete=models.CASCADE, related_name="bars")
+    another_foo = models.ForeignKey("app.Foo", on_delete=models.CASCADE, related_name="other_bars")
+    baz = models.ForeignKey("app.Baz", on_delete=models.CASCADE, related_name="bars")
+    
+    class Meta:
+        app_label = 'app'
+
+# Create the database tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Foo)
+    schema_editor.create_model(Bar)
+    schema_editor.create_model(Baz)
+    schema_editor.create_model(Qux)
+
+# Test the issue
+from django.db.models import Q
+
+print("Creating test data...")
+qux = Qux.objects.create()
+qs1 = qux.foos.all()
+qs2 = Foo.objects.filter(
+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())
+)
+
+print("Testing qs2 | qs1 (should work)...")
+try:
+    result1 = qs2 | qs1
+    print("✓ qs2 | qs1 worked fine")
+except AssertionError as e:
+    print(f"✗ qs2 | qs1 failed: {e}")
+
+print("Testing qs1 | qs2 (should fail with AssertionError)...")
+try:
+    result2 = qs1 | qs2
+    print("✓ qs1 | qs2 worked fine")
+except AssertionError as e:
+    print(f"✗ qs1 | qs2 failed: {e}")
+    print(f"Error type: {type(e)}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file