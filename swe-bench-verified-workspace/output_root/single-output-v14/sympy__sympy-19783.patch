diff --git a/check_dagger_class.py b/check_dagger_class.py
new file mode 100644
index 0000000000..5bb7d2c725
--- /dev/null
+++ b/check_dagger_class.py
@@ -0,0 +1,9 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+
+print("Type of Dagger class:", type(Dagger))
+print("Type of B:", type(B))
+print("Is B an instance of Dagger?", isinstance(B, Dagger))
\ No newline at end of file
diff --git a/check_dagger_content.py b/check_dagger_content.py
new file mode 100644
index 0000000000..a902230053
--- /dev/null
+++ b/check_dagger_content.py
@@ -0,0 +1,9 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+
+print("B.args:", B.args)
+print("Type of B.args[0]:", type(B.args[0]))
+print("Is B.args[0] an Operator?", isinstance(B.args[0], Operator))
\ No newline at end of file
diff --git a/check_dagger_inheritance.py b/check_dagger_inheritance.py
new file mode 100644
index 0000000000..5b82c35ced
--- /dev/null
+++ b/check_dagger_inheritance.py
@@ -0,0 +1,10 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+from sympy.core import Expr
+
+A = Operator('A')
+B = Dagger(A)
+
+print("Is Dagger(A) an Expr?", isinstance(B, Expr))
+print("Dagger class:", type(B))
+print("Dagger class MRO:", type(B).__mro__)
\ No newline at end of file
diff --git a/check_dagger_methods.py b/check_dagger_methods.py
new file mode 100644
index 0000000000..ac1e5ed2ca
--- /dev/null
+++ b/check_dagger_methods.py
@@ -0,0 +1,11 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+
+print("Has adjoint method:", hasattr(B, 'adjoint'))
+print("Has conjugate method:", hasattr(B, 'conjugate'))
+print("Has transpose method:", hasattr(B, 'transpose'))
+if hasattr(B, 'adjoint'):
+    print("adjoint() returns:", B.adjoint())
\ No newline at end of file
diff --git a/check_dagger_mul.py b/check_dagger_mul.py
new file mode 100644
index 0000000000..b98f4b5b63
--- /dev/null
+++ b/check_dagger_mul.py
@@ -0,0 +1,16 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+A = Operator('A')
+B = Dagger(A)
+Identity = IdentityOperator()
+
+print("Has Dagger __mul__ method:", hasattr(B, '__mul__'))
+print("Has Identity __mul__ method:", hasattr(Identity, '__mul__'))
+
+# Let's see which __mul__ method gets called first
+import inspect
+if hasattr(B, '__mul__'):
+    print("Dagger __mul__ source:", inspect.getsource(B.__mul__))
+if hasattr(Identity, '__mul__'):
+    print("Identity __mul__ source:", inspect.getsource(Identity.__mul__))
\ No newline at end of file
diff --git a/debug_multiplication.py b/debug_multiplication.py
new file mode 100644
index 0000000000..2436f2b4ef
--- /dev/null
+++ b/debug_multiplication.py
@@ -0,0 +1,20 @@
+from sympy.physics.quantum.operator import IdentityOperator
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+Identity = IdentityOperator()
+
+# Let's see what happens step by step
+print("B:", B)
+print("Identity:", Identity)
+print("B * Identity:", B * Identity)
+
+# Let's check if the multiplication is going through Mul
+from sympy import Mul
+result = B * Identity
+print("Type of result:", type(result))
+print("Is result a Mul?", isinstance(result, Mul))
+if isinstance(result, Mul):
+    print("Mul args:", result.args)
\ No newline at end of file
diff --git a/debug_types.py b/debug_types.py
new file mode 100644
index 0000000000..1efdc9f8ba
--- /dev/null
+++ b/debug_types.py
@@ -0,0 +1,12 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+A = Operator('A')
+Identity = IdentityOperator()
+B = Dagger(A)
+
+print("Type of A:", type(A))
+print("Type of B:", type(B))
+print("Type of Identity:", type(Identity))
+print("Is B an Operator?", isinstance(B, Operator))
+print("Is B an IdentityOperator?", isinstance(B, IdentityOperator))
\ No newline at end of file
diff --git a/find_mul_inheritance.py b/find_mul_inheritance.py
new file mode 100644
index 0000000000..dfee726951
--- /dev/null
+++ b/find_mul_inheritance.py
@@ -0,0 +1,12 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+
+# Find where __mul__ is defined
+for cls in type(B).__mro__:
+    if hasattr(cls, '__mul__') and hasattr(object, '__mul__') and cls.__mul__ is not object.__mul__:
+        print(f"__mul__ defined in: {cls}")
+        print(f"__mul__ method: {cls.__mul__}")
+        break
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f003666fc2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,12 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+# Create operators
+A = Operator('A')
+Identity = IdentityOperator()
+
+print("A * Identity:", A * Identity)  # This should give A, correctly
+
+B = Dagger(A)
+print("B * Identity:", B * Identity)  # This returns A^\dagger I, but should give B
+print("Expected result should be:", B)
\ No newline at end of file
diff --git a/simple_find_mul.py b/simple_find_mul.py
new file mode 100644
index 0000000000..52b5adf5f3
--- /dev/null
+++ b/simple_find_mul.py
@@ -0,0 +1,18 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+
+# Check each class in MRO for __mul__ method
+for cls in type(B).__mro__:
+    if hasattr(cls, '__mul__'):
+        print(f"Class {cls} has __mul__ method")
+        # Try to get the source if possible
+        try:
+            import inspect
+            source = inspect.getsource(cls.__mul__)
+            print(f"Source: {source}")
+        except:
+            print(f"Cannot get source for {cls}.__mul__")
+        print()
\ No newline at end of file
diff --git a/sympy/physics/quantum/dagger.py b/sympy/physics/quantum/dagger.py
index 17da3cfd2c..e80dc9a8d3 100644
--- a/sympy/physics/quantum/dagger.py
+++ b/sympy/physics/quantum/dagger.py
@@ -85,5 +85,11 @@ def __new__(cls, arg):
             return obj
         return Expr.__new__(cls, arg)
 
+    def __mul__(self, other):
+        # Check if other is an IdentityOperator without circular import
+        if hasattr(other, '__class__') and other.__class__.__name__ == 'IdentityOperator':
+            return self
+        return super(Dagger, self).__mul__(other)
+
 adjoint.__name__ = "Dagger"
 adjoint._sympyrepr = lambda a, b: "Dagger(%s)" % b._print(a.args[0])
diff --git a/sympy/physics/quantum/operator.py b/sympy/physics/quantum/operator.py
index 306bfee64f..5ed0d52cf3 100644
--- a/sympy/physics/quantum/operator.py
+++ b/sympy/physics/quantum/operator.py
@@ -310,6 +310,9 @@ def __mul__(self, other):
         if isinstance(other, Operator):
             return other
 
+        if isinstance(other, Dagger):
+            return other
+
         return Mul(self, other)
 
     def _represent_default_basis(self, **options):
diff --git a/test_commutative.py b/test_commutative.py
new file mode 100644
index 0000000000..800d797e77
--- /dev/null
+++ b/test_commutative.py
@@ -0,0 +1,17 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+A = Operator('A')
+Identity = IdentityOperator()
+B = Dagger(A)
+
+print("Testing commutative property:")
+print("Identity * B:", Identity * B)
+print("B * Identity:", B * Identity)
+print("Are they equal?", Identity * B == B * Identity)
+
+# Also test with regular operators
+print("\nTesting with regular operators:")
+print("Identity * A:", Identity * A)
+print("A * Identity:", A * Identity)
+print("Are they equal?", Identity * A == A * Identity)
\ No newline at end of file
diff --git a/test_complex_cases.py b/test_complex_cases.py
new file mode 100644
index 0000000000..880f79f61f
--- /dev/null
+++ b/test_complex_cases.py
@@ -0,0 +1,19 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+A = Operator('A')
+B = Operator('B')
+Identity = IdentityOperator()
+
+print("Testing complex expressions:")
+print("Dagger(A+B) * Identity:", Dagger(A+B) * Identity)
+print("Dagger(A*B) * Identity:", Dagger(A*B) * Identity)
+print("Dagger(A**2) * Identity:", Dagger(A**2) * Identity)
+
+print("\nTesting that non-identity multiplication still works:")
+print("Dagger(A) * B:", Dagger(A) * B)
+print("Dagger(A) * 2:", Dagger(A) * 2)
+print("Dagger(A) * Dagger(B):", Dagger(A) * Dagger(B))
+
+print("\nTesting nested identity:")
+print("Identity * Identity:", Identity * Identity)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d84d5a0724
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,34 @@
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator, IdentityOperator
+
+# Test basic case
+A = Operator('A')
+Identity = IdentityOperator()
+B = Dagger(A)
+
+print("Basic case:")
+print("B * Identity:", B * Identity)
+print()
+
+# Test with other operators
+C = Operator('C')
+D = Dagger(C)
+print("With another operator:")
+print("D * Identity:", D * Identity)
+print()
+
+# Test that normal multiplication still works
+print("Normal multiplication (should not be simplified):")
+print("B * C:", B * C)
+print("B * 2:", B * 2)
+print()
+
+# Test that Identity * Dagger also works (commutative property)
+print("Identity * B (should be simplified):")
+print("Identity * B:", Identity * B)
+print()
+
+# Test with nested Dagger
+print("Nested Dagger:")
+E = Dagger(Dagger(A))
+print("E * Identity:", E * Identity)
\ No newline at end of file
diff --git a/test_import.py b/test_import.py
new file mode 100644
index 0000000000..d7babc0ea5
--- /dev/null
+++ b/test_import.py
@@ -0,0 +1,11 @@
+from sympy.physics.quantum.operator import IdentityOperator
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+
+A = Operator('A')
+B = Dagger(A)
+Identity = IdentityOperator()
+
+print("Is Dagger imported correctly?", Dagger)
+print("Is B an instance of Dagger?", isinstance(B, Dagger))
+print("B * Identity:", B * Identity)
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..8372415846
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,14 @@
+# Exact reproduction of the GitHub issue example
+from sympy.physics.quantum.dagger import Dagger
+from sympy.physics.quantum.operator import Operator
+from sympy.physics.quantum import IdentityOperator
+
+A = Operator('A')
+Identity = IdentityOperator()
+
+print("A * Identity:", A * Identity)  # This gives A, correctly
+
+B = Dagger(A)
+print("B * Identity:", B * Identity)  # This should now return A^\dagger (not A^\dagger I)
+print("Expected: Dagger(A)")
+print("Test passed:", B * Identity == Dagger(A))
\ No newline at end of file