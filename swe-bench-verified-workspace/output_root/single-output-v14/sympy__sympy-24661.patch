diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e0ef46ab3d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt
+
+print("Testing the issue with parse_expr and evaluate=False for relationals")
+
+# This should return Lt(1, 2, evaluate=False) but currently returns True
+result = parse_expr('1 < 2', evaluate=False)
+print(f"parse_expr('1 < 2', evaluate=False) = {result}")
+print(f"Type: {type(result)}")
+
+# This is what it should return
+expected = Lt(1, 2, evaluate=False)
+print(f"Expected: {expected}")
+print(f"Expected type: {type(expected)}")
+
+# Test other relational operators
+print("\nTesting other relational operators:")
+operators = ['<', '>', '<=', '>=', '==', '!=']
+for op in operators:
+    try:
+        expr = f'1 {op} 2'
+        result = parse_expr(expr, evaluate=False)
+        print(f"parse_expr('{expr}', evaluate=False) = {result}")
+    except Exception as e:
+        print(f"parse_expr('{expr}', evaluate=False) failed: {e}")
\ No newline at end of file
diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py
index 52711d1324..3b9e383515 100644
--- a/sympy/parsing/sympy_parser.py
+++ b/sympy/parsing/sympy_parser.py
@@ -1110,6 +1110,14 @@ class EvaluateFalseTransformer(ast.NodeTransformer):
         ast.BitAnd: 'And',
         ast.BitXor: 'Not',
     }
+    relational_operators = {
+        ast.Lt: 'Lt',
+        ast.Gt: 'Gt',
+        ast.LtE: 'Le',
+        ast.GtE: 'Ge',
+        ast.Eq: 'Eq',
+        ast.NotEq: 'Ne',
+    }
     functions = (
         'Abs', 'im', 're', 'sign', 'arg', 'conjugate',
         'acos', 'acot', 'acsc', 'asec', 'asin', 'atan',
@@ -1192,6 +1200,22 @@ def visit_Call(self, node):
             new_node.keywords.append(ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load())))
         return new_node
 
+    def visit_Compare(self, node):
+        # Handle comparison operations (relational operators)
+        if len(node.ops) == 1 and node.ops[0].__class__ in self.relational_operators:
+            sympy_class = self.relational_operators[node.ops[0].__class__]
+            left = self.visit(node.left)
+            right = self.visit(node.comparators[0])
+            
+            return ast.Call(
+                func=ast.Name(id=sympy_class, ctx=ast.Load()),
+                args=[left, right],
+                keywords=[ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load()))],
+                starargs=None,
+                kwargs=None
+            )
+        return node
+
 
 _transformation = {  # items can be added but never re-ordered
 0: lambda_notation,
diff --git a/test_ast_structure.py b/test_ast_structure.py
new file mode 100644
index 0000000000..e9f5d89ed5
--- /dev/null
+++ b/test_ast_structure.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+import ast
+
+def analyze_ast_expr(expr_str):
+    """Analyze the AST structure of an expression"""
+    tree = ast.parse(expr_str, mode='eval')
+    print(f"Expression: {expr_str}")
+    print(f"AST structure: {ast.dump(tree, indent=2)}")
+    print()
+
+# Test different relational operators
+expressions = [
+    '1 < 2',
+    '1 > 2', 
+    '1 <= 2',
+    '1 >= 2',
+    '1 == 2',
+    '1 != 2'
+]
+
+for expr in expressions:
+    analyze_ast_expr(expr)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..cec4ab783d
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt, Gt, Le, Ge, Eq, Ne, Symbol
+
+print("Comprehensive test of parse_expr with evaluate=False for relationals")
+
+# Test basic relational operations
+print("\n1. Basic relational operations:")
+tests = [
+    ('1 < 2', Lt(1, 2, evaluate=False)),
+    ('1 > 2', Gt(1, 2, evaluate=False)),
+    ('1 <= 2', Le(1, 2, evaluate=False)),
+    ('1 >= 2', Ge(1, 2, evaluate=False)),
+    ('1 == 2', Eq(1, 2, evaluate=False)),
+    ('1 != 2', Ne(1, 2, evaluate=False)),
+]
+
+for expr_str, expected in tests:
+    result = parse_expr(expr_str, evaluate=False)
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result}")
+    print(f"  Type: {type(result)}")
+    print(f"  Expected: {expected}")
+    print(f"  Match: {result == expected}")
+    print()
+
+# Test with variables
+print("\n2. Test with variables:")
+x = Symbol('x')
+tests_with_vars = [
+    ('x < 2', Lt(x, 2, evaluate=False)),
+    ('x > 2', Gt(x, 2, evaluate=False)),
+    ('x <= 2', Le(x, 2, evaluate=False)),
+    ('x >= 2', Ge(x, 2, evaluate=False)),
+    ('x == 2', Eq(x, 2, evaluate=False)),
+    ('x != 2', Ne(x, 2, evaluate=False)),
+]
+
+for expr_str, expected in tests_with_vars:
+    result = parse_expr(expr_str, evaluate=False)
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result}")
+    print(f"  Type: {type(result)}")
+    print(f"  Expected: {expected}")
+    print(f"  Match: {result == expected}")
+    print()
+
+# Test that evaluate=True still works
+print("\n3. Test that evaluate=True still works:")
+print(f"parse_expr('1 < 2', evaluate=True) = {parse_expr('1 < 2', evaluate=True)}")
+print(f"parse_expr('1 > 2', evaluate=True) = {parse_expr('1 > 2', evaluate=True)}")
+print(f"parse_expr('x < 2', evaluate=True) = {parse_expr('x < 2', evaluate=True)}")
+
+# Test complex expressions
+print("\n4. Test complex expressions:")
+complex_tests = [
+    'x + 1 < y - 2',
+    '2*x > 3*y',
+    'x**2 <= y**2',
+]
+
+for expr_str in complex_tests:
+    result_false = parse_expr(expr_str, evaluate=False)
+    result_true = parse_expr(expr_str, evaluate=True)
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result_false}")
+    print(f"parse_expr('{expr_str}', evaluate=True) = {result_true}")
+    print(f"  Different results: {result_false != result_true}")
+    print()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..dda53b0d09
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+
+print("Testing edge cases for parse_expr with evaluate=False")
+
+# Test chained comparisons (should remain as is since we only handle single comparisons)
+print("\n1. Chained comparisons:")
+chained_tests = [
+    '1 < 2 < 3',
+    '1 < x < 3',
+    'x < y < z',
+]
+
+for expr_str in chained_tests:
+    try:
+        result = parse_expr(expr_str, evaluate=False)
+        print(f"parse_expr('{expr_str}', evaluate=False) = {result}")
+        print(f"  Type: {type(result)}")
+    except Exception as e:
+        print(f"parse_expr('{expr_str}', evaluate=False) failed: {e}")
+    print()
+
+# Test with mixed expressions
+print("\n2. Mixed expressions with relationals:")
+mixed_tests = [
+    '(x + 1) < (y - 2)',
+    '2*x + 3 > 5',
+    'x**2 == y**2',
+]
+
+for expr_str in mixed_tests:
+    result_false = parse_expr(expr_str, evaluate=False)
+    result_true = parse_expr(expr_str, evaluate=True)
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result_false}")
+    print(f"parse_expr('{expr_str}', evaluate=True) = {result_true}")
+    print(f"  Different results: {result_false != result_true}")
+    print()
+
+# Test with evaluate=True to ensure we didn't break anything
+print("\n3. Test evaluate=True still works for relationals:")
+print(f"parse_expr('1 < 2', evaluate=True) = {parse_expr('1 < 2', evaluate=True)}")
+print(f"parse_expr('1 > 2', evaluate=True) = {parse_expr('1 > 2', evaluate=True)}")
+print(f"parse_expr('1 == 2', evaluate=True) = {parse_expr('1 == 2', evaluate=True)}")
\ No newline at end of file
diff --git a/test_error_cases.py b/test_error_cases.py
new file mode 100644
index 0000000000..e467af3f30
--- /dev/null
+++ b/test_error_cases.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+
+print("Testing error cases and edge cases")
+
+# Test with unsupported comparison operators (if any)
+print("1. Test with potentially unsupported operators:")
+try:
+    # This might not be a valid comparison operator, but let's see
+    result = parse_expr('1 in [1, 2, 3]', evaluate=False)
+    print(f"parse_expr('1 in [1, 2, 3]', evaluate=False) = {result}")
+except Exception as e:
+    print(f"parse_expr('1 in [1, 2, 3]', evaluate=False) failed: {e}")
+
+try:
+    # Test 'is' operator
+    result = parse_expr('1 is 2', evaluate=False)
+    print(f"parse_expr('1 is 2', evaluate=False) = {result}")
+except Exception as e:
+    print(f"parse_expr('1 is 2', evaluate=False) failed: {e}")
+
+# Test empty comparison
+try:
+    result = parse_expr('1 <', evaluate=False)
+    print(f"parse_expr('1 <', evaluate=False) = {result}")
+except Exception as e:
+    print(f"parse_expr('1 <', evaluate=False) failed: {e}")
+
+print("\n2. Test that normal expressions still work:")
+print(f"parse_expr('x + y') = {parse_expr('x + y')}")
+print(f"parse_expr('sin(x)') = {parse_expr('sin(x)')}")
+print(f"parse_expr('2**3', evaluate=False) = {parse_expr('2**3', evaluate=False)}")
\ No newline at end of file
diff --git a/test_final_validation.py b/test_final_validation.py
new file mode 100644
index 0000000000..d02aa818cb
--- /dev/null
+++ b/test_final_validation.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt, Gt, Le, Ge, Eq, Ne, Symbol
+
+print("Final validation tests for parse_expr with evaluate=False")
+
+# Test the original issue
+print("1. Original issue test:")
+result = parse_expr('1 < 2', evaluate=False)
+expected = Lt(1, 2, evaluate=False)
+print(f"parse_expr('1 < 2', evaluate=False) = {result}")
+print(f"Expected: {expected}")
+print(f"Type: {type(result)}")
+print(f"Success: {result == expected}")
+print()
+
+# Test all relational operators
+print("2. All relational operators:")
+tests = [
+    ('1 < 2', Lt),
+    ('1 > 2', Gt), 
+    ('1 <= 2', Le),
+    ('1 >= 2', Ge),
+    ('1 == 2', Eq),
+    ('1 != 2', Ne),
+]
+
+for expr_str, sympy_class in tests:
+    result = parse_expr(expr_str, evaluate=False)
+    expected = sympy_class(1, 2, evaluate=False)
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result}")
+    print(f"  Type: {type(result)}, Expected type: {sympy_class}")
+    print(f"  Success: {result == expected}")
+print()
+
+# Test that evaluate=True still works
+print("3. evaluate=True still works:")
+print(f"parse_expr('1 < 2', evaluate=True) = {parse_expr('1 < 2', evaluate=True)} (should be True)")
+print(f"parse_expr('1 > 2', evaluate=True) = {parse_expr('1 > 2', evaluate=True)} (should be False)")
+print()
+
+# Test with variables
+print("4. Test with variables:")
+x = Symbol('x')
+y = Symbol('y')
+result = parse_expr('x < y', evaluate=False)
+expected = Lt(x, y, evaluate=False)
+print(f"parse_expr('x < y', evaluate=False) = {result}")
+print(f"Expected: {expected}")
+print(f"Success: {result == expected}")
+print()
+
+# Test complex expressions
+print("5. Complex expressions:")
+complex_expr = '(x + 1) < (y**2 - 2)'
+result_false = parse_expr(complex_expr, evaluate=False)
+result_true = parse_expr(complex_expr, evaluate=True)
+print(f"parse_expr('{complex_expr}', evaluate=False) = {result_false}")
+print(f"parse_expr('{complex_expr}', evaluate=True) = {result_true}")
+print(f"Different results: {result_false != result_true} (should be True)")
+print()
+
+print("All tests completed successfully!")
\ No newline at end of file