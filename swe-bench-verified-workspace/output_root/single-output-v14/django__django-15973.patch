diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bf16fcc9d5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,154 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the ManyToManyField through model issue
+"""
+
+import os
+import sys
+import tempfile
+import django
+from django.conf import settings
+
+# Configure Django settings
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        'fonte',
+        'fonte_variavel',
+        'variavel',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+# Create the models as described in the issue
+from django.db import models
+
+# Create the models in memory first
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+    
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Vari치vel'
+        verbose_name_plural = 'Vari치veis'
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+
+# Now try to create migrations
+from django.core.management import execute_from_command_line
+
+# Create a temporary directory for the apps
+import tempfile
+import shutil
+
+# Create temporary app directories
+temp_dir = tempfile.mkdtemp()
+os.makedirs(os.path.join(temp_dir, 'fonte'), exist_ok=True)
+os.makedirs(os.path.join(temp_dir, 'variavel'), exist_ok=True)
+os.makedirs(os.path.join(temp_dir, 'fonte_variavel'), exist_ok=True)
+
+# Create __init__.py files
+for app in ['fonte', 'variavel', 'fonte_variavel']:
+    with open(os.path.join(temp_dir, app, '__init__.py'), 'w') as f:
+        f.write('')
+
+# Create models.py files
+with open(os.path.join(temp_dir, 'fonte', 'models.py'), 'w') as f:
+    f.write('''
+from django.db import models
+
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+    
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+''')
+
+with open(os.path.join(temp_dir, 'variavel', 'models.py'), 'w') as f:
+    f.write('''
+from django.db import models
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Vari치vel'
+        verbose_name_plural = 'Vari치veis'
+''')
+
+with open(os.path.join(temp_dir, 'fonte_variavel', 'models.py'), 'w') as f:
+    f.write('''
+from django.db import models
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+''')
+
+# Add the temp directory to Python path
+sys.path.insert(0, temp_dir)
+
+try:
+    # Try to create migrations
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(['manage.py', 'makemigrations', 'fonte'])
+    print("Migration created successfully!")
+except Exception as e:
+    print(f"Error creating migration: {e}")
+    import traceback
+    traceback.print_exc()
+
+finally:
+    # Clean up
+    shutil.rmtree(temp_dir)
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..169a53e1b8
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the ManyToManyField through model issue
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+# Now let's examine the issue in the schema.py file
+from django.db import models
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+# Create a simple test case
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+
+class ThroughModel(models.Model):
+    source = models.ForeignKey(TestModel, on_delete=models.CASCADE)
+    target = models.ForeignKey(TestModel, on_delete=models.CASCADE)
+
+class ModelWithM2M(models.Model):
+    name = models.CharField(max_length=100)
+    related = models.ManyToManyField(TestModel, through=ThroughModel)
+
+# The issue is that when through is a string, it's not resolved to a model
+# Let's simulate this
+from django.db.models.fields.related import ManyToManyField
+
+# Create a field with string through reference
+field = ManyToManyField("simple_reproduce.TestModel", through="simple_reproduce.ThroughModel")
+
+print("Field through type:", type(field.remote_field.through))
+print("Field through value:", field.remote_field.through)
+
+# The problem is in schema.py line 453 where it tries to access _meta on a string
+try:
+    if field.remote_field.through._meta.auto_created:
+        print("This would work if through was resolved")
+except AttributeError as e:
+    print(f"AttributeError: {e}")
+    print("This is the exact error from the issue!")
\ No newline at end of file