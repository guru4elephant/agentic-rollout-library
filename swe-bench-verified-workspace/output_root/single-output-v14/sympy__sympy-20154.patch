diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5d1c6e4ade
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy.utilities.iterables import partitions
+
+def test_partitions_reuse_issue():
+    print("Testing partitions() dictionary reuse issue...")
+    
+    # Test the issue mentioned in the docstring
+    result = list(partitions(6, k=2))
+    print(f"list(partitions(6, k=2)) = {result}")
+    
+    # Check if all elements are the same object
+    print(f"All elements are the same object: {all(x is result[0] for x in result)}")
+    
+    # Test with a simple case
+    result2 = list(partitions(3))
+    print(f"list(partitions(3)) = {result2}")
+    print(f"All elements are the same object: {all(x is result2[0] for x in result2)}")
+    
+    # This should show the expected result
+    expected_partitions_3 = [
+        {3: 1},
+        {1: 1, 2: 1},
+        {1: 3}
+    ]
+    
+    print(f"Expected partitions of 3: {expected_partitions_3}")
+    print(f"Actual partitions of 3 (as values): {[{k: v for k, v in p.items()} for p in result2]}")
+    
+    # Test that the values are correct but the objects are reused
+    values_correct = all(
+        dict(p) == expected for p, expected in zip(result2, expected_partitions_3)
+    )
+    print(f"Values are correct: {values_correct}")
+
+if __name__ == "__main__":
+    test_partitions_reuse_issue()
\ No newline at end of file
diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py
index dd36dea304..3e46d5bf16 100644
--- a/sympy/utilities/iterables.py
+++ b/sympy/utilities/iterables.py
@@ -1802,9 +1802,9 @@ def partitions(n, m=None, k=None, size=False):
         keys.append(r)
     room = m - q - bool(r)
     if size:
-        yield sum(ms.values()), ms
+        yield sum(ms.values()), ms.copy()
     else:
-        yield ms
+        yield ms.copy()
 
     while keys != [1]:
         # Reuse any 1's.
@@ -1842,9 +1842,9 @@ def partitions(n, m=None, k=None, size=False):
             break
         room -= need
         if size:
-            yield sum(ms.values()), ms
+            yield sum(ms.values()), ms.copy()
         else:
-            yield ms
+            yield ms.copy()
 
 
 def ordered_partitions(n, m=None, sort=True):