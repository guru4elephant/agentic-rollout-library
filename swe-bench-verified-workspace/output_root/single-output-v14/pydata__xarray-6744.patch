diff --git a/debug_centering.py b/debug_centering.py
new file mode 100644
index 00000000..e96e05fc
--- /dev/null
+++ b/debug_centering.py
@@ -0,0 +1,52 @@
+import xarray as xr
+import numpy as np
+
+# Debug the centering logic more carefully
+my_data = xr.DataArray(np.arange(1,10), dims="x")
+window_size = 3
+
+# Let's see what construct produces for centered windows
+rolling_center = my_data.rolling(x=window_size, center=True)
+constructed = rolling_center.construct("window_dim")
+print("Constructed centered windows:")
+print(constructed.values)
+
+print("\nIndividual windows from construct:")
+for i in range(len(my_data)):
+    window = constructed.isel(x=i)
+    print(f"Position {i}: {window.values}")
+
+# Now let's see what the correct window positions should be
+print("\nExpected window positions for center=True:")
+n = len(my_data)
+for i in range(n):
+    # For centered windows, the window should be centered around position i
+    # The window should span from i - window_size//2 to i + window_size//2
+    start = i - window_size // 2
+    end = start + window_size
+    
+    # Handle edge cases by adjusting the slice
+    if start < 0:
+        # Need to pad at the beginning
+        pad_start = -start
+        start = 0
+    else:
+        pad_start = 0
+        
+    if end > n:
+        # Need to pad at the end
+        pad_end = end - n
+        end = n
+    else:
+        pad_end = 0
+        
+    # Get the actual data slice
+    window_slice = slice(start, end)
+    actual_data = my_data.isel(x=window_slice).values
+    
+    # Create the full window with padding
+    full_window = np.full(window_size, np.nan)
+    full_window[pad_start:window_size-pad_end] = actual_data
+    
+    print(f"Position {i}: start={start}, end={end}, pad_start={pad_start}, pad_end={pad_end}")
+    print(f"  Window: {full_window}")
\ No newline at end of file
diff --git a/debug_iteration.py b/debug_iteration.py
new file mode 100644
index 00000000..588e4db4
--- /dev/null
+++ b/debug_iteration.py
@@ -0,0 +1,37 @@
+import xarray as xr
+import numpy as np
+
+# Debug the iteration logic
+my_data = xr.DataArray(np.arange(1,10), dims="x")
+window_size = 3
+
+# Left-aligned (center=False)
+rolling_left = my_data.rolling(x=window_size, center=False)
+print("Left-aligned windows:")
+for i, (label, window) in enumerate(rolling_left):
+    print(f"Label {label}: window = {window.values}")
+
+print("\n" + "="*50 + "\n")
+
+# Center-aligned (center=True)  
+rolling_center = my_data.rolling(x=window_size, center=True)
+print("Center-aligned windows:")
+for i, (label, window) in enumerate(rolling_center):
+    print(f"Label {label}: window = {window.values}")
+
+# Let's also see what the expected windows should be for center=True
+print("\nExpected center-aligned windows:")
+expected_windows = [
+    [np.nan, 1, 2],    # centered around index 1 (value 2)
+    [1, 2, 3],         # centered around index 2 (value 3)
+    [2, 3, 4],         # centered around index 3 (value 4)
+    [3, 4, 5],         # centered around index 4 (value 5)
+    [4, 5, 6],         # centered around index 5 (value 6)
+    [5, 6, 7],         # centered around index 6 (value 7)
+    [6, 7, 8],         # centered around index 7 (value 8)
+    [7, 8, 9],         # centered around index 8 (value 9)
+    [8, 9, np.nan],    # centered around index 9 (value 10, but out of bounds)
+]
+
+for i, expected in enumerate(expected_windows):
+    print(f"Index {i}: expected = {expected}")
\ No newline at end of file
diff --git a/debug_iteration_internals.py b/debug_iteration_internals.py
new file mode 100644
index 00000000..4330a17d
--- /dev/null
+++ b/debug_iteration_internals.py
@@ -0,0 +1,54 @@
+import xarray as xr
+import numpy as np
+
+# Let's manually debug the iteration logic
+my_data = xr.DataArray(np.arange(1,10), dims="x")
+window_size = 3
+n_labels = len(my_data)
+
+print("Manual debugging of iteration logic:")
+print(f"Data: {my_data.values}")
+print(f"Window size: {window_size}")
+print(f"Number of labels: {n_labels}")
+
+# Simulate the iteration logic
+centers = np.arange(n_labels)
+starts = centers - window_size // 2
+stops = starts + window_size
+
+print("\nCalculated window positions:")
+for i, (start, stop) in enumerate(zip(starts, stops)):
+    print(f"Position {i}: start={start}, stop={stop}")
+    
+    # Handle edge cases
+    if start < 0:
+        pad_start = -start
+        actual_start = 0
+    else:
+        pad_start = 0
+        actual_start = start
+    
+    if stop > n_labels:
+        pad_end = stop - n_labels
+        actual_stop = n_labels
+    else:
+        pad_end = 0
+        actual_stop = stop
+        
+    print(f"  pad_start={pad_start}, actual_start={actual_start}, pad_end={pad_end}, actual_stop={actual_stop}")
+    
+    # Get the actual data slice
+    window_slice = slice(actual_start, actual_stop)
+    window_data = my_data.isel(x=window_slice).values
+    print(f"  Actual data: {window_data}")
+    
+    # Create the full window
+    if pad_start > 0 or pad_end > 0:
+        full_window = np.full(window_size, np.nan, dtype=float)
+        full_window[pad_start:window_size - pad_end] = window_data
+        print(f"  Full window: {full_window}")
+    else:
+        full_window = window_data
+        print(f"  Full window: {full_window}")
+    
+    print()
\ No newline at end of file
diff --git a/debug_padding.py b/debug_padding.py
new file mode 100644
index 00000000..8a4e6635
--- /dev/null
+++ b/debug_padding.py
@@ -0,0 +1,18 @@
+import xarray as xr
+import numpy as np
+
+# Debug the padding logic specifically
+my_data = xr.DataArray(np.arange(1,10), dims="x")
+window_size = 3
+
+rolling_center = my_data.rolling(x=window_size, center=True)
+
+print("Debugging padding for centered windows:")
+for i, (label, window) in enumerate(rolling_center):
+    print(f"Label {label} (position {i}): window = {window.values}")
+    
+    # Let's check the window size and padding
+    if i == 0:
+        print(f"  Window shape: {window.shape}")
+        print(f"  Window dtype: {window.dtype}")
+        print(f"  Window coords: {window.coords}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..941100c6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+import xarray as xr
+import numpy as np
+
+# Reproduce the issue described in the GitHub issue
+my_data = xr.DataArray(np.arange(1,10), dims="x")
+
+# Option 1: take a center-justified rolling average
+result1 = my_data.rolling(x=3, center=True).mean().values
+print("Result 1 (rolling mean with center=True):")
+print(result1)
+
+# Option 2: try to manually iterate, but the result is not centered
+my_data_rolling = my_data.rolling(x=3, center=True)
+result2 = [window.mean().values.item() for label, window in my_data_rolling]
+print("\nResult 2 (manual iteration):")
+print(result2)
+
+# Expected result should be the same as result1
+print("\nExpected result (should match result1):")
+print([np.nan, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, np.nan])
\ No newline at end of file
diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py
index aef290f6..9ebbe6cb 100644
--- a/xarray/core/rolling.py
+++ b/xarray/core/rolling.py
@@ -270,16 +270,67 @@ class DataArrayRolling(Rolling["DataArray"]):
     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:
         if self.ndim > 1:
             raise ValueError("__iter__ is only supported for 1d-rolling")
-        stops = np.arange(1, len(self.window_labels) + 1)
-        starts = stops - int(self.window[0])
-        starts[: int(self.window[0])] = 0
-        for (label, start, stop) in zip(self.window_labels, starts, stops):
-            window = self.obj.isel({self.dim[0]: slice(start, stop)})
-
-            counts = window.count(dim=self.dim[0])
-            window = window.where(counts >= self.min_periods)
-
-            yield (label, window)
+        
+        window_size = int(self.window[0])
+        n_labels = len(self.window_labels)
+        
+        if self.center[0]:
+            # For centered windows, each window is centered around the label position
+            centers = np.arange(n_labels)
+            starts = centers - window_size // 2
+            stops = starts + window_size
+            
+            for i, (label, start, stop) in enumerate(zip(self.window_labels, starts, stops)):
+                # Handle edge cases by adjusting the slice and padding with NaN
+                if start < 0:
+                    # Pad at the beginning
+                    pad_start = -start
+                    actual_start = 0
+                else:
+                    pad_start = 0
+                    actual_start = start
+                
+                if stop > n_labels:
+                    # Pad at the end
+                    pad_end = stop - n_labels
+                    actual_stop = n_labels
+                else:
+                    pad_end = 0
+                    actual_stop = stop
+                
+                # Get the actual data slice
+                window_slice = slice(actual_start, actual_stop)
+                window = self.obj.isel({self.dim[0]: window_slice})
+                
+                # Apply padding if needed
+                if pad_start > 0 or pad_end > 0:
+                    # Create a full-sized window with NaN padding
+                    full_window_values = np.full(window_size, np.nan, dtype=float)
+                    full_window_values[pad_start:window_size - pad_end] = window.values
+                    # Debug output
+                    print(f"DEBUG: Position {i}, pad_start={pad_start}, pad_end={pad_end}")
+                    print(f"DEBUG: Original window values: {window.values}")
+                    print(f"DEBUG: Full window values: {full_window_values}")
+                    # Preserve coordinates by creating a new DataArray with the same structure
+                    window = type(window)(full_window_values, dims=window.dims, coords=window.coords, attrs=window.attrs)
+                
+                counts = window.count(dim=self.dim[0])
+                window = window.where(counts >= self.min_periods)
+
+                yield (label, window)
+        else:
+            # For left-aligned windows (original behavior)
+            stops = np.arange(1, n_labels + 1)
+            starts = stops - window_size
+            starts[:window_size] = 0
+            
+            for (label, start, stop) in zip(self.window_labels, starts, stops):
+                window = self.obj.isel({self.dim[0]: slice(start, stop)})
+
+                counts = window.count(dim=self.dim[0])
+                window = window.where(counts >= self.min_periods)
+
+                yield (label, window)
 
     def construct(
         self,