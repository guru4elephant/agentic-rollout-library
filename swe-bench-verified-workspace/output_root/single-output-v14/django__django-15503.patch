diff --git a/db.sqlite3 b/db.sqlite3
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/debug_json_path.py b/debug_json_path.py
new file mode 100644
index 0000000000..c390d5a6f0
--- /dev/null
+++ b/debug_json_path.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand how compile_json_path works with numeric keys.
+"""
+
+import json
+from django.db.models.fields.json import compile_json_path
+
+# Test the compile_json_path function with different key types
+test_cases = [
+    ['foo'],
+    ['1111'],
+    ['123abc'],
+    [123],  # integer
+    ['0'],  # string zero
+    [0],    # integer zero
+]
+
+for key in test_cases:
+    path = compile_json_path(key)
+    print(f"Key: {key} -> Path: {path}")
\ No newline at end of file
diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fdca700c9d..b56a6ba9d8 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -129,13 +129,12 @@ class JSONField(CheckFieldDefaultMixin, Field):
 def compile_json_path(key_transforms, include_root=True):
     path = ["$"] if include_root else []
     for key_transform in key_transforms:
-        try:
-            num = int(key_transform)
-        except ValueError:  # non-integer
+        # Only treat as array index if it's actually an integer, not a string
+        if isinstance(key_transform, int):
+            path.append("[%s]" % key_transform)
+        else:
             path.append(".")
             path.append(json.dumps(key_transform))
-        else:
-            path.append("[%s]" % num)
     return "".join(path)
 
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..75651e758a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the JSONField has_key issue with numeric keys on SQLite.
+Based on the GitHub issue description.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'db.sqlite3',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Define the test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+
+    class Meta:
+        app_label = 'test'
+
+# Create test data and run the test
+from django.test import TestCase
+
+class JsonFieldHasKeyTestCase(TestCase):
+    def setUp(self):
+        test = JsonFieldHasKeyTest(data={'foo': 'bar'})
+        test2 = JsonFieldHasKeyTest(data={'1111': 'bar'})
+        test.save()
+        test2.save()
+
+    def test_json_field_has_key(self):
+        c1 = JsonFieldHasKeyTest.objects.filter(data__has_key='foo').count()
+        c2 = JsonFieldHasKeyTest.objects.filter(data__has_key='1111').count()
+        print(f"Count for key 'foo': {c1}")
+        print(f"Count for key '1111': {c2}")
+        self.assertEqual(c1, 1, "Should have found 1 entry with key 'foo'")
+        self.assertEqual(c2, 1, "Should have found 1 entry with key '1111'")
+
+if __name__ == '__main__':
+    # Run the test using Django's test framework
+    import unittest
+    suite = unittest.TestSuite()
+    suite.addTest(JsonFieldHasKeyTestCase('test_json_field_has_key'))
+    runner = unittest.TextTestRunner()
+    result = runner.run(suite)
+    if result.wasSuccessful():
+        print("Test completed successfully!")
+    else:
+        print("Test failed!")
\ No newline at end of file
diff --git a/test_db.sqlite3 b/test_db.sqlite3
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..931028ccdd
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the JSONField has_key fix works with numeric keys.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+from django.db.models.fields.json import compile_json_path
+import json
+
+# Test the compile_json_path function directly
+print("Testing compile_json_path function:")
+test_cases = [
+    ['foo'],
+    ['1111'],
+    ['123abc'],
+    [123],  # integer
+    ['0'],  # string zero
+    [0],    # integer zero
+]
+
+for key in test_cases:
+    path = compile_json_path(key)
+    print(f"Key: {key} -> Path: {path}")
+
+# Test with SQLite JSON functions to see if the paths work correctly
+print("\nTesting SQLite JSON functions with generated paths:")
+
+# Create a test JSON object
+test_json = json.dumps({'foo': 'bar', '1111': 'numeric_value', '0': 'zero_value'})
+print(f"Test JSON: {test_json}")
+
+# Test the paths with SQLite JSON functions
+with connection.cursor() as cursor:
+    # Test string key
+    cursor.execute(f"SELECT JSON_TYPE('{test_json}', '$.\"foo\"')")
+    result = cursor.fetchone()
+    print(f"JSON_TYPE($.\"foo\"): {result[0]}")
+
+    # Test numeric string key (this should work now)
+    cursor.execute(f"SELECT JSON_TYPE('{test_json}', '$.\"1111\"')")
+    result = cursor.fetchone()
+    print(f"JSON_TYPE($.\"1111\"): {result[0]}")
+
+    # Test zero string key
+    cursor.execute(f"SELECT JSON_TYPE('{test_json}', '$.\"0\"')")
+    result = cursor.fetchone()
+    print(f"JSON_TYPE($.\"0\"): {result[0]}")
+
+    # Test integer key (array access)
+    cursor.execute(f"SELECT JSON_TYPE('{test_json}', '$[0]')")
+    result = cursor.fetchone()
+    print(f"JSON_TYPE($[0]): {result[0]}")
+
+print("Test completed!")
\ No newline at end of file