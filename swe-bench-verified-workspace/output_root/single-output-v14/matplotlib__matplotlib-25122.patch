diff --git a/lib/matplotlib/mlab.py b/lib/matplotlib/mlab.py
index 3552904c3d..709ec68051 100644
--- a/lib/matplotlib/mlab.py
+++ b/lib/matplotlib/mlab.py
@@ -400,7 +400,7 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,
         # we unwrap the phase later to handle the onesided vs. twosided case
         result = np.angle(result)
     elif mode == 'complex':
-        result /= np.abs(window).sum()
+        result /= window.sum()
 
     if mode == 'psd':
 
@@ -424,10 +424,10 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,
             result /= Fs
             # Scale the spectrum by the norm of the window to compensate for
             # windowing loss; see Bendat & Piersol Sec 11.5.2.
-            result /= (np.abs(window)**2).sum()
+            result /= (window**2).sum()
         else:
             # In this case, preserve power in the segment, not amplitude
-            result /= np.abs(window).sum()**2
+            result /= window.sum()**2
 
     t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2191c6af33
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+import numpy as np
+import matplotlib.mlab as mlab
+
+# Create a window with negative values to reproduce the issue
+# This simulates a window like flattop that can have negative values
+window = np.array([1.0, -0.5, 0.3, -0.2, 0.1])
+print("Testing window correction factor with negative values:")
+print(f"Window: {window}")
+print(f"np.abs(window).sum()**2 - window.sum()**2 = {np.abs(window).sum()**2 - window.sum()**2}")
+print(f"Expected: 0 (or very close to 0)")
+
+# The issue: np.abs(window) vs window
+print(f"\nMathematical proof:")
+print(f"window.sum() = {window.sum()}")
+print(f"np.abs(window).sum() = {np.abs(window).sum()}")
+print(f"These should be equal for the correction to work properly")
+
+# Test with the actual mlab._spectral_helper function
+# Create some dummy data
+Fs = 1000
+N = 1024
+t = np.arange(N) / Fs
+x = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 * t)
+
+# Also test the correction factors directly
+print(f"\nDirect correction factor tests:")
+print(f"Current (incorrect) method: (np.abs(window)**2).sum() = {(np.abs(window)**2).sum()}")
+print(f"Correct method: (window**2).sum() = {(window**2).sum()}")
+print(f"Difference: {(np.abs(window)**2).sum() - (window**2).sum()}")
\ No newline at end of file