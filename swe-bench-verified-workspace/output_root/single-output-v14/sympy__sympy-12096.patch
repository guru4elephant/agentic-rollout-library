diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..083a23bef3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python3
+
+from sympy.utilities.lambdify import implemented_function
+from sympy import evalf
+
+# Reproduce the issue from the GitHub issue
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+
+print("Testing individual functions:")
+print("f(2).evalf():", f(2).evalf())
+print("g(2).evalf():", g(2).evalf())
+
+print("\nTesting composition (this should fail):")
+print("f(g(2)).evalf():", f(g(2)).evalf())
\ No newline at end of file
diff --git a/sympy/core/function.py b/sympy/core/function.py
index 1b8005e1d2..da52d37a77 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -507,7 +507,16 @@ def _eval_evalf(self, prec):
             func = getattr(mpmath, fname)
         except (AttributeError, KeyError):
             try:
-                return Float(self._imp_(*self.args), prec)
+                # Evaluate arguments recursively before calling _imp_
+                evaluated_args = []
+                for arg in self.args:
+                    # Try to evaluate the argument recursively
+                    if hasattr(arg, '_eval_evalf'):
+                        evaluated_arg = arg._eval_evalf(prec)
+                        evaluated_args.append(evaluated_arg if evaluated_arg is not None else arg)
+                    else:
+                        evaluated_args.append(arg)
+                return Float(self._imp_(*evaluated_args), prec)
             except (AttributeError, TypeError, ValueError):
                 return
 
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..bc7fc0877e
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy.utilities.lambdify import implemented_function
+from sympy import evalf
+
+# Test edge cases for the fix
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+h = implemented_function('h', lambda x: x + 1)
+
+print("Testing multiple levels of composition:")
+print("f(g(h(2))).evalf():", f(g(h(2))).evalf())  # Should be f(g(3)) = f(6) = 36
+
+print("\nTesting with regular sympy expressions:")
+from sympy import sin
+print("f(sin(0)).evalf():", f(sin(0)).evalf())  # Should be f(0) = 0
+
+print("\nTesting with non-numeric arguments:")
+print("f(g(x)).evalf():", f(g(2)).evalf())  # Should still work with numeric input
+
+print("\nTesting error handling:")
+try:
+    # This should fail gracefully
+    bad_func = implemented_function('bad', lambda x: 1/x)
+    print("bad_func(0).evalf():", bad_func(0).evalf())
+except Exception as e:
+    print("Error handled correctly:", type(e).__name__)
\ No newline at end of file
diff --git a/test_no_evalf.py b/test_no_evalf.py
new file mode 100644
index 0000000000..5412355688
--- /dev/null
+++ b/test_no_evalf.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+from sympy.utilities.lambdify import implemented_function
+
+# Test case where arguments don't have evalf method
+class CustomObject:
+    def __init__(self, value):
+        self.value = value
+    
+    def __repr__(self):
+        return f"CustomObject({self.value})"
+
+f = implemented_function('f', lambda x: x.value ** 2 if hasattr(x, 'value') else x ** 2)
+
+# Test with custom object (no evalf method)
+custom_obj = CustomObject(3)
+print("f(custom_obj):", f(custom_obj))
+print("f(custom_obj).evalf():", f(custom_obj).evalf())
+
+# Test with regular number (has evalf method)
+print("f(3):", f(3))
+print("f(3).evalf():", f(3).evalf())
\ No newline at end of file