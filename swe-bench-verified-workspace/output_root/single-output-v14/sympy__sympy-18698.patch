diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..1aa081f0c1
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+
+from sympy import sqf_list, symbols, Poly
+from sympy.polys.rings import ring
+from sympy.polys.domains import ZZ
+
+x = symbols('x')
+
+# Test case from the issue
+expr = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3
+print("Original expression:", expr)
+print()
+
+# Let's test the ring implementation directly
+R, x_ring = ring("x", ZZ)
+expr_ring = (x_ring**2 + 1) * (x_ring - 1)**2 * (x_ring - 2)**3 * (x_ring - 3)**3
+print("Ring expression:", expr_ring)
+ring_result = R.dup_sqf_list(expr_ring)
+print("Ring sqf_list result:", ring_result)
+print()
+
+# Let's see what happens when we convert the ring result back to symbolic
+print("Converting ring result back to symbolic:")
+coeff, factors = ring_result
+for i, (factor, multiplicity) in enumerate(factors):
+    print(f"Factor {i}: {factor} (multiplicity {multiplicity})")
+    print(f"  As expression: {factor.as_expr()}")
+    print(f"  Is this factor reducible? {factor.as_expr().factor() != factor.as_expr()}")
+    if factor.as_expr().factor() != factor.as_expr():
+        print(f"  Factors into: {factor.as_expr().factor()}")
+    print()
+
+# Let's also test what happens with a Poly object
+print("Testing with Poly object:")
+poly_expr = Poly(expr, x)
+print("Poly object:", poly_expr)
+poly_result = poly_expr.sqf_list()
+print("Poly sqf_list result:", poly_result)
+print()
+
+# And finally, the symbolic sqf_list
+print("Symbolic sqf_list result:")
+symbolic_result = sqf_list(expr)
+print(symbolic_result)
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..c674e5143a
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+from sympy import sqf_list, symbols, expand
+from sympy.polys.rings import ring
+from sympy.polys.domains import ZZ
+
+x = symbols('x')
+
+# Test case from the issue
+expr = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3
+print("Original expression:", expr)
+print("Expanded:", expand(expr))
+print("sqf_list result:", sqf_list(expr))
+print()
+
+# Let's test what happens if we manually combine (x-2) and (x-3)
+combined_factor = (x-2)*(x-3)
+print("Combined factor (x-2)*(x-3):", combined_factor)
+print("sqf_list of combined factor:", sqf_list(combined_factor))
+print()
+
+# Let's test the ring implementation directly
+R, x_ring = ring("x", ZZ)
+expr_ring = (x_ring**2 + 1) * (x_ring - 1)**2 * (x_ring - 2)**3 * (x_ring - 3)**3
+print("Ring expression:", expr_ring)
+print("Ring sqf_list result:", R.dup_sqf_list(expr_ring))
+print()
+
+# Let's also test the second example from the issue
+expr2 = x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2
+print("Second expression:", expr2)
+print("sqf_list result:", sqf_list(expr2))
+print("Factorized:", expr2.factor())
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dd5bfbb6a9
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+from sympy import sqf_list, symbols
+
+x = symbols('x')
+
+# Test case from the issue
+print("Test case 1:")
+expr1 = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3
+result1 = sqf_list(expr1)
+print(f"Expression: {expr1}")
+print(f"Result: {result1}")
+print()
+
+# Expected: (1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])
+# Current (wrong): (1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])
+
+print("Test case 2 (should be correct):")
+expr2 = x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2
+result2 = sqf_list(expr2)
+print(f"Expression: {expr2}")
+print(f"Result: {result2}")
+print()
+
+# Expected: (1, [(x - 2, 1), (x**2 - 1, 2)])
+# Current (correct): (1, [(x - 2, 1), (x**2 - 1, 2)])
+
+# Let's also test the individual factors
+print("Testing individual factors:")
+print(f"sqf_list(x**2 + 1): {sqf_list(x**2 + 1)}")
+print(f"sqf_list((x - 1)**2): {sqf_list((x - 1)**2)}")
+print(f"sqf_list((x - 2)**3): {sqf_list((x - 2)**3)}")
+print(f"sqf_list((x - 3)**3): {sqf_list((x - 3)**3)}")
\ No newline at end of file
diff --git a/test_conversion.py b/test_conversion.py
new file mode 100644
index 0000000000..f5941a075a
--- /dev/null
+++ b/test_conversion.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Poly
+from sympy.polys.rings import ring
+from sympy.polys.domains import ZZ
+
+x = symbols('x')
+
+# Create a polynomial object
+R, x_ring = ring("x", ZZ)
+poly_obj = x_ring**2 - 5*x_ring + 6
+
+print("Polynomial object:", poly_obj)
+print("Type:", type(poly_obj))
+print("As expression:", poly_obj.as_expr())
+print("As expression type:", type(poly_obj.as_expr()))
+print("String representation:", str(poly_obj))
+print("Repr:", repr(poly_obj))
+
+# Let's see if we can prevent factorization
+expr = poly_obj.as_expr()
+print("Can we prevent factorization?", expr)
+print("Factorized:", expr.factor())
+
+# Let's try using the Poly constructor to preserve the form
+poly_from_ring = Poly(poly_obj, x)
+print("Poly from ring:", poly_from_ring)
+print("Poly as expr:", poly_from_ring.as_expr())
\ No newline at end of file
diff --git a/trace_detailed.py b/trace_detailed.py
new file mode 100644
index 0000000000..b11d8d4dbd
--- /dev/null
+++ b/trace_detailed.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+import sympy
+from sympy import sqf_list, symbols
+from sympy.polys.polytools import _symbolic_factor_list
+from sympy.polys.rings import ring
+from sympy.polys.domains import ZZ
+
+# Test the ring implementation directly
+x = symbols('x')
+R, x_ring = ring("x", ZZ)
+expr_ring = (x_ring**2 + 1) * (x_ring - 1)**2 * (x_ring - 2)**3 * (x_ring - 3)**3
+
+print("Ring implementation:")
+ring_result = R.dup_sqf_list(expr_ring)
+print(f"Ring result: {ring_result}")
+
+print("\nSymbolic implementation:")
+expr_symbolic = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3
+
+# Monkey patch to add more detailed debug
+original_poly_from_expr = sympy.polys.polytools._poly_from_expr
+
+def debug_poly_from_expr(expr, opt):
+    print(f"DEBUG: _poly_from_expr called with expr={expr}")
+    result = original_poly_from_expr(expr, opt)
+    print(f"DEBUG: _poly_from_expr result = {result}")
+    return result
+
+sympy.polys.polytools._poly_from_expr = debug_poly_from_expr
+
+result = _symbolic_factor_list(expr_symbolic, {'polys': False}, 'sqf')
+print(f"Symbolic result: {result}")
\ No newline at end of file
diff --git a/trace_sqf.py b/trace_sqf.py
new file mode 100644
index 0000000000..d4ef218e0b
--- /dev/null
+++ b/trace_sqf.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+import sympy
+from sympy import sqf_list, symbols
+from sympy.polys.polytools import _generic_factor_list
+
+# Monkey patch to add debug output
+original_symbolic_factor_list = sympy.polys.polytools._symbolic_factor_list
+
+def debug_symbolic_factor_list(expr, opt, method):
+    print(f"DEBUG: _symbolic_factor_list called with method={method}")
+    print(f"DEBUG: expr = {expr}")
+    result = original_symbolic_factor_list(expr, opt, method)
+    print(f"DEBUG: _symbolic_factor_list result = {result}")
+    return result
+
+sympy.polys.polytools._symbolic_factor_list = debug_symbolic_factor_list
+
+# Test the issue
+x = symbols('x')
+expr = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3
+
+print("Testing sqf_list:")
+result = sqf_list(expr)
+print(f"Final result: {result}")
+
+print("\nTesting _generic_factor_list directly:")
+result2 = _generic_factor_list(expr, [], {}, method='sqf')
+print(f"Direct result: {result2}")
\ No newline at end of file