diff --git a/django/db/models/base.py b/django/db/models/base.py
index e3b14a41a0..6b44f74449 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -840,6 +840,7 @@ class Model(metaclass=ModelBase):
                        if f.name in update_fields or f.attname in update_fields]
 
         pk_val = self._get_pk_val(meta)
+        pk_was_none = pk_val is None
         if pk_val is None:
             pk_val = meta.pk.get_pk_value_on_save(self)
             setattr(self, meta.pk.attname, pk_val)
@@ -848,11 +849,14 @@ class Model(metaclass=ModelBase):
             raise ValueError("Cannot force an update in save() with no primary key.")
         updated = False
         # Skip an UPDATE when adding an instance and primary key has a default.
+        # Only force INSERT if the primary key was generated by the default mechanism,
+        # not if an explicit primary key value was provided.
         if (
             not force_insert and
             self._state.adding and
             self._meta.pk.default and
-            self._meta.pk.default is not NOT_PROVIDED
+            self._meta.pk.default is not NOT_PROVIDED and
+            pk_was_none  # Only force INSERT if pk was None (generated by default)
         ):
             force_insert = True
         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5502d6dfcf
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from uuid import uuid4
+from django.db import models
+
+class Sample(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid4)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_issue():
+    print("Testing the issue described in the GitHub issue...")
+    
+    # Create the database tables
+    from django.db import connection
+    from django.db.backends.base.base import BaseDatabaseWrapper
+    
+    # Create table using Django's schema editor
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Sample)
+    
+    try:
+        # Create first object
+        s0 = Sample.objects.create()
+        print(f"Created s0 with pk: {s0.pk}")
+        
+        # Create second object with explicit pk from s0
+        s1 = Sample(pk=s0.pk, name='Test 1')
+        print(f"Created s1 with explicit pk: {s1.pk}")
+        
+        # This should result in an UPDATE in Django 2.2, but INSERT in Django 3.0+
+        s1.save()
+        print("s1.save() completed successfully")
+        
+        # Check if we have two objects (should be False if UPDATE worked)
+        count = Sample.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 2:
+            print("ISSUE REPRODUCED: Two INSERTs occurred instead of INSERT+UPDATE")
+        else:
+            print("No issue: Expected behavior (INSERT+UPDATE)")
+            
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_issue()
\ No newline at end of file
diff --git a/run_force_insert_tests.py b/run_force_insert_tests.py
new file mode 100644
index 0000000000..0c1d8b8489
--- /dev/null
+++ b/run_force_insert_tests.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Add the tests directory to Python path
+sys.path.insert(0, 'tests')
+
+# Now we can import and run the tests
+from force_insert_update.tests import ForceTests, InheritanceTests
+import unittest
+
+def run_tests():
+    print("Running force_insert_update tests...")
+    
+    # Create database tables first
+    from django.db import connection
+    
+    # Create tables for the test models
+    from force_insert_update.models import Counter, InheritedCounter, ProxyCounter, SubCounter, WithCustomPK
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Counter)
+        schema_editor.create_model(InheritedCounter)
+        schema_editor.create_model(ProxyCounter)
+        schema_editor.create_model(SubCounter)
+        schema_editor.create_model(WithCustomPK)
+    
+    # Create test suite
+    suite = unittest.TestSuite()
+    suite.addTest(unittest.makeSuite(ForceTests))
+    suite.addTest(unittest.makeSuite(InheritanceTests))
+    
+    # Run tests
+    runner = unittest.TextTestRunner(verbosity=2)
+    result = runner.run(suite)
+    
+    print(f"\nTests run: {result.testsRun}")
+    print(f"Errors: {len(result.errors)}")
+    print(f"Failures: {len(result.failures)}")
+    
+    return result.wasSuccessful()
+
+if __name__ == '__main__':
+    success = run_tests()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..356bbf3606
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from uuid import uuid4
+from django.db import models
+
+class SampleWithDefault(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid4)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test1'
+
+class SampleWithoutDefault(models.Model):
+    id = models.UUIDField(primary_key=True)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test2'
+
+def test_edge_cases():
+    print("Testing edge cases...")
+    
+    # Create the database tables
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(SampleWithDefault)
+        schema_editor.create_model(SampleWithoutDefault)
+    
+    # Test 1: With default, explicit pk provided (should UPDATE)
+    print("\n1. Testing with default and explicit pk...")
+    try:
+        s0 = SampleWithDefault.objects.create()
+        print(f"Created s0 with pk: {s0.pk}")
+        
+        s1 = SampleWithDefault(pk=s0.pk, name='Test 1')
+        print(f"Created s1 with explicit pk: {s1.pk}")
+        
+        s1.save()
+        print("s1.save() completed successfully")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 1:
+            print("✓ PASS: Expected behavior (UPDATE)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 2: Without default, explicit pk provided (should INSERT)
+    print("\n2. Testing without default and explicit pk...")
+    try:
+        import uuid
+        test_pk = uuid.uuid4()
+        s2 = SampleWithoutDefault(pk=test_pk, name='Test 2')
+        print(f"Created s2 with explicit pk: {s2.pk}")
+        
+        s2.save()
+        print("s2.save() completed successfully")
+        
+        count = SampleWithoutDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 1:
+            print("✓ PASS: Expected behavior (INSERT)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 3: With default, no explicit pk provided (should INSERT with generated pk)
+    print("\n3. Testing with default and no explicit pk...")
+    try:
+        s3 = SampleWithDefault(name='Test 3')
+        print("Created s3 with no explicit pk")
+        
+        s3.save()
+        print(f"s3.save() completed successfully, pk: {s3.pk}")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 2:  # s0 + s3 (s1 updated s0)
+            print("✓ PASS: Expected behavior (INSERT with generated pk)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..77b0fb2dc2
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,168 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from uuid import uuid4
+from django.db import models
+
+class SampleWithDefault(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid4)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class SampleWithoutDefault(models.Model):
+    id = models.UUIDField(primary_key=True)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_scenarios():
+    print("Testing comprehensive scenarios for the fix...")
+    
+    # Create the database tables
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(SampleWithDefault)
+        schema_editor.create_model(SampleWithoutDefault)
+    
+    # Test 1: With default, explicit pk provided (should UPDATE, not INSERT)
+    print("\n1. Testing with default and explicit pk (should UPDATE)...")
+    try:
+        s0 = SampleWithDefault.objects.create()
+        print(f"Created s0 with pk: {s0.pk}")
+        
+        s1 = SampleWithDefault(pk=s0.pk, name='Test 1')
+        print(f"Created s1 with explicit pk: {s1.pk}")
+        
+        s1.save()
+        print("s1.save() completed successfully")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 1:
+            print("✓ PASS: Expected behavior (UPDATE)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 2: Without default, explicit pk provided (should INSERT)
+    print("\n2. Testing without default and explicit pk (should INSERT)...")
+    try:
+        import uuid
+        test_pk = uuid.uuid4()
+        s2 = SampleWithoutDefault(pk=test_pk, name='Test 2')
+        print(f"Created s2 with explicit pk: {s2.pk}")
+        
+        s2.save()
+        print("s2.save() completed successfully")
+        
+        count = SampleWithoutDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 1:
+            print("✓ PASS: Expected behavior (INSERT)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 3: With default, no explicit pk provided (should INSERT with generated pk)
+    print("\n3. Testing with default and no explicit pk (should INSERT with generated pk)...")
+    try:
+        s3 = SampleWithDefault(name='Test 3')
+        print("Created s3 with no explicit pk")
+        
+        s3.save()
+        print(f"s3.save() completed successfully, pk: {s3.pk}")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 2:  # s0 + s3 (s1 updated s0)
+            print("✓ PASS: Expected behavior (INSERT with generated pk)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 4: Edge case - try to update non-existent object with explicit pk
+    print("\n4. Testing update non-existent object with explicit pk (should INSERT)...")
+    try:
+        import uuid
+        non_existent_pk = uuid.uuid4()
+        s4 = SampleWithDefault(pk=non_existent_pk, name='Test 4')
+        print(f"Created s4 with explicit pk for non-existent object: {s4.pk}")
+        
+        s4.save()
+        print("s4.save() completed successfully")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 3:  # Should have inserted new object
+            print("✓ PASS: Expected behavior (INSERT for non-existent pk)")
+        else:
+            print("✗ FAIL: Unexpected behavior")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    # Test 5: Test the original GitHub issue scenario exactly
+    print("\n5. Testing exact GitHub issue scenario...")
+    try:
+        # This is the exact scenario from the GitHub issue
+        s0 = SampleWithDefault.objects.create()
+        print(f"Created s0 with pk: {s0.pk}")
+        
+        s1 = SampleWithDefault(pk=s0.pk, name='Test 1')
+        print(f"Created s1 with explicit pk: {s1.pk}")
+        
+        # In Django 2.2: INSERT followed by UPDATE
+        # In Django 3.0+: Two INSERTs (second fails)
+        # With our fix: INSERT followed by UPDATE
+        s1.save()
+        print("s1.save() completed successfully")
+        
+        count = SampleWithDefault.objects.count()
+        print(f"Total objects in database: {count}")
+        
+        if count == 3:  # s0, s3, s4 (s1 updated s0)
+            print("✓ PASS: GitHub issue fixed! (INSERT+UPDATE behavior restored)")
+        else:
+            print("✗ FAIL: GitHub issue not fixed")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+
+if __name__ == '__main__':
+    test_scenarios()
\ No newline at end of file
diff --git a/test_github_issue_only.py b/test_github_issue_only.py
new file mode 100644
index 0000000000..a400478880
--- /dev/null
+++ b/test_github_issue_only.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from uuid import uuid4
+from django.db import models
+
+class Sample(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid4)
+    name = models.CharField(blank=True, max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_github_issue():
+    print("Testing exact GitHub issue scenario...")
+    
+    # Create the database tables
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Sample)
+    
+    # This is the exact scenario from the GitHub issue
+    s0 = Sample.objects.create()
+    print(f"Created s0 with pk: {s0.pk}")
+    
+    s1 = Sample(pk=s0.pk, name='Test 1')
+    print(f"Created s1 with explicit pk: {s1.pk}")
+    
+    # In Django 2.2: INSERT followed by UPDATE
+    # In Django 3.0+: Two INSERTs (second fails)
+    # With our fix: INSERT followed by UPDATE
+    s1.save()
+    print("s1.save() completed successfully")
+    
+    count = Sample.objects.count()
+    print(f"Total objects in database: {count}")
+    
+    if count == 1:
+        print("✓ PASS: GitHub issue fixed! (INSERT+UPDATE behavior restored)")
+        return True
+    else:
+        print("✗ FAIL: GitHub issue not fixed")
+        return False
+
+if __name__ == '__main__':
+    success = test_github_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/tests/force_insert_update/models.py b/tests/force_insert_update/models.py
index a98eadb4f9..219345e359 100644
--- a/tests/force_insert_update/models.py
+++ b/tests/force_insert_update/models.py
@@ -9,20 +9,33 @@ class Counter(models.Model):
     name = models.CharField(max_length=10)
     value = models.IntegerField()
 
+    class Meta:
+        app_label = 'force_insert_update'
+
 
 class InheritedCounter(Counter):
     tag = models.CharField(max_length=10)
 
+    class Meta:
+        app_label = 'force_insert_update'
+
 
 class ProxyCounter(Counter):
     class Meta:
         proxy = True
+        app_label = 'force_insert_update'
 
 
 class SubCounter(Counter):
     pass
 
+    class Meta:
+        app_label = 'force_insert_update'
+
 
 class WithCustomPK(models.Model):
     name = models.IntegerField(primary_key=True)
     value = models.IntegerField()
+
+    class Meta:
+        app_label = 'force_insert_update'