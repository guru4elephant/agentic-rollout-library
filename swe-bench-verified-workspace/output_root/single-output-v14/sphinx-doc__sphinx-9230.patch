diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..f7fc94be3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+
+"""Script to reproduce the docstring parameter rendering issue."""
+
+def test_function(opc_meta):
+    """
+    Test function with parameter that has dict(str, str) type annotation.
+    
+    :param dict(str, str) opc_meta: (optional) A dictionary mapping strings to strings
+    :return: None
+    """
+    pass
+
+def main():
+    """Main function to demonstrate the issue."""
+    # Let's parse the docstring to see what happens
+    import inspect
+    from sphinx.ext.autodoc import Documenter
+    from sphinx.application import Sphinx
+    from sphinx.util.docstrings import extract_metadata
+    
+    docstring = test_function.__doc__
+    print("Original docstring:")
+    print(docstring)
+    print("\n" + "="*50 + "\n")
+    
+    # Try to extract parameter information
+    lines = docstring.split('\n')
+    for line in lines:
+        if ':param' in line:
+            print(f"Parameter line: {line}")
+            
+            # Let's see how Sphinx parses this
+            # This is a simplified version of what happens in autodoc
+            param_line = line.strip()
+            if param_line.startswith(':param'):
+                # Remove ':param ' prefix
+                param_part = param_line[6:].strip()
+                print(f"After removing ':param': {param_part}")
+                
+                # Try to split on colon to separate type from description
+                if ':' in param_part:
+                    type_and_name, description = param_part.split(':', 1)
+                    print(f"Type and name: '{type_and_name}'")
+                    print(f"Description: '{description}'")
+                    
+                    # Split type and name
+                    parts = type_and_name.strip().split()
+                    if len(parts) >= 2:
+                        type_part = parts[0]
+                        name_part = parts[1]
+                        print(f"Type part: '{type_part}'")
+                        print(f"Name part: '{name_part}'")
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/reproduce_issue_detailed.py b/reproduce_issue_detailed.py
new file mode 100644
index 000000000..13285dbc9
--- /dev/null
+++ b/reproduce_issue_detailed.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+
+"""Detailed script to reproduce the docstring parameter rendering issue."""
+
+def test_function(opc_meta):
+    """
+    Test function with parameter that has dict(str, str) type annotation.
+    
+    :param dict(str, str) opc_meta: (optional) A dictionary mapping strings to strings
+    :return: None
+    """
+    pass
+
+def main():
+    """Main function to demonstrate the issue."""
+    # Let's parse the docstring using docutils field parsing
+    from docutils.parsers.rst.states import Body
+    from docutils.parsers.rst import Parser
+    from docutils.utils import new_document
+    from docutils.frontend import OptionParser
+    from docutils import nodes
+    
+    docstring = test_function.__doc__
+    print("Original docstring:")
+    print(repr(docstring))
+    print("\n" + "="*50 + "\n")
+    
+    # Parse using docutils field pattern
+    import re
+    field_list_item_re = re.compile(Body.patterns['field_marker'])
+    print("Field marker pattern:", repr(Body.patterns['field_marker']))
+    
+    lines = docstring.split('\n')
+    for line in lines:
+        line = line.strip()
+        if not line:
+            continue
+            
+        match = field_list_item_re.match(line)
+        if match:
+            print(f"Matched field line: {repr(line)}")
+            field_marker = match.group()
+            print(f"Field marker: {repr(field_marker)}")
+            
+            # Extract the field body
+            field_body = line[match.end():].strip()
+            print(f"Field body: {repr(field_body)}")
+            
+            # Parse the field body to see how it's split
+            if field_marker.startswith(':param'):
+                # This is where the issue likely occurs - parsing the field body
+                field_body_parts = field_body.split(':', 1)
+                print(f"Field body parts: {field_body_parts}")
+                
+                if len(field_body_parts) > 1:
+                    param_part = field_body_parts[0].strip()
+                    desc_part = field_body_parts[1].strip()
+                    print(f"Parameter part: {repr(param_part)}")
+                    print(f"Description part: {repr(desc_part)}")
+                    
+                    # Now let's see how the parameter part is parsed
+                    # This is where the issue likely is - splitting on spaces incorrectly
+                    param_parts = param_part.split()
+                    print(f"Parameter parts: {param_parts}")
+                    
+                    if len(param_parts) >= 2:
+                        # The issue: it splits on spaces, but dict(str, str) should be treated as one token
+                        type_part = param_parts[0]
+                        name_part = param_parts[1]
+                        print(f"Type part (incorrect): {repr(type_part)}")
+                        print(f"Name part (incorrect): {repr(name_part)}")
+                        
+                        # Let's try to parse it more intelligently
+                        # Look for the first word that ends with ) followed by a word
+                        import re
+                        better_match = re.match(r'^(.+?\))\s+(\w+)$', param_part)
+                        if better_match:
+                            correct_type = better_match.group(1)
+                            correct_name = better_match.group(2)
+                            print(f"Correct type: {repr(correct_type)}")
+                            print(f"Correct name: {repr(correct_name)}")
+                        else:
+                            print("Could not parse with better regex")
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/setup.py b/setup.py
index 2538952e3..94e1d8b32 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.14,<0.18',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py
index af4b47bb0..53a261868 100644
--- a/sphinx/ext/autodoc/typehints.py
+++ b/sphinx/ext/autodoc/typehints.py
@@ -85,6 +85,7 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No
     fields = cast(Iterable[nodes.field], node)
     for field in fields:
         field_name = field[0].astext()
+        # Handle complex type annotations with parentheses
         parts = re.split(' +', field_name)
         if parts[0] == 'param':
             if len(parts) == 2:
@@ -92,9 +93,28 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No
                 arg = arguments.setdefault(parts[1], {})
                 arg['param'] = True
             elif len(parts) > 2:
-                # :param xxx yyy:
-                name = ' '.join(parts[2:])
-                arg = arguments.setdefault(name, {})
+                # Handle complex type annotations like :param dict(str, str) xxx:
+                # Join parts from index 1 until we find a part that ends with )
+                type_parts = []
+                param_name = None
+                for i in range(1, len(parts)):
+                    if parts[i].endswith(')') and not parts[i].endswith('())'):
+                        # This part ends with ), so it's likely the end of the type
+                        type_parts.append(parts[i])
+                        if i + 1 < len(parts):
+                            param_name = ' '.join(parts[i + 1:])
+                        else:
+                            # No parameter name found, use the last part as name
+                            param_name = parts[i]
+                        break
+                    else:
+                        type_parts.append(parts[i])
+                
+                if param_name is None:
+                    # Fallback: use the original logic
+                    param_name = ' '.join(parts[2:])
+                
+                arg = arguments.setdefault(param_name, {})
                 arg['param'] = True
                 arg['type'] = True
         elif parts[0] == 'type':
diff --git a/tox.ini b/tox.ini
index a363e187f..3b8bc12d0 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3