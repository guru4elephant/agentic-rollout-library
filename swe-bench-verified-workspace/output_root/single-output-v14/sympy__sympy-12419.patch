diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b24c69bf85
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+e = None
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Correct: M.T * M is an identity matrix.
+print("Matrix e:", e)
+print("Elements:", e[0, 0], e[0, 1], e[1, 0], e[1, 1])
+
+# Correct: The output is True True
+print("Is diagonal:", ask(Query.diagonal(e)))
+print("Has integer elements:", ask(Query.integer_elements(e)))
+
+# Correct: The sum of the diagonal elements is n
+print("Sum of diagonal:", Sum(e[i, i], (i, 0, n-1)).doit())
+
+# So far so good
+# Total sum of the elements is expected to be 'n' but the answer is 0!
+print("Total sum of elements:", Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
\ No newline at end of file
diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py
index 372487664c..99d28cd423 100644
--- a/sympy/concrete/summations.py
+++ b/sympy/concrete/summations.py
@@ -855,6 +855,21 @@ def eval_sum(f, limits):
     if a == b:
         return f.subs(i, a)
     if isinstance(f, Piecewise):
+        # Special case: Piecewise((1, condition), (0, True)) summed over range where condition is true
+        if len(f.args) == 2 and f.args[0].expr == 1 and f.args[1].expr == 0 and f.args[1].cond == True:
+            condition = f.args[0].cond
+            # Check if the summation range matches the condition
+            # For Sum(Piecewise((1, condition), (0, True)), (i, a, b)), if condition is equivalent to (a <= i <= b)
+            # then the result should be (b - a + 1)
+            from sympy.solvers.solveset import solveset
+            from sympy.sets import Interval
+            try:
+                solution = solveset(condition, i, domain=S.Reals)
+                if solution == Interval(a, b):
+                    return b - a + 1
+            except:
+                pass
+        
         if not any(i in arg.args[1].free_symbols for arg in f.args):
             # Piecewise conditions do not depend on the dummy summation variable,
             # therefore we can fold:     Sum(Piecewise((e, c), ...), limits)
diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py
index b4d759836e..02c0fd1848 100644
--- a/sympy/matrices/expressions/matexpr.py
+++ b/sympy/matrices/expressions/matexpr.py
@@ -476,8 +476,11 @@ def conjugate(self):
         return self
 
     def _entry(self, i, j):
+        from sympy.functions import KroneckerDelta
         if i == j:
             return S.One
+        elif isinstance(i, (Symbol, Expr)) or isinstance(j, (Symbol, Expr)):
+            return KroneckerDelta(i, j)
         else:
             return S.Zero