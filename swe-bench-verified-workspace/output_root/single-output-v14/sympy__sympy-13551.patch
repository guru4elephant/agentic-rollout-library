diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..1d7b1b815b
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import n,k
+
+# Let's debug what happens with the Add case
+term = n + 1 / 2**k
+print("Original term:", term)
+print("Term type:", type(term))
+
+# Check what as_numer_denom() returns
+p, q = term.as_numer_denom()
+print("as_numer_denom() result:")
+print("  p:", p)
+print("  q:", q)
+
+# Check what as_coeff_Add() returns for p
+coeff_add = p.as_coeff_Add()
+print("p.as_coeff_Add():", coeff_add)
+
+# Let's see what happens when we try to evaluate each part separately
+print("\nEvaluating each part separately:")
+for i in p.as_coeff_Add():
+    print(f"  Part {i}:")
+    prod_i = Product(i, (k, 0, n-1)).doit()
+    print(f"    Product result: {prod_i}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e1dc78f3fa
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import n,k
+
+# Reproduce the issue
+print("Testing the issue with Product(n + 1 / 2**k, [k, 0, n-1])")
+
+p = Product(n + 1 / 2**k, [k, 0, n-1]).doit()
+print("Result from doit():", p)
+
+simplified = simplify(p)
+print("Simplified result:", simplified)
+
+# Test with n=2
+print("\nTesting with n=2:")
+result_n2 = p.subs(n, 2)
+print("Result for n=2:", result_n2)
+
+# Manual calculation for n=2
+manual_n2 = (2 + 1/2**0) * (2 + 1/2**1)
+print("Manual calculation for n=2:", manual_n2)
+print("Are they equal?", result_n2 == manual_n2)
+
+# The correct expression should be (n; 1/2)_n * 2^(n(n-1)/2)
+# where (a; q)_n is the q-Pochhammer symbol
+print("\nExpected result should involve q-Pochhammer symbol")
\ No newline at end of file
diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..46e835194d 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -275,18 +275,10 @@ def _eval_product(self, term, limits):
             return poly.LC()**(n - a + 1) * A * B
 
         elif term.is_Add:
-            p, q = term.as_numer_denom()
-            q = self._eval_product(q, (k, a, n))
-            if q.is_Number:
-
-                # There is expression, which couldn't change by
-                # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).
-                # We have to catch this case.
-
-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])
-            else:
-                p = self._eval_product(p, (k, a, n))
-            return p / q
+            # Products of sums cannot be distributed like sums can
+            # For example: ∏(a + b) ≠ ∏a + ∏b and ∏(a + b) ≠ ∏a * ∏b
+            # We return None to avoid incorrect results
+            return None
 
         elif term.is_Mul:
             exclude, include = [], []
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..583c742d32
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import n,k,i
+
+print("Testing edge cases for Product fix:")
+
+# Test 1: Simple product that should still work
+print("\n1. Simple product (should work):")
+p1 = Product(k, (k, 1, n)).doit()
+print("Product(k, (k, 1, n)) =", p1)
+
+# Test 2: Product with constant term (should work)
+print("\n2. Product with constant term (should work):")
+p2 = Product(2, (k, 1, n)).doit()
+print("Product(2, (k, 1, n)) =", p2)
+
+# Test 3: Product of sum (should remain unevaluated)
+print("\n3. Product of sum (should remain unevaluated):")
+p3 = Product(n + k, (k, 1, n)).doit()
+print("Product(n + k, (k, 1, n)) =", p3)
+
+# Test 4: Product that can be simplified (should work)
+print("\n4. Product that can be simplified (should work):")
+p4 = Product(2**k, (k, 1, n)).doit()
+print("Product(2**k, (k, 1, n)) =", p4)
+
+# Test 5: Original issue case (should remain unevaluated)
+print("\n5. Original issue case (should remain unevaluated):")
+p5 = Product(n + 1/2**k, (k, 0, n-1)).doit()
+print("Product(n + 1/2**k, (k, 0, n-1)) =", p5)
+
+# Test 6: With specific numeric value (should work or remain unevaluated)
+print("\n6. With specific numeric value:")
+p6 = Product(2 + 1/2**k, (k, 0, 1)).doit()
+print("Product(2 + 1/2**k, (k, 0, 1)) =", p6)
\ No newline at end of file
diff --git a/test_numeric_case.py b/test_numeric_case.py
new file mode 100644
index 0000000000..00aa29b291
--- /dev/null
+++ b/test_numeric_case.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import k
+
+print("Testing numeric case:")
+
+# Test with specific numeric values
+p = Product(2 + 1/2**k, (k, 0, 1)).doit()
+print("Product(2 + 1/2**k, (k, 0, 1)) =", p)
+
+# Manual calculation
+manual = (2 + 1/2**0) * (2 + 1/2**1)
+print("Manual calculation:", manual)
+print("Are they equal?", p == manual)
+
+# This should give the correct result since it uses direct multiplication
+# when the difference is an integer
\ No newline at end of file
diff --git a/test_product_logic.py b/test_product_logic.py
new file mode 100644
index 0000000000..52500e2cef
--- /dev/null
+++ b/test_product_logic.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.abc import n,k
+
+# Test the mathematical correctness of the current approach
+term = n + 1 / 2**k
+print("Original term:", term)
+
+# Current approach: as_numer_denom()
+p, q = term.as_numer_denom()
+print("Numerator:", p)
+print("Denominator:", q)
+
+# Evaluate product of denominator
+prod_q = Product(q, (k, 0, n-1)).doit()
+print("Product of denominator:", prod_q)
+
+# Current approach tries to sum products of numerator parts
+# This is mathematically incorrect!
+parts = p.as_coeff_Add()
+print("Numerator parts:", parts)
+
+# What the current code does (incorrectly):
+sum_of_products = sum([Product(part, (k, 0, n-1)).doit() for part in parts])
+print("Sum of products (current approach):", sum_of_products)
+
+# What it should do (but even this would be incorrect):
+product_of_parts = Mul(*[Product(part, (k, 0, n-1)).doit() for part in parts])
+print("Product of parts (still incorrect):", product_of_parts)
+
+# The correct result should be:
+correct_result = Product(term, (k, 0, n-1)).doit()
+print("Correct result:", correct_result)
+
+# The fundamental issue: product(a + b) != product(a) + product(b)
+# and product(a + b) != product(a) * product(b)
\ No newline at end of file