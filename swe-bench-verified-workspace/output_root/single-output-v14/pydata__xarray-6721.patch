diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..be0e36c2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where accessing chunks on zarr backed xarray
+loads entire array into memory.
+"""
+import xarray as xr
+
+# Create a simple test with local zarr data instead of remote
+# to avoid network dependencies
+import numpy as np
+import zarr
+
+# Create a test zarr dataset group
+import os
+import shutil
+if os.path.exists('test.zarr'):
+    shutil.rmtree('test.zarr')
+
+store = zarr.DirectoryStore('test.zarr')
+root = zarr.group(store=store)
+data = np.random.rand(100, 100)
+z = root.create_dataset('test_var', data=data, chunks=(50, 50))
+zarr.consolidate_metadata('test.zarr')
+
+# Open with xarray
+ds = xr.open_dataset('test.zarr', engine='zarr')
+
+print("Dataset opened successfully")
+print("Dataset variables:", list(ds.variables.keys()))
+
+# This should trigger the issue - accessing chunks
+print("Accessing chunks property...")
+try:
+    chunks = ds.chunks
+    print("Chunks accessed successfully:", chunks)
+except Exception as e:
+    print(f"Error accessing chunks: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 00000000..df7cb4d3
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""
+Simpler script to reproduce the chunks issue by directly testing the problematic code path.
+"""
+import xarray as xr
+import numpy as np
+
+# Create a simple in-memory dataset first to understand the issue
+data = np.random.rand(10, 10)
+ds = xr.Dataset({'test_var': (['x', 'y'], data)})
+
+print("Created simple dataset")
+print("Dataset variables:", list(ds.variables.keys()))
+
+# Test the chunks property - this should work fine for in-memory data
+print("Accessing chunks property...")
+try:
+    chunks = ds.chunks
+    print("Chunks accessed successfully:", chunks)
+except Exception as e:
+    print(f"Error accessing chunks: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Now let's examine the problematic code path
+from xarray.core.common import get_chunksizes
+from xarray.core.variable import Variable
+
+print("\nTesting get_chunksizes directly...")
+variables = ds.variables.values()
+try:
+    result = get_chunksizes(variables)
+    print("get_chunksizes result:", result)
+except Exception as e:
+    print(f"Error in get_chunksizes: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test.zarr/.zgroup b/test.zarr/.zgroup
new file mode 100644
index 00000000..3b7daf22
--- /dev/null
+++ b/test.zarr/.zgroup
@@ -0,0 +1,3 @@
+{
+    "zarr_format": 2
+}
\ No newline at end of file
diff --git a/test.zarr/.zmetadata b/test.zarr/.zmetadata
new file mode 100644
index 00000000..1ffe4815
--- /dev/null
+++ b/test.zarr/.zmetadata
@@ -0,0 +1,30 @@
+{
+    "metadata": {
+        ".zgroup": {
+            "zarr_format": 2
+        },
+        "test_var/.zarray": {
+            "chunks": [
+                50,
+                50
+            ],
+            "compressor": {
+                "blocksize": 0,
+                "clevel": 5,
+                "cname": "lz4",
+                "id": "blosc",
+                "shuffle": 1
+            },
+            "dtype": "<f8",
+            "fill_value": 0.0,
+            "filters": null,
+            "order": "C",
+            "shape": [
+                100,
+                100
+            ],
+            "zarr_format": 2
+        }
+    },
+    "zarr_consolidated_format": 1
+}
\ No newline at end of file
diff --git a/test.zarr/test_var/.zarray b/test.zarr/test_var/.zarray
new file mode 100644
index 00000000..ba9346a0
--- /dev/null
+++ b/test.zarr/test_var/.zarray
@@ -0,0 +1,22 @@
+{
+    "chunks": [
+        50,
+        50
+    ],
+    "compressor": {
+        "blocksize": 0,
+        "clevel": 5,
+        "cname": "lz4",
+        "id": "blosc",
+        "shuffle": 1
+    },
+    "dtype": "<f8",
+    "fill_value": 0.0,
+    "filters": null,
+    "order": "C",
+    "shape": [
+        100,
+        100
+    ],
+    "zarr_format": 2
+}
\ No newline at end of file
diff --git a/test.zarr/test_var/0.0 b/test.zarr/test_var/0.0
new file mode 100644
index 00000000..58ab738b
Binary files /dev/null and b/test.zarr/test_var/0.0 differ
diff --git a/test.zarr/test_var/0.1 b/test.zarr/test_var/0.1
new file mode 100644
index 00000000..14d4b1ef
Binary files /dev/null and b/test.zarr/test_var/0.1 differ
diff --git a/test.zarr/test_var/1.0 b/test.zarr/test_var/1.0
new file mode 100644
index 00000000..4bfb30cf
Binary files /dev/null and b/test.zarr/test_var/1.0 differ
diff --git a/test.zarr/test_var/1.1 b/test.zarr/test_var/1.1
new file mode 100644
index 00000000..ab807f8d
Binary files /dev/null and b/test.zarr/test_var/1.1 differ
diff --git a/test_zarr_chunks.py b/test_zarr_chunks.py
new file mode 100644
index 00000000..28d598ef
--- /dev/null
+++ b/test_zarr_chunks.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+"""
+Test to verify that accessing chunks doesn't load zarr-backed data into memory.
+"""
+import xarray as xr
+import numpy as np
+from xarray.core.common import get_chunksizes
+from xarray.core.variable import Variable
+
+# Create a mock zarr-like array that has chunks but doesn't load data
+class MockZarrArray:
+    def __init__(self, shape, chunks):
+        self.shape = shape
+        self.chunks = chunks
+        self._data_loaded = False
+    
+    def __array__(self):
+        # This simulates what happens when zarr data is loaded
+        self._data_loaded = True
+        return np.random.rand(*self.shape)
+    
+    def __repr__(self):
+        return f"MockZarrArray(shape={self.shape}, chunks={self.chunks}, data_loaded={self._data_loaded})"
+
+# Create a variable with mock zarr data
+mock_data = MockZarrArray((100, 100), (50, 50))
+var = Variable(['x', 'y'], mock_data)
+
+print("Created mock zarr variable")
+print("Variable data:", var._data)
+print("Variable chunksizes:", var.chunksizes)
+
+# Test get_chunksizes directly
+print("\nTesting get_chunksizes with mock zarr variable...")
+try:
+    result = get_chunksizes([var])
+    print("get_chunksizes result:", result)
+    print("Data was loaded:", mock_data._data_loaded)
+except Exception as e:
+    print(f"Error in get_chunksizes: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Test with regular numpy array for comparison
+print("\nTesting with regular numpy array...")
+regular_data = np.random.rand(10, 10)
+regular_var = Variable(['x', 'y'], regular_data)
+regular_result = get_chunksizes([regular_var])
+print("Regular array result:", regular_result)
\ No newline at end of file
diff --git a/test_zarr_chunks_fixed.py b/test_zarr_chunks_fixed.py
new file mode 100644
index 00000000..4aa4f398
--- /dev/null
+++ b/test_zarr_chunks_fixed.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""
+Test to verify that accessing chunks doesn't load zarr-backed data into memory.
+This test simulates how zarr-backed variables are actually created.
+"""
+import xarray as xr
+import numpy as np
+from xarray.core.common import get_chunksizes
+from xarray.core.variable import Variable
+from xarray.core import indexing
+
+# Create a mock zarr-like array wrapper that simulates ZarrArrayWrapper
+class MockZarrArrayWrapper(indexing.ExplicitlyIndexed):
+    def __init__(self, shape, chunks):
+        self.shape = shape
+        self.chunks = chunks
+        self.ndim = len(shape)
+        self._data_loaded = False
+    
+    def __getitem__(self, key):
+        # Simulate data loading when accessed
+        self._data_loaded = True
+        return np.random.rand(*self.shape)
+    
+    def __array__(self, dtype=None):
+        # This simulates what happens when zarr data is loaded
+        self._data_loaded = True
+        return np.asarray(self[:], dtype=dtype)
+
+# Create a variable that simulates zarr-backed data
+mock_data = indexing.LazilyIndexedArray(MockZarrArrayWrapper((100, 100), (50, 50)))
+var = Variable(['x', 'y'], mock_data)
+
+# Add encoding information like zarr backend does
+var.encoding = {
+    "chunks": (50, 50),
+    "preferred_chunks": {"x": 50, "y": 50}
+}
+
+print("Created mock zarr-backed variable")
+print("Variable data type:", type(var._data))
+print("Variable encoding:", var.encoding)
+print("Variable chunksizes:", var.chunksizes)
+
+# Test get_chunksizes directly
+print("\nTesting get_chunksizes with mock zarr-backed variable...")
+try:
+    result = get_chunksizes([var])
+    print("get_chunksizes result:", result)
+    print("Data was loaded:", mock_data.array._data_loaded)
+except Exception as e:
+    print(f"Error in get_chunksizes: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Test with regular numpy array for comparison
+print("\nTesting with regular numpy array...")
+regular_data = np.random.rand(10, 10)
+regular_var = Variable(['x', 'y'], regular_data)
+regular_result = get_chunksizes([regular_var])
+print("Regular array result:", regular_result)
\ No newline at end of file
diff --git a/xarray/core/common.py b/xarray/core/common.py
index 3c328f42..3065c101 100644
--- a/xarray/core/common.py
+++ b/xarray/core/common.py
@@ -2023,7 +2023,7 @@ def get_chunksizes(
 
     chunks: dict[Any, tuple[int, ...]] = {}
     for v in variables:
-        if hasattr(v.data, "chunks"):
+        if v.chunksizes:
             for dim, c in v.chunksizes.items():
                 if dim in chunks and c != chunks[dim]:
                     raise ValueError(