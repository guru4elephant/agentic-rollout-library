diff --git a/pylint/config/callback_actions.py b/pylint/config/callback_actions.py
index 761995399..250e8a3f6 100644
--- a/pylint/config/callback_actions.py
+++ b/pylint/config/callback_actions.py
@@ -45,6 +45,11 @@ class _DoNothingAction(_CallbackAction):
     without erroring when they are then processed again by argparse.
     """
 
+    def __init__(self, *args, **kwargs):
+        # Set nargs=0 to indicate that this action doesn't expect any arguments
+        kwargs["nargs"] = 0
+        super().__init__(*args, **kwargs)
+
     def __call__(
         self,
         parser: argparse.ArgumentParser,
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..35f906e3d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+import subprocess
+import sys
+
+def test_verbose_option():
+    """Test the verbose option behavior."""
+    
+    # Create a simple test file
+    test_file = "mytest.py"
+    with open(test_file, "w") as f:
+        f.write("print('Hello, world!')\n")
+    
+    try:
+        # Test long option (should work)
+        print("Testing --verbose option:")
+        result = subprocess.run([
+            sys.executable, "-m", "pylint", test_file, "--verbose"
+        ], capture_output=True, text=True, timeout=30)
+        print(f"Exit code: {result.returncode}")
+        print(f"Stdout: {result.stdout}")
+        print(f"Stderr: {result.stderr}")
+        print()
+        
+        # Test short option (should fail according to the issue)
+        print("Testing -v option:")
+        result = subprocess.run([
+            sys.executable, "-m", "pylint", test_file, "-v"
+        ], capture_output=True, text=True, timeout=30)
+        print(f"Exit code: {result.returncode}")
+        print(f"Stdout: {result.stdout}")
+        print(f"Stderr: {result.stderr}")
+        
+    except subprocess.TimeoutExpired:
+        print("Command timed out")
+    except Exception as e:
+        print(f"Error: {e}")
+    finally:
+        # Clean up
+        import os
+        if os.path.exists(test_file):
+            os.remove(test_file)
+
+if __name__ == "__main__":
+    test_verbose_option()
\ No newline at end of file