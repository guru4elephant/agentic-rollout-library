diff --git a/check_types.py b/check_types.py
new file mode 100644
index 0000000000..fa4daf511f
--- /dev/null
+++ b/check_types.py
@@ -0,0 +1,19 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+t1 = tp(1,1)
+t2 = tp(1,1)
+e = t1 * t2
+
+print("type(t1) =", type(t1))
+print("type(t2) =", type(t2))
+print("type(e) =", type(e))
+print("e =", e)
+print("e.args =", e.args)
+
+# Let's also check what happens with regular multiplication
+t3 = tp(1,1)
+t4 = tp(1,1)
+e2 = Mul(t3, t4)
+print("type(e2) =", type(e2))
+print("e2 =", e2)
\ No newline at end of file
diff --git a/debug_call_flow.py b/debug_call_flow.py
new file mode 100644
index 0000000000..71b8da2e30
--- /dev/null
+++ b/debug_call_flow.py
@@ -0,0 +1,35 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Let's trace the call flow
+t1 = tp(1,1)
+t2 = tp(1,1)
+e = t1 * t2
+
+print("Input to tps:", e)
+print("Type of input:", type(e))
+
+# Check if it's a Pow object
+if isinstance(e, Pow):
+    print("It's a Pow object")
+    # Check what tensor_product_simp does with the base
+    base_simp = tps(e.base)
+    print("Base after tps:", base_simp)
+    print("Type of base after tps:", type(base_simp))
+    
+    # Check if the base is still a TensorProduct
+    if isinstance(base_simp, tp):
+        print("Base is still a TensorProduct")
+        # Check if we should handle the power case
+        if e.exp.is_integer:
+            print("Exponent is integer:", e.exp)
+            # This should trigger our special handling
+            result = tps(e)
+            print("Final result from tps:", result)
+        else:
+            print("Exponent is not integer")
+    else:
+        print("Base is not a TensorProduct after simplification")
+else:
+    print("Not a Pow object")
\ No newline at end of file
diff --git a/debug_exponent.py b/debug_exponent.py
new file mode 100644
index 0000000000..d1029cc6bf
--- /dev/null
+++ b/debug_exponent.py
@@ -0,0 +1,18 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+t1 = tp(1,1)
+t2 = tp(1,1)
+e = t1 * t2
+
+print("e =", e)
+print("type(e) =", type(e))
+print("e.base =", e.base)
+print("e.exp =", e.exp)
+print("type(e.exp) =", type(e.exp))
+print("e.exp.is_integer =", e.exp.is_integer)
+
+# Let's also check with a different exponent
+e2 = t1 ** 3
+print("e2.exp =", e2.exp)
+print("e2.exp.is_integer =", e2.exp.is_integer)
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..ab8c79143b
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,19 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul
+
+# Test the multiplication directly
+t1 = tp(1,1)
+t2 = tp(1,1)
+print("t1 =", t1)
+print("t2 =", t2)
+print("t1 * t2 =", t1 * t2)
+
+# Test tensor_product_simp_Mul directly
+result = tensor_product_simp_Mul(t1 * t2)
+print("tensor_product_simp_Mul(t1 * t2) =", result)
+
+# Test what happens when we multiply the components
+print("1 * 1 =", 1 * 1)
+print("1 * 1 =", 1 * 1)
\ No newline at end of file
diff --git a/debug_tps.py b/debug_tps.py
new file mode 100644
index 0000000000..ded1cce79c
--- /dev/null
+++ b/debug_tps.py
@@ -0,0 +1,40 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Let's add some debug to the tensor_product_simp function
+# First, let's see what happens when we call it directly
+t1 = tp(1,1)
+t2 = tp(1,1)
+e = t1 * t2
+
+print("Input to tps:", e)
+print("Type of input:", type(e))
+
+# Let's manually trace through the function
+if isinstance(e, Pow):
+    print("It's a Pow object")
+    base = tps(e.base)
+    exp = e.exp
+    print("Base after tps:", base)
+    print("Exponent:", exp)
+    print("isinstance(base, TensorProduct):", isinstance(base, tp))
+    print("exp.is_integer:", exp.is_integer)
+    
+    if isinstance(base, tp) and exp.is_integer:
+        print("Entering special handling for TensorProduct power")
+        if exp == 1:
+            result = base
+        elif exp > 1:
+            product = base
+            for _ in range(exp - 1):
+                product = product * base
+            result = tps(product)
+        else:
+            result = base ** exp
+    else:
+        result = base ** exp
+        
+    print("Final result:", result)
+else:
+    print("Not a Pow object")
\ No newline at end of file
diff --git a/debug_tps_mul.py b/debug_tps_mul.py
new file mode 100644
index 0000000000..875b5272b5
--- /dev/null
+++ b/debug_tps_mul.py
@@ -0,0 +1,24 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul
+
+# Let's test the tensor_product_simp_Mul function directly
+t1 = tp(1,1)
+t2 = tp(1,1)
+
+# Create a Mul object instead of Pow
+mul_obj = Mul(t1, t2)
+print("mul_obj =", mul_obj)
+print("type(mul_obj) =", type(mul_obj))
+
+# Test tensor_product_simp_Mul on this
+result = tensor_product_simp_Mul(mul_obj)
+print("tensor_product_simp_Mul result =", result)
+
+# Let's also test with a different case
+t3 = tp(1, Symbol('a', commutative=False))
+t4 = tp(1, Symbol('a', commutative=False))
+mul_obj2 = Mul(t3, t4)
+print("mul_obj2 =", mul_obj2)
+result2 = tensor_product_simp_Mul(mul_obj2)
+print("tensor_product_simp_Mul result2 =", result2)
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 0000000000..acb6584dde
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,48 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul
+
+# Let's trace through what happens in tensor_product_simp_Mul
+t1 = tp(1,1)
+t2 = tp(1,1)
+e = t1 * t2
+
+print("e =", e)
+print("e.args =", e.args)
+
+# Get commutative and non-commutative parts
+c_part, nc_part = e.args_cnc()
+print("c_part =", c_part)
+print("nc_part =", nc_part)
+
+# Check if e has TensorProduct
+print("e.has(TensorProduct) =", e.has(tp))
+
+# Now let's trace through the function manually
+current = nc_part[0]
+print("current =", current)
+print("isinstance(current, TensorProduct) =", isinstance(current, tp))
+
+n_terms = len(current.args)
+new_args = list(current.args)
+print("n_terms =", n_terms)
+print("new_args =", new_args)
+
+for next_item in nc_part[1:]:
+    print("next_item =", next_item)
+    print("isinstance(next_item, TensorProduct) =", isinstance(next_item, tp))
+    
+    if isinstance(next_item, tp):
+        if n_terms != len(next_item.args):
+            print("Different lengths error!")
+        else:
+            for i in range(len(new_args)):
+                print(f"new_args[{i}] = {new_args[i]}, next_item.args[{i}] = {next_item.args[i]}")
+                new_args[i] = new_args[i] * next_item.args[i]
+                print(f"new_args[{i}] after multiplication = {new_args[i]}")
+    
+    current = next_item
+
+print("Final new_args =", new_args)
+result = Mul(*c_part) * tp(*new_args)
+print("Final result =", result)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5deb168505
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,33 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+from sympy.physics.paulialgebra import Pauli
+
+a = Symbol('a', commutative=False)
+
+print("=== Test case 1: tp(1,1)*tp(1,1) ===")
+t1 = tp(1,1)*tp(1,1)
+print("t1 =", t1)
+print("tps(t1) =", tps(t1))
+print("t1.expand(tensorproduct=True) =", t1.expand(tensorproduct=True))
+print("Expected: 1x1")
+print()
+
+print("=== Test case 2: tp(1,1)*tp(1,a) with a=1 ===")
+t2 = tp(1,1)*tp(1,a)
+print("tps(t2.subs(a, 1)) =", tps(t2.subs(a, 1)))
+print("Expected: 1x1")
+print()
+
+print("=== Test case 3: tp(1,Pauli(3))*tp(1,Pauli(3)) ===")
+t3 = tp(1,Pauli(3))*tp(1,Pauli(3))
+print("t3 =", t3)
+print("tps(t3) =", tps(t3))
+print("t3.expand(tensorproduct=True) =", t3.expand(tensorproduct=True))
+print("Expected: 1xsigma3**2")
+print()
+
+print("=== Test case 4: tp(1,Pauli(3))*tp(1,a) with a=Pauli(3) ===")
+t4 = tp(1,Pauli(3))*tp(1,a)
+print("tps(t4.subs(a, Pauli(3))) =", tps(t4.subs(a, Pauli(3))))
+print("Expected: 1x1")
\ No newline at end of file
diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..5f4bc677f6 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -313,6 +313,21 @@ def tensor_product_simp_Mul(e):
     # TensorProducts, like an Add, Pow, Commutator, etc.
     # TODO: This only works for the equivalent of single Qbit gates.
     if not isinstance(e, Mul):
+        # Handle the case where we have a Pow object with TensorProduct base
+        if isinstance(e, Pow) and isinstance(e.base, TensorProduct) and e.exp.is_integer:
+            # For example: (1x1)**2 should simplify to 1x1
+            if e.exp == 1:
+                return e.base
+            elif e.exp > 1:
+                # Create a product of exp copies of the base
+                product = e.base
+                for _ in range(e.exp - 1):
+                    product = Mul(product, e.base)
+                # Recursively simplify the product
+                return tensor_product_simp_Mul(product)
+            else:
+                # For non-positive exponents, use default behavior
+                return e
         return e
     c_part, nc_part = e.args_cnc()
     n_nc = len(nc_part)
@@ -382,7 +397,26 @@ def tensor_product_simp(e, **hints):
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        # Handle special case where base is a TensorProduct and exponent is an integer
+        base = tensor_product_simp(e.base)
+        exp = e.exp
+        
+        if isinstance(base, TensorProduct) and exp.is_integer:
+            # For example: (1x1)**2 should simplify to 1x1
+            if exp == 1:
+                return base
+            elif exp > 1:
+                # Create a product of exp copies of the base
+                product = base
+                for _ in range(exp - 1):
+                    product = Mul(product, base)
+                # Simplify the product using tensor_product_simp_Mul
+                return tensor_product_simp_Mul(product)
+            else:
+                # For non-positive exponents, use default behavior
+                return base ** exp
+        else:
+            return base ** exp
     elif isinstance(e, Mul):
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):