diff --git a/debug_nested_class.py b/debug_nested_class.py
new file mode 100644
index 0000000000..c894c353da
--- /dev/null
+++ b/debug_nested_class.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the problematic model
+class Profile(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+
+# Debug the class structure
+default_func = Profile.Capability.default
+print(f"Function: {default_func}")
+print(f"Function name: {default_func.__name__}")
+print(f"Function qualname: {default_func.__qualname__}")
+print(f"Function module: {default_func.__module__}")
+print(f"Function self: {getattr(default_func, '__self__', None)}")
+print(f"Function self type: {type(getattr(default_func, '__self__', None))}")
+
+if getattr(default_func, "__self__", None) and isinstance(default_func.__self__, type):
+    klass = default_func.__self__
+    print(f"Class: {klass}")
+    print(f"Class name: {klass.__name__}")
+    print(f"Class qualname: {klass.__qualname__}")
+    print(f"Class module: {klass.__module__}")
+    
+    # Check if the class is nested
+    print(f"Class defined in: {klass.__module__}.{klass.__qualname__}")
\ No newline at end of file
diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index d88cda6e20..06657ebaab 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -168,7 +168,7 @@ class FunctionTypeSerializer(BaseSerializer):
         ):
             klass = self.value.__self__
             module = klass.__module__
-            return "%s.%s.%s" % (module, klass.__name__, self.value.__name__), {
+            return "%s.%s.%s" % (module, klass.__qualname__, self.value.__name__), {
                 "import %s" % module
             }
         # Further error checking
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..d6e34bef96
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+print("=== Testing the fix for nested class methods ===")
+
+# Test 1: Original issue - nested class with classmethod
+class Profile(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+
+default_func = Profile.Capability.default
+result, imports = serializer_factory(default_func).serialize()
+print(f"Test 1 - Nested class method:")
+print(f"  Result: {result}")
+print(f"  Expected: __main__.Profile.Capability.default")
+print(f"  ✓ PASS" if result == "__main__.Profile.Capability.default" else f"  ✗ FAIL")
+print()
+
+# Test 2: Multiple levels of nesting
+class OuterClass:
+    class MiddleClass:
+        class InnerClass:
+            @classmethod
+            def inner_method(cls):
+                return "inner"
+
+inner_method = OuterClass.MiddleClass.InnerClass.inner_method
+result, imports = serializer_factory(inner_method).serialize()
+print(f"Test 2 - Multiple nesting levels:")
+print(f"  Result: {result}")
+print(f"  Expected: __main__.OuterClass.MiddleClass.InnerClass.inner_method")
+print(f"  ✓ PASS" if result == "__main__.OuterClass.MiddleClass.InnerClass.inner_method" else f"  ✗ FAIL")
+print()
+
+# Test 3: Regular class method (should still work)
+class RegularClass:
+    @classmethod
+    def regular_method(cls):
+        return "regular"
+
+regular_method = RegularClass.regular_method
+result, imports = serializer_factory(regular_method).serialize()
+print(f"Test 3 - Regular class method:")
+print(f"  Result: {result}")
+print(f"  Expected: __main__.RegularClass.regular_method")
+print(f"  ✓ PASS" if result == "__main__.RegularClass.regular_method" else f"  ✗ FAIL")
+print()
+
+# Test 4: Instance method (should use different code path)
+class TestClass:
+    def instance_method(self):
+        return "instance"
+
+instance_method = TestClass().instance_method
+try:
+    result, imports = serializer_factory(instance_method).serialize()
+    print(f"Test 4 - Instance method:")
+    print(f"  Result: {result}")
+    print(f"  Expected: __main__.TestClass.instance_method")
+    print(f"  ✓ PASS" if result == "__main__.TestClass.instance_method" else f"  ✗ FAIL")
+except Exception as e:
+    print(f"Test 4 - Instance method failed (expected for some cases): {e}")
+print()
+
+# Test 5: Basic types should still work
+print("Test 5 - Basic types:")
+basic_tests = [
+    ("string", "test", "'test'"),
+    ("integer", 123, "123"),
+    ("float", 1.23, "1.23"),
+    ("list", [1, 2, 3], "[1, 2, 3]"),
+    ("dict", {"key": "value"}, "{'key': 'value'}"),
+]
+
+all_basic_pass = True
+for test_name, value, expected in basic_tests:
+    try:
+        result, imports = serializer_factory(value).serialize()
+        if result == expected:
+            print(f"  {test_name}: ✓ PASS")
+        else:
+            print(f"  {test_name}: ✗ FAIL (got {result}, expected {expected})")
+            all_basic_pass = False
+    except Exception as e:
+        print(f"  {test_name}: ✗ ERROR - {e}")
+        all_basic_pass = False
+
+print(f"  Basic types overall: {'✓ PASS' if all_basic_pass else '✗ FAIL'}")
+print()
+
+print("=== Summary ===")
+print("The fix correctly handles nested class methods while maintaining")
+print("backward compatibility with existing functionality.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a69cdefb15
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the problematic model
+class Profile(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+    
+    # Use a simple CharField instead of ArrayField to avoid PostgreSQL dependencies
+    capability = models.CharField(
+        choices=Capability.choices, 
+        max_length=30, 
+        blank=True,
+        default=Capability.default
+    )
+
+# Test the serialization
+from django.db.migrations.serializer import serializer_factory
+
+# Get the default function
+default_func = Profile.Capability.default
+
+try:
+    result, imports = serializer_factory(default_func).serialize()
+    print(f"Serialized result: {result}")
+    print(f"Imports: {imports}")
+except Exception as e:
+    print(f"Error during serialization: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..064c8410d7
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+# Test 1: Original issue - nested class with classmethod
+class Profile(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+
+# Test 2: Multiple levels of nesting
+class OuterClass:
+    class MiddleClass:
+        class InnerClass:
+            @classmethod
+            def inner_method(cls):
+                return "inner"
+            
+            @staticmethod
+            def inner_static():
+                return "static"
+
+# Test 3: Regular class method (not nested)
+class RegularClass:
+    @classmethod
+    def regular_method(cls):
+        return "regular"
+
+print("=== Test 1: Nested class with classmethod ===")
+default_func = Profile.Capability.default
+result, imports = serializer_factory(default_func).serialize()
+print(f"Result: {result}")
+print(f"Expected: __main__.Profile.Capability.default")
+print(f"Match: {result == '__main__.Profile.Capability.default'}")
+print()
+
+print("=== Test 2: Multiple levels of nesting ===")
+inner_method = OuterClass.MiddleClass.InnerClass.inner_method
+result, imports = serializer_factory(inner_method).serialize()
+print(f"Result: {result}")
+print(f"Expected: __main__.OuterClass.MiddleClass.InnerClass.inner_method")
+print(f"Match: {result == '__main__.OuterClass.MiddleClass.InnerClass.inner_method'}")
+print()
+
+print("=== Test 3: Regular class method ===")
+regular_method = RegularClass.regular_method
+result, imports = serializer_factory(regular_method).serialize()
+print(f"Result: {result}")
+print(f"Expected: __main__.RegularClass.regular_method")
+print(f"Match: {result == '__main__.RegularClass.regular_method'}")
\ No newline at end of file
diff --git a/test_migration_scenario.py b/test_migration_scenario.py
new file mode 100644
index 0000000000..8fd457aa37
--- /dev/null
+++ b/test_migration_scenario.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Simulate the original issue scenario
+class Profile(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+    
+    # Simulate the ArrayField default (we'll just test the function serialization)
+    capabilities_default = Capability.default
+
+# Test the serialization that would be used in migrations
+from django.db.migrations.serializer import serializer_factory
+
+print("=== Testing migration scenario ===")
+print("Original issue: Capability.default was serialized as 'appname.models.Capability.default'")
+print("Expected fix: Should be serialized as 'appname.models.Profile.Capability.default'")
+
+default_func = Profile.capabilities_default
+result, imports = serializer_factory(default_func).serialize()
+
+print(f"\nSerialized result: {result}")
+print(f"Expected pattern: __main__.Profile.Capability.default")
+
+# Check if the result contains the full nested path
+if "Profile.Capability.default" in result:
+    print("✓ SUCCESS: The nested class path is correctly included")
+else:
+    print("✗ FAILURE: The nested class path is missing")
+
+print(f"\nThis would generate migration code like:")
+print(f"default={result}")
+
+print("\nBefore the fix, this would have been:")
+print("default=appname.models.Capability.default (INCORRECT)")
+
+print("\nAfter the fix, this is now:")
+print("default=appname.models.Profile.Capability.default (CORRECT)")
\ No newline at end of file