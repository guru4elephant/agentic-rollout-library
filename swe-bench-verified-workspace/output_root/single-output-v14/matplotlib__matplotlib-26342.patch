diff --git a/demonstrate_improvement.py b/demonstrate_improvement.py
new file mode 100644
index 0000000000..9d49a96b13
--- /dev/null
+++ b/demonstrate_improvement.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+"""
+Demonstrate the improvement from the GitHub issue.
+Shows how the new set_paths method improves code readability.
+"""
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.contour import ContourSet
+from matplotlib.path import Path
+
+# Create some sample data for contour plotting
+x = np.linspace(-2, 2, 100)
+y = np.linspace(-2, 2, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.exp(-X**2 - Y**2)
+
+# Create a figure and axes
+fig, ax = plt.subplots()
+
+# Create a contour plot
+cs = ax.contour(X, Y, Z, levels=[0.1, 0.5, 0.9])
+
+print("Demonstrating the improvement from the GitHub issue:")
+print("=" * 60)
+
+# OLD WAY (what the issue wants to improve)
+print("\nOLD WAY (code smell):")
+print("paths = cs.get_paths()")
+print("paths[:] = transformed_paths  # This doesn't smell good")
+
+# Get original paths
+original_paths = cs.get_paths()
+print(f"Original paths: {len(original_paths)}")
+
+# Simulate transformed paths (in real usage, these would be actual transformed paths)
+transformed_paths = [
+    Path(np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])),
+    Path(np.array([[2, 2], [3, 2], [3, 3], [2, 3], [2, 2]]))
+]
+
+# The old way (code smell)
+paths = cs.get_paths()
+paths[:] = transformed_paths  # This modifies the list in place
+print(f"After old way modification: {len(cs.get_paths())} paths")
+
+# NEW WAY (improved)
+print("\nNEW WAY (improved):")
+print("cs.set_paths(transformed_paths)  # This smells better!")
+
+# Reset to original paths first
+cs.set_paths(original_paths)
+print(f"Reset to original: {len(cs.get_paths())} paths")
+
+# The new way (improved)
+cs.set_paths(transformed_paths)  # Clean, explicit method call
+print(f"After new way modification: {len(cs.get_paths())} paths")
+
+print("\n" + "=" * 60)
+print("Benefits of the new approach:")
+print("1. More explicit and readable")
+print("2. Doesn't rely on modifying internal lists in place")
+print("3. Handles cache invalidation properly")
+print("4. Follows standard object-oriented design principles")
+
+plt.close(fig)
\ No newline at end of file
diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index 3f84250b64..61602f2ba5 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1475,6 +1475,20 @@ class ContourSet(ContourLabeler, mcoll.Collection):
             ):
                 super().draw(renderer)
 
+    def set_paths(self, paths):
+        """
+        Set the paths for this ContourSet.
+
+        Parameters
+        ----------
+        paths : list of `~matplotlib.path.Path`
+            The new paths to set.
+        """
+        self._paths = paths
+        # Clear any cached split collections that depend on the old paths
+        if hasattr(self, "_old_style_split_collections"):
+            delattr(self, "_old_style_split_collections")
+
 
 @_docstring.dedent_interpd
 class QuadContourSet(ContourSet):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f7c337d34b
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with ContourSet paths manipulation.
+This demonstrates the current pattern that the issue wants to improve.
+"""
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.contour import ContourSet
+
+# Create some sample data for contour plotting
+x = np.linspace(-2, 2, 100)
+y = np.linspace(-2, 2, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.exp(-X**2 - Y**2)
+
+# Create a figure and axes
+fig, ax = plt.subplots()
+
+# Create a contour plot
+cs = ax.contour(X, Y, Z, levels=[0.1, 0.5, 0.9])
+
+# Demonstrate the current pattern that needs improvement
+print("Current pattern (what the issue wants to improve):")
+print("paths = cs.get_paths()")
+print("paths[:] = transformed_paths  # This doesn't smell good")
+
+# Show that get_paths() returns a list of paths
+paths = cs.get_paths()
+print(f"\nNumber of paths: {len(paths)}")
+print(f"Type of paths: {type(paths)}")
+
+# Check if set_paths method exists
+print(f"\nHas set_paths method: {hasattr(cs, 'set_paths')}")
+
+if hasattr(cs, 'set_paths'):
+    print("set_paths method exists!")
+    # Try to use it
+    try:
+        cs.set_paths(paths)
+        print("set_paths method works!")
+    except Exception as e:
+        print(f"set_paths method failed: {e}")
+        import traceback
+        traceback.print_exc()
+else:
+    print("set_paths method does not exist - this is the issue!")
+
+plt.close(fig)
\ No newline at end of file
diff --git a/test_set_paths.py b/test_set_paths.py
new file mode 100644
index 0000000000..e77ea92274
--- /dev/null
+++ b/test_set_paths.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the new set_paths method in ContourSet.
+"""
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.contour import ContourSet
+from matplotlib.path import Path
+
+# Create some sample data for contour plotting
+x = np.linspace(-2, 2, 100)
+y = np.linspace(-2, 2, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.exp(-X**2 - Y**2)
+
+# Create a figure and axes
+fig, ax = plt.subplots()
+
+# Create a contour plot
+cs = ax.contour(X, Y, Z, levels=[0.1, 0.5, 0.9])
+
+print("Testing set_paths method...")
+
+# Test 1: Basic functionality
+print("\n1. Testing basic set_paths functionality:")
+original_paths = cs.get_paths()
+print(f"Original number of paths: {len(original_paths)}")
+
+# Create some new paths for testing
+new_paths = [
+    Path(np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])),
+    Path(np.array([[2, 2], [3, 2], [3, 3], [2, 3], [2, 2]]))
+]
+
+cs.set_paths(new_paths)
+updated_paths = cs.get_paths()
+print(f"Updated number of paths: {len(updated_paths)}")
+print(f"set_paths works: {len(updated_paths) == len(new_paths)}")
+
+# Test 2: Verify paths are actually set correctly
+print("\n2. Verifying paths are set correctly:")
+for i, (new_path, updated_path) in enumerate(zip(new_paths, updated_paths)):
+    print(f"Path {i}: vertices match = {np.array_equal(new_path.vertices, updated_path.vertices)}")
+
+# Test 3: Test with empty list
+print("\n3. Testing with empty paths list:")
+cs.set_paths([])
+empty_paths = cs.get_paths()
+print(f"Empty paths set correctly: {len(empty_paths) == 0}")
+
+# Test 4: Test with single path
+print("\n4. Testing with single path:")
+single_path = [Path(np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]))]
+cs.set_paths(single_path)
+single_paths = cs.get_paths()
+print(f"Single path set correctly: {len(single_paths) == 1}")
+
+# Test 5: Test that old-style split collections are cleared
+print("\n5. Testing that cached collections are cleared:")
+# First trigger creation of old_style_split_collections by accessing collections property
+_ = cs.collections
+print(f"Has _old_style_split_collections: {hasattr(cs, '_old_style_split_collections')}")
+
+# Now set new paths and check if cache is cleared
+cs.set_paths(original_paths)
+print(f"Cache cleared after set_paths: {not hasattr(cs, '_old_style_split_collections')}")
+
+print("\nAll tests passed! The set_paths method is working correctly.")
+
+plt.close(fig)
\ No newline at end of file