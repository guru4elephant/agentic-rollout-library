diff --git a/debug_symbols.py b/debug_symbols.py
new file mode 100644
index 0000000000..103e273010
--- /dev/null
+++ b/debug_symbols.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+import sympy as smp
+
+# Let's debug what happens when we call symbols with tuple and cls parameter
+def debug_symbols_call():
+    names = ('q:2', 'u:2')
+    cls = smp.Function
+    args = {'cls': cls}
+    
+    print(f"names: {names}")
+    print(f"cls: {cls}")
+    print(f"args: {args}")
+    
+    # This is what happens internally in the symbols function
+    result = []
+    for name in names:
+        print(f"\nProcessing name: {name}")
+        print(f"Calling symbols({name}, **{args})")
+        symbol_result = smp.symbols(name, **args)
+        print(f"Result: {symbol_result}, type: {type(symbol_result)}")
+        result.append(symbol_result)
+    
+    print(f"\nFinal result: {type(names)(result)}")
+    return type(names)(result)
+
+# Test the debug call
+q, u = debug_symbols_call()
+print(f"\nq: {q}, type: {type(q[0])}")
+print(f"u: {u}, type: {type(u[0])}")
\ No newline at end of file
diff --git a/debug_symbols2.py b/debug_symbols2.py
new file mode 100644
index 0000000000..577076ceb2
--- /dev/null
+++ b/debug_symbols2.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+import sympy as smp
+
+# Test the exact case from the issue
+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)
+print(f"q: {q}, type of q[0]: {type(q[0])}")
+print(f"u: {u}, type of u[0]: {type(u[0])}")
+
+# Let's also check what q and u actually contain
+print(f"\nq is: {q}")
+print(f"u is: {u}")
+print(f"q[0] is: {q[0]}")
+print(f"u[0] is: {u[0]}")
+
+# Test the expected case
+result = smp.symbols('q:2 u:2', cls=smp.Function)
+print(f"\nNormal case result: {result}")
+print(f"result[0]: {result[0]}, type: {type(result[0])}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0ea1aac838
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,17 @@
+#!/usr/bin/env python3
+
+import sympy as smp
+
+# Test case from the issue
+print("Testing the issue case:")
+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)
+print(f"Type of q[0]: {type(q[0])}")
+print(f"Expected: <class 'sympy.core.function.UndefinedFunction'>")
+print(f"Actual: {type(q[0])}")
+
+# Test normal case without extra parentheses for comparison
+print("\nTesting normal case without extra parentheses:")
+result = smp.symbols('q:2 u:2', cls=smp.Function)
+print(f"Type of result[0]: {type(result[0])}")
+print(f"Expected: <class 'sympy.core.function.UndefinedFunction'>")
+print(f"Actual: {type(result[0])}")
\ No newline at end of file
diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py
index f4a555c13f..2aca8bab27 100644
--- a/sympy/core/symbol.py
+++ b/sympy/core/symbol.py
@@ -791,7 +791,7 @@ def literal(s):
         return tuple(result)
     else:
         for name in names:
-            result.append(symbols(name, **args))
+            result.append(symbols(name, cls=cls, **args))
 
         return type(names)(result)
 
diff --git a/test_keyword_only.py b/test_keyword_only.py
new file mode 100644
index 0000000000..b23b9c0a2e
--- /dev/null
+++ b/test_keyword_only.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+# Test to understand how keyword-only parameters work
+def test_func(*, cls=Symbol, **args):
+    print(f"cls: {cls}")
+    print(f"args: {args}")
+    
+    # This won't work because cls is keyword-only
+    try:
+        result = test_func("test", **args)
+        print("Success!")
+    except Exception as e:
+        print(f"Error: {e}")
+
+# Mock Symbol class for testing
+class Symbol:
+    pass
+
+test_func(cls=Symbol, other_arg="test")
\ No newline at end of file