diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..b7946883
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+
+# Script to reproduce the issue with builtin_str converting binary strings
+# to their literal string representation instead of the actual content
+
+from requests.compat import builtin_str
+
+def test_builtin_str_issue():
+    # This simulates what happens when neutronclient passes a binary method
+    binary_method = b'GET'
+    print(f"Original binary method: {binary_method}")
+    print(f"Type: {type(binary_method)}")
+    
+    # This is what currently happens in sessions.py line 428
+    converted_method = builtin_str(binary_method)
+    print(f"After builtin_str conversion: {converted_method}")
+    print(f"Type after conversion: {type(converted_method)}")
+    
+    # The issue: converted_method becomes "b'GET'" instead of "GET"
+    # This would cause HTTP requests to fail because they try to use "b'GET'" as the method
+    
+    # Expected behavior: we want "GET" not "b'GET'"
+    expected_method = binary_method.decode('utf-8')
+    print(f"Expected result: {expected_method}")
+    print(f"Type of expected result: {type(expected_method)}")
+    
+    # Test if they're equal
+    print(f"Are they equal? {converted_method == expected_method}")
+    
+    return converted_method, expected_method
+
+if __name__ == "__main__":
+    test_builtin_str_issue()
\ No newline at end of file
diff --git a/requests/sessions.py b/requests/sessions.py
index d701ff2e..adcfbac7 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -425,7 +425,7 @@ class Session(SessionRedirectMixin):
             If Tuple, ('cert', 'key') pair.
         """
 
-        method = builtin_str(method)
+        method = to_native_string(method)
 
         # Create the Request.
         req = Request(
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..373eaf5e
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+
+# Test edge cases for our fix
+
+from requests.utils import to_native_string
+
+def test_edge_cases():
+    test_cases = [
+        b'GET',       # Original issue case
+        b'POST',      # Another HTTP method
+        b'PUT',       # Another HTTP method
+        b'DELETE',    # Another HTTP method
+        b'HEAD',      # Another HTTP method
+        b'OPTIONS',   # Another HTTP method
+        'GET',        # Already a string (should work unchanged)
+        'POST',       # Already a string
+        b'',          # Empty bytes
+        '',           # Empty string
+        b'get',       # Lowercase (should be converted to uppercase later)
+        b'PoSt',      # Mixed case
+    ]
+    
+    print("Testing edge cases for to_native_string:")
+    print("=" * 50)
+    
+    for i, method in enumerate(test_cases):
+        print(f"\nTest case {i+1}: {method} (type: {type(method)})")
+        result = to_native_string(method)
+        print(f"Result: {result} (type: {type(result)})")
+        
+        # Test that it can be uppercased (as done in sessions.py line 432)
+        uppercased = result.upper()
+        print(f"Uppercased: {uppercased}")
+        
+        # Verify it's a proper string that can be used as HTTP method
+        if isinstance(result, str) and result.isprintable():
+            print("✓ Valid HTTP method string")
+        else:
+            print("✗ Invalid HTTP method string")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 00000000..1f753302
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+
+# Test to verify our fix works correctly
+
+from requests.utils import to_native_string
+from requests.compat import builtin_str
+
+def test_fix():
+    # Simulate the binary method input from neutronclient
+    binary_method = b'GET'
+    print(f"Original binary method: {binary_method}")
+    print(f"Type: {type(binary_method)}")
+    
+    # OLD behavior (what was causing the issue)
+    old_result = builtin_str(binary_method)
+    print(f"OLD behavior (builtin_str): {old_result}")
+    print(f"Type: {type(old_result)}")
+    
+    # NEW behavior (our fix)
+    new_result = to_native_string(binary_method)
+    print(f"NEW behavior (to_native_string): {new_result}")
+    print(f"Type: {type(new_result)}")
+    
+    # Expected result
+    expected_result = "GET"
+    print(f"Expected result: {expected_result}")
+    
+    # Check if our fix works
+    print(f"NEW behavior matches expected: {new_result == expected_result}")
+    print(f"OLD behavior matches expected: {old_result == expected_result}")
+    
+    # Test that the method can be properly uppercased (as done in line 432)
+    print(f"NEW uppercased: {new_result.upper()}")
+    print(f"OLD uppercased: {old_result.upper()}")
+    
+    return new_result, old_result, expected_result
+
+if __name__ == "__main__":
+    test_fix()
\ No newline at end of file
diff --git a/test_to_native_string.py b/test_to_native_string.py
new file mode 100644
index 00000000..dbc51c9f
--- /dev/null
+++ b/test_to_native_string.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+# Test to verify that to_native_string properly handles binary strings
+
+from requests.utils import to_native_string
+from requests.compat import builtin_str
+
+def test_to_native_string():
+    # Test with binary string
+    binary_method = b'GET'
+    print(f"Original binary method: {binary_method}")
+    print(f"Type: {type(binary_method)}")
+    
+    # Current problematic behavior with builtin_str
+    builtin_str_result = builtin_str(binary_method)
+    print(f"builtin_str result: {builtin_str_result}")
+    print(f"Type: {type(builtin_str_result)}")
+    
+    # Test with to_native_string
+    native_str_result = to_native_string(binary_method)
+    print(f"to_native_string result: {native_str_result}")
+    print(f"Type: {type(native_str_result)}")
+    
+    # Expected result
+    expected_result = "GET"
+    print(f"Expected result: {expected_result}")
+    
+    # Check if they match
+    print(f"to_native_string matches expected: {native_str_result == expected_result}")
+    print(f"builtin_str matches expected: {builtin_str_result == expected_result}")
+    
+    return native_str_result, builtin_str_result, expected_result
+
+if __name__ == "__main__":
+    test_to_native_string()
\ No newline at end of file