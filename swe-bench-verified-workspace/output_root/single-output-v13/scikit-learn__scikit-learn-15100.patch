diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..bd291db8d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,24 @@
+from sklearn.feature_extraction.text import strip_accents_unicode
+
+# This string contains one code point, "LATIN SMALL LETTER N WITH TILDE"
+s1 = chr(241)
+
+# This string contains two code points, "LATIN SMALL LETTER N" followed by "COMBINING TILDE"
+s2 = chr(110) + chr(771)
+
+# They are visually identical, as expected
+print("s1:", s1) # => ñ
+print("s2:", s2) # => ñ
+
+# The tilde is removed from s1, as expected
+print("strip_accents_unicode(s1):", strip_accents_unicode(s1)) # => n
+
+# But strip_accents_unicode returns s2 unchanged
+result = strip_accents_unicode(s2)
+print("strip_accents_unicode(s2):", result)
+print("strip_accents_unicode(s2) == s2:", result == s2) # => True
+
+# Expected: both should return "n"
+print("Expected both to be 'n':")
+print("s1 ->", strip_accents_unicode(s1))
+print("s2 ->", strip_accents_unicode(s2))
\ No newline at end of file
diff --git a/sklearn/feature_extraction/text.py b/sklearn/feature_extraction/text.py
index bb5a9d646..11236d958 100644
--- a/sklearn/feature_extraction/text.py
+++ b/sklearn/feature_extraction/text.py
@@ -130,10 +130,7 @@ def strip_accents_unicode(s):
         ASCII equivalent.
     """
     normalized = unicodedata.normalize('NFKD', s)
-    if normalized == s:
-        return s
-    else:
-        return ''.join([c for c in normalized if not unicodedata.combining(c)])
+    return ''.join([c for c in normalized if not unicodedata.combining(c)])
 
 
 def strip_accents_ascii(s):
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..2f25eb422
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,34 @@
+from sklearn.feature_extraction.text import strip_accents_unicode
+import unicodedata
+
+# Test 1: Empty string
+print("Empty string:", repr(strip_accents_unicode("")))
+
+# Test 2: String with no accents
+print("No accents:", repr(strip_accents_unicode("hello")))
+
+# Test 3: String with multiple accents
+s3 = "café" + chr(771)  # café with additional combining tilde
+print("Multiple accents:", repr(strip_accents_unicode(s3)))
+
+# Test 4: String that's already decomposed
+s4 = "e" + chr(769)  # e with acute accent (decomposed)
+print("Already decomposed:", repr(strip_accents_unicode(s4)))
+
+# Test 5: Mixed case - some characters with accents, some without
+s5 = "naïve café"
+print("Mixed case:", repr(strip_accents_unicode(s5)))
+
+# Test 6: Verify that the function still works with the original example
+s1 = chr(241)  # ñ
+s2 = chr(110) + chr(771)  # n + combining tilde
+print("Original s1:", repr(strip_accents_unicode(s1)))
+print("Original s2:", repr(strip_accents_unicode(s2)))
+print("Are they equal?", strip_accents_unicode(s1) == strip_accents_unicode(s2))
+
+# Test 7: Verify normalization still works
+test_str = "café"
+normalized = unicodedata.normalize('NFKD', test_str)
+print("Normalization check - original:", repr(test_str))
+print("Normalization check - normalized:", repr(normalized))
+print("Normalization check - stripped:", repr(strip_accents_unicode(test_str)))
\ No newline at end of file
diff --git a/test_exact_issue.py b/test_exact_issue.py
new file mode 100644
index 000000000..5d5b45e20
--- /dev/null
+++ b/test_exact_issue.py
@@ -0,0 +1,23 @@
+from sklearn.feature_extraction.text import strip_accents_unicode
+
+# This string contains one code point, "LATIN SMALL LETTER N WITH TILDE"
+s1 = chr(241)
+
+# This string contains two code points, "LATIN SMALL LETTER N" followed by "COMBINING TILDE"
+s2 = chr(110) + chr(771)
+
+# They are visually identical, as expected
+print(s1) # => ñ
+print(s2) # => ñ
+
+# The tilde is removed from s1, as expected
+print(strip_accents_unicode(s1)) # => n
+
+# But strip_accents_unicode returns s2 unchanged
+print(strip_accents_unicode(s2) == s2) # => True
+
+# Expected Results: s1 and s2 should both be normalized to the same string, "n"
+print("s1 result:", strip_accents_unicode(s1))
+print("s2 result:", strip_accents_unicode(s2))
+print("Both equal to 'n':", strip_accents_unicode(s1) == "n" and strip_accents_unicode(s2) == "n")
+print("Both results equal:", strip_accents_unicode(s1) == strip_accents_unicode(s2))
\ No newline at end of file
diff --git a/test_performance.py b/test_performance.py
new file mode 100644
index 000000000..24a50406d
--- /dev/null
+++ b/test_performance.py
@@ -0,0 +1,20 @@
+from sklearn.feature_extraction.text import strip_accents_unicode
+import time
+
+# Test performance with a large string
+test_string = "àáâãäåçèéêëìíîïñòóôõöùúûüý" * 1000
+
+start_time = time.time()
+result = strip_accents_unicode(test_string)
+end_time = time.time()
+
+print(f"Processing time: {end_time - start_time:.4f} seconds")
+print(f"Input length: {len(test_string)}")
+print(f"Output length: {len(result)}")
+print(f"Result starts with: {result[:20]}")
+
+# Test that the function still works correctly
+# The expected result should be the same pattern repeated: "aaaaaaceeeeiiiinooooouuuuy" * 1000
+expected = "aaaaaaceeeeiiiinooooouuuuy" * 1000
+assert expected == result
+print("Performance test passed!")
\ No newline at end of file