diff --git a/django/core/paginator.py b/django/core/paginator.py
index 1f92da5d4f..6dc25dbbf7 100644
--- a/django/core/paginator.py
+++ b/django/core/paginator.py
@@ -106,6 +106,11 @@ class Paginator:
         """
         return range(1, self.num_pages + 1)
 
+    def __iter__(self):
+        """Iterate through all pages in the paginator."""
+        for page_num in self.page_range:
+            yield self.page(page_num)
+
     def _check_object_list_is_ordered(self):
         """
         Warn if self.object_list is unordered (typically a QuerySet).
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9311e0bb18
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the paginator iteration issue.
+Demonstrates the current behavior and what we want to achieve.
+"""
+
+from django.core.paginator import Paginator
+
+# Create some sample data
+data = list(range(1, 101))  # 100 items
+
+# Create a paginator
+paginator = Paginator(data, 10)  # 10 items per page
+
+print("Current way to iterate through pages (using page_range):")
+for page_num in paginator.page_range:
+    page = paginator.page(page_num)
+    print(f"Page {page_num}: {list(page)}")
+
+print("\nWhat we want to achieve (using __iter__):")
+try:
+    for page in paginator:
+        print(f"Page {page.number}: {list(page)}")
+except TypeError as e:
+    print(f"Error: {e}")
+    print("This demonstrates the need for __iter__ implementation")
\ No newline at end of file
diff --git a/run_pagination_tests.py b/run_pagination_tests.py
new file mode 100644
index 0000000000..f51211b0cc
--- /dev/null
+++ b/run_pagination_tests.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""
+Script to run pagination tests with proper Django configuration.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.pagination',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+# Now we can import and run the tests
+import unittest
+from tests.pagination.tests import PaginationTests
+
+def run_tests():
+    """Run the pagination tests."""
+    suite = unittest.TestLoader().loadTestsFromTestCase(PaginationTests)
+    runner = unittest.TextTestRunner(verbosity=2)
+    result = runner.run(suite)
+    return result.wasSuccessful()
+
+if __name__ == '__main__':
+    success = run_tests()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..e1d5a9fda7
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the Paginator __iter__ implementation.
+"""
+
+from django.core.paginator import Paginator
+
+def test_empty_paginator():
+    """Test paginator with empty data."""
+    print("Testing empty paginator...")
+    paginator = Paginator([], 10)
+    pages = list(paginator)
+    print(f"Number of pages: {len(pages)}")
+    print(f"Pages: {pages}")
+
+def test_single_page():
+    """Test paginator with data that fits in one page."""
+    print("\nTesting single page...")
+    paginator = Paginator([1, 2, 3, 4, 5], 10)
+    pages = list(paginator)
+    print(f"Number of pages: {len(pages)}")
+    for page in pages:
+        print(f"Page {page.number}: {list(page)}")
+
+def test_exactly_one_page():
+    """Test paginator with exactly one page worth of data."""
+    print("\nTesting exactly one page...")
+    paginator = Paginator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)
+    pages = list(paginator)
+    print(f"Number of pages: {len(pages)}")
+    for page in pages:
+        print(f"Page {page.number}: {list(page)}")
+
+def test_multiple_pages():
+    """Test paginator with multiple pages."""
+    print("\nTesting multiple pages...")
+    paginator = Paginator(list(range(1, 26)), 5)  # 25 items, 5 per page = 5 pages
+    pages = list(paginator)
+    print(f"Number of pages: {len(pages)}")
+    for page in pages:
+        print(f"Page {page.number}: {list(page)}")
+
+def test_iteration_twice():
+    """Test that we can iterate multiple times."""
+    print("\nTesting iteration twice...")
+    paginator = Paginator([1, 2, 3, 4, 5, 6], 2)  # 3 pages
+    print("First iteration:")
+    for page in paginator:
+        print(f"Page {page.number}: {list(page)}")
+    
+    print("Second iteration:")
+    for page in paginator:
+        print(f"Page {page.number}: {list(page)}")
+
+if __name__ == "__main__":
+    test_empty_paginator()
+    test_single_page()
+    test_exactly_one_page()
+    test_multiple_pages()
+    test_iteration_twice()
+    print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/test_iter_implementation.py b/test_iter_implementation.py
new file mode 100644
index 0000000000..610819c560
--- /dev/null
+++ b/test_iter_implementation.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+"""
+Test that the __iter__ implementation matches exactly what was requested in the issue.
+"""
+
+from django.core.paginator import Paginator
+
+def test_iter_implementation():
+    """Test that __iter__ works exactly as described in the issue."""
+    # Create test data
+    data = list(range(1, 21))  # 20 items
+    
+    # Create paginator
+    paginator = Paginator(data, 5)  # 5 items per page = 4 pages
+    
+    print("Testing __iter__ implementation:")
+    print("Expected behavior from issue:")
+    print("for page_num in self.page_range:")
+    print("    yield self.page(page_num)")
+    print()
+    
+    # Test that our implementation matches the expected behavior
+    pages_from_iter = list(paginator)
+    pages_from_manual = [paginator.page(page_num) for page_num in paginator.page_range]
+    
+    print(f"Pages from __iter__: {len(pages_from_iter)} pages")
+    print(f"Pages from manual iteration: {len(pages_from_manual)} pages")
+    
+    # Verify they are the same
+    assert len(pages_from_iter) == len(pages_from_manual), "Page counts don't match"
+    
+    for i, (page_iter, page_manual) in enumerate(zip(pages_from_iter, pages_from_manual)):
+        assert page_iter.number == page_manual.number, f"Page numbers don't match at index {i}"
+        assert list(page_iter) == list(page_manual), f"Page content doesn't match at index {i}"
+        print(f"Page {page_iter.number}: {list(page_iter)}")
+    
+    print("\n✅ __iter__ implementation matches expected behavior!")
+    print("✅ All pages are identical whether using __iter__ or manual page_range iteration")
+
+if __name__ == "__main__":
+    test_iter_implementation()
\ No newline at end of file