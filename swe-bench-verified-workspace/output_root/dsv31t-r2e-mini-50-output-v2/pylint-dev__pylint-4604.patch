diff --git a/debug_ast.py b/debug_ast.py
new file mode 100644
index 000000000..6336627e7
--- /dev/null
+++ b/debug_ast.py
@@ -0,0 +1,19 @@
+import astroid
+
+code = '''
+"""Docstring."""
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+'''
+
+module = astroid.parse(code)
+for node in module.nodes_of_class(astroid.Assign):
+    print(f"Node: {node}")
+    print(f"Type annotation: {getattr(node, 'type_annotation', None)}")
+    print(f"Type comment: {getattr(node, 'type_comment', None)}")
+    print(f"All attributes: {dir(node)}")
+    print("---")
\ No newline at end of file
diff --git a/debug_nested.py b/debug_nested.py
new file mode 100644
index 000000000..b88747dd2
--- /dev/null
+++ b/debug_nested.py
@@ -0,0 +1,31 @@
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Create a simple linter
+linter = PyLinter()
+checker = VariablesChecker(linter)
+checker.open()
+
+code = '''
+import abc
+from abc import ABC
+
+Z = ...  # type: abc.ABC.defg
+'''
+
+module = astroid.parse(code)
+
+# Process the module
+checker.visit_module(module)
+
+# Check what type annotation names were stored
+print("Type annotation names:", checker._type_annotation_names)
+
+# Process the assignments
+for node in module.nodes_of_class(astroid.Assign):
+    print(f"Processing assignment: {node}")
+    print(f"Type annotation: {getattr(node, 'type_annotation', None)}")
+    checker.leave_assign(node)
+    print("Type annotation names after processing:", checker._type_annotation_names)
+    print("---")
\ No newline at end of file
diff --git a/debug_variables.py b/debug_variables.py
new file mode 100644
index 000000000..1801943c4
--- /dev/null
+++ b/debug_variables.py
@@ -0,0 +1,36 @@
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Create a simple linter
+linter = PyLinter()
+checker = VariablesChecker(linter)
+checker.open()
+
+code = '''
+"""Docstring."""
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+'''
+
+module = astroid.parse(code)
+
+# Process the module
+checker.visit_module(module)
+
+# Check what type annotation names were stored
+print("Type annotation names:", checker._type_annotation_names)
+
+# Process the assignments
+for node in module.nodes_of_class(astroid.Assign):
+    print(f"Processing assignment: {node}")
+    print(f"Type annotation: {getattr(node, 'type_annotation', None)}")
+    checker.leave_assign(node)
+    print("Type annotation names after processing:", checker._type_annotation_names)
+    print("---")
+
+checker.leave_module(module)
\ No newline at end of file
diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 3ddafd599..fecab6a7d 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1826,6 +1826,14 @@ class VariablesChecker(BaseChecker):
             self._type_annotation_names.append(type_annotation.name)
             return
 
+        # Handle attribute access like abc.ABC or abc.ABC.defg
+        if isinstance(type_annotation, astroid.Attribute):
+            # Add the attribute name itself
+            self._type_annotation_names.append(type_annotation.attrname)
+            # Recursively process the expression to handle nested attributes
+            self._store_type_annotation_node(type_annotation.expr)
+            return
+
         if not isinstance(type_annotation, astroid.Subscript):
             return
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..ba4ac30f5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,7 @@
+"""Docstring."""
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 000000000..f12c947f6
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,25 @@
+"""Test various type comment scenarios."""
+
+import abc
+from abc import ABC, abstractmethod
+import typing
+from typing import List, Dict
+
+# Test basic type comments
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+
+# Test nested attribute access
+Z = ...  # type: abc.ABC.defg
+
+# Test typing module usage
+A = ...  # type: typing.List[int]
+B = ...  # type: List[str]
+
+# Test function with type comments
+def test_func(param):
+    # type: (abc.ABC) -> typing.Dict[str, ABC]
+    return {}
+
+# Test variable with complex type
+C = ...  # type: Dict[str, ABC]
\ No newline at end of file