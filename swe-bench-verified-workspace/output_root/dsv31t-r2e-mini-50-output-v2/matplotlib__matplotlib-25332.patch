diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py
index c9699b2e21..4967871ef6 100644
--- a/lib/matplotlib/cbook.py
+++ b/lib/matplotlib/cbook.py
@@ -846,6 +846,25 @@ class Grouper:
         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])
         return [x() for x in siblings]
 
+    def __getstate__(self):
+        """
+        Return state for pickling.
+        
+        Weak references cannot be pickled, so we return an empty state.
+        The Grouper is used for runtime alignment tracking and doesn't need
+        to preserve its state across pickling/unpickling.
+        """
+        return {}
+
+    def __setstate__(self, state):
+        """
+        Restore state from unpickling.
+        
+        The Grouper is used for runtime alignment tracking, so we initialize
+        it with an empty state when unpickling.
+        """
+        self._mapping = {}
+
 
 class GrouperView:
     """Immutable view over a `.Grouper`."""
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..4d5721daa6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,24 @@
+import matplotlib.pyplot as plt
+import pickle
+
+fig = plt.figure()
+ax1 = fig.add_subplot(211)
+ax2 = fig.add_subplot(212)
+time=[0,1,2,3,4]
+speed=[40000,4300,4500,4700,4800]
+acc=[10,11,12,13,14]
+ax1.plot(time,speed)
+ax1.set_ylabel('speed')
+ax2.plot(time,acc)
+ax2.set_ylabel('acc')
+
+fig.align_labels() ##pickling works after removing this line 
+
+try:
+    pickle.dumps(fig)
+    print("Pickling successful!")
+except Exception as e:
+    print(f"Pickling failed with error: {e}")
+    print(f"Error type: {type(e)}")
+
+plt.show()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..4dab5291e5
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,116 @@
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+
+def test_pickle_after_align_labels():
+    """Test that figures can be pickled after calling align_labels"""
+    print("Testing pickle after align_labels...")
+    
+    # Create figure with multiple subplots
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time = [0, 1, 2, 3, 4]
+    speed = [40000, 4300, 4500, 4700, 4800]
+    acc = [10, 11, 12, 13, 14]
+    ax1.plot(time, speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time, acc)
+    ax2.set_ylabel('acc')
+    
+    # Call align_labels which was causing the issue
+    fig.align_labels()
+    
+    # Test pickling
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("✓ Pickling successful after align_labels()")
+        
+        # Test unpickling
+        unpickled_fig = pickle.loads(pickled_data)
+        print("✓ Unpickling successful")
+        
+        # Verify the unpickled figure has the expected properties
+        assert len(unpickled_fig.axes) == 2
+        assert unpickled_fig.axes[0].get_ylabel() == 'speed'
+        assert unpickled_fig.axes[1].get_ylabel() == 'acc'
+        print("✓ Unpickled figure has correct properties")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_pickle_before_align_labels():
+    """Test that figures can be pickled before calling align_labels"""
+    print("Testing pickle before align_labels...")
+    
+    # Create figure with multiple subplots
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time = [0, 1, 2, 3, 4]
+    speed = [40000, 4300, 4500, 4700, 4800]
+    acc = [10, 11, 12, 13, 14]
+    ax1.plot(time, speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time, acc)
+    ax2.set_ylabel('acc')
+    
+    # Test pickling before align_labels
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("✓ Pickling successful before align_labels()")
+        
+        # Test unpickling
+        unpickled_fig = pickle.loads(pickled_data)
+        print("✓ Unpickling successful")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_multiple_align_calls():
+    """Test multiple align calls and pickling"""
+    print("Testing multiple align calls...")
+    
+    fig = plt.figure()
+    ax1 = fig.add_subplot(221)
+    ax2 = fig.add_subplot(222)
+    ax3 = fig.add_subplot(223)
+    ax4 = fig.add_subplot(224)
+    
+    for i, ax in enumerate([ax1, ax2, ax3, ax4]):
+        ax.plot([0, 1, 2], [i, i+1, i+2])
+        ax.set_xlabel(f'xlabel {i}')
+        ax.set_ylabel(f'ylabel {i}')
+    
+    # Multiple align calls
+    fig.align_labels()
+    fig.align_xlabels()
+    fig.align_ylabels()
+    
+    try:
+        pickled_data = pickle.dumps(fig)
+        unpickled_fig = pickle.loads(pickled_data)
+        print("✓ Multiple align calls and pickling successful")
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Running comprehensive pickle tests...\n")
+    
+    success = True
+    success &= test_pickle_before_align_labels()
+    print()
+    success &= test_pickle_after_align_labels()
+    print()
+    success &= test_multiple_align_calls()
+    
+    print(f"\nOverall result: {'✓ ALL TESTS PASSED' if success else '✗ SOME TESTS FAILED'}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..e2c8adf249
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,112 @@
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+import gc
+
+def test_with_dead_weak_references():
+    """Test that Grouper handles dead weak references correctly during pickling"""
+    print("Testing with dead weak references...")
+    
+    from matplotlib.cbook import Grouper
+    
+    # Create objects that will be garbage collected
+    class TestObject:
+        def __init__(self, name):
+            self.name = name
+        def __repr__(self):
+            return f"TestObject({self.name})"
+    
+    # Create objects and add them to Grouper
+    obj1 = TestObject("obj1")
+    obj2 = TestObject("obj2")
+    obj3 = TestObject("obj3")
+    
+    grouper = Grouper()
+    grouper.join(obj1, obj2)
+    grouper.join(obj2, obj3)
+    
+    # Delete some objects to create dead weak references
+    del obj2, obj3
+    gc.collect()  # Force garbage collection
+    
+    # Now test pickling - should handle dead references gracefully
+    try:
+        pickled_data = pickle.dumps(grouper)
+        print("✓ Pickling successful with dead weak references")
+        
+        # Test unpickling
+        unpickled_grouper = pickle.loads(pickled_data)
+        print("✓ Unpickling successful with dead weak references")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_empty_grouper():
+    """Test pickling empty Grouper"""
+    print("Testing empty Grouper...")
+    
+    from matplotlib.cbook import Grouper
+    
+    grouper = Grouper()
+    
+    try:
+        pickled_data = pickle.dumps(grouper)
+        unpickled_grouper = pickle.loads(pickled_data)
+        print("✓ Empty Grouper pickling successful")
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_grouper_with_live_references():
+    """Test pickling Grouper with live references"""
+    print("Testing Grouper with live references...")
+    
+    from matplotlib.cbook import Grouper
+    
+    class TestObject:
+        def __init__(self, name):
+            self.name = name
+        def __repr__(self):
+            return f"TestObject({self.name})"
+    
+    obj1 = TestObject("obj1")
+    obj2 = TestObject("obj2")
+    obj3 = TestObject("obj3")
+    
+    grouper = Grouper()
+    grouper.join(obj1, obj2)
+    grouper.join(obj2, obj3)
+    
+    try:
+        pickled_data = pickle.dumps(grouper)
+        unpickled_grouper = pickle.loads(pickled_data)
+        print("✓ Grouper with live references pickling successful")
+        
+        # Verify the unpickled grouper works correctly
+        assert unpickled_grouper.joined(obj1, obj2)
+        assert unpickled_grouper.joined(obj1, obj3)
+        assert not unpickled_grouper.joined(obj1, TestObject("new_obj"))
+        print("✓ Unpickled Grouper functions correctly")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Running edge case tests for Grouper pickling...\n")
+    
+    success = True
+    success &= test_empty_grouper()
+    print()
+    success &= test_grouper_with_live_references()
+    print()
+    success &= test_with_dead_weak_references()
+    
+    print(f"\nOverall result: {'✓ ALL TESTS PASSED' if success else '✗ SOME TESTS FAILED'}")
\ No newline at end of file
diff --git a/test_realistic_edge_cases.py b/test_realistic_edge_cases.py
new file mode 100644
index 0000000000..bf4c54088d
--- /dev/null
+++ b/test_realistic_edge_cases.py
@@ -0,0 +1,115 @@
+import matplotlib.pyplot as plt
+import pickle
+import gc
+
+def test_figure_with_dead_axes():
+    """Test pickling figure with axes that might have been garbage collected"""
+    print("Testing figure with potentially dead axes...")
+    
+    # Create figure and axes
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    
+    # Plot some data
+    ax1.plot([0, 1, 2], [0, 1, 2])
+    ax2.plot([0, 1, 2], [2, 1, 0])
+    
+    # Set labels and align them
+    ax1.set_ylabel('left axis')
+    ax2.set_ylabel('right axis')
+    fig.align_labels()
+    
+    # Now try to pickle - should work even if there are weak references
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("✓ Pickling successful with aligned labels")
+        
+        # Test unpickling
+        unpickled_fig = pickle.loads(pickled_data)
+        print("✓ Unpickling successful")
+        
+        # Verify the unpickled figure works
+        assert len(unpickled_fig.axes) == 2
+        assert unpickled_fig.axes[0].get_ylabel() == 'left axis'
+        assert unpickled_fig.axes[1].get_ylabel() == 'right axis'
+        print("✓ Unpickled figure has correct properties")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_multiple_figures():
+    """Test pickling multiple figures with align_labels"""
+    print("Testing multiple figures...")
+    
+    # Create multiple figures with aligned labels
+    figures = []
+    for i in range(3):
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        
+        ax1.plot([0, 1, 2], [i, i+1, i+2])
+        ax2.plot([0, 1, 2], [i+2, i+1, i])
+        
+        ax1.set_ylabel(f'fig{i}_ax1')
+        ax2.set_ylabel(f'fig{i}_ax2')
+        
+        fig.align_labels()
+        figures.append(fig)
+    
+    try:
+        # Pickle all figures
+        pickled_figures = [pickle.dumps(fig) for fig in figures]
+        print("✓ Multiple figures pickling successful")
+        
+        # Unpickle all figures
+        unpickled_figures = [pickle.loads(data) for data in pickled_figures]
+        print("✓ Multiple figures unpickling successful")
+        
+        # Verify each figure
+        for i, fig in enumerate(unpickled_figures):
+            assert len(fig.axes) == 2
+            assert fig.axes[0].get_ylabel() == f'fig{i}_ax1'
+            assert fig.axes[1].get_ylabel() == f'fig{i}_ax2'
+        print("✓ All unpickled figures have correct properties")
+        
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+def test_no_axes():
+    """Test pickling figure with no axes after align_labels"""
+    print("Testing figure with no axes...")
+    
+    fig = plt.figure()
+    
+    # Call align_labels on empty figure
+    fig.align_labels()
+    
+    try:
+        pickled_data = pickle.dumps(fig)
+        unpickled_fig = pickle.loads(pickled_data)
+        print("✓ Empty figure with align_labels pickling successful")
+    except Exception as e:
+        print(f"✗ Failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Running realistic edge case tests...\n")
+    
+    success = True
+    success &= test_no_axes()
+    print()
+    success &= test_figure_with_dead_axes()
+    print()
+    success &= test_multiple_figures()
+    
+    print(f"\nOverall result: {'✓ ALL TESTS PASSED' if success else '✗ SOME TESTS FAILED'}")
\ No newline at end of file