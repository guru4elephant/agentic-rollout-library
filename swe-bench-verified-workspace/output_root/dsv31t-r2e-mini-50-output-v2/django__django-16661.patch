diff --git a/debug_condition.py b/debug_condition.py
new file mode 100644
index 0000000000..8af7d0c058
--- /dev/null
+++ b/debug_condition.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the specific condition
+model = Waiter
+lookup = 'restaurant__place__country'
+
+current_model = model
+prev_field = None
+
+print("Debugging the condition step by step:")
+for part in lookup.split('__'):
+    print(f"\nProcessing: {part}")
+    
+    field = current_model._meta.get_field(part)
+    print(f"Field: {field}")
+    print(f"Field type: {type(field)}")
+    
+    if prev_field:
+        print(f"Previous field: {prev_field}")
+        print(f"Previous field path_infos: {prev_field.path_infos}")
+        if prev_field.path_infos:
+            target_fields = prev_field.path_infos[-1].target_fields
+            print(f"Target fields: {target_fields}")
+            print(f"Current field in target_fields: {field in target_fields}")
+            
+            # Evaluate the condition
+            condition_part1 = prev_field.is_relation
+            condition_part2 = field not in target_fields
+            full_condition = condition_part1 and condition_part2
+            
+            print(f"prev_field.is_relation: {condition_part1}")
+            print(f"field not in target_fields: {condition_part2}")
+            print(f"Full condition: {full_condition}")
+    
+    if hasattr(field, 'path_infos') and field.path_infos:
+        prev_field = field
+        current_model = field.path_infos[-1].to_opts.model
+    else:
+        break
\ No newline at end of file
diff --git a/debug_invalid_lookups.py b/debug_invalid_lookups.py
new file mode 100644
index 0000000000..88207735ff
--- /dev/null
+++ b/debug_invalid_lookups.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.db.models.constants import LOOKUP_SEP
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Debug invalid lookups
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+print("Debugging invalid lookups:")
+for lookup in ['invalid_field', 'restaurant__invalid_field']:
+    print(f"\nLookup: {lookup}")
+    
+    model = Waiter
+    relation_parts = []
+    prev_field = None
+    
+    for part in lookup.split(LOOKUP_SEP):
+        print(f"Processing part: {part}")
+        
+        try:
+            field = model._meta.get_field(part)
+            print(f"Field found: {field}")
+            
+            # Check the condition
+            if not prev_field or (
+                prev_field.is_relation
+                and (
+                    field not in prev_field.path_infos[-1].target_fields
+                    or field.is_relation
+                )
+            ):
+                relation_parts.append(part)
+                print(f"Added to relation_parts: {relation_parts}")
+            
+            if not getattr(field, "path_intos", None):
+                break
+                
+            prev_field = field
+            model = field.path_infos[-1].to_opts.model
+            
+        except Exception as e:
+            print(f"Field not found: {e}")
+            break
+    
+    print(f"Final relation_parts: {relation_parts}")
+    print(f"Length: {len(relation_parts)}")
+    
+    if len(relation_parts) <= 1:
+        print("Would return True (length <= 1)")
+    else:
+        print("Would check against valid_lookups")
\ No newline at end of file
diff --git a/debug_join_field.py b/debug_join_field.py
new file mode 100644
index 0000000000..aa6ea5732d
--- /dev/null
+++ b/debug_join_field.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the join_field specifically
+model = Waiter
+lookup = 'restaurant__place__country'
+
+current_model = model
+prev_field = None
+
+print("Debugging join_field:")
+for part in lookup.split('__'):
+    print(f"\nProcessing: {part}")
+    
+    field = current_model._meta.get_field(part)
+    print(f"Field: {field}")
+    
+    if prev_field:
+        print(f"Previous field: {prev_field}")
+        print(f"Previous field path_infos: {prev_field.path_infos}")
+        if prev_field.path_infos:
+            path_info = prev_field.path_infos[-1]
+            print(f"Join field: {path_info.join_field}")
+            print(f"Target fields: {path_info.target_fields}")
+            
+            # Check the new condition
+            condition1 = prev_field.is_relation
+            condition2 = field not in path_info.target_fields
+            condition3 = field != path_info.join_field
+            full_condition = condition1 and condition2 and condition3
+            
+            print(f"prev_field.is_relation: {condition1}")
+            print(f"field not in target_fields: {condition2}")
+            print(f"field != join_field: {condition3}")
+            print(f"Full condition: {full_condition}")
+    
+    if hasattr(field, 'path_infos') and field.path_infos:
+        prev_field = field
+        current_model = field.path_infos[-1].to_opts.model
+    else:
+        break
\ No newline at end of file
diff --git a/debug_lookup.py b/debug_lookup.py
new file mode 100644
index 0000000000..d77cc0a394
--- /dev/null
+++ b/debug_lookup.py
@@ -0,0 +1,130 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.db.models.constants import LOOKUP_SEP
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the lookup_allowed logic manually
+model = Waiter
+lookup = 'restaurant__place__country'
+value = 'test_value'
+
+print(f"Model: {model}")
+print(f"Lookup: {lookup}")
+print(f"Value: {value}")
+
+relation_parts = []
+prev_field = None
+current_model = model
+
+print("\nProcessing lookup parts:")
+for part in lookup.split(LOOKUP_SEP):
+    print(f"\nProcessing part: {part}")
+    print(f"Current model: {current_model}")
+    
+    try:
+        field = current_model._meta.get_field(part)
+        print(f"Field found: {field}")
+        print(f"Field type: {type(field)}")
+        print(f"Field is_relation: {field.is_relation}")
+        if hasattr(field, 'path_infos'):
+            print(f"Field path_infos: {field.path_infos}")
+            if field.path_infos:
+                print(f"Target fields: {field.path_infos[-1].target_fields}")
+        
+        # Check the condition that determines if we add to relation_parts
+        condition = not prev_field or (
+            prev_field.is_relation
+            and field not in prev_field.path_infos[-1].target_fields
+        )
+        print(f"Should add to relation_parts: {condition}")
+        
+        if condition:
+            relation_parts.append(part)
+            print(f"Added '{part}' to relation_parts: {relation_parts}")
+        
+        if not getattr(field, "path_infos", None):
+            print("No path_infos, breaking")
+            break
+        
+        prev_field = field
+        current_model = field.path_infos[-1].to_opts.model
+        print(f"New model: {current_model}")
+        
+    except Exception as e:
+        print(f"Error getting field: {e}")
+        break
+
+print(f"\nFinal relation_parts: {relation_parts}")
+print(f"Length of relation_parts: {len(relation_parts)}")
+
+# Check if it would pass the length check
+if len(relation_parts) <= 1:
+    print("Would return True due to length <= 1")
+else:
+    print("Would proceed to check valid_lookups")
+    
+    # Check what valid lookups would be
+    valid_lookups = {'restaurant__place__country'}
+    print(f"Valid lookups: {valid_lookups}")
+    
+    # Check the final condition
+    lookup_candidates = {
+        LOOKUP_SEP.join(relation_parts),
+        LOOKUP_SEP.join(relation_parts + [part]),
+    }
+    print(f"Lookup candidates: {lookup_candidates}")
+    
+    result = not lookup_candidates.isdisjoint(valid_lookups)
+    print(f"Final result would be: {result}")
\ No newline at end of file
diff --git a/debug_new_condition.py b/debug_new_condition.py
new file mode 100644
index 0000000000..24d4f2ffa3
--- /dev/null
+++ b/debug_new_condition.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the new condition
+model = Waiter
+lookup = 'restaurant__place__country'
+
+current_model = model
+prev_field = None
+
+print("Debugging new condition:")
+for part in lookup.split('__'):
+    print(f"\nProcessing: {part}")
+    
+    field = current_model._meta.get_field(part)
+    print(f"Field: {field}")
+    
+    if prev_field:
+        print(f"Previous field: {prev_field}")
+        print(f"Previous field path_infos: {prev_field.path_infos}")
+        if prev_field.path_infos:
+            path_info = prev_field.path_infos[-1]
+            print(f"Join field: {path_info.join_field}")
+            print(f"Target fields: {path_info.target_fields}")
+            
+            # Check the new condition
+            condition1 = prev_field.is_relation
+            condition2a = field not in path_info.target_fields
+            condition2b = field == path_info.join_field
+            condition2 = condition2a or condition2b
+            full_condition = condition1 and condition2
+            
+            print(f"prev_field.is_relation: {condition1}")
+            print(f"field not in target_fields: {condition2a}")
+            print(f"field == join_field: {condition2b}")
+            print(f"Condition2 (not in targets OR is join): {condition2}")
+            print(f"Full condition: {full_condition}")
+    
+    if hasattr(field, 'path_infos') and field.path_infos:
+        prev_field = field
+        current_model = field.path_infos[-1].to_opts.model
+    else:
+        break
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5240b07cd6..b93b03277a 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -466,7 +466,10 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
             # then the id value would be found already from employee__department_id.
             if not prev_field or (
                 prev_field.is_relation
-                and field not in prev_field.path_infos[-1].target_fields
+                and (
+                    field not in prev_field.path_infos[-1].target_fields
+                    or field.is_relation
+                )
             ):
                 relation_parts.append(part)
             if not getattr(field, "path_infos", None):
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..05c02d008e
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+# Exact test case from the GitHub issue
+def test_lookup_allowed_foreign_primary():
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        
+        class Meta:
+            app_label = 'test_final'
+    
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test_final'
+    
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        
+        class Meta:
+            app_label = 'test_final'
+    
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test_final'
+    
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+    
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+    
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"Result: {result}")
+    
+    if result:
+        print("SUCCESS: The issue has been fixed!")
+        return True
+    else:
+        print("FAILURE: The issue persists!")
+        return False
+
+# Run the test
+if test_lookup_allowed_foreign_primary():
+    print("\nThe GitHub issue has been successfully resolved!")
+else:
+    print("\nThe GitHub issue has NOT been resolved!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..71f0b8ea17
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Test the issue
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+try:
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"lookup_allowed result: {result}")
+    if result:
+        print("SUCCESS: lookup_allowed returned True as expected")
+    else:
+        print("FAILURE: lookup_allowed returned False, should be True")
+except Exception as e:
+    print(f"ERROR: {e}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..1f64803261
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Test edge case: Normal OneToOneField (not as primary key)
+class Person(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test_edge'
+
+class Profile(models.Model):
+    person = models.OneToOneField(Person, models.CASCADE)
+    bio = models.TextField()
+    
+    class Meta:
+        app_label = 'test_edge'
+
+class ProfileAdmin(ModelAdmin):
+    list_filter = [
+        'person__name',
+    ]
+
+# Run tests
+site = AdminSite()
+
+print("Test 1: Normal OneToOneField (not as primary key)")
+ma1 = ProfileAdmin(Profile, site)
+result1 = ma1.lookup_allowed('person__name', 'test_value')
+print(f"person__name: {result1} (should be True)")
+
+print("\nTest 2: The original issue")
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test_edge2'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test_edge2'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test_edge2'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test_edge2'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+ma3 = WaiterAdmin(Waiter, site)
+result3 = ma3.lookup_allowed('restaurant__place__country', 'test_value')
+print(f"restaurant__place__country: {result3} (should be True)")
+
+# Summary
+print(f"\nSummary:")
+print(f"Test 1 (normal OneToOne): {'PASS' if result1 else 'FAIL'}")
+print(f"Test 2 (original issue): {'PASS' if result3 else 'FAIL'}")
+
+if all([result1, result3]):
+    print("\nALL EDGE CASE TESTS PASSED!")
+else:
+    print("\nSOME EDGE CASE TESTS FAILED!")
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..0da65c8b8e
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,142 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Test 1: The original issue - foreign key as primary key
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test1'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test1'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    
+    class Meta:
+        app_label = 'test1'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test1'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Test 2: Normal foreign key relationship (should still work)
+class Department(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test2'
+
+class Employee(models.Model):
+    name = models.CharField(max_length=256)
+    department = models.ForeignKey(Department, models.CASCADE)
+    
+    class Meta:
+        app_label = 'test2'
+
+class EmployeeAdmin(ModelAdmin):
+    list_filter = [
+        'department__name',
+    ]
+
+# Test 3: Multi-level foreign key (should still work)
+class Company(models.Model):
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test3'
+
+class Division(models.Model):
+    company = models.ForeignKey(Company, models.CASCADE)
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test3'
+
+class Team(models.Model):
+    division = models.ForeignKey(Division, models.CASCADE)
+    name = models.CharField(max_length=256)
+    
+    class Meta:
+        app_label = 'test3'
+
+class TeamAdmin(ModelAdmin):
+    list_filter = [
+        'division__company__name',
+    ]
+
+# Run tests
+site = AdminSite()
+
+print("Test 1: Foreign key as primary key (original issue)")
+ma1 = WaiterAdmin(Waiter, site)
+result1 = ma1.lookup_allowed('restaurant__place__country', 'test_value')
+print(f"restaurant__place__country: {result1} (should be True)")
+
+print("\nTest 2: Normal foreign key relationship")
+ma2 = EmployeeAdmin(Employee, site)
+result2 = ma2.lookup_allowed('department__name', 'test_value')
+print(f"department__name: {result2} (should be True)")
+
+print("\nTest 3: Multi-level foreign key")
+ma3 = TeamAdmin(Team, site)
+result3 = ma3.lookup_allowed('division__company__name', 'test_value')
+print(f"division__company__name: {result3} (should be True)")
+
+print("\nTest 4: Invalid lookups (should return False)")
+result4 = ma1.lookup_allowed('invalid_field', 'test_value')
+print(f"invalid_field: {result4} (should be False)")
+
+result5 = ma1.lookup_allowed('restaurant__invalid_field', 'test_value')
+print(f"restaurant__invalid_field: {result5} (should be False)")
+
+# Summary
+print(f"\nSummary:")
+print(f"Test 1 (original issue): {'PASS' if result1 else 'FAIL'}")
+print(f"Test 2 (normal foreign key): {'PASS' if result2 else 'FAIL'}")
+print(f"Test 3 (multi-level foreign key): {'PASS' if result3 else 'FAIL'}")
+print(f"Test 4 (invalid lookups): {'PASS' if not result4 and not result5 else 'FAIL'}")
+
+if all([result1, result2, result3, not result4, not result5]):
+    print("\nALL TESTS PASSED!")
+else:
+    print("\nSOME TESTS FAILED!")
\ No newline at end of file