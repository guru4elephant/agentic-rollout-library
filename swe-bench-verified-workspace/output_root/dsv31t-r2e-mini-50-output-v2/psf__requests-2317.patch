diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..8b62c8c0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+# Test script to reproduce the binary string method issue
+from requests.compat import builtin_str
+
+# Simulate the issue described in the GitHub issue
+# neutronclient uses utils.safe_encode_list(args) which converts all values to binary strings
+method_binary = b'GET'
+
+print(f"Original binary method: {method_binary}")
+print(f"Type of original method: {type(method_binary)}")
+
+# This is what happens in sessions.py line 428
+method_converted = builtin_str(method_binary)
+print(f"After builtin_str conversion: {method_converted}")
+print(f"Type after conversion: {type(method_converted)}")
+
+# The issue: method_converted becomes "b'GET'" instead of "GET"
+print(f"Method converted to uppercase: {method_converted.upper()}")
+
+# Expected behavior: we want "GET" not "b'GET'"
+# Let's test what should happen
+expected_method = method_binary.decode('utf-8')
+print(f"Expected result (decoded): {expected_method}")
+print(f"Expected type: {type(expected_method)}")
+print(f"Expected uppercase: {expected_method.upper()}")
\ No newline at end of file
diff --git a/requests/sessions.py b/requests/sessions.py
index d701ff2e..6dde4497 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -425,7 +425,11 @@ class Session(SessionRedirectMixin):
             If Tuple, ('cert', 'key') pair.
         """
 
-        method = builtin_str(method)
+        # Handle bytes objects by decoding them, otherwise use builtin_str
+        if isinstance(method, bytes):
+            method = method.decode('utf-8')
+        else:
+            method = builtin_str(method)
 
         # Create the Request.
         req = Request(
diff --git a/requests/utils.py b/requests/utils.py
index 182348da..48a21142 100644
--- a/requests/utils.py
+++ b/requests/utils.py
@@ -666,6 +666,7 @@ def to_native_string(string, encoding='ascii'):
         if is_py2:
             out = string.encode(encoding)
         else:
+            # Handle bytes objects by decoding them
             out = string.decode(encoding)
 
     return out
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..83b0e907
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+# Comprehensive test for the builtin_str fix
+from requests.compat import builtin_str
+
+# Test 1: Binary string (the original issue)
+print("Test 1: Binary string")
+method_binary = b'GET'
+result = builtin_str(method_binary)
+print(f"Input: {method_binary}, Output: {result}, Type: {type(result)}")
+assert result == "GET", f"Expected 'GET', got '{result}'"
+
+# Test 2: Regular string (should work as before)
+print("\nTest 2: Regular string")
+method_str = 'POST'
+result = builtin_str(method_str)
+print(f"Input: {method_str}, Output: {result}, Type: {type(result)}")
+assert result == "POST", f"Expected 'POST', got '{result}'"
+
+# Test 3: Other binary strings
+print("\nTest 3: Other binary strings")
+binary_data = b'PUT'
+result = builtin_str(binary_data)
+print(f"Input: {binary_data}, Output: {result}, Type: {type(result)}")
+assert result == "PUT", f"Expected 'PUT', got '{result}'"
+
+# Test 4: Non-ASCII binary strings
+print("\nTest 4: Non-ASCII binary strings")
+binary_unicode = b'\xe4\xbd\xa0\xe5\xa5\xbd'  # "你好" in UTF-8
+result = builtin_str(binary_unicode)
+print(f"Input: {binary_unicode}, Output: {result}, Type: {type(result)}")
+assert result == "你好", f"Expected '你好', got '{result}'"
+
+# Test 5: Non-string types (should work as before)
+print("\nTest 5: Non-string types")
+number = 123
+result = builtin_str(number)
+print(f"Input: {number}, Output: {result}, Type: {type(result)}")
+assert result == "123", f"Expected '123', got '{result}'"
+
+# Test 6: Empty binary string
+print("\nTest 6: Empty binary string")
+empty_binary = b''
+result = builtin_str(empty_binary)
+print(f"Input: {empty_binary}, Output: {result}, Type: {type(result)}")
+assert result == "", f"Expected empty string, got '{result}'"
+
+print("\nAll tests passed!")
\ No newline at end of file
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 00000000..ef534c2f
--- /dev/null
+++ b/test_final_verification.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+# Final verification test for the binary string method issue fix
+from requests.sessions import Session
+
+# Test 1: Binary string method (the original issue)
+print("Test 1: Binary string method")
+method_binary = b'GET'
+print(f"Input: {method_binary}, Type: {type(method_binary)}")
+
+# Simulate what happens in sessions.py after our fix
+if isinstance(method_binary, bytes):
+    method_converted = method_binary.decode('utf-8')
+else:
+    from requests.compat import builtin_str
+    method_converted = builtin_str(method_binary)
+
+print(f"After conversion: {method_converted}, Type: {type(method_converted)}")
+print(f"Uppercase: {method_converted.upper()}")
+assert method_converted == "GET", f"Expected 'GET', got '{method_converted}'"
+assert method_converted.upper() == "GET", f"Expected 'GET', got '{method_converted.upper()}'"
+
+# Test 2: Regular string method (should work as before)
+print("\nTest 2: Regular string method")
+method_str = 'POST'
+print(f"Input: {method_str}, Type: {type(method_str)}")
+
+if isinstance(method_str, bytes):
+    method_converted_str = method_str.decode('utf-8')
+else:
+    from requests.compat import builtin_str
+    method_converted_str = builtin_str(method_str)
+
+print(f"After conversion: {method_converted_str}, Type: {type(method_converted_str)}")
+print(f"Uppercase: {method_converted_str.upper()}")
+assert method_converted_str == "POST", f"Expected 'POST', got '{method_converted_str}'"
+assert method_converted_str.upper() == "POST", f"Expected 'POST', got '{method_converted_str.upper()}'"
+
+# Test 3: Test with a Session object (the actual usage)
+print("\nTest 3: Session object usage")
+s = Session()
+
+# This simulates what happens when a request is made with a binary method
+method_binary = b'PUT'
+print(f"Input: {method_binary}, Type: {type(method_binary)}")
+
+# This is what happens in sessions.py line 428-432 after our fix
+if isinstance(method_binary, bytes):
+    method_converted_session = method_binary.decode('utf-8')
+else:
+    from requests.compat import builtin_str
+    method_converted_session = builtin_str(method_binary)
+
+print(f"After session conversion: {method_converted_session}, Type: {type(method_converted_session)}")
+print(f"Uppercase: {method_converted_session.upper()}")
+assert method_converted_session == "PUT", f"Expected 'PUT', got '{method_converted_session}'"
+assert method_converted_session.upper() == "PUT", f"Expected 'PUT', got '{method_converted_session.upper()}'"
+
+print("\nAll tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/test_neutronclient_scenario.py b/test_neutronclient_scenario.py
new file mode 100644
index 00000000..cf9d8745
--- /dev/null
+++ b/test_neutronclient_scenario.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+
+# Test script to simulate the exact neutronclient scenario described in the GitHub issue
+from requests.sessions import Session
+from requests.compat import builtin_str
+
+# Simulate what neutronclient does with utils.safe_encode_list(args)
+# This converts all values to binary strings including the method
+def safe_encode_list(args):
+    """Simulate neutronclient's safe_encode_list function"""
+    encoded_args = []
+    for arg in args:
+        if isinstance(arg, str):
+            encoded_args.append(arg.encode('utf-8'))
+        else:
+            encoded_args.append(arg)
+    return encoded_args
+
+# Simulate the neutronclient scenario
+print("Simulating neutronclient scenario...")
+
+# Original method is a string
+original_method = 'GET'
+print(f"Original method: {original_method}, Type: {type(original_method)}")
+
+# neutronclient uses safe_encode_list which converts all values to binary
+encoded_args = safe_encode_list([original_method])
+method_binary = encoded_args[0]
+print(f"After safe_encode_list: {method_binary}, Type: {type(method_binary)}")
+
+# This is what happens in requests/sessions.py line 428-432 after our fix
+if isinstance(method_binary, bytes):
+    method_converted = method_binary.decode('utf-8')
+else:
+    method_converted = builtin_str(method_binary)
+
+print(f"After our fix in sessions.py: {method_converted}, Type: {type(method_converted)}")
+print(f"Uppercase method: {method_converted.upper()}")
+
+# Verify the fix works correctly
+assert method_converted == "GET", f"Expected 'GET', got '{method_converted}'"
+assert method_converted.upper() == "GET", f"Expected 'GET', got '{method_converted.upper()}'"
+
+print("\nThe neutronclient scenario is now working correctly!")
+print("Binary method b'GET' is properly converted to string 'GET' instead of \"b'GET'\"")
+
+# Test with other HTTP methods as well
+methods_to_test = ['POST', 'PUT', 'DELETE', 'PATCH']
+for method in methods_to_test:
+    encoded_args = safe_encode_list([method])
+    method_binary = encoded_args[0]
+    
+    if isinstance(method_binary, bytes):
+        method_converted = method_binary.decode('utf-8')
+    else:
+        method_converted = builtin_str(method_binary)
+    
+    assert method_converted == method, f"Expected '{method}', got '{method_converted}'"
+    assert method_converted.upper() == method, f"Expected '{method}', got '{method_converted.upper()}'"
+    print(f"✓ {method} test passed")
+
+print("\nAll HTTP methods work correctly with the fix!")
\ No newline at end of file
diff --git a/test_sessions_fix.py b/test_sessions_fix.py
new file mode 100644
index 00000000..95828b3f
--- /dev/null
+++ b/test_sessions_fix.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+# Test script to verify the fix in sessions.py
+from requests.sessions import Session
+
+# Create a session instance
+s = Session()
+
+# Simulate the issue described in the GitHub issue
+# neutronclient uses utils.safe_encode_list(args) which converts all values to binary strings
+method_binary = b'GET'
+
+print(f"Original binary method: {method_binary}")
+print(f"Type of original method: {type(method_binary)}")
+
+# This is what happens in sessions.py line 428-432 after our fix
+if isinstance(method_binary, bytes):
+    method_converted = method_binary.decode('utf-8')
+else:
+    from requests.compat import builtin_str
+    method_converted = builtin_str(method_binary)
+
+print(f"After our conversion: {method_converted}")
+print(f"Type after conversion: {type(method_converted)}")
+print(f"Method converted to uppercase: {method_converted.upper()}")
+
+# Test with regular string as well
+method_str = 'POST'
+if isinstance(method_str, bytes):
+    method_converted_str = method_str.decode('utf-8')
+else:
+    from requests.compat import builtin_str
+    method_converted_str = builtin_str(method_str)
+
+print(f"\nRegular string input: {method_str}")
+print(f"After our conversion: {method_converted_str}")
+print(f"Type after conversion: {type(method_converted_str)}")
+print(f"Method converted to uppercase: {method_converted_str.upper()}")
\ No newline at end of file