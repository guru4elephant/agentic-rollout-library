diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c3ac9f19dd
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, F, Case, When, FilteredRelation
+from django.db.models.functions import Coalesce
+
+# Create test models
+class Zone(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class MyModel(models.Model):
+    name = models.CharField(max_length=100)
+    zone = models.ForeignKey(Zone, on_delete=models.CASCADE, null=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class MyRelation(models.Model):
+    mymodel = models.ForeignKey(MyModel, on_delete=models.CASCADE, related_name='myrelation')
+    
+    class Meta:
+        app_label = 'test'
+
+class Nested(models.Model):
+    myrelation = models.ForeignKey(MyRelation, on_delete=models.CASCADE, related_name='nested')
+    is_all = models.BooleanField(default=False)
+    zone = models.ForeignKey(Zone, on_delete=models.CASCADE, null=True)
+    price = models.DecimalField(max_digits=10, decimal_places=2)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_filtered_relation_issue():
+    """Test the issue with multiple FilteredRelation on same relation"""
+    
+    # Create some test data
+    zone1 = Zone.objects.create(name="Zone 1")
+    zone2 = Zone.objects.create(name="Zone 2")
+    
+    model1 = MyModel.objects.create(name="Model 1", zone=zone1)
+    model2 = MyModel.objects.create(name="Model 2", zone=zone2)
+    
+    relation1 = MyRelation.objects.create(mymodel=model1)
+    relation2 = MyRelation.objects.create(mymodel=model2)
+    
+    # Create nested entries - one with is_all=True and one with specific zone
+    Nested.objects.create(myrelation=relation1, is_all=True, price=100.00)
+    Nested.objects.create(myrelation=relation1, is_all=False, zone=zone1, price=150.00)
+    
+    Nested.objects.create(myrelation=relation2, is_all=True, price=200.00)
+    
+    # Test the query that should demonstrate the issue
+    qs = MyModel.objects.all()
+    
+    qs = qs.alias(
+        relation_zone=FilteredRelation(
+            "myrelation__nested",
+            condition=Q(myrelation__nested__zone=F("zone"))
+        ),
+        relation_all=FilteredRelation(
+            "myrelation__nested", 
+            condition=Q(myrelation__nested__is_all=True)
+        ),
+        price_zone=F("relation_zone__price")
+    ).annotate(
+        price_final=Case(
+            When(
+                price_zone__isnull=True,
+                then=F("relation_all__price"),
+            ),
+            default=F("price_zone")
+        )
+    )
+    
+    print("Generated SQL:")
+    print(str(qs.query))
+    print("\n" + "="*50 + "\n")
+    
+    # Execute the query
+    results = list(qs)
+    print("Results:")
+    for result in results:
+        print(f"{result.name}: price_final={result.price_final}")
+    
+    # Check if both filtered relations are present in the query
+    sql = str(qs.query)
+    relation_zone_count = sql.count('relation_zone')
+    relation_all_count = sql.count('relation_all')
+    
+    print(f"\nRelation 'relation_zone' appears {relation_zone_count} times in SQL")
+    print(f"Relation 'relation_all' appears {relation_all_count} times in SQL")
+    
+    # The issue: relation_all should appear in SQL but doesn't
+    if relation_all_count == 0:
+        print("BUG CONFIRMED: relation_all filtered relation is missing from SQL!")
+        return False
+    else:
+        print("Both filtered relations are present in SQL")
+        return True
+
+if __name__ == "__main__":
+    # Just test the SQL generation without creating tables
+    success = test_filtered_relation_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file