diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..0cf8d23b3c
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the error_messages deepcopy fix.
+"""
+
+import copy
+import os
+import django
+from django.conf import settings
+
+# Configure minimal Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+settings.configure(
+    USE_I18N=False,
+    USE_L10N=False,
+    USE_TZ=False,
+)
+
+django.setup()
+
+from django.forms import CharField, EmailField, IntegerField
+
+def test_field_deepcopy(field_class, **kwargs):
+    """Test deepcopy for a specific field class."""
+    print(f"\nTesting {field_class.__name__}:")
+    
+    # Create original field
+    field1 = field_class(**kwargs)
+    print(f"Original error_messages: {field1.error_messages}")
+    
+    # Make deep copy
+    field2 = copy.deepcopy(field1)
+    print(f"Copied error_messages: {field2.error_messages}")
+    
+    # Modify original
+    original_msg = field1.error_messages.get('required', 'default')
+    field1.error_messages['required'] = f"Modified {original_msg}"
+    
+    print(f"After modification:")
+    print(f"Original: {field1.error_messages}")
+    print(f"Copied: {field2.error_messages}")
+    
+    # Check if they're independent
+    if field1.error_messages is field2.error_messages:
+        print("‚ùå FAIL: Fields share error_messages dictionary")
+        return False
+    else:
+        print("‚úÖ PASS: Fields have independent error_messages")
+        return True
+
+# Test various field types
+results = []
+
+# Test 1: CharField with custom error messages
+results.append(test_field_deepcopy(
+    CharField, 
+    error_messages={'required': 'Custom required', 'invalid': 'Custom invalid'}
+))
+
+# Test 2: EmailField with default error messages
+results.append(test_field_deepcopy(EmailField))
+
+# Test 3: IntegerField with custom error messages
+results.append(test_field_deepcopy(
+    IntegerField,
+    error_messages={'required': 'Number required', 'invalid': 'Invalid number'}
+))
+
+# Test 4: Multiple levels of copying
+print("\nTesting multiple levels of copying:")
+field1 = CharField(error_messages={'required': 'Level 1'})
+field2 = copy.deepcopy(field1)
+field3 = copy.deepcopy(field2)
+
+field1.error_messages['required'] = 'Modified Level 1'
+
+if (field1.error_messages is not field2.error_messages and 
+    field1.error_messages is not field3.error_messages and
+    field2.error_messages is not field3.error_messages):
+    print("‚úÖ PASS: All levels have independent error_messages")
+    results.append(True)
+else:
+    print("‚ùå FAIL: Some levels share error_messages")
+    results.append(False)
+
+# Summary
+print(f"\n{'='*50}")
+print(f"Summary: {sum(results)}/{len(results)} tests passed")
+if all(results):
+    print("üéâ All tests passed! The fix is working correctly.")
+else:
+    print("‚ùå Some tests failed. The fix needs more work.")
\ No newline at end of file
diff --git a/django/forms/fields.py b/django/forms/fields.py
index 03cd8af8d7..18007accab 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -199,6 +199,7 @@ class Field:
         result = copy.copy(self)
         memo[id(self)] = result
         result.widget = copy.deepcopy(self.widget, memo)
+        result.error_messages = copy.deepcopy(self.error_messages, memo)
         result.validators = self.validators[:]
         return result
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..045ad605af
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,31 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with Field.__deepcopy__ not copying error_messages properly.
+"""
+
+import copy
+from django.forms import Form, CharField
+
+# Create a field with custom error messages
+field1 = CharField(error_messages={'required': 'Custom required message'})
+
+# Make a deep copy
+field2 = copy.deepcopy(field1)
+
+print("Original field error_messages:", field1.error_messages)
+print("Copied field error_messages:", field2.error_messages)
+
+# Modify the error messages on the original field
+field1.error_messages['required'] = 'Modified message'
+
+print("\nAfter modifying original field:")
+print("Original field error_messages:", field1.error_messages)
+print("Copied field error_messages:", field2.error_messages)
+
+# The issue: both fields should have independent error_messages dictionaries
+# But currently they share the same dictionary due to shallow copying
+
+if field1.error_messages is field2.error_messages:
+    print("\n‚ùå ISSUE CONFIRMED: Both fields share the same error_messages dictionary")
+else:
+    print("\n‚úÖ NO ISSUE: Fields have independent error_messages dictionaries")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..556b278a1f
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Simple test for the error_messages deepcopy fix without Django settings.
+"""
+
+import copy
+import os
+import django
+from django.conf import settings
+
+# Configure minimal Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+settings.configure(
+    USE_I18N=False,
+    USE_L10N=False,
+    USE_TZ=False,
+)
+
+django.setup()
+
+from django.forms import CharField
+
+# Test basic functionality
+field1 = CharField(error_messages={'required': 'Custom required message'})
+field2 = copy.deepcopy(field1)
+
+print("Original field error_messages:", field1.error_messages)
+print("Copied field error_messages:", field2.error_messages)
+
+# Modify the error messages on the original field
+field1.error_messages['required'] = 'Modified message'
+
+print("\nAfter modifying original field:")
+print("Original field error_messages:", field1.error_messages)
+print("Copied field error_messages:", field2.error_messages)
+
+# The issue should be fixed now
+if field1.error_messages is field2.error_messages:
+    print("\n‚ùå FAIL: Both fields still share the same error_messages dictionary")
+else:
+    print("\n‚úÖ PASS: Fields have independent error_messages dictionaries")
+
+# Test that the content is correct
+if field2.error_messages['required'] == 'Custom required message':
+    print("‚úÖ PASS: Copied field maintains original error message")
+else:
+    print("‚ùå FAIL: Copied field error message was modified")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..c05d5e3b80
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the error_messages deepcopy fix.
+"""
+
+import copy
+from django.forms import CharField
+
+# Test 1: Nested dictionaries in error_messages
+field1 = CharField(error_messages={
+    'required': 'Custom required message',
+    'invalid': {'code': 'invalid_input', 'message': 'Invalid input'}
+})
+
+field2 = copy.deepcopy(field1)
+
+print("Test 1: Nested dictionaries")
+print("Original:", field1.error_messages)
+print("Copied:", field2.error_messages)
+
+# Modify nested structure
+field1.error_messages['invalid']['message'] = 'Modified nested message'
+
+print("After modifying original nested structure:")
+print("Original:", field1.error_messages)
+print("Copied:", field2.error_messages)
+
+if field1.error_messages['invalid'] is field2.error_messages['invalid']:
+    print("‚ùå FAIL: Nested dictionaries are still shared")
+else:
+    print("‚úÖ PASS: Nested dictionaries are independent")
+
+print("\n" + "="*50 + "\n")
+
+# Test 2: Empty error_messages
+field3 = CharField()  # No custom error_messages
+field4 = copy.deepcopy(field3)
+
+print("Test 2: Empty/default error_messages")
+print("Original:", field3.error_messages)
+print("Copied:", field4.error_messages)
+
+# Modify original
+field3.error_messages['required'] = 'Modified default'
+
+print("After modifying original:")
+print("Original:", field3.error_messages)
+print("Copied:", field4.error_messages)
+
+if field3.error_messages is field4.error_messages:
+    print("‚ùå FAIL: Default error_messages are still shared")
+else:
+    print("‚úÖ PASS: Default error_messages are independent")
+
+print("\n" + "="*50 + "\n")
+
+# Test 3: Multiple levels of copying
+field5 = CharField(error_messages={'required': 'Level 1'})
+field6 = copy.deepcopy(field5)
+field7 = copy.deepcopy(field6)
+
+print("Test 3: Multiple levels of copying")
+print("Original:", field5.error_messages)
+print("First copy:", field6.error_messages)
+print("Second copy:", field7.error_messages)
+
+# Modify original
+field5.error_messages['required'] = 'Modified original'
+
+print("After modifying original:")
+print("Original:", field5.error_messages)
+print("First copy:", field6.error_messages)
+print("Second copy:", field7.error_messages)
+
+all_independent = (field5.error_messages is not field6.error_messages and
+                  field5.error_messages is not field7.error_messages and
+                  field6.error_messages is not field7.error_messages)
+
+if all_independent:
+    print("‚úÖ PASS: All copies have independent error_messages")
+else:
+    print("‚ùå FAIL: Some copies still share error_messages")
\ No newline at end of file