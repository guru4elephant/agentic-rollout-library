diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a6cb47f4d3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,14 @@
+#!/usr/bin/env python3
+
+from sympy import FiniteSet, Interval, Complement, symbols
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+a = FiniteSet(x, y, 2)
+b = Interval(-10, 10)
+result = Complement(a, b)
+
+print("a =", a)
+print("b =", b)
+print("Complement(a, b) =", result)
+print("Expected: {x, y} \\ [-10,10]")
\ No newline at end of file
diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 917717bb74..657c9aae98 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -217,7 +217,31 @@ def _complement(self, other):
             return S.EmptySet
 
         elif isinstance(other, FiniteSet):
-            return FiniteSet(*[el for el in other if self.contains(el) != True])
+            # For FiniteSet complement, remove elements that are definitely in the set
+            # and keep elements that are not definitely in the set with complement operation
+            elements_in_set = []
+            elements_not_in_set = []
+            elements_uncertain = []
+            
+            for element in other:
+                containment = self.contains(element)
+                if containment is S.true:
+                    elements_in_set.append(element)
+                elif containment is S.false:
+                    elements_not_in_set.append(element)
+                else:
+                    elements_uncertain.append(element)
+            
+            result_set = FiniteSet(*elements_not_in_set, *elements_uncertain)
+            
+            if len(elements_in_set) > 0 or len(elements_uncertain) > 0:
+                # If some elements are definitely in the set or there are uncertain elements,
+                # we need to return a Complement
+                return Complement(result_set, self, evaluate=False)
+            else:
+                # If no elements are definitely in the set and no uncertain elements,
+                # just return the result set
+                return result_set
 
     def symmetric_difference(self, other):
         """
@@ -1798,6 +1822,27 @@ def _boundary(self):
         return self
 
     def _complement(self, other):
+        if isinstance(other, FiniteSet):
+            # For FiniteSet complement, remove elements that are definitely in the interval
+            # and keep elements that are not definitely in the interval with complement operation
+            elements_in_interval = []
+            elements_not_definitely_in_interval = []
+            
+            for element in other.args:
+                containment = self.contains(element)
+                if containment is S.true:
+                    elements_in_interval.append(element)
+                else:
+                    elements_not_definitely_in_interval.append(element)
+            
+            result_set = FiniteSet(*elements_not_definitely_in_interval)
+            
+            if len(elements_in_interval) > 0:
+                # If some elements are definitely in the interval, we need to return a Complement
+                return Complement(result_set, self, evaluate=False)
+            else:
+                # If no elements are definitely in the interval, just return the result set
+                return result_set
         return other
 
     def _symmetric_difference(self, other):
@@ -1933,8 +1978,9 @@ def _intersect(self, other):
     def _complement(self, other):
         if isinstance(other, Interval):
             nums = sorted(m for m in self.args if m.is_number)
+            syms = [m for m in self.args if m.is_Symbol]
+            
             if other == S.Reals and nums != []:
-                syms = [m for m in self.args if m.is_Symbol]
                 # Reals cannot contain elements other than numbers and symbols.
 
                 intervals = []  # Build up a list of intervals between the elements
@@ -1948,6 +1994,23 @@ def _complement(self, other):
                             FiniteSet(*syms), evaluate=False)
                 else:
                     return Union(intervals, evaluate=False)
+            elif nums != []:
+                # For general intervals, remove numbers that are in the interval
+                # and keep symbols with complement operation
+                nums_in_interval = [num for num in nums if other.contains(num) is S.true]
+                nums_not_in_interval = [num for num in nums if other.contains(num) is S.false]
+                
+                # For numbers with unknown containment, keep them
+                nums_unknown = [num for num in nums if other.contains(num) not in (S.true, S.false)]
+                
+                result_set = FiniteSet(*syms, *nums_not_in_interval, *nums_unknown)
+                
+                if len(nums_in_interval) > 0:
+                    # If some numbers are in the interval, we need to return a Complement
+                    return Complement(result_set, other, evaluate=False)
+                else:
+                    # If no numbers are in the interval, just return the result set
+                    return result_set
             elif nums == []:
                 return None
 
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..37711d0fea
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+
+from sympy import FiniteSet, Interval, Complement, symbols, S
+
+# Test case 1: Original issue - mixed symbols and numbers
+x, y = symbols('x y')
+a = FiniteSet(x, y, 2)
+b = Interval(-10, 10)
+result1 = Complement(a, b)
+print("Test 1 - Mixed symbols and numbers:")
+print("a =", a)
+print("b =", b)
+print("Complement(a, b) =", result1)
+print("Expected: {x, y} \\ [-10,10]")
+print()
+
+# Test case 2: All numbers in interval
+c = FiniteSet(1, 2, 3)
+d = Interval(0, 5)
+result2 = Complement(c, d)
+print("Test 2 - All numbers in interval:")
+print("c =", c)
+print("d =", d)
+print("Complement(c, d) =", result2)
+print("Expected: EmptySet (since all numbers are in interval)")
+print()
+
+# Test case 3: No numbers in interval
+e = FiniteSet(11, 12, 13)
+f = Interval(0, 5)
+result3 = Complement(e, f)
+print("Test 3 - No numbers in interval:")
+print("e =", e)
+print("f =", f)
+print("Complement(e, f) =", result3)
+print("Expected: {11, 12, 13} (since no numbers are in interval)")
+print()
+
+# Test case 4: Only symbols
+g = FiniteSet(x, y)
+h = Interval(-10, 10)
+result4 = Complement(g, h)
+print("Test 4 - Only symbols:")
+print("g =", g)
+print("h =", h)
+print("Complement(g, h) =",  result4)
+print("Expected: {x, y} \\ [-10,10]")
+print()
+
+# Test case 5: Mixed with some numbers not in interval
+i = FiniteSet(x, y, -15, 15)
+j = Interval(-10, 10)
+result5 = Complement(i, j)
+print("Test 5 - Mixed with numbers not in interval:")
+print("i =", i)
+print("j =", j)
+print("Complement(i, j) =", result5)
+print("Expected: {-15, 15, x, y} \\ [-10,10]")
\ No newline at end of file