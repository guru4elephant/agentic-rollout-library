diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
index ac0b62d0bf..ea88c54b0d 100644
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -68,7 +68,7 @@ class Aggregate(Func):
         return []
 
     def as_sql(self, compiler, connection, **extra_context):
-        extra_context['distinct'] = 'DISTINCT' if self.distinct else ''
+        extra_context['distinct'] = 'DISTINCT ' if self.distinct else ''
         if self.filter:
             if connection.features.supports_aggregate_filter_clause:
                 filter_sql, filter_params = self.filter.as_sql(compiler, connection)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..23ee438ec0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import Count, Case, When, Q
+from django.db.models.functions import Cast
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the issue: Count with both Case condition and distinct=True
+def test_count_with_case_and_distinct():
+    print("Testing Count with Case condition and distinct=True...")
+    
+    # Create a query with Count containing both Case and distinct
+    try:
+        query = TestModel.objects.annotate(
+            count_field=Count(
+                Case(When(Q(name__startswith='test'), then='value')),
+                distinct=True
+            )
+        )
+        
+        # Try to get the SQL to see if there's an error
+        sql = str(query.query)
+        print("SQL generated successfully:")
+        print(sql)
+        
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        print(f"Error type: {type(e)}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_count_with_case_and_distinct()
+    if success:
+        print("No error reproduced")
+    else:
+        print("Error reproduced successfully")
\ No newline at end of file
diff --git a/test_distinct_false.py b/test_distinct_false.py
new file mode 100644
index 0000000000..05187b0c60
--- /dev/null
+++ b/test_distinct_false.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import Count
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_distinct_false_no_extra_space():
+    """Test that when distinct=False, no extra space is added"""
+    print("Testing distinct=False doesn't add extra space...")
+    
+    try:
+        query = TestModel.objects.annotate(count=Count('value', distinct=False))
+        sql = str(query.query)
+        print("SQL:", sql)
+        
+        # Check that there's no extra space before the expression
+        if "COUNT( " in sql:
+            print("✗ Extra space found when distinct=False")
+            return False
+        else:
+            print("✓ No extra space when distinct=False")
+            return True
+            
+    except Exception as e:
+        print(f"✗ Error: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing distinct=False case...")
+    
+    if test_distinct_false_no_extra_space():
+        print("\n✓ distinct=False works correctly!")
+    else:
+        print("\n✗ distinct=False has issues!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..998000370b
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python3
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import Count, Case, When, Q
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_count_with_distinct_only():
+    """Test Count with distinct=True but without Case"""
+    print("Testing Count with distinct=True only...")
+    try:
+        query = TestModel.objects.annotate(
+            count_field=Count('value', distinct=True)
+        )
+        sql = str(query.query)
+        print("SQL:", sql)
+        print("✓ Success")
+        return True
+    except Exception as e:
+        print(f"✗ Error: {e}")
+        return False
+
+def test_count_with_case_only():
+    """Test Count with Case but without distinct=True"""
+    print("Testing Count with Case only...")
+    try:
+        query = TestModel.objects.annotate(
+            count_field=Count(
+                Case(When(Q(name__startswith='test'), then='value'))
+            )
+        )
+        sql = str(query.query)
+        print("SQL:", sql)
+        print("✓ Success")
+        return True
+    except Exception as e:
+        print(f"✗ Error: {e}")
+        return False
+
+def test_count_with_neither():
+    """Test Count without distinct and without Case"""
+    print("Testing Count without distinct and without Case...")
+    try:
+        query = TestModel.objects.annotate(
+            count_field=Count('value')
+        )
+        sql = str(query.query)
+        print("SQL:", sql)
+        print("✓ Success")
+        return True
+    except Exception as e:
+        print(f"✗ Error: {e}")
+        return False
+
+def test_count_with_case_and_distinct():
+    """Test Count with both Case and distinct=True (the original issue)"""
+    print("Testing Count with Case and distinct=True...")
+    try:
+        query = TestModel.objects.annotate(
+            count_field=Count(
+                Case(When(Q(name__startswith='test'), then='value')),
+                distinct=True
+            )
+        )
+        sql = str(query.query)
+        print("SQL:", sql)
+        print("✓ Success")
+        return True
+    except Exception as e:
+        print(f"✗ Error: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing edge cases for Count aggregation fix...")
+    
+    results = []
+    results.append(test_count_with_distinct_only())
+    results.append(test_count_with_case_only())
+    results.append(test_count_with_neither())
+    results.append(test_count_with_case_and_distinct())
+    
+    if all(results):
+        print("\n✓ All tests passed!")
+    else:
+        print("\n✗ Some tests failed!")
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..7f3b385ebf
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python3
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+import django
+from django.conf import settings
+from django.db import models
+from django.db.models import Count, Avg, Max, Min, Sum
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_basic_aggregations():
+    """Test that basic aggregations still work"""
+    print("Testing basic aggregations...")
+    
+    # Test Count
+    try:
+        query = TestModel.objects.annotate(count=Count('value'))
+        sql = str(query.query)
+        print("✓ Count without distinct works")
+    except Exception as e:
+        print(f"✗ Count without distinct failed: {e}")
+        return False
+    
+    # Test Count with distinct
+    try:
+        query = TestModel.objects.annotate(count=Count('value', distinct=True))
+        sql = str(query.query)
+        print("✓ Count with distinct works")
+    except Exception as e:
+        print(f"✗ Count with distinct failed: {e}")
+        return False
+    
+    # Test Avg
+    try:
+        query = TestModel.objects.annotate(avg=Avg('value'))
+        sql = str(query.query)
+        print("✓ Avg works")
+    except Exception as e:
+        print(f"✗ Avg failed: {e}")
+        return False
+    
+    # Test Max
+    try:
+        query = TestModel.objects.annotate(max=Max('value'))
+        sql = str(query.query)
+        print("✓ Max works")
+    except Exception as e:
+        print(f"✗ Max failed: {e}")
+        return False
+    
+    # Test Min
+    try:
+        query = TestModel.objects.annotate(min=Min('value'))
+        sql = str(query.query)
+        print("✓ Min works")
+    except Exception as e:
+        print(f"✗ Min failed: {e}")
+        return False
+    
+    # Test Sum
+    try:
+        query = TestModel.objects.annotate(sum=Sum('value'))
+        sql = str(query.query)
+        print("✓ Sum works")
+    except Exception as e:
+        print(f"✗ Sum failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Testing existing aggregation functionality...")
+    
+    if test_basic_aggregations():
+        print("\n✓ All basic aggregations work correctly!")
+    else:
+        print("\n✗ Some aggregations failed!")
\ No newline at end of file