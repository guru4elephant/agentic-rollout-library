diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..7fe0e2381e
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""Comprehensive test to understand the Mod lambdify issue"""
+
+from sympy import Mod, lambdify, symbols, simplify, expand
+
+# Test the issue described in the GitHub issue
+x, y = symbols('x y')
+
+# Test various expressions with Mod
+expressions = [
+    -Mod(x, y),
+    2 * Mod(x, y),
+    -2 * Mod(x, y),
+    Mod(-x, y),
+    Mod(x, y) * 2,
+    Mod(x, y) * -2,
+]
+
+print("Testing various Mod expressions:")
+for i, expr in enumerate(expressions, 1):
+    print(f"\n{i}. Expression: {expr}")
+    print(f"   Simplified: {simplify(expr)}")
+    print(f"   Expanded: {expand(expr)}")
+    
+    # Test lambdify with modules=[]
+    try:
+        f = lambdify([x, y], expr, modules=[])
+        result = f(3, 7)
+        print(f"   Lambdify result: {result}")
+        print(f"   Expected: {expr.subs({x: 3, y: 7})}")
+    except Exception as e:
+        print(f"   Error: {e}")
+
+# Test what the mathematical behavior should be
+print("\n\nMathematical behavior test:")
+print("-(3 % 7) =", -(3 % 7))
+print("(-3) % 7 =", (-3) % 7)
+print("2 * (3 % 7) =", 2 * (3 % 7))
+print("(2 * 3) % 7 =", (2 * 3) % 7)
+print("-2 * (3 % 7) =", -2 * (3 % 7))
+print("(-2 * 3) % 7 =", (-2 * 3) % 7)
+
+# Test what SymPy evaluates to symbolically
+print("\n\nSymPy symbolic evaluation:")
+for i, expr in enumerate(expressions, 1):
+    result = expr.subs({x: 3, y: 7})
+    print(f"{i}. {expr} -> {result}")
\ No newline at end of file
diff --git a/debug_lambdify.py b/debug_lambdify.py
new file mode 100644
index 0000000000..57e8e626ee
--- /dev/null
+++ b/debug_lambdify.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+"""Debug script to understand lambdify processing"""
+
+from sympy import Mod, lambdify, symbols
+from sympy.printing.pycode import PythonCodePrinter
+
+# Test the issue described in the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Original expression:", expr)
+
+# Test what the printer generates
+printer = PythonCodePrinter()
+print("Python code:", printer.doprint(expr))
+
+# Test lambdify with different modules
+print("\nTesting lambdify with modules=[]:")
+f_empty = lambdify([x, y], expr, modules=[])
+print("Result:", f_empty(3, 7))
+
+print("\nTesting lambdify with default modules:")
+f_default = lambdify([x, y], expr)
+print("Result:", f_default(3, 7))
+
+# Let's also check what the expression looks like after processing
+print("\nExpression after processing:")
+print("Type:", type(expr))
+print("Args:", expr.args)
+print("Func:", expr.func)
+
+# Check if there's any simplification happening
+from sympy import simplify
+print("Simplified:", simplify(expr))
\ No newline at end of file
diff --git a/debug_mod.py b/debug_mod.py
new file mode 100644
index 0000000000..e5a21f4bc0
--- /dev/null
+++ b/debug_mod.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+"""Debug script to understand the Mod lambdify issue"""
+
+from sympy import Mod, lambdify, symbols, print_latex
+from sympy.printing.pycode import PythonCodePrinter
+
+# Test the issue described in the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Expression:", expr)
+print("LaTeX:", print_latex(expr))
+
+# Test the printer directly
+printer = PythonCodePrinter()
+print("Python code:", printer.doprint(expr))
+
+# Test with different multipliers
+expr2 = 2 * Mod(x, y)
+print("Expression 2:", expr2)
+print("Python code 2:", printer.doprint(expr2))
+
+expr3 = -2 * Mod(x, y)
+print("Expression 3:", expr3)
+print("Python code 3:", printer.doprint(expr3))
+
+# Let's also check what the arguments look like
+print("Mod args:", Mod(x, y).args)
+print("Mod type:", type(Mod(x, y)))
\ No newline at end of file
diff --git a/exact_issue_test.py b/exact_issue_test.py
new file mode 100644
index 0000000000..b534fdd878
--- /dev/null
+++ b/exact_issue_test.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+"""Test that exactly matches the GitHub issue example"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Exact example from GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Testing exact GitHub issue example:")
+print("Expression:", expr)
+
+# Test without modules=[]
+f = lambdify([x, y], expr)
+print("f(3, 7) =", f(3, 7))
+print("Source code:")
+print(inspect.getsource(f))
+
+# Test with modules=[]
+g = lambdify([x, y], expr, modules=[])
+print("g(3, 7) =", g(3, 7))
+print("Source code:")
+print(inspect.getsource(g))
+
+# Expected results according to GitHub issue
+print("\nExpected results from GitHub issue:")
+print("f(3, 7) should be -3 (from -mod(x, y))")
+print("g(3, 7) should be 4 (from -x % y)")
+
+# Let's also test what the actual Python behavior should be
+print("\nPython modulo behavior:")
+print("-(3 % 7) =", -(3 % 7))
+print("(-3) % 7 =", (-3) % 7)
\ No newline at end of file
diff --git a/module_comparison.py b/module_comparison.py
new file mode 100644
index 0000000000..e3285e2cb6
--- /dev/null
+++ b/module_comparison.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""Compare different module configurations"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Comparing different module configurations:")
+print("Expression:", expr)
+
+modules_configs = [
+    None,  # default
+    [],
+    ['math'],
+    ['numpy'],
+    ['sympy']
+]
+
+for modules in modules_configs:
+    try:
+        if modules is None:
+            f = lambdify([x, y], expr)
+            modules_str = "default"
+        else:
+            f = lambdify([x, y], expr, modules=modules)
+            modules_str = str(modules)
+        
+        result = f(3, 7)
+        source = inspect.getsource(f)
+        print(f"\nmodules={modules_str}:")
+        print(f"  Result: {result}")
+        print(f"  Source: {source}")
+    except Exception as e:
+        print(f"\nmodules={modules_str}: Error - {e}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..33d8539682
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""Script to reproduce the Mod function lambdify bug"""
+
+import inspect
+from sympy import Mod, lambdify, symbols
+
+# Test the issue described in the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Testing lambdify without modules=[]:")
+f = lambdify([x, y], expr)
+print(f"f(3, 7) = {f(3, 7)}")
+print("Source code:")
+print(inspect.getsource(f))
+print()
+
+print("Testing lambdify with modules=[]:")
+g = lambdify([x, y], expr, modules=[])
+print(f"g(3, 7) = {g(3, 7)}")
+print("Source code:")
+print(inspect.getsource(g))
+print()
+
+# Let's also test with different multipliers
+print("Testing with different multipliers:")
+expr2 = 2 * Mod(x, y)
+h = lambdify([x, y], expr2, modules=[])
+print(f"h(3, 7) = {h(3, 7)}")
+print("Source code:")
+print(inspect.getsource(h))
+print()
+
+expr3 = -2 * Mod(x, y)
+i = lambdify([x, y], expr3, modules=[])
+print(f"i(3, 7) = {i(3, 7)}")
+print("Source code:")
+print(inspect.getsource(i))
+print()
+
+# Expected behavior: all should return the same result as Python's modulo
+print("Expected results:")
+print("-3 % 7 =", -3 % 7)
+print("2 * (3 % 7) =", 2 * (3 % 7))
+print("-2 * (3 % 7) =", -2 * (3 % 7))
\ No newline at end of file
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..23c636185c 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -233,8 +233,13 @@ def _print_ComplexInfinity(self, expr):
         return self._print_NaN(expr)
 
     def _print_Mod(self, expr):
-        PREC = precedence(expr)
-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+        # Use the precedence of multiplication (50) for modulo operator %
+        PREC = 50
+        mod_str = '{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args))
+        
+        # Always add parentheses to ensure correct evaluation order
+        # This prevents expressions like -Mod(x, y) from becoming -x % y
+        return '({})'.format(mod_str)
 
     def _print_Piecewise(self, expr):
         result = []