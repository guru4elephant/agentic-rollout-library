diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5e7b23f9a0..7355fdd0f8 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -580,9 +580,18 @@ class ModelAdmin(BaseModelAdmin):
     def __str__(self):
         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
 
+    def get_inlines(self, request, obj=None):
+        """
+        Hook for specifying the list of inline classes to use for this ModelAdmin.
+
+        Override this method to dynamically set inlines based on the request or
+        model instance.
+        """
+        return self.inlines
+
     def get_inline_instances(self, request, obj=None):
         inline_instances = []
-        for inline_class in self.inlines:
+        for inline_class in self.get_inlines(request, obj):
             inline = inline_class(self.model, self.admin_site)
             if request:
                 if not (inline.has_view_or_change_permission(request, obj) or
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..4a1afae030
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Final verification that the get_inlines() hook implementation is correct.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.contrib import admin
+from django.db import models
+import inspect
+
+# Create test models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create inline admin
+class BookInline(admin.TabularInline):
+    model = Book
+    extra = 1
+
+# Test the implementation
+print("Final verification of get_inlines() hook implementation...")
+
+# Test 1: Check method exists and has correct signature
+ma = admin.ModelAdmin(Author, admin.site)
+print("1. Method existence and signature:")
+print(f"   hasattr(ma, 'get_inlines'): {hasattr(ma, 'get_inlines')}")
+
+# Check signature
+sig = inspect.signature(ma.get_inlines)
+print(f"   Method signature: {sig}")
+
+# Test 2: Default behavior
+print("\n2. Default behavior:")
+result = ma.get_inlines(None)
+print(f"   Default get_inlines() returns: {result}")
+print(f"   Type: {type(result)}")
+print(f"   Content: {[cls.__name__ for cls in result] if result else result}")
+
+# Test 3: Backward compatibility
+print("\n3. Backward compatibility:")
+print(f"   ma.inlines: {ma.inlines}")
+print(f"   ma.inlines == ma.get_inlines(None): {ma.inlines == ma.get_inlines(None)}")
+
+# Test 4: Method override
+class CustomAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+    
+    def get_inlines(self, request, obj=None):
+        return [BookInline]  # Same as default but could be customized
+
+custom_ma = CustomAdmin(Author, admin.site)
+print("\n4. Custom implementation:")
+print(f"   Custom get_inlines() returns: {[cls.__name__ for cls in custom_ma.get_inlines(None)]}")
+
+# Test 5: Verify get_inline_instances still works
+print("\n5. get_inline_instances integration:")
+instances = ma.get_inline_instances(None)
+print(f"   get_inline_instances() returned {len(instances)} instances")
+
+# Test 6: Check that the method is properly documented
+print("\n6. Documentation:")
+doc = ma.get_inlines.__doc__
+print(f"   Method has documentation: {bool(doc)}")
+if doc:
+    print(f"   Documentation: {doc.strip()}")
+
+print("\n✅ Final verification completed successfully!")
+print("The get_inlines() hook has been correctly implemented:")
+print("   - Method exists with correct signature")
+print("   - Default behavior maintains backward compatibility")
+print("   - Custom implementations work correctly")
+print("   - Integration with get_inline_instances is maintained")
+print("   - Proper documentation is included")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..1de0d18709
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the get_inlines() hook issue.
+This script demonstrates the need for a get_inlines() hook in ModelAdmin.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.contrib import admin
+from django.db import models
+
+# Create test models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create inline admin
+class BookInline(admin.TabularInline):
+    model = Book
+    extra = 1
+
+# Create ModelAdmin to demonstrate the issue
+class AuthorAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+
+# Register the admin
+admin.site.register(Author, AuthorAdmin)
+
+# Test the current behavior
+print("Testing current ModelAdmin behavior...")
+author_admin = AuthorAdmin(Author, admin.site)
+
+# Show the current get_inline_instances method
+print("Current get_inline_instances method:")
+print("=" * 50)
+with open('/testbed/django/contrib/admin/options.py', 'r') as f:
+    lines = f.readlines()
+    for i, line in enumerate(lines[582:596], 583):
+        print(f"{i}: {line.rstrip()}")
+
+print("\nThe issue is that developers have to copy the for loop logic")
+print("from get_inline_instances instead of just overriding get_inlines()")
+print("to return the appropriate inline classes based on request/obj.")
+
+print("\nDesired solution:")
+print("1. Add get_inlines(request, obj=None) method to ModelAdmin")
+print("2. Modify get_inline_instances to call get_inlines() instead of using self.inlines directly")
+print("3. Allow developers to override get_inlines() to return dynamic inline classes")
\ No newline at end of file
diff --git a/test_basic_functionality.py b/test_basic_functionality.py
new file mode 100644
index 0000000000..18f13a026a
--- /dev/null
+++ b/test_basic_functionality.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Test script to verify basic admin functionality still works after adding get_inlines() hook.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.contrib import admin
+from django.db import models
+
+# Create test models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create inline admin
+class BookInline(admin.TabularInline):
+    model = Book
+    extra = 1
+
+# Test 1: Basic ModelAdmin without overriding get_inlines
+class BasicAuthorAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+
+# Test 2: ModelAdmin that overrides get_inlines
+class CustomAuthorAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+    
+    def get_inlines(self, request, obj=None):
+        """Custom implementation that returns the same inlines"""
+        return self.inlines
+
+# Register the admins
+admin.site.register(Author, BasicAuthorAdmin)
+
+# Test basic functionality
+print("Testing basic admin functionality...")
+
+# Test 1: Basic ModelAdmin
+basic_admin = BasicAuthorAdmin(Author, admin.site)
+print("1. Basic ModelAdmin:")
+print(f"   inlines attribute: {[inline.__name__ for inline in basic_admin.inlines]}")
+print(f"   get_inlines() result: {[inline.__name__ for inline in basic_admin.get_inlines(None)]}")
+
+# Test 2: Custom ModelAdmin
+custom_admin = CustomAuthorAdmin(Author, admin.site)
+print("2. Custom ModelAdmin:")
+print(f"   inlines attribute: {[inline.__name__ for inline in custom_admin.inlines]}")
+print(f"   get_inlines() result: {[inline.__name__ for inline in custom_admin.get_inlines(None)]}")
+
+# Test 3: get_inline_instances still works
+print("3. Testing get_inline_instances:")
+instances = basic_admin.get_inline_instances(None)
+print(f"   get_inline_instances returned {len(instances)} instances")
+
+# Test 4: Verify the new method exists
+print("4. Method availability:")
+print(f"   hasattr(basic_admin, 'get_inlines'): {hasattr(basic_admin, 'get_inlines')}")
+print(f"   hasattr(custom_admin, 'get_inlines'): {hasattr(custom_admin, 'get_inlines')}")
+
+print("\n✅ Basic functionality tests passed!")
+print("The get_inlines() hook has been successfully added without breaking existing functionality.")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d979ef0e65
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python3
+"""
+Test script to verify edge cases and backward compatibility for get_inlines() hook.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.contrib import admin
+from django.db import models
+
+# Create test models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create inline admin
+class BookInline(admin.TabularInline):
+    model = Book
+    extra = 1
+
+print("Testing edge cases and backward compatibility...")
+
+# Test 1: Empty inlines
+class EmptyInlinesAdmin(admin.ModelAdmin):
+    inlines = []
+
+empty_admin = EmptyInlinesAdmin(Author, admin.site)
+print("1. Empty inlines:")
+print(f"   get_inlines() result: {empty_admin.get_inlines(None)}")
+print(f"   get_inline_instances result: {len(empty_admin.get_inline_instances(None))} instances")
+
+# Test 2: None request and obj
+class TestAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+
+test_admin = TestAdmin(Author, admin.site)
+print("2. None request and obj:")
+print(f"   get_inlines(None, None): {[inline.__name__ for inline in test_admin.get_inlines(None, None)]}")
+
+# Test 3: Custom get_inlines returning empty list
+class CustomEmptyAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+    
+    def get_inlines(self, request, obj=None):
+        return []
+
+custom_empty_admin = CustomEmptyAdmin(Author, admin.site)
+print("3. Custom get_inlines returning empty list:")
+print(f"   get_inlines() result: {custom_empty_admin.get_inlines(None)}")
+print(f"   get_inline_instances result: {len(custom_empty_admin.get_inline_instances(None))} instances")
+
+# Test 4: Custom get_inlines returning different inlines based on conditions
+class ConditionalAdmin(admin.ModelAdmin):
+    inlines = [BookInline]
+    
+    def get_inlines(self, request, obj=None):
+        if obj and obj.name == "Special":
+            return [BookInline]  # Return same as default but could be different
+        elif request and hasattr(request, 'custom_flag') and request.custom_flag:
+            return []
+        else:
+            return super().get_inlines(request, obj)
+
+conditional_admin = ConditionalAdmin(Author, admin.site)
+
+# Test with different conditions
+author1 = Author(name="Special")
+author2 = Author(name="Regular")
+
+print("4. Conditional get_inlines:")
+print(f"   With special author: {[inline.__name__ for inline in conditional_admin.get_inlines(None, author1)]}")
+print(f"   With regular author: {[inline.__name__ for inline in conditional_admin.get_inlines(None, author2)]}")
+
+# Test with request flag
+class MockRequest:
+    custom_flag = True
+
+request = MockRequest()
+print(f"   With flagged request: {[inline.__name__ for inline in conditional_admin.get_inlines(request, None)]}")
+
+# Test 5: Verify backward compatibility - existing code should work unchanged
+print("5. Backward compatibility:")
+print("   Existing code using self.inlines directly still works:")
+print(f"   test_admin.inlines: {[inline.__name__ for inline in test_admin.inlines]}")
+
+print("\n✅ All edge case tests passed!")
+print("The get_inlines() hook maintains backward compatibility and handles edge cases correctly.")
\ No newline at end of file
diff --git a/test_get_inlines.py b/test_get_inlines.py
new file mode 100644
index 0000000000..8f0cceb27b
--- /dev/null
+++ b/test_get_inlines.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the get_inlines() hook implementation.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.contrib import admin
+from django.db import models
+from django.http import HttpRequest
+
+# Create test models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class Review(models.Model):
+    content = models.TextField()
+    book = models.ForeignKey(Book, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create inline admins
+class BookInline(admin.TabularInline):
+    model = Book
+    extra = 1
+
+class ReviewInline(admin.TabularInline):
+    model = Review
+    extra = 1
+
+# Create ModelAdmin that uses the new get_inlines() hook
+class AuthorAdmin(admin.ModelAdmin):
+    inlines = [BookInline]  # Default inlines
+    
+    def get_inlines(self, request, obj=None):
+        """
+        Override get_inlines to dynamically return inlines based on request or obj.
+        """
+        # Example: Return different inlines based on some condition
+        if obj and obj.name == "Special Author":
+            return [BookInline, ReviewInline]
+        elif request and request.method == "POST":
+            return [BookInline]
+        else:
+            # Default behavior - return the configured inlines
+            return super().get_inlines(request, obj)
+
+# Register the admin
+admin.site.register(Author, AuthorAdmin)
+
+# Test the new get_inlines() hook
+print("Testing new get_inlines() hook...")
+author_admin = AuthorAdmin(Author, admin.site)
+request = HttpRequest()
+
+# Test 1: Default behavior
+print("\n1. Testing default behavior:")
+inlines = author_admin.get_inlines(request)
+print(f"get_inlines() returned: {[inline.__name__ for inline in inlines]}")
+
+# Test 2: With obj parameter
+print("\n2. Testing with obj parameter:")
+author_obj = Author(name="Special Author")
+inlines = author_admin.get_inlines(request, author_obj)
+print(f"get_inlines(request, special_author) returned: {[inline.__name__ for inline in inlines]}")
+
+# Test 3: Test get_inline_instances with minimal setup (skip permission checks)
+print("\n3. Testing get_inline_instances with None request (skips permission checks):")
+instances = author_admin.get_inline_instances(None)
+print(f"get_inline_instances returned {len(instances)} instances")
+print(f"Instance classes: {[instance.__class__.__name__ for instance in instances]}")
+
+# Test 4: Test with different obj
+print("\n4. Testing with different obj:")
+author_obj2 = Author(name="Regular Author")
+inlines = author_admin.get_inlines(request, author_obj2)
+print(f"get_inlines(request, regular_author) returned: {[inline.__name__ for inline in inlines]}")
+
+print("\n✅ All tests passed! The get_inlines() hook is working correctly.")
+print("Developers can now override get_inlines() to dynamically set inlines")
+print("based on request or model instance without copying the for loop logic.")
\ No newline at end of file