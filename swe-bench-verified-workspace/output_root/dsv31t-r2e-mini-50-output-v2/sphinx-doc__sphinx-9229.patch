diff --git a/check_output.py b/check_output.py
new file mode 100644
index 000000000..5cb5ad70b
--- /dev/null
+++ b/check_output.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+"""Check the generated output to verify the fix works."""
+
+import tempfile
+import os
+import subprocess
+import sys
+
+def test_generated_docs():
+    """Test that the generated documentation includes docstrings for type aliases."""
+    
+    # Create a temporary directory
+    test_dir = tempfile.mkdtemp()
+    old_cwd = os.getcwd()
+    
+    try:
+        os.chdir(test_dir)
+        
+        # Create the test file
+        with open('file.py', 'w') as f:
+            f.write('''from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Signatures for the documentation purposes
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed, such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
+''')
+
+        # Generate API docs using sphinx-apidoc
+        result = subprocess.run([
+            'sphinx-apidoc',
+            '-f', '-o', 'api', '.'
+        ], capture_output=True, text=True)
+        
+        if result.returncode != 0:
+            print(f"Error generating API docs: {result.stderr}")
+            return False
+        
+        # Check if the generated RST file contains docstrings
+        api_file = os.path.join('api', 'file.rst')
+        if os.path.exists(api_file):
+            with open(api_file, 'r') as f:
+                content = f.read()
+            
+            print("Generated API content:")
+            print(content)
+            
+            # Check if docstrings are present
+            if 'Dictionary with PyScaffold' in content and 'When the file content' in content:
+                print("✅ Docstrings are present in the generated documentation!")
+                return True
+            else:
+                print("❌ Docstrings are missing from the generated documentation.")
+                return False
+        else:
+            print("❌ API file was not generated.")
+            return False
+            
+    finally:
+        os.chdir(old_cwd)
+        # Clean up
+        import shutil
+        shutil.rmtree(test_dir, ignore_errors=True)
+
+if __name__ == "__main__":
+    success = test_generated_docs()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..85e42001a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,41 @@
+# reproduce_issue.py
+from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Signatures for the documentation purposes
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed, such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
\ No newline at end of file
diff --git a/setup.py b/setup.py
index b669afc00..0986baec3 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.14,<0.18',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..33915fc62
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""Simple test to understand how autodoc handles type aliases."""
+
+import sys
+import os
+sys.path.insert(0, os.path.abspath('.'))
+
+from sphinx.ext.autodoc import DataDocumenter, ClassDocumenter
+from sphinx.application import Sphinx
+from sphinx.config import Config
+from sphinx.environment import BuildEnvironment
+from docutils.utils import Reporter
+from docutils.parsers.rst.states import RSTState
+from docutils import nodes
+
+# Create a minimal Sphinx app for testing
+from sphinx.util.docutils import docutils_namespace
+
+with docutils_namespace():
+    app = Sphinx(srcdir='.', confdir='.', outdir='_build', doctreedir='_doctrees',
+                 buildername='html', confoverrides={}, status=None, warning=None)
+    
+    # Test the type aliases from the issue
+    from pathlib import Path
+    from typing import Any, Callable, Dict, Union
+    
+    ScaffoldOpts = Dict[str, Any]
+    FileContents = Union[str, None] 
+    FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+    
+    print("Testing documenter selection:")
+    print("ScaffoldOpts:", type(ScaffoldOpts))
+    print("FileContents:", type(FileContents)) 
+    print("FileOp:", type(FileOp))
+    
+    # Test which documenter can handle these
+    print("\nClassDocumenter.can_document_member:")
+    print("ScaffoldOpts:", ClassDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+    print("FileContents:", ClassDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+    print("FileOp:", ClassDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+    
+    print("\nDataDocumenter.can_document_member:")
+    print("ScaffoldOpts:", DataDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+    print("FileContents:", DataDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+    print("FileOp:", DataDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+    
+    # Test isgenericalias
+    from sphinx.util import inspect
+    print("\nisgenericalias:")
+    print("ScaffoldOpts:", inspect.isgenericalias(ScaffoldOpts))
+    print("FileContents:", inspect.isgenericalias(FileContents))
+    print("FileOp:", inspect.isgenericalias(FileOp))
\ No newline at end of file
diff --git a/simple_test2.py b/simple_test2.py
new file mode 100644
index 000000000..405249f14
--- /dev/null
+++ b/simple_test2.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+"""Simple test to understand how autodoc handles type aliases."""
+
+# Test the type aliases from the issue
+from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+ScaffoldOpts = Dict[str, Any]
+FileContents = Union[str, None] 
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+print("Testing type aliases:")
+print("ScaffoldOpts:", type(ScaffoldOpts))
+print("FileContents:", type(FileContents)) 
+print("FileOp:", type(FileOp))
+
+# Test which documenter can handle these
+from sphinx.ext.autodoc import DataDocumenter, ClassDocumenter
+
+print("\nClassDocumenter.can_document_member:")
+print("ScaffoldOpts:", ClassDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+print("FileContents:", ClassDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+print("FileOp:", ClassDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+
+print("\nDataDocumenter.can_document_member:")
+print("ScaffoldOpts:", DataDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+print("FileContents:", DataDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+print("FileOp:", DataDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+
+# Test isgenericalias
+from sphinx.util import inspect
+print("\nisgenericalias:")
+print("ScaffoldOpts:", inspect.isgenericalias(ScaffoldOpts))
+print("FileContents:", inspect.isgenericalias(FileContents))
+print("FileOp:", inspect.isgenericalias(FileOp))
+
+# Test isinstance type
+print("\nisinstance type:")
+print("ScaffoldOpts isinstance type:", isinstance(ScaffoldOpts, type))
+print("FileContents isinstance type:", isinstance(FileContents, type))
+print("FileOp isinstance type:", isinstance(FileOp, type))
\ No newline at end of file
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index 1f4c98284..d92242e8f 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -1800,6 +1800,18 @@ class GenericAliasMixin(DataDocumenterMixinBase):
         if inspect.isgenericalias(self.object):
             more_content.append(_('alias of %s') % restify(self.object), '')
             more_content.append('', '')
+            
+            # Add docstring for type aliases if available
+            if hasattr(self, 'analyzer') and self.analyzer:
+                attr_docs = self.analyzer.find_attr_docs()
+                key = ('', self.object_name)  # Module-level attributes have empty module name
+                if key in attr_docs:
+                    docstring_lines = list(attr_docs[key])
+                    if docstring_lines:
+                        more_content.append('', '')
+                        for line in docstring_lines:
+                            more_content.append(line, '')
+                        more_content.append('', '')
 
         super().update_content(more_content)
 
@@ -1921,7 +1933,8 @@ class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
     @classmethod
     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
                             ) -> bool:
-        return isinstance(parent, ModuleDocumenter) and isattr
+        from sphinx.util import inspect
+        return (isinstance(parent, ModuleDocumenter) and isattr) or inspect.isgenericalias(member)
 
     def update_annotations(self, parent: Any) -> None:
         """Update __annotations__ to support type_comment and so on."""
diff --git a/test_direct.py b/test_direct.py
new file mode 100644
index 000000000..c842fba7e
--- /dev/null
+++ b/test_direct.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+"""Direct test of DataDocumenter with type aliases."""
+
+import sys
+import os
+sys.path.insert(0, os.path.abspath('.'))
+
+from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Create the type aliases with docstrings
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed,2 such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
+
+# Test that DataDocumenter can handle them
+from sphinx.ext.autodoc import DataDocumenter
+from sphinx.util import inspect
+
+print("Testing DataDocumenter.can_document_member:")
+print("ScaffoldOpts:", DataDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+print("FileContents:", DataDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+print("FileOp:", DataDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+
+print("\nTesting isgenericalias:")
+print("ScaffoldOpts:", inspect.isgenericalias(ScaffoldOpts))
+print("FileContents:", inspect.isgenericalias(FileContents))
+print("FileOp:", inspect.isgenericalias(FileOp))
+
+# Test the analyzer functionality
+import tempfile
+import shutil
+from sphinx.pycode import ModuleAnalyzer
+
+# Create a temporary file with our type aliases
+with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
+    f.write('''
+from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options."""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``."""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions."""
+''')
+    temp_file = f.name
+
+try:
+    analyzer = ModuleAnalyzer.for_file(temp_file, 'test_module')
+    analyzer.analyze()
+    
+    print("\nAnalyzer attr_docs:")
+    attr_docs = analyzer.find_attr_docs()
+    for key, value in attr_docs.items():
+        print(f"  {key}: {list(value)}")
+        
+finally:
+    os.unlink(temp_file)
\ No newline at end of file
diff --git a/test_final.py b/test_final.py
new file mode 100644
index 000000000..6ee20f8e4
--- /dev/null
+++ b/test_final.py
@@ -0,0 +1,135 @@
+#!/usr/bin/env python3
+"""Final test to verify the fix works by building actual HTML documentation."""
+
+import tempfile
+import os
+import subprocess
+import sys
+
+def test_fix():
+    """Test that type alias docstrings are preserved in the final HTML output."""
+    
+    # Create a temporary directory
+    test_dir = tempfile.mkdtemp()
+    old_cwd = os.getcwd()
+    
+    try:
+        os.chdir(test_dir)
+        print(f"Working in: {test_dir}")
+        
+        # Create the test file
+        with open('file.py', 'w') as f:
+            f.write('''from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Signatures for the documentation purposes
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed, such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
+''')
+
+        # Initialize Sphinx
+        result = subprocess.run(['sphinx-quickstart', '-q', '-p', 'Test', '-a', 'Test', '-v', '1.0', '.'], 
+                              capture_output=True, text=True)
+        if result.returncode != 0:
+            print(f"Error initializing Sphinx: {result.stderr}")
+            return False
+
+        # Update conf.py
+        with open('conf.py', 'a') as f:
+            f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+extensions = ['sphinx.ext.autodoc']
+''')
+
+        # Update index.rst
+        with open('index.rst', 'w') as f:
+            f.write('''
+Test Documentation
+==================
+
+.. toctree::
+   :maxdepth: 2
+   :caption: Contents:
+
+   api/file
+''')
+
+        # Generate API docs
+        result = subprocess.run(['sphinx-apidoc', '-f', '-o', 'api', '.'], 
+                              capture_output=True, text=True)
+        if result.returncode != 0:
+            print(f"Error generating API docs: {result.stderr}")
+            return False
+
+        # Build HTML
+        result = subprocess.run(['make', 'html'], capture_output=True, text=True)
+        if result.returncode != 0:
+            print(f"Error building HTML: {result.stderr}")
+            return False
+
+        # Check the generated HTML file
+        html_file = os.path.join('_build', 'html', 'api', 'file.html')
+        if os.path.exists(html_file):
+            with open(html_file, 'r') as f:
+                content = f.read()
+            
+            # Check if docstrings are present in the HTML
+            if ('Dictionary with PyScaffold' in content and 
+                'When the file content' in content and
+                'Signature of functions' in content):
+                print("✅ SUCCESS: Docstrings are preserved in the HTML output!")
+                return True
+            else:
+                print("❌ FAILURE: Docstrings are missing from the HTML output.")
+                print("Content snippet:")
+                print(content[:2000])
+                return False
+        else:
+            print("❌ HTML file was not generated.")
+            return False
+            
+    finally:
+        os.chdir(old_cwd)
+        # Clean up
+        import shutil
+        shutil.rmtree(test_dir, ignore_errors=True)
+
+if __name__ == "__main__":
+    success = test_fix()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..9ee8be7c3
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""Test to verify that the fix for type alias documentation works."""
+
+import tempfile
+import os
+import sys
+from pathlib import Path
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.abspath('.'))
+
+def test_type_alias_documentation():
+    """Test that type aliases are documented with their docstrings."""
+    
+    # Import the test module
+    from reproduce_issue import ScaffoldOpts, FileContents, FileOp
+    
+    # Import Sphinx autodoc components
+    from sphinx.ext.autodoc import DataDocumenter, ModuleDocumenter
+    from sphinx.application import Sphinx
+    from sphinx.config import Config
+    from sphinx.environment import BuildEnvironment
+    from docutils.utils import Reporter
+    from docutils.parsers.rst.states import RSTState
+    from docutils import nodes
+    
+    # Test that DataDocumenter can now handle type aliases
+    print("Testing DataDocumenter.can_document_member for type aliases:")
+    print("ScaffoldOpts:", DataDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None))
+    print("FileContents:", DataDocumenter.can_document_member(FileContents, 'FileContents', True, None))
+    print("FileOp:", DataDocumenter.can_document_member(FileOp, 'FileOp', True, None))
+    
+    # Test that they are generic aliases
+    from sphinx.util import inspect
+    print("\nTesting isgenericalias:")
+    print("ScaffoldOpts:", inspect.isgenericalias(ScaffoldOpts))
+    print("FileContents:", inspect.isgenericalias(FileContents))
+    print("FileOp:", inspect.isgenericalias(FileOp))
+    
+    # Test that they have docstrings
+    print("\nTesting docstrings:")
+    print("ScaffoldOpts docstring:", bool(ScaffoldOpts.__doc__))
+    print("FileContents docstring:", bool(FileContents.__doc__))
+    print("FileOp docstring:", bool(FileOp.__doc__))
+    
+    if (DataDocumenter.can_document_member(ScaffoldOpts, 'ScaffoldOpts', True, None) and
+        DataDocumenter.can_document_member(FileContents, 'FileContents', True, None) and
+        DataDocumenter.can_document_member(FileOp, 'FileOp', True, None) and
+        inspect.isgenericalias(ScaffoldOpts) and
+        inspect.isgenericalias(FileContents) and
+        inspect.isgenericalias(FileOp) and
+        ScaffoldOpts.__doc__ and
+        FileContents.__doc__ and
+        FileOp.__doc__):
+        print("\n✅ Fix is working! Type aliases are now properly handled by DataDocumenter.")
+        return True
+    else:
+        print("\n❌ Fix is not working properly.")
+        return False
+
+if __name__ == "__main__":
+    success = test_type_alias_documentation()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_reproduction.py b/test_reproduction.py
new file mode 100644
index 000000000..715d79ff6
--- /dev/null
+++ b/test_reproduction.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""Test script to reproduce the type alias documentation issue."""
+
+import tempfile
+import os
+import shutil
+from pathlib import Path
+
+# Create a temporary directory for our test
+test_dir = tempfile.mkdtemp()
+os.chdir(test_dir)
+
+# Create the test file
+test_file_content = '''from pathlib import Path
+from typing import Any, Callable, Dict, Union
+
+# Signatures for the documentation purposes
+
+ScaffoldOpts = Dict[str, Any]
+"""Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.
+Should be treated as immutable (if required, copy before changing).
+
+Please notice some behaviours given by the options **SHOULD** be observed. For example,
+files should be overwritten when the **force** option is ``True``. Similarly when
+**pretend** is ``True``, no operation should be really performed, but any action should
+be logged as if realized.
+"""
+
+FileContents = Union[str, None]
+"""When the file content is ``None``, the file should not be written to
+disk (empty files are represented by an empty string ``""`` as content).
+"""
+
+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+"""Signature of functions considered file operations::
+
+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]
+
+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed
+  in the disk.
+- **contents** (:obj:`FileContents`): usually a string that represents a text content
+  of the file. :obj:`None` indicates the file should not be written.
+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.
+
+If the file is written (or more generally changed, such as new access permissions),
+by convention they should return the :obj:`file path <pathlib.Path>`.
+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**
+might return :obj:`None` if a pre-existing file in the disk is not modified.
+
+.. note::
+    A **FileOp** usually has side effects (e.g. write a file to the disk), see
+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.
+"""
+'''
+
+with open('file.py', 'w') as f:
+    f.write(test_file_content)
+
+# Create sphinx documentation
+os.system('sphinx-quickstart -q -p "Test" -a "Test Author" -v "1.0" .')
+
+# Update conf.py
+conf_py_content = '''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+extensions = ['sphinx.ext.autodoc']
+'''
+with open('conf.py', 'a') as f:
+    f.write(conf_py_content)
+
+# Update index.rst
+index_rst_content = '''
+Test Documentation
+==================
+
+.. toctree::
+   :maxdepth: 2
+   :caption: Contents:
+
+   api/file
+'''
+with open('index.rst', 'w') as f:
+    f.write(index_rst_content)
+
+# Generate API docs
+os.system('sphinx-apidoc -f -o api .')
+
+# Build HTML
+os.system('make html')
+
+# Check the output
+print("Build completed. Check _build/html/api/file.html for the results.")
+
+# Clean up
+os.chdir('/')
+shutil.rmtree(test_dir)
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index a363e187f..3b8bc12d0 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3