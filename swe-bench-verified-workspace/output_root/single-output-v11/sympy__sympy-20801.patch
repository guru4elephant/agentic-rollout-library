diff --git a/debug_eq.py b/debug_eq.py
new file mode 100644
index 0000000000..0fb35d86fe
--- /dev/null
+++ b/debug_eq.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.core.sympify import _sympify
+
+print("Debugging equality comparison:")
+print(f"S(0.0) == S.false: {S(0.0) == S.false}")
+
+# Let's trace what happens step by step
+print("\nStep by step analysis:")
+print(f"1. Type of S(0.0): {type(S(0.0))}")
+print(f"2. Type of S.false: {type(S.false)}")
+
+# Check if Float has __eq__ method
+print(f"3. Has Float.__eq__: {hasattr(S(0.0), '__eq__')}")
+print(f"4. Has BooleanFalse.__eq__: {hasattr(S.false, '__eq__')}")
+
+# Check what happens when we call Float.__eq__ directly
+print(f"5. S(0.0).__eq__(S.false): {S(0.0).__eq__(S.false)}")
+
+# Check what happens when we call BooleanFalse.__eq__ directly
+print(f"6. S.false.__eq__(S(0.0)): {S.false.__eq__(S(0.0))}")
+
+# Check Basic.__eq__ behavior
+print(f"7. Basic.__eq__(S.false, S(0.0)): {Basic.__eq__(S.false, S(0.0))}")
\ No newline at end of file
diff --git a/debug_not_self.py b/debug_not_self.py
new file mode 100644
index 0000000000..9064dbfc00
--- /dev/null
+++ b/debug_not_self.py
@@ -0,0 +1,16 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+print("Debugging 'not self' behavior:")
+print(f"S(0.0): {S(0.0)}")
+print(f"not S(0.0): {not S(0.0)}")
+print(f"bool(S(0.0)): {bool(S(0.0))}")
+
+print(f"\nS.false: {S.false}")
+print(f"not S.false: {not S.false}")
+print(f"bool(S.false)): {bool(S.false)}")
+
+print(f"\nS(1.0): {S(1.0)}")
+print(f"not S(1.0): {not S(1.0)}")
+print(f"bool(S(1.0)): {bool(S(1.0))}")
\ No newline at end of file
diff --git a/debug_sympify.py b/debug_sympify.py
new file mode 100644
index 0000000000..545f3b17fd
--- /dev/null
+++ b/debug_sympify.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.core.sympify import _sympify
+
+print("Debugging sympification:")
+print(f"_sympify(0.0): {_sympify(0.0)}")
+print(f"Type of _sympify(0.0): {type(_sympify(0.0))}")
+
+print("\nHashable content:")
+print(f"S(0.0)._hashable_content(): {S(0.0)._hashable_content()}")
+print(f"S.false._hashable_content(): {S.false._hashable_content()}")
+
+print("\nDirect comparison:")
+print(f"S(0.0)._hashable_content() == S.false._hashable_content(): {S(0.0)._hashable_content() == S.false._hashable_content()}")
+
+print("\nChecking sympify behavior:")
+print(f"sympify(0.0): {sympify(0.0)}")
+print(f"sympify(False): {sympify(False)}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ac131a78cf
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+print("Reproducing the issue:")
+print(f"S(0.0) == S.false: {S(0.0) == S.false}")
+print(f"S.false == S(0.0): {S.false == S(0.0)}")
+
+print("\nExpected behavior (based on S(0) comparison):")
+print(f"S(0) == S.false: {S(0) == S.false}")
+print(f"S.false == S(0): {S.false == S(0)}")
+
+print("\nAdditional info:")
+print(f"Type of S(0.0): {type(S(0.0))}")
+print(f"Type of S.false: {type(S.false)}")
+print(f"Type of S(0): {type(S(0))}")
+print(f"S(0.0) == 0: {S(0.0) == 0}")
+print(f"S(0.0) == 0.0: {S(0.0) == 0.0}")
\ No newline at end of file
diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py
index 79f6a7d165..ef5a157a7b 100644
--- a/sympy/core/numbers.py
+++ b/sympy/core/numbers.py
@@ -1386,8 +1386,6 @@ def __eq__(self, other):
             other = _sympify(other)
         except SympifyError:
             return NotImplemented
-        if not self:
-            return not other
         if isinstance(other, Boolean):
             return False
         if other.is_NumberSymbol:
diff --git a/test_basic_functionality.py b/test_basic_functionality.py
new file mode 100644
index 0000000000..0cfad307b7
--- /dev/null
+++ b/test_basic_functionality.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+print("Testing basic functionality after our fix:")
+
+# Test basic float operations
+print("Basic float operations:")
+print(f"S(1.0) + S(2.0): {S(1.0) + S(2.0)}")
+print(f"S(3.0) - S(1.0): {S(3.0) - S(1.0)}")
+print(f"S(2.0) * S(3.0): {S(2.0) * S(3.0)}")
+print(f"S(6.0) / S(2.0): {S(6.0) / S(2.0)}")
+
+# Test float comparisons
+print("\nFloat comparisons:")
+print(f"S(1.0) == S(1.0): {S(1.0) == S(1.0)}")
+print(f"S(1.0) != S(2.0): {S(1.0) != S(2.0)}")
+print(f"S(0.0) == S(0.0): {S(0.0) == S(0.0)}")
+print(f"S(0.0) == 0: {S(0.0) == 0}")
+print(f"S(0.0) == 0.0: {S(0.0) == 0.0}")
+
+# Test boolean operations
+print("\nBoolean operations:")
+print(f"S.true & S.false: {S.true & S.false}")
+print(f"S.true | S.false: {S.true | S.false}")
+print(f"~S.true: {~S.true}")
+print(f"~S.false: {~S.false}")
+
+# Test the original issue is fixed
+print("\nOriginal issue:")
+print(f"S(0.0) == S.false: {S(0.0) == S.false}")
+print(f"S.false == S(0.0): {S.false == S(0.0)}")
+
+print("\nAll tests passed!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..72acfc787e
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+print("Testing edge cases:")
+
+# Test with other falsy values
+print(f"S(0) == S.false: {S(0) == S.false}")
+print(f"S.false == S(0): {S.false == S(0)}")
+
+print(f"S(0.0) == S.false: {S(0.0) == S.false}")
+print(f"S.false == S(0.0): {S.false == S(0.0)}")
+
+print(f"S(0+0j) == S.false: {S(0+0j) == S.false}")
+print(f"S.false == S(0+0j): {S.false == S(0+0j)}")
+
+# Test with truthy values
+print(f"S(1) == S.true: {S(1) == S.true}")
+print(f"S.true == S(1): {S.true == S(1)}")
+
+print(f"S(1.0) == S.true: {S(1.0) == S.true}")
+print(f"S.true == S(1.0): {S.true == S(1.0)}")
+
+print(f"S(1+0j) == S.true: {S(1+0j) == S.true}")
+print(f"S.true == S(1+0j): {S.true == S(1+0j)}")
+
+# Test with regular Python booleans
+print(f"S(0.0) == False: {S(0.0) == False}")
+print(f"False == S(0.0): {False == S(0.0)}")
+
+print(f"S(1.0) == True: {S(1.0) == True}")
+print(f"True == S(1.0): {True == S(1.0)}")
+
+# Test that normal float comparisons still work
+print(f"S(0.0) == 0: {S(0.0) == 0}")
+print(f"S(0.0) == 0.0: {S(0.0) == 0.0}")
+print(f"S(1.0) == 1: {S(1.0) == 1}")
+print(f"S(1.0) == 1.0: {S(1.0) == 1.0}")
\ No newline at end of file
diff --git a/test_zero_cases.py b/test_zero_cases.py
new file mode 100644
index 0000000000..d13447c147
--- /dev/null
+++ b/test_zero_cases.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+print("Testing zero value edge cases:")
+
+# Test various zero representations
+zeros = [0, 0.0, S(0), S(0.0), S(0+0j)]
+
+for i, zero1 in enumerate(zeros):
+    for j, zero2 in enumerate(zeros):
+        if i <= j:  # Avoid duplicate tests
+            print(f"{zero1} == {zero2}: {zero1 == zero2}")
+
+# Test that zero values don't equal boolean false
+print("\nZero values vs Boolean false:")
+for zero in zeros:
+    print(f"{zero} == S.false: {zero == S.false}")
+    print(f"S.false == {zero}: {S.false == zero}")
+
+# Test that non-zero values don't equal boolean true  
+print("\nNon-zero values vs Boolean true:")
+non_zeros = [1, 1.0, S(1), S(1.0), S(1+0j)]
+for non_zero in non_zeros:
+    print(f"{non_zero} == S.true: {non_zero == S.true}")
+    print(f"S.true == {non_zero}: {S.true == non_zero}")
+
+print("\nAll zero tests passed!")
\ No newline at end of file