diff --git a/better_test.py b/better_test.py
new file mode 100644
index 0000000000..5aa116eb32
--- /dev/null
+++ b/better_test.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+"""
+Better test for non-blocking behavior
+"""
+import tempfile
+import os
+import threading
+from django.core.files import locks
+
+def test_non_blocking_correctly():
+    """Test non-blocking locks work correctly across different file descriptors"""
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # First process acquires exclusive lock
+        with open(temp_file_path, 'r+') as f1:
+            result1 = locks.lock(f1, locks.LOCK_EX)
+            print(f"First process lock: {result1} (should be True)")
+            
+            # Second process tries non-blocking lock (should fail)
+            with open(temp_file_path, 'r+') as f2:
+                result2 = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)
+                print(f"Second process non-blocking lock: {result2} (should be False)")
+                
+            locks.unlock(f1)
+            
+    finally:
+        os.unlink(temp_file_path)
+
+def test_non_blocking_same_fd():
+    """Test non-blocking behavior on same file descriptor"""
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        with open(temp_file_path, 'r+') as f:
+            # First lock should succeed
+            result1 = locks.lock(f, locks.LOCK_SH)
+            print(f"First lock: {result1} (should be True)")
+            
+            # Second non-blocking lock attempt on same fd
+            # This might behave differently than expected
+            result2 = locks.lock(f, locks.LOCK_SH | locks.LOCK_NB)
+            print(f"Second non-blocking lock on same fd: {result2}")
+            
+            locks.unlock(f)
+            
+    finally:
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    print("Testing non-blocking across different file descriptors:")
+    test_non_blocking_correctly()
+    print("\nTesting non-blocking on same file descriptor:")
+    test_non_blocking_same_fd()
\ No newline at end of file
diff --git a/django/core/files/locks.py b/django/core/files/locks.py
index c46b00b905..4938347ea7 100644
--- a/django/core/files/locks.py
+++ b/django/core/files/locks.py
@@ -107,9 +107,15 @@ else:
             return True
     else:
         def lock(f, flags):
-            ret = fcntl.flock(_fd(f), flags)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), flags)
+                return True
+            except OSError:
+                return False
 
         def unlock(f):
-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), fcntl.LOCK_UN)
+                return True
+            except OSError:
+                return False
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..7e6c7c6677
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the bug in django/core/files/locks.py posix implementation
+"""
+import tempfile
+import os
+from django.core.files import locks
+
+def test_lock_behavior():
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Try to acquire a lock (should return True)
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_SH)
+            print(f"Lock acquired (SH): {result}")
+            
+            # Test 2: Try to acquire non-blocking exclusive lock (should return False if already locked)
+            result_nb = locks.lock(f, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock attempt (EX|NB): {result_nb}")
+            
+            # Unlock
+            unlock_result = locks.unlock(f)
+            print(f"Unlock result: {unlock_result}")
+            
+        # Test 3: Try to acquire exclusive lock on unlocked file (should return True)
+        with open(temp_file_path, 'r+') as f:
+            result_ex = locks.lock(f, locks.LOCK_EX)
+            print(f"Exclusive lock acquired: {result_ex}")
+            
+            unlock_result = locks.unlock(f)
+            print(f"Unlock result: {unlock_result}")
+            
+    finally:
+        # Clean up
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_lock_behavior()
\ No newline at end of file
diff --git a/test_cache_locks.py b/test_cache_locks.py
new file mode 100644
index 0000000000..d65e46668e
--- /dev/null
+++ b/test_cache_locks.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+"""
+Test that the file-based cache works correctly with our locks fix
+"""
+import tempfile
+import os
+from django.core.cache.backends.filebased import FileBasedCache
+
+def test_cache_locks():
+    """Test that file-based cache locking works correctly"""
+    # Create a temporary directory for cache
+    cache_dir = tempfile.mkdtemp()
+    
+    try:
+        # Create file-based cache instance
+        cache = FileBasedCache(cache_dir, {})
+        
+        # Test basic cache operations that use locks
+        key = "test_key"
+        value = "test_value"
+        
+        # Set a value (uses locks internally)
+        result_set = cache.set(key, value)
+        print(f"Cache set result: {result_set} (should be True)")
+        
+        # Get the value
+        result_get = cache.get(key)
+        print(f"Cache get result: {result_get} (should be 'test_value')")
+        
+        # Touch the key (uses locks internally)
+        result_touch = cache.touch(key, 300)
+        print(f"Cache touch result: {result_touch} (should be True)")
+        
+        # Delete the key
+        result_delete = cache.delete(key)
+        print(f"Cache delete result: {result_delete} (should be True)")
+        
+    finally:
+        # Clean up
+        import shutil
+        shutil.rmtree(cache_dir)
+
+if __name__ == "__main__":
+    test_cache_locks()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d3d74e7958
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the fixed locks implementation
+"""
+import tempfile
+import os
+import threading
+import time
+from django.core.files import locks
+
+def test_non_blocking_behavior():
+    """Test that non-blocking locks work correctly"""
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Non-blocking lock on unlocked file should succeed
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock on unlocked file: {result} (should be True)")
+            
+            # Test 2: Non-blocking lock on already locked file should fail
+            result2 = locks.lock(f, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock on locked file: {result2} (should be False)")
+            
+            locks.unlock(f)
+            
+    finally:
+        os.unlink(temp_file_path)
+
+def test_concurrent_access():
+    """Test concurrent access with non-blocking locks"""
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        lock_acquired = [False]
+        
+        def try_lock():
+            with open(temp_file_path, 'r+') as f:
+                lock_acquired[0] = locks.lock(f, locks.LOCK_EX | locks.LOCK_NB)
+        
+        # First thread acquires the lock
+        with open(temp_file_path, 'r+') as f:
+            result1 = locks.lock(f, locks.LOCK_EX)
+            print(f"First thread lock: {result1} (should be True)")
+            
+            # Second thread tries non-blocking lock (should fail)
+            t = threading.Thread(target=try_lock)
+            t.start()
+            t.join()
+            
+            print(f"Second thread non-blocking lock: {lock_acquired[0]} (should be False)")
+            
+            locks.unlock(f)
+            
+    finally:
+        os.unlink(temp_file_path)
+
+def test_unlock_behavior():
+    """Test that unlock always returns True (unless there's an actual error)"""
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test unlock on locked file
+        with open(temp_file_path, 'r+') as f:
+            locks.lock(f, locks.LOCK_EX)
+            result = locks.unlock(f)
+            print(f"Unlock on locked file: {result} (should be True)")
+            
+        # Test unlock on already unlocked file
+        with open(temp_file_path, 'r+') as f:
+            result = locks.unlock(f)
+            print(f"Unlock on unlocked file: {result} (should be True)")
+            
+    finally:
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    print("Testing non-blocking behavior:")
+    test_non_blocking_behavior()
+    print("\nTesting concurrent access:")
+    test_concurrent_access()
+    print("\nTesting unlock behavior:")
+    test_unlock_behavior()
\ No newline at end of file
diff --git a/test_file_move.py b/test_file_move.py
new file mode 100644
index 0000000000..8aa67ca5f4
--- /dev/null
+++ b/test_file_move.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""
+Test that file moving with locks works correctly
+"""
+import tempfile
+import os
+from django.core.files.move import file_move_safe
+
+def test_file_move_with_locks():
+    """Test that file_move_safe works correctly with our locks fix"""
+    # Create source and destination files
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as src:
+        src.write("test content")
+        src_path = src.name
+    
+    dest_path = src_path + ".moved"
+    
+    try:
+        # Move the file (uses locks internally)
+        result = file_move_safe(src_path, dest_path)
+        print(f"File move result: {result} (should be None)")
+        
+        # Verify the file was moved
+        if os.path.exists(dest_path) and not os.path.exists(src_path):
+            print("File was successfully moved")
+        else:
+            print("File move failed")
+            
+    finally:
+        # Clean up
+        for path in [src_path, dest_path]:
+            if os.path.exists(path):
+                os.remove(path)
+
+if __name__ == "__main__":
+    test_file_move_with_locks()
\ No newline at end of file