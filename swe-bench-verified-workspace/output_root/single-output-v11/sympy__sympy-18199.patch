diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..fb900571c0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+from sympy.ntheory.residue_ntheory import nthroot_mod
+
+# Test case from the issue: nthroot_mod(17*17, 5, 17) should include 0 mod 17
+# Since 17*17 = 289 ≡ 0 mod 17, and 0**5 = 0 ≡ 0 mod 17, so 0 should be a root
+
+print("Testing nthroot_mod(289, 5, 17)...")
+result = nthroot_mod(289, 5, 17, all_roots=True)
+print(f"Result: {result}")
+
+# Expected result should include 0
+print("Expected result should include 0 since 0^5 ≡ 0 mod 17")
+
+# Let's also test with a simple case: x^2 = 0 mod 5
+print("\nTesting nthroot_mod(0, 2, 5)...")
+result2 = nthroot_mod(0, 2, 5, all_roots=True)
+print(f"Result: {result2}")
+print("Expected result should include 0 since 0^2 ≡ 0 mod 5")
\ No newline at end of file
diff --git a/reproduce_issue2.py b/reproduce_issue2.py
new file mode 100644
index 0000000000..2929ea7d1d
--- /dev/null
+++ b/reproduce_issue2.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy.ntheory.residue_ntheory import nthroot_mod
+
+# Test case from the issue: nthroot_mod(17*17, 5, 17) should include 0 mod 17
+# Since 17*17 = 289 ≡ 0 mod 17, and 0**5 = 0 ≡ 0 mod 17, so 0 should be a root
+
+print("Testing nthroot_mod(289, 5, 17)...")
+result = nthroot_mod(289, 5, 17, all_roots=True)
+print(f"Result: {result}")
+
+# Expected result should include 0
+print("Expected result should include 0 since 0^5 ≡ 0 mod 17")
+
+# Let's also test with a simple case: x^2 = 0 mod 5
+print("\nTesting nthroot_mod(0, 2, 5)...")
+result2 = nthroot_mod(0, 2, 5, all_roots=True)
+print(f"Result: {result2}")
+print("Expected result should include 0 since 0^2 ≡ 0 mod 5")
+
+# Test the exact example from the issue description
+print("\nTesting exact issue example: nthroot_mod(17*17, 5, 17)...")
+result3 = nthroot_mod(17*17, 5, 17, all_roots=True)
+print(f"Result: {result3}")
+
+# Let's test with non-zero case to see the difference
+print("\nTesting non-zero case: nthroot_mod(1, 5, 17)...")
+result4 = nthroot_mod(1, 5, 17, all_roots=True)
+print(f"Result: {result4}")
\ No newline at end of file
diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py
index 9a3052d4c3..a06878b338 100644
--- a/sympy/ntheory/residue_ntheory.py
+++ b/sympy/ntheory/residue_ntheory.py
@@ -776,6 +776,13 @@ def nthroot_mod(a, n, p, all_roots=False):
     if not isprime(p):
         raise NotImplementedError("Not implemented for composite p")
 
+    # Special case: when a ≡ 0 mod p, x = 0 is always a root
+    if a % p == 0:
+        if all_roots:
+            return [0]
+        else:
+            return 0
+
     if (p - 1) % n == 0:
         return _nthroot_mod1(a, n, p, all_roots)
     # The roots of ``x**n - a = 0 (mod p)`` are roots of
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..2b8346d2a5
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+
+from sympy.ntheory.residue_ntheory import nthroot_mod
+
+def test_edge_cases():
+    """Test edge cases for the nthroot_mod fix"""
+    
+    print("Testing edge cases for nthroot_mod")
+    print("=" * 50)
+    
+    # Test cases with different scenarios
+    test_cases = [
+        # Basic zero cases
+        (0, 2, 5, "x^2 ≡ 0 mod 5"),
+        (0, 3, 7, "x^3 ≡ 0 mod 7"),
+        (0, 5, 11, "x^5 ≡ 0 mod 11"),
+        
+        # Cases where a ≡ 0 mod p but a != 0
+        (7, 2, 7, "x^2 ≡ 7 ≡ 0 mod 7"),
+        (14, 3, 7, "x^3 ≡ 14 ≡ 0 mod 7"),
+        (22, 4, 11, "x^4 ≡ 22 ≡ 0 mod 11"),
+        (289, 5, 17, "x^5 ≡ 289 ≡ 0 mod 17"),
+        
+        # Cases where p-1 is divisible by n (goes through _nthroot_mod1)
+        (0, 3, 13, "x^3 ≡ 0 mod 13 (p-1 divisible by n)"),
+        (13, 3, 13, "x^3 ≡ 13 ≡ 0 mod 13"),
+        
+        # Cases where p-1 is not divisible by n (goes through general algorithm)
+        (0, 3, 11, "x^3 ≡ 0 mod 11 (p-1 not divisible by n)"),
+        (11, 3, 11, "x^3 ≡ 11 ≡ 0 mod 11"),
+        
+        # Non-zero cases to ensure we didn't break anything
+        (1, 3, 7, "x^3 ≡ 1 mod 7 (non-zero)"),
+        (2, 3, 11, "x^3 ≡ 2 mod 11 (non-zero)"),
+    ]
+    
+    for a, n, p, description in test_cases:
+        print(f"\n{description}")
+        print(f"a={a}, n={n}, p={p}")
+        print(f"a % p = {a} % {p} = {a % p}")
+        
+        try:
+            # Test with all_roots=False
+            result_single = nthroot_mod(a, n, p, all_roots=False)
+            print(f"Single root result: {result_single}")
+            
+            # Test with all_roots=True
+            result_all = nthroot_mod(a, n, p, all_roots=True)
+            print(f"All roots result: {result_all}")
+            
+            # Verify the results
+            if a % p == 0:
+                # For zero cases, 0 should be included
+                if result_all is not None and 0 in result_all:
+                    print("✓ 0 is correctly included in the roots")
+                else:
+                    print("✗ 0 is missing from the roots!")
+                    
+                # Single result should be 0
+                if result_single == 0:
+                    print("✓ Single root is correctly 0")
+                else:
+                    print("✗ Single root should be 0")
+            
+            # Verify the root is correct
+            if result_single is not None:
+                verification = pow(result_single, n, p)
+                print(f"Verification: {result_single}^{n} mod {p} = {verification}")
+                if verification == a % p:
+                    print("✓ Root verification passed")
+                else:
+                    print("✗ Root verification failed")
+                    
+        except Exception as e:
+            print(f"Error: {e}")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_multiple_roots.py b/test_multiple_roots.py
new file mode 100644
index 0000000000..62598b2bca
--- /dev/null
+++ b/test_multiple_roots.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+
+from sympy.ntheory.residue_ntheory import nthroot_mod
+
+def test_multiple_roots_with_zero():
+    """Test cases where there might be multiple roots including 0"""
+    
+    print("Testing cases with multiple roots including 0")
+    print("=" * 50)
+    
+    # Test cases where there are multiple roots, one of which is 0
+    test_cases = [
+        # x^2 ≡ 0 mod 4 (but p=4 is not prime, so should raise error)
+        (0, 2, 4, "x^2 ≡ 0 mod 4 (composite p)"),
+        
+        # x^2 ≡ 0 mod 3 (only one root: 0)
+        (0, 2, 3, "x^2 ≡ 0 mod 3"),
+        
+        # x^2 ≡ 0 mod 7 (only one root: 0)
+        (0, 2, 7, "x^2 ≡ 0 mod 7"),
+        
+        # Cases where there might be multiple non-zero roots + 0
+        # But note: for prime p, x^n ≡ 0 mod p only has x=0 as a solution
+        # since p is prime and 0^n ≡ 0 mod p
+    ]
+    
+    for a, n, p, description in test_cases:
+        print(f"\n{description}")
+        print(f"a={a}, n={n}, p={p}")
+        print(f"a % p = {a} % {p} = {a % p}")
+        
+        try:
+            # Test with all_roots=False
+            result_single = nthroot_mod(a, n, p, all_roots=False)
+            print(f"Single root result: {result_single}")
+            
+            # Test with all_roots=True
+            result_all = nthroot_mod(a, n, p, all_roots=True)
+            print(f"All roots result: {result_all}")
+            
+            # Verify the results
+            if a % p == 0:
+                # For zero cases, 0 should be included
+                if result_all is not None and 0 in result_all:
+                    print("✓ 0 is correctly included in the roots")
+                else:
+                    print("✗ 0 is missing from the roots!")
+            
+            # Verify the root is correct
+            if result_single is not None:
+                verification = pow(result_single, n, p)
+                print(f"Verification: {result_single}^{n} mod {p} = {verification}")
+                if verification == a % p:
+                    print("✓ Root verification passed")
+                else:
+                    print("✗ Root verification failed")
+                    
+        except Exception as e:
+            print(f"Error (expected for composite p): {e}")
+
+if __name__ == "__main__":
+    test_multiple_roots_with_zero()
\ No newline at end of file
diff --git a/test_zero_case.py b/test_zero_case.py
new file mode 100644
index 0000000000..a078e5f751
--- /dev/null
+++ b/test_zero_case.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+
+from sympy.ntheory.residue_ntheory import nthroot_mod
+
+def test_zero_mod_cases():
+    """Test cases where a ≡ 0 mod p"""
+    
+    print("Testing cases where a ≡ 0 mod p (a % p == 0)")
+    print("=" * 50)
+    
+    # Test cases with different primes and exponents
+    test_cases = [
+        (0, 2, 5),      # x^2 ≡ 0 mod 5
+        (0, 3, 7),      # x^3 ≡ 0 mod 7
+        (0, 5, 11),     # x^5 ≡ 0 mod 11
+        (7, 2, 7),      # x^2 ≡ 7 ≡ 0 mod 7
+        (14, 3, 7),     # x^3 ≡ 14 ≡ 0 mod 7
+        (22, 4, 11),    # x^4 ≡ 22 ≡ 0 mod 11
+        (17*17, 5, 17), # The exact issue case: x^5 ≡ 289 ≡ 0 mod 17
+    ]
+    
+    for a, n, p in test_cases:
+        print(f"\nTesting nthroot_mod({a}, {n}, {p}):")
+        print(f"a % p = {a} % {p} = {a % p}")
+        
+        # Test with all_roots=False
+        result_single = nthroot_mod(a, n, p, all_roots=False)
+        print(f"Single root result: {result_single}")
+        
+        # Test with all_roots=True
+        result_all = nthroot_mod(a, n, p, all_roots=True)
+        print(f"All roots result: {result_all}")
+        
+        # Verify that 0 is a valid root
+        if 0 in result_all if result_all is not None else False:
+            print("✓ 0 is correctly included in the roots")
+        else:
+            print("✗ 0 is missing from the roots!")
+            
+        # Verify the root is correct
+        if result_single is not None:
+            verification = pow(result_single, n, p)
+            print(f"Verification: {result_single}^{n} mod {p} = {verification}")
+            if verification == a % p:
+                print("✓ Root verification passed")
+            else:
+                print("✗ Root verification failed")
+
+if __name__ == "__main__":
+    test_zero_mod_cases()
\ No newline at end of file