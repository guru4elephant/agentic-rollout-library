diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..8b821eaf7f
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+
+from django.db.migrations.operations.models import AlterUniqueTogether, AlterIndexTogether
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_comprehensive_cases():
+    """Test comprehensive optimization cases for AlterFooTogether operations"""
+    
+    optimizer = MigrationOptimizer()
+    
+    print("=== Test 1: Basic optimization (from issue) ===")
+    operations1 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterIndexTogether(name='mymodel', index_together=set()),
+        AlterUniqueTogether(name='mymodel', unique_together={("col",)}),
+        AlterIndexTogether(name='mymodel', index_together={("col",)}),
+    ]
+    
+    optimized1 = optimizer.optimize(operations1, app_label="testapp")
+    print(f"Original: {len(operations1)} → Optimized: {len(optimized1)}")
+    assert len(optimized1) == 2, f"Expected 2 operations, got {len(optimized1)}"
+    assert optimized1[0].unique_together == {("col",)}, "First operation should have final unique_together"
+    assert optimized1[1].index_together == {("col",)}, "Second operation should have final index_together"
+    print("✓ PASS")
+    
+    print("\n=== Test 2: Only unique together operations ===")
+    operations2 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterUniqueTogether(name='mymodel', unique_together={("col",)}),
+    ]
+    
+    optimized2 = optimizer.optimize(operations2, app_label="testapp")
+    print(f"Original: {len(operations2)} → Optimized: {len(optimized2)}")
+    assert len(optimized2) == 1, f"Expected 1 operation, got {len(optimized2)}"
+    assert optimized2[0].unique_together == {("col",)}, "Operation should have final unique_together"
+    print("✓ PASS")
+    
+    print("\n=== Test 3: Only index together operations ===")
+    operations3 = [
+        AlterIndexTogether(name='mymodel', index_together=set()),
+        AlterIndexTogether(name='mymodel', index_together={("col",)}),
+    ]
+    
+    optimized3 = optimizer.optimize(operations3, app_label="testapp")
+    print(f"Original: {len(operations3)} → Optimized: {len(optimized3)}")
+    assert len(optimized3) == 1, f"Expected 1 operation, got {len(optimized3)}"
+    assert optimized3[0].index_together == {("col",)}, "Operation should have final index_together"
+    print("✓ PASS")
+    
+    print("\n=== Test 4: Mixed operations on different models ===")
+    operations4 = [
+        AlterUniqueTogether(name='model1', unique_together=set()),
+        AlterIndexTogether(name='model2', index_together=set()),
+        AlterUniqueTogether(name='model1', unique_together={("col",)}),
+        AlterIndexTogether(name='model2', index_together={("col",)}),
+    ]
+    
+    optimized4 = optimizer.optimize(operations4, app_label="testapp")
+    print(f"Original: {len(operations4)} → Optimized: {len(optimized4)}")
+    assert len(optimized4) == 2, f"Expected 2 operations, got {len(optimized4)}"
+    assert optimized4[0].unique_together == {("col",)}, "First operation should have final unique_together"
+    assert optimized4[1].index_together == {("col",)}, "Second operation should have final index_together"
+    print("✓ PASS")
+    
+    print("\n=== Test 5: Complex mixed operations ===")
+    operations5 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterIndexTogether(name='mymodel', index_together=set()),
+        AlterUniqueTogether(name='mymodel', unique_together={("col1",)}),
+        AlterIndexTogether(name='mymodel', index_together={("col1",)}),
+        AlterUniqueTogether(name='mymodel', unique_together={("col2",)}),
+        AlterIndexTogether(name='mymodel', index_together={("col2",)}),
+    ]
+    
+    optimized5 = optimizer.optimize(operations5, app_label="testapp")
+    print(f"Original: {len(operations5)} → Optimized: {len(optimized5)}")
+    assert len(optimized5) == 2, f"Expected 2 operations, got {len(optimized5)}"
+    assert optimized5[0].unique_together == {("col2",)}, "First operation should have final unique_together"
+    assert optimized5[1].index_together == {("col2",)}, "Second operation should have final index_together"
+    print("✓ PASS")
+    
+    print("\n=== Test 6: No optimization needed ===")
+    operations6 = [
+        AlterUniqueTogether(name='mymodel', unique_together={("col1",)}),
+        AlterIndexTogether(name='mymodel', index_together={("col1",)}),
+    ]
+    
+    optimized6 = optimizer.optimize(operations6, app_label="testapp")
+    print(f"Original: {len(operations6)} → Optimized: {len(optimized6)}")
+    assert len(optimized6) == 2, f"Expected 2 operations, got {len(optimized6)}"
+    assert optimized6[0].unique_together == {("col1",)}, "First operation should have original unique_together"
+    assert optimized6[1].index_together == {("col1",)}, "Second operation should have original index_together"
+    print("✓ PASS")
+    
+    print("\n=== All tests passed! ===")
+
+if __name__ == "__main__":
+    test_comprehensive_cases()
\ No newline at end of file
diff --git a/debug_empty_ops.py b/debug_empty_ops.py
new file mode 100644
index 0000000000..0a5fa89857
--- /dev/null
+++ b/debug_empty_ops.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+from django.db.migrations.operations.models import AlterUniqueTogether, AlterIndexTogether
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def debug_empty_operations():
+    """Debug what happens with empty operations"""
+    
+    optimizer = MigrationOptimizer()
+    
+    print("=== Debug empty operations ===")
+    operations = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterIndexTogether(name='mymodel', index_together=set()),
+    ]
+    
+    print("Original operations:")
+    for i, op in enumerate(operations):
+        print(f"  {i}: {op}")
+    
+    optimized = optimizer.optimize(operations, app_label="testapp")
+    
+    print(f"\nOptimized operations ({len(optimized)}):")
+    for i, op in enumerate(optimized):
+        print(f"  {i}: {op}")
+    
+    # Check if empty operations are considered elidable
+    print(f"\nFirst operation elidable: {operations[0].elidable}")
+    print(f"Second operation elidable: {operations[1].elidable}")
+
+if __name__ == "__main__":
+    debug_empty_operations()
\ No newline at end of file
diff --git a/detailed_test.py b/detailed_test.py
new file mode 100644
index 0000000000..fe7785f07f
--- /dev/null
+++ b/detailed_test.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+
+from django.db.migrations.operations.models import AlterUniqueTogether, AlterIndexTogether
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_specific_cases():
+    """Test specific optimization cases for AlterFooTogether operations"""
+    
+    print("=== Test 1: Same operation type optimization ===")
+    # This should work - two AlterUniqueTogether on same model
+    operations1 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterUniqueTogether(name='mymodel', unique_together={("col",)}),
+    ]
+    
+    optimizer = MigrationOptimizer()
+    optimized1 = optimizer.optimize(operations1, app_label="testapp")
+    
+    print(f"Original: {len(operations1)} operations")
+    print(f"Optimized: {len(optimized1)} operations")
+    for i, op in enumerate(optimized1):
+        print(f"  {i}: {op}")
+    
+    print("\n=== Test 2: Different operation types (current issue) ===")
+    # This should be optimized but currently isn't
+    operations2 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterIndexTogether(name='mymodel', index_together=set()),
+        AlterUniqueTogether(name='mymodel', unique_together={("col",)}),
+        AlterIndexTogether(name='mymodel', index_together={("col",)}),
+    ]
+    
+    optimized2 = optimizer.optimize(operations2, app_label="testapp")
+    
+    print(f"Original: {len(operations2)} operations")
+    print(f"Optimized: {len(optimized2)} operations")
+    for i, op in enumerate(optimized2):
+        print(f"  {i}: {op}")
+    
+    print("\n=== Test 3: Mixed operations on different models ===")
+    # This should not be optimized
+    operations3 = [
+        AlterUniqueTogether(name='model1', unique_together=set()),
+        AlterIndexTogether(name='model2', index_together=set()),
+        AlterUniqueTogether(name='model1', unique_together={("col",)}),
+        AlterIndexTogether(name='model2', index_together={("col",)}),
+    ]
+    
+    optimized3 = optimizer.optimize(operations3, app_label="testapp")
+    
+    print(f"Original: {len(operations3)} operations")
+    print(f"Optimized: {len(optimized3)} operations")
+    for i, op in enumerate(optimized3):
+        print(f"  {i}: {op}")
+
+if __name__ == "__main__":
+    test_specific_cases()
\ No newline at end of file
diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index c120f5d32d..d640f9cdbf 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -411,6 +411,12 @@ class ModelOptionOperation(ModelOperation):
     def reduce(self, operation, app_label):
         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:
             return [operation]
+        # Handle optimization of multiple AlterTogetherOptionOperation on same model
+        # Check if operation is AlterUniqueTogether or AlterIndexTogether
+        if (hasattr(operation, 'option_name') and 
+            hasattr(self, 'option_name') and 
+            self.name_lower == operation.name_lower):
+            return True
         return super().reduce(operation, app_label)
 
 
diff --git a/edge_case_test.py b/edge_case_test.py
new file mode 100644
index 0000000000..f3b33bf67e
--- /dev/null
+++ b/edge_case_test.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+
+from django.db.migrations.operations.models import AlterUniqueTogether, AlterIndexTogether, AlterModelTable
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_edge_cases():
+    """Test edge cases to ensure the fix doesn't break anything"""
+    
+    optimizer = MigrationOptimizer()
+    
+    print("=== Test 1: Different operation types (should not optimize) ===")
+    operations1 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterModelTable(name='mymodel', table='new_table'),  # Different operation type
+        AlterUniqueTogether(name='mymodel',unique_together={("col",)}),
+    ]
+    
+    optimized1 = optimizer.optimize(operations1, app_label="testapp")
+    print(f"Original: {len(operations1)} → Optimized: {len(optimized1)}")
+    # Should not optimize through different operation types
+    assert len(optimized1) == 3, f"Expected 3 operations, got {len(optimized1)}"
+    print("✓ PASS")
+    
+    print("\n=== Test 2: Operations without option_name (should not optimize) ===")
+    operations2 = [
+        AlterModelTable(name='mymodel', table='table1'),
+        AlterModelTable(name='mymodel', table='table2'),  # ModelOptionOperation but no option_name
+    ]
+    
+    optimized2 = optimizer.optimize(operations2, app_label="testapp")
+    print(f"Original: {len(operations2)} → Optimized: {len(optimized2)}")
+    # Should not optimize ModelOptionOperation without option_name
+    assert len(optimized2) == 1, f"Expected 1 operation, got {len(optimized2)}"
+    assert optimized2[0].table == 'table2', "Should keep the final table value"
+    print("✓ PASS")
+    
+    print("\n=== Test 3: Empty operations (should not optimize away) ===")
+    operations3 = [
+        AlterUniqueTogether(name='mymodel', unique_together=set()),
+        AlterIndexTogether(name='mymodel', index_together=set()),
+    ]
+    
+    optimized3 = optimizer.optimize(operations3, app_label="testapp")
+    print(f"Original: {len(operations3)} → Optimized: {len(optimized3)}")
+    # Should not optimize away empty operations as they are still valid
+    assert len(optimized3) == 2, f"Expected 2 operations, got {len(optimized3)}"
+    print("✓ PASS")
+    
+    print("\n=== All edge case tests passed! ===")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..def1f6b72a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+from django.db.migrations.operations.models import AlterUniqueTogether, AlterIndexTogether
+from django.db.migrations.optimizer import MigrationOptimizer
+
+def test_optimization():
+    """Test the current optimization behavior for AlterFooTogether operations"""
+    
+    # Create the operations as described in the issue
+    operations = [
+        AlterUniqueTogether(
+            name='mymodel',
+            unique_together=set(),
+        ),
+        AlterIndexTogether(
+            name='mymodel',
+            index_together=set(),
+        ),
+        AlterUniqueTogether(
+            name='mymodel',
+            unique_together={("col",)},
+        ),
+        AlterIndexTogether(
+            name='mymodel',
+            index_together={("col",)},
+        ),
+    ]
+    
+    print("Original operations:")
+    for i, op in enumerate(operations):
+        print(f"  {i}: {op}")
+    
+    # Optimize the operations
+    optimizer = MigrationOptimizer()
+    optimized_operations = optimizer.optimize(operations, app_label="testapp")
+    
+    print("\nOptimized operations:")
+    for i, op in enumerate(optimized_operations):
+        print(f"  {i}: {op}")
+    
+    print(f"\nOriginal count: {len(operations)}")
+    print(f"Optimized count: {len(optimized_operations)}")
+    
+    # Expected result should be 2 operations instead of 4
+    if len(optimized_operations) == 2:
+        print("✓ Optimization successful!")
+    else:
+        print("✗ Optimization failed - should be reduced to 2 operations")
+
+if __name__ == "__main__":
+    test_optimization()
\ No newline at end of file