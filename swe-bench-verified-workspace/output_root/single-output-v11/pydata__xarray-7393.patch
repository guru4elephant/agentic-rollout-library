diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..39cc5864
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,8 @@
+import xarray as xr
+import numpy as np
+
+# Create the minimal example from the issue
+ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+print("Original dtype:", ds['a'].values.dtype)
+print("Stacked dtype:", ds.stack(b=('a',))['a'].values.dtype)
+print("Comparison result:", ds['a'].values.dtype == ds.stack(b=('a',))['a'].values.dtype)
\ No newline at end of file
diff --git a/test_adapter_dtype.py b/test_adapter_dtype.py
new file mode 100644
index 00000000..2a3ac460
--- /dev/null
+++ b/test_adapter_dtype.py
@@ -0,0 +1,30 @@
+import numpy as np
+import pandas as pd
+from xarray.core.indexing import PandasMultiIndexingAdapter
+
+# Test what happens with PandasMultiIndexingAdapter
+arr = np.array([0], dtype='i4')
+print("Original array dtype:", arr.dtype)
+
+# Create a MultiIndex
+level_indexes = [pd.Index([0])]
+split_labels, levels = zip(*[lev.factorize() for lev in level_indexes])
+labels_mesh = np.meshgrid(*split_labels, indexing="ij")
+labels = [x.ravel() for x in labels_mesh]
+multi_index = pd.MultiIndex(levels, labels, sortorder=0, names=['a'])
+
+print("MultiIndex level dtype:", multi_index.levels[0].dtype)
+
+# Test with PandasMultiIndexingAdapter without explicit dtype
+adapter1 = PandasMultiIndexingAdapter(multi_index, level='a')
+print("Adapter without explicit dtype:", adapter1.dtype)
+
+# Test with PandasMultiIndexingAdapter with explicit dtype (int32)
+adapter2 = PandasMultiIndexingAdapter(multi_index, dtype=np.dtype('i4'), level='a')
+print("Adapter with explicit int32 dtype:", adapter2.dtype)
+
+# Test what the array looks like
+print("Adapter1 array:", adapter1.__array__())
+print("Adapter1 array dtype:", adapter1.__array__().dtype)
+print("Adapter2 array:", adapter2.__array__())
+print("Adapter2 array dtype:", adapter2.__array__().dtype)
\ No newline at end of file
diff --git a/test_dtype_issue.py b/test_dtype_issue.py
new file mode 100644
index 00000000..fbb4e7f8
--- /dev/null
+++ b/test_dtype_issue.py
@@ -0,0 +1,28 @@
+import numpy as np
+import pandas as pd
+from xarray.core.utils import get_valid_numpy_dtype
+
+# Test what happens with get_valid_numpy_dtype
+arr = np.array([0], dtype='i4')
+print("Original array dtype:", arr.dtype)
+
+# Test with numpy array
+result = get_valid_numpy_dtype(arr)
+print("get_valid_numpy_dtype result:", result)
+
+# Test with pandas index
+index = pd.Index(arr)
+print("Pandas index dtype:", index.dtype)
+result2 = get_valid_numpy_dtype(index)
+print("get_valid_numpy_dtype result for index:", result2)
+
+# Test with MultiIndex
+level_indexes = [pd.Index([0])]
+split_labels, levels = zip(*[lev.factorize() for lev in level_indexes])
+labels_mesh = np.meshgrid(*split_labels, indexing="ij")
+labels = [x.ravel() for x in labels_mesh]
+multi_index = pd.MultiIndex(levels, labels, sortorder=0, names=['a'])
+
+print("MultiIndex level dtype:", multi_index.levels[0].dtype)
+result3 = get_valid_numpy_dtype(multi_index.levels[0])
+print("get_valid_numpy_dtype result for multi-index level:", result3)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..9a0aec74
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,40 @@
+import xarray as xr
+import numpy as np
+
+# Test 1: Original issue - int32 dtype
+print("Test 1: int32 dtype preservation")
+ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+result = ds['a'].values.dtype == ds.stack(b=('a',))['a'].values.dtype
+print(f"int32 preserved: {result}")
+
+# Test 2: int64 dtype (should still work)
+print("\nTest 2: int64 dtype preservation")
+ds2 = xr.Dataset(coords={'a': np.array([0], dtype='i8')})
+result2 = ds2['a'].values.dtype == ds2.stack(b=('a',))['a'].values.dtype
+print(f"int64 preserved: {result2}")
+
+# Test 3: float32 dtype
+print("\nTest 3: float32 dtype preservation")
+ds3 = xr.Dataset(coords={'a': np.array([0.0], dtype='f4')})
+result3 = ds3['a'].values.dtype == ds3.stack(b=('a',))['a'].values.dtype
+print(f"float32 preserved: {result3}")
+
+# Test 4: Multiple coordinates
+print("\nTest 4: Multiple coordinates")
+ds4 = xr.Dataset(coords={
+    'a': np.array([0], dtype='i4'),
+    'b': np.array([1, 2], dtype='i4')
+})
+stacked = ds4.stack(c=('a', 'b'))
+result4a = ds4['a'].values.dtype == stacked['a'].values.dtype
+result4b = ds4['b'].values.dtype == stacked['b'].values.dtype
+print(f"Multiple coords - a preserved: {result4a}")
+print(f"Multiple coords - b preserved: {result4b}")
+
+# Test 5: Unstack operation
+print("\nTest 5: Stack/unstack roundtrip")
+ds5 = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+stacked = ds5.stack(b=('a',))
+unstacked = stacked.unstack('b')
+result5 = ds5['a'].values.dtype == unstacked['a'].values.dtype
+print(f"Stack/unstack roundtrip: {result5}")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 00000000..d54ae97b
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,18 @@
+"""
+Test for the exact GitHub issue reported:
+stack casts int32 dtype coordinate to int64
+"""
+import xarray as xr
+import numpy as np
+
+# Exact test case from the GitHub issue
+ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})
+result = ds['a'].values.dtype == ds.stack(b=('a',))['a'].values.dtype
+
+print(f"Original dtype: {ds['a'].values.dtype}")
+print(f"Stacked dtype: {ds.stack(b=('a',))['a'].values.dtype}")
+print(f"Comparison result: {result}")
+
+# The issue should be fixed - result should be True
+assert result == True, "The GitHub issue is not fixed - dtype is not preserved"
+print("âœ“ GitHub issue is fixed - dtype is preserved during stack operation")
\ No newline at end of file
diff --git a/test_none_dtype.py b/test_none_dtype.py
new file mode 100644
index 00000000..0a67f454
--- /dev/null
+++ b/test_none_dtype.py
@@ -0,0 +1,22 @@
+import numpy as np
+import pandas as pd
+from xarray.core.indexing import PandasMultiIndexingAdapter
+
+# Test what happens when dtype is None (should use pandas default behavior)
+level_indexes = [pd.Index([0])]
+split_labels, levels = zip(*[lev.factorize() for lev in level_indexes])
+labels_mesh = np.meshgrid(*split_labels, indexing="ij")
+labels = [x.ravel() for x in labels_mesh]
+multi_index = pd.MultiIndex(levels, labels, sortorder=0, names=['a'])
+
+# Test with dtype=None (should use pandas default behavior)
+adapter = PandasMultiIndexingAdapter(multi_index, dtype=None, level='a')
+print("Adapter with dtype=None:", adapter.dtype)
+print("Adapter array with dtype=None:", adapter.__array__())
+print("Adapter array dtype with dtype=None:", adapter.__array__().dtype)
+
+# Test with explicit dtype
+adapter2 = PandasMultiIndexingAdapter(multi_index, dtype=np.dtype('i4'), level='a')
+print("Adapter with explicit int32 dtype:", adapter2.dtype)
+print("Adapter array with explicit int32 dtype:", adapter2.__array__())
+print("Adapter array dtype with explicit int32 dtype:", adapter2.__array__().dtype)
\ No newline at end of file
diff --git a/test_reshape.py b/test_reshape.py
new file mode 100644
index 00000000..0736a280
--- /dev/null
+++ b/test_reshape.py
@@ -0,0 +1,20 @@
+import numpy as np
+
+# Test what happens with numpy reshape
+arr = np.array([0], dtype='i4')
+print("Original dtype:", arr.dtype)
+print("Original shape:", arr.shape)
+
+reshaped = arr.reshape((1,))
+print("Reshaped dtype:", reshaped.dtype)
+print("Reshaped shape:", reshaped.shape)
+
+# Test with different reshape
+reshaped2 = arr.reshape((-1,))
+print("Reshaped2 dtype:", reshaped2.dtype)
+print("Reshaped2 shape:", reshaped2.shape)
+
+# Test with different approach
+reshaped3 = np.reshape(arr, (-1,))
+print("Reshaped3 dtype:", reshaped3.dtype)
+print("Reshaped3 shape:", reshaped3.shape)
\ No newline at end of file
diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py
index ba937183..9fe23da6 100644
--- a/xarray/core/indexing.py
+++ b/xarray/core/indexing.py
@@ -1532,7 +1532,10 @@ class PandasMultiIndexingAdapter(PandasIndexingAdapter):
 
     def __array__(self, dtype: DTypeLike = None) -> np.ndarray:
         if self.level is not None:
-            return self.array.get_level_values(self.level).values
+            values = self.array.get_level_values(self.level).values
+            if dtype is None:
+                dtype = self.dtype
+            return np.asarray(values, dtype=dtype)
         else:
             return super().__array__(dtype)