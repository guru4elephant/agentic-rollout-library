diff --git a/django/core/cache/backends/db.py b/django/core/cache/backends/db.py
index 33c79c5a14..4d67c18b61 100644
--- a/django/core/cache/backends/db.py
+++ b/django/core/cache/backends/db.py
@@ -267,9 +267,11 @@ class DatabaseCache(BaseDatabaseCache):
                 cursor.execute(
                     connection.ops.cache_key_culling_sql() % table,
                     [cull_num])
-                cursor.execute("DELETE FROM %s "
-                               "WHERE cache_key < %%s" % table,
-                               [cursor.fetchone()[0]])
+                result = cursor.fetchone()
+                if result is not None:
+                    cursor.execute("DELETE FROM %s "
+                                   "WHERE cache_key < %%s" % table,
+                                   [result[0]])
 
     def clear(self):
         db = router.db_for_write(self.cache_model_class)
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..3892a08c69
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix works and doesn't break existing functionality.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'test_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 3,  # Small number to easily trigger culling
+                    'CULL_FREQUENCY': 2,
+                }
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_cache_functionality():
+    """Test that cache works correctly with the fix"""
+    print("Testing cache functionality with the fix...")
+    
+    from django.core.cache import cache
+    from django.db import connection
+    
+    # Create the cache table
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+    
+    # Test 1: Normal cache operations
+    print("Test 1: Normal cache operations")
+    cache.set('test_key', 'test_value')
+    value = cache.get('test_key')
+    assert value == 'test_value', f"Expected 'test_value', got {value}"
+    print("✓ Normal cache operations work")
+    
+    # Test 2: Trigger culling with empty table (this would previously fail)
+    print("Test 2: Trigger culling with empty table")
+    cache.clear()  # Clear the table
+    
+    # This should not raise an error anymore
+    try:
+        # Add more items than MAX_ENTRIES to trigger culling
+        for i in range(5):
+            cache.set(f'key_{i}', f'value_{i}')
+        print("✓ Culling with empty table works correctly")
+    except Exception as e:
+        print(f"✗ Error during culling: {e}")
+        return False
+    
+    # Test 3: Verify cache still works after culling
+    print("Test 3: Verify cache functionality after culling")
+    value = cache.get('key_4')
+    assert value == 'value_4', f"Expected 'value_4', got {value}"
+    print("✓ Cache functionality preserved after culling")
+    
+    print("All tests passed! The fix works correctly.")
+    return True
+
+if __name__ == '__main__':
+    test_cache_functionality()
\ No newline at end of file
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..24ee34caf9
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+"""
+Final verification that the fix works for the exact scenario described in the issue.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_original_issue():
+    """Test the exact scenario described in the GitHub issue"""
+    print("Testing the exact scenario from the GitHub issue...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    
+    # Create cache backend with settings that would trigger culling
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create the cache table manually
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Simulate the exact code from the _cull method that was failing
+        table = connection.ops.quote_name('test_cache_table')
+        
+        # This is the problematic code from the original issue:
+        # cursor.execute(
+        #     connection.ops.cache_key_culling_sql() % table,
+        #     [cull_num])
+        # cursor.execute("DELETE FROM %s "
+        #                "WHERE cache_key < %%s" % table,
+        #                [cursor.fetchone()[0]])  # This line would fail
+        
+        # Test with a cull_num that would cause fetchone() to return None
+        cull_num = 10  # Large number that will result in no rows
+        
+        cursor.execute(
+            connection.ops.cache_key_culling_sql() % table,
+            [cull_num]
+        )
+        
+        # The original problematic code:
+        # result = cursor.fetchone()[0]  # This would fail with TypeError
+        
+        # The fixed code:
+        result = cursor.fetchone()
+        if result is not None:
+            cache_key = result[0]
+            print(f"Would delete entries with cache_key < {cache_key}")
+        else:
+            print("No rows to delete (fix prevents the TypeError)")
+        
+        print("SUCCESS: The original issue has been fixed!")
+        print("Before the fix: TypeError: 'NoneType' object is not subscriptable")
+        print("After the fix: Gracefully handles the None case")
+        return True
+
+if __name__ == '__main__':
+    test_original_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f6022285d4
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the cache backend '_cull' method error.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        CACHES={
+            'default': {
+                'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+                'LOCATION': 'my_cache_table',
+                'OPTIONS': {
+                    'MAX_ENTRIES': 5,  # Small number to trigger culling easily
+                    'CULL_FREQUENCY': 2,
+                }
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.core.cache import cache
+from django.core.management import execute_from_command_line
+
+def test_cull_error():
+    """Test that reproduces the NoneType error in _cull method"""
+    print("Testing cache culling functionality...")
+    
+    # Create cache table first
+    from django.db import connection
+    from django.core.cache.backends.db import DatabaseCache
+    cache_backend = DatabaseCache('my_cache_table', {'MAX_ENTRIES': 5, 'CULL_FREQUENCY': 2})
+    
+    # Create the table using the cache backend's model
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(cache_backend.cache_model_class)
+    
+    # Clear cache first
+    cache.clear()
+    
+    # Add more items than MAX_ENTRIES to trigger culling
+    for i in range(10):
+        cache.set(f'key_{i}', f'value_{i}')
+    
+    print("Cache populated successfully")
+    
+    # Try to add one more item to trigger culling
+    try:
+        cache.set('trigger_cull', 'should_trigger_culling')
+        print("Cache set operation completed without error")
+    except Exception as e:
+        print(f"Error occurred: {type(e).__name__}: {e}")
+        return False
+    
+    return True
+
+if __name__ == '__main__':
+    test_cull_error()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..c2483b07fa
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the _cull method error.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_cull_error():
+    """Test that reproduces the NoneType error in _cull method"""
+    print("Testing _cull method directly...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    
+    # Create cache backend
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create cursor
+    with connection.cursor() as cursor:
+        # Create the cache table manually
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Simulate the scenario where cache_key_culling_sql returns no results
+        # This happens when there are no entries or offset is too large
+        table = connection.ops.quote_name('test_cache_table')
+        
+        # Test the problematic code directly
+        cull_num = 10  # Large number that will result in no rows
+        cursor.execute(
+            connection.ops.cache_key_culling_sql() % table,
+            [cull_num]
+        )
+        
+        # This is where the error occurs - fetchone() returns None
+        result = cursor.fetchone()
+        print(f"fetchone() result: {result}")
+        
+        if result is None:
+            print("SUCCESS: Reproduced the issue - fetchone() returned None")
+            try:
+                # This should raise the error
+                cache_key = result[0]
+                print(f"Cache key: {cache_key}")
+            except TypeError as e:
+                print(f"ERROR: {type(e).__name__}: {e}")
+                return True
+        else:
+            print("No issue reproduced")
+            return False
+
+if __name__ == '__main__':
+    test_cull_error()
\ No newline at end of file
diff --git a/test_edge_case.py b/test_edge_case.py
new file mode 100644
index 0000000000..02cd51572d
--- /dev/null
+++ b/test_edge_case.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python3
+"""
+Test edge case where there are some entries but culling number is too large.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_edge_case():
+    """Test edge case with some entries but large culling number"""
+    print("Testing edge case with some entries but large culling number...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    from django.utils import timezone
+    from datetime import timedelta
+    
+    # Create cache backend
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create the cache table manually
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Add a few entries
+        future_time = timezone.now() + timedelta(hours=1)
+        for i in range(3):
+            cursor.execute(
+                "INSERT INTO test_cache_table (cache_key, value, expires) VALUES (%s, %s, %s)",
+                [f'key_{i}', f'value_{i}', future_time]
+            )
+        
+        # Test the edge case: more entries than MAX_ENTRIES but cull_num is too large
+        table = connection.ops.quote_name('test_cache_table')
+        
+        cursor.execute("SELECT COUNT(*) FROM %s" % table)
+        num = cursor.fetchone()[0]
+        print(f"Number of entries: {num}")
+        
+        # Force a large culling number that will result in no rows
+        cull_num = 10  # Larger than number of entries
+        
+        # This is the fixed code from the _cull method
+        cursor.execute(
+            connection.ops.cache_key_culling_sql() % table,
+            [cull_num]
+        )
+        
+        result = cursor.fetchone()
+        print(f"fetchone() result: {result}")
+        
+        # This should not raise an error anymore
+        if result is not None:
+            cursor.execute("DELETE FROM %s "
+                           "WHERE cache_key < %%s" % table,
+                           [result[0]])
+            print("DELETE query executed successfully")
+        else:
+            print("No rows to delete (edge case handled correctly)")
+        
+        print("SUCCESS: Edge case handled correctly - no TypeError occurred!")
+        return True
+
+if __name__ == '__main__':
+    test_edge_case()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..f2c4c843e9
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for the _cull method error.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_fix():
+    """Test that the fix works correctly"""
+    print("Testing the fix for _cull method...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    
+    # Create cache backend
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create cursor
+    with connection.cursor() as cursor:
+        # Create the cache table manually
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Test the fixed _cull method directly
+        table = connection.ops.quote_name('test_cache_table')
+        
+        # Simulate the scenario that would previously cause the error
+        cull_num = 10  # Large number that will result in no rows
+        
+        # This is the fixed code from the _cull method
+        cursor.execute(
+            connection.ops.cache_key_culling_sql() % table,
+            [cull_num]
+        )
+        
+        result = cursor.fetchone()
+        print(f"fetchone() result: {result}")
+        
+        # This should not raise an error anymore
+        if result is not None:
+            cursor.execute("DELETE FROM %s "
+                           "WHERE cache_key < %%s" % table,
+                           [result[0]])
+            print("DELETE query executed successfully")
+        else:
+            print("No rows to delete (this is expected behavior)")
+        
+        print("SUCCESS: Fix works correctly - no TypeError raised!")
+        return True
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/test_normal_functionality.py b/test_normal_functionality.py
new file mode 100644
index 0000000000..799793fd48
--- /dev/null
+++ b/test_normal_functionality.py
@@ -0,0 +1,99 @@
+#!/usr/bin/env python3
+"""
+Test script to verify normal functionality still works after the fix.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def test_normal_functionality():
+    """Test that normal culling functionality still works"""
+    print("Testing normal culling functionality...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    from django.utils import timezone
+    from datetime import timedelta
+    
+    # Create cache backend
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create cursor
+    with connection.cursor() as cursor:
+        # Create the cache table manually
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Add some test data
+        now = timezone.now()
+        future_time = now + timedelta(hours=1)
+        
+        for i in range(10):
+            cursor.execute(
+                "INSERT INTO test_cache_table (cache_key, value, expires) VALUES (%s, %s, %s)",
+                [f'key_{i}', f'value_{i}', future_time]
+            )
+        
+        # Test the fixed _cull method with actual data
+        table = connection.ops.quote_name('test_cache_table')
+        
+        # Get count first
+        cursor.execute("SELECT COUNT(*) FROM %s" % table)
+        num = cursor.fetchone()[0]
+        print(f"Number of entries: {num}")
+        
+        if num > cache_backend._max_entries:
+            cull_num = num // cache_backend._cull_frequency
+            print(f"Culling number: {cull_num}")
+            
+            # This is the fixed code from the _cull method
+            cursor.execute(
+                connection.ops.cache_key_culling_sql() % table,
+                [cull_num]
+            )
+            
+            result = cursor.fetchone()
+            print(f"fetchone() result: {result}")
+            
+            if result is not None:
+                cursor.execute("DELETE FROM %s "
+                               "WHERE cache_key < %%s" % table,
+                               [result[0]])
+                print("DELETE query executed successfully")
+                
+                # Check how many rows were deleted
+                cursor.execute("SELECT COUNT(*) FROM %s" % table)
+                remaining = cursor.fetchone()[0]
+                print(f"Remaining entries after culling: {remaining}")
+            else:
+                print("No rows to delete")
+        
+        print("SUCCESS: Normal functionality works correctly!")
+        return True
+
+if __name__ == '__main__':
+    test_normal_functionality()
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..b05d473f8f
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Simple verification that the fix prevents the NoneType error.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+def verify_fix():
+    """Verify that the fix prevents the NoneType error"""
+    print("Verifying the fix for _cull method...")
+    
+    from django.core.cache.backends.db import DatabaseCache
+    from django.db import connection
+    
+    # Create cache backend
+    cache_backend = DatabaseCache('test_cache_table', {
+        'MAX_ENTRIES': 5,
+        'CULL_FREQUENCY': 2
+    })
+    
+    # Create the cache table manually
+    with connection.cursor() as cursor:
+        cursor.execute("""
+            CREATE TABLE test_cache_table (
+                cache_key VARCHAR(255) NOT NULL PRIMARY KEY,
+                value TEXT NOT NULL,
+                expires TIMESTAMP NOT NULL
+            )
+        """)
+        
+        # Test the exact scenario that was causing the error
+        table = connection.ops.quote_name('test_cache_table')
+        
+        # Simulate the _cull method logic
+        cursor.execute("SELECT COUNT(*) FROM %s" % table)
+        num = cursor.fetchone()[0]
+        print(f"Number of entries: {num}")
+        
+        if num > cache_backend._max_entries:
+            cull_num = num // cache_backend._cull_frequency
+            print(f"Culling number: {cull_num}")
+            
+            # This is the fixed code from the _cull method
+            cursor.execute(
+                connection.ops.cache_key_culling_sql() % table,
+                [cull_num]
+            )
+            
+            result = cursor.fetchone()
+            print(f"fetchone() result: {result}")
+            
+            # This is where the fix is - check for None before accessing [0]
+            if result is not None:
+                cursor.execute("DELETE FROM %s "
+                               "WHERE cache_key < %%s" % table,
+                               [result[0]])
+                print("DELETE query executed successfully")
+            else:
+                print("No rows to delete (fix prevents TypeError)")
+        
+        print("SUCCESS: Fix verified - no TypeError occurred!")
+        return True
+
+if __name__ == '__main__':
+    verify_fix()
\ No newline at end of file