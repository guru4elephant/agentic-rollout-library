diff --git a/django/utils/decorators.py b/django/utils/decorators.py
index 5c9a5d01c7..d532e1634f 100644
--- a/django/utils/decorators.py
+++ b/django/utils/decorators.py
@@ -38,6 +38,9 @@ def _multi_decorate(decorators, method):
         # 'func'. Also, wrap method.__get__() in a function because new
         # attributes can't be set on bound method objects, only on functions.
         bound_method = partial(method.__get__(self, type(self)))
+        # Preserve function attributes on the partial object so decorators
+        # can access them (e.g., __name__, __module__, etc.)
+        update_wrapper(bound_method, method)
         for dec in decorators:
             bound_method = dec(bound_method)
         return bound_method(*args, **kwargs)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..73ce3a4a51
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the method_decorator issue with wrapper assignments.
+"""
+
+import functools
+from django.utils.decorators import method_decorator
+
+
+def logger(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            print(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+
+
+if __name__ == "__main__":
+    try:
+        test = Test()
+        result = test.hello_world()
+        print(f"Success! Result: {result}")
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..b745fd34ab
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for method_decorator fix to ensure it handles various edge cases.
+"""
+
+import functools
+from django.utils.decorators import method_decorator
+
+
+def decorator1(func):
+    """First decorator that adds an attribute."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.decorator1 = True
+    return wrapper
+
+
+def decorator2(func):
+    """Second decorator that uses functools.wraps."""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    wrapper.decorator2 = True
+    return wrapper
+
+
+def decorator3(func):
+    """Third decorator that accesses function attributes."""
+    def wrapper(*args, **kwargs):
+        print(f"Function being called: {func.__name__}")
+        return func(*args, **kwargs)
+    return wrapper
+
+
+class TestClass:
+    @method_decorator(decorator1)
+    @method_decorator(decorator2)
+    @method_decorator(decorator3)
+    def complex_method(self, arg1, arg2):
+        return f"result: {arg1}, {arg2}"
+
+    @method_decorator([decorator1, decorator2, decorator3])
+    def method_with_list_decorators(self):
+        return "list decorators result"
+
+
+def test_comprehensive():
+    """Test comprehensive functionality."""
+    test = TestClass()
+    
+    # Test chained decorators
+    result = test.complex_method("test1", "test2")
+    assert result == "result: test1, test2"
+    print("✓ Chained decorators test passed")
+    
+    # Test list of decorators
+    result = test.method_with_list_decorators()
+    assert result == "list decorators result"
+    print("✓ List decorators test passed")
+    
+    # Test function attributes are preserved
+    assert hasattr(test.complex_method, '__name__')
+    assert test.complex_method.__name__ == 'complex_method'
+    print("✓ Function name preservation test passed")
+    
+    assert hasattr(test.complex_method, '__module__')
+    print("✓ Function module preservation test passed")
+    
+    # Test decorator attributes
+    assert hasattr(test.complex_method, 'decorator1')
+    assert test.complex_method.decorator1 is True
+    print("✓ Decorator1 attribute test passed")
+    
+    assert hasattr(test.complex_method, 'decorator2')
+    assert test.complex_method.decorator2 is True
+    print("✓ Decorator2 attribute test passed")
+    
+    print("All comprehensive tests passed! ✅")
+
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/test_edge_case_no_attributes.py b/test_edge_case_no_attributes.py
new file mode 100644
index 0000000000..0ce0f0432d
--- /dev/null
+++ b/test_edge_case_no_attributes.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+"""
+Test edge case where the original function might not have certain attributes.
+"""
+
+import functools
+from django.utils.decorators import method_decorator
+
+
+def simple_decorator(func):
+    """A decorator that doesn't use functools.wraps."""
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    return wrapper
+
+
+# Create a function without some attributes
+def func_without_attrs():
+    return "no attrs"
+
+
+# Remove some attributes to test edge case
+del func_without_attrs.__module__
+del func_without_attrs.__qualname__
+
+
+class TestClass:
+    @method_decorator(simple_decorator)
+    def method(self):
+        return "method result"
+
+
+def test_edge_case():
+    """Test that our fix handles edge cases gracefully."""
+    test = TestClass()
+    
+    # Basic functionality should still work
+    result = test.method()
+    assert result == "method result"
+    print("✓ Basic functionality test passed")
+    
+    # The method should still have a __name__ attribute
+    assert hasattr(test.method, '__name__')
+    assert test.method.__name__ == 'method'
+    print("✓ Function name attribute test passed")
+    
+    # Even if some attributes are missing, it should not crash
+    print("✓ Edge case handling test passed")
+    
+    print("All edge case tests passed! ✅")
+
+
+if __name__ == "__main__":
+    test_edge_case()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..a73652b74c
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the method_decorator fix.
+"""
+
+import functools
+from django.utils.decorators import method_decorator
+
+
+def logger(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # Test accessing various function attributes
+            print(f"Function name: {func.__name__}")
+            print(f"Function module: {func.__module__}")
+            print(f"Function qualname: {func.__qualname__}")
+            print(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+
+def decorator_with_wraps(func):
+    """A decorator that uses functools.wraps"""
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        print(f"Decorated function: {func.__name__}")
+        return func(*args, **kwargs)
+    return wrapper
+
+
+def simple_decorator(func):
+    """A simple decorator without functools.wraps"""
+    def wrapper(*args, **kwargs):
+        print(f"Simple decorated function: {func.__name__}")
+        return func(*args, **kwargs)
+    return wrapper
+
+
+class TestClass:
+    @method_decorator(logger)
+    def method1(self):
+        return "method1 result"
+    
+    @method_decorator(decorator_with_wraps)
+    def method2(self):
+        return "method2 result"
+    
+    @method_decorator(simple_decorator)
+    def method3(self):
+        return "method3 result"
+    
+    @method_decorator(logger)
+    @method_decorator(decorator_with_wraps)
+    def chained_decorators(self):
+        return "chained result"
+
+
+if __name__ == "__main__":
+    print("Testing method_decorator with various decorators...")
+    
+    test = TestClass()
+    
+    print("\n=== Testing method1 (logger decorator) ===")
+    result1 = test.method1()
+    print(f"Result: {result1}")
+    
+    print("\n=== Testing method2 (decorator_with_wraps) ===")
+    result2 = test.method2()
+    print(f"Result: {result2}")
+    
+    print("\n=== Testing method3 (simple_decorator) ===")
+    result3 = test.method3()
+    print(f"Result: {result3}")
+    
+    print("\n=== Testing chained_decorators ===")
+    result4 = test.chained_decorators()
+    print(f"Result: {result4}")
+    
+    print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/test_function_attributes.py b/test_function_attributes.py
new file mode 100644
index 0000000000..a439ffb8b8
--- /dev/null
+++ b/test_function_attributes.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+"""
+Test to verify that method_decorator preserves function attributes correctly.
+This specifically tests the issue described in the GitHub issue.
+"""
+
+import functools
+from django.utils.decorators import method_decorator
+
+
+def logger(func):
+    """A decorator that accesses function attributes like __name__."""
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # This would fail before the fix because func would be a partial object
+            # without __name__, __module__, etc. attributes
+            print(f"Function name: {func.__name__}")
+            print(f"Function module: {func.__module__}")
+            print(f"Function qualname: {func.__qualname__}")
+            print(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+
+class TestClass:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+    
+    @method_decorator(logger)
+    def method_with_args(self, arg1, arg2):
+        return f"args: {arg1}, {arg2}"
+
+
+def test_function_attributes():
+    """Test that function attributes are preserved correctly."""
+    test = TestClass()
+    
+    # Test basic functionality
+    result = test.hello_world()
+    assert result == "hello"
+    print("✓ Basic functionality test passed")
+    
+    # Test method with arguments
+    result = test.method_with_args("test1", "test2")
+    assert result == "args: test1, test2"
+    print("✓ Method with arguments test passed")
+    
+    # Test that the method still has correct attributes
+    assert hasattr(test.hello_world, '__name__')
+    assert test.hello_world.__name__ == 'hello_world'
+    print("✓ Function name attribute test passed")
+    
+    assert hasattr(test.hello_world, '__module__')
+    print("✓ Function module attribute test passed")
+    
+    assert hasattr(test.hello_world, '__qualname__')
+    print("✓ Function qualname attribute test passed")
+    
+    print("All tests passed! ✅")
+
+
+if __name__ == "__main__":
+    test_function_attributes()
\ No newline at end of file