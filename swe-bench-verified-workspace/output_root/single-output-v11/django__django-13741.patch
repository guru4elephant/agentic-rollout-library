diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py
index b9eb33329f..9a6614a809 100644
--- a/django/contrib/auth/forms.py
+++ b/django/contrib/auth/forms.py
@@ -56,6 +56,7 @@ class ReadOnlyPasswordHashField(forms.Field):
 
     def __init__(self, *args, **kwargs):
         kwargs.setdefault("required", False)
+        kwargs.setdefault("disabled", True)
         super().__init__(*args, **kwargs)
 
     def bound_data(self, data, initial):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..44ec8b7ff0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, '.')
+
+# Configure Django settings first
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-key-for-reproduction',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django import forms
+from django.contrib.auth.forms import ReadOnlyPasswordHashField, UserChangeForm
+from django.contrib.auth.models import User
+
+def test_readonly_password_hash_field():
+    """Test that ReadOnlyPasswordHashField has disabled=True by default"""
+    print("Testing ReadOnlyPasswordHashField behavior...")
+    
+    # Create a field instance
+    field = ReadOnlyPasswordHashField()
+    
+    # Check if field has disabled attribute set to True
+    disabled_attr = getattr(field, 'disabled', 'NOT SET')
+    print(f"Field disabled attribute: {disabled_attr}")
+    
+    # Set initial value (password hash)
+    initial_hash = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+    
+    # Simulate form submission with tampered data
+    tampered_data = "tampered_value"
+    
+    # Test bound_data method - this should return initial value regardless of submitted data
+    result = field.bound_data(tampered_data, initial_hash)
+    print(f"Initial hash: {initial_hash}")
+    print(f"Tampered data submitted: {tampered_data}")
+    print(f"Result from bound_data: {result}")
+    
+    # Test has_changed method
+    changed = field.has_changed(initial_hash, tampered_data)
+    print(f"has_changed result: {changed}")
+    
+    # The main test: disabled should be True by default
+    return disabled_attr is True and result == initial_hash and not changed
+
+def test_user_change_form():
+    """Test UserChangeForm clean_password method"""
+    print("\nTesting UserChangeForm clean_password method...")
+    
+    # Create a user with a password hash
+    user = User(username='testuser')
+    user.password = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+    
+    # Create form with initial data
+    form = UserChangeForm(instance=user)
+    
+    # Simulate form submission with tampered password data
+    form_data = {'password': 'tampered_value'}
+    
+    # Check if form is valid and what password value is returned
+    if form.is_valid():
+        cleaned_password = form.cleaned_data.get('password')
+        print(f"Cleaned password value: {cleaned_password}")
+        print(f"Expected initial value: {user.password}")
+        return cleaned_password == user.password
+    else:
+        print("Form validation failed")
+        return False
+
+if __name__ == "__main__":
+    print("Reproducing the issue described in the GitHub issue...")
+    
+    # Test 1: ReadOnlyPasswordHashField behavior
+    test1_passed = test_readonly_password_hash_field()
+    print(f"\nTest 1 (ReadOnlyPasswordHashField) passed: {test1_passed}")
+    
+    # Test 2: UserChangeForm behavior
+    test2_passed = test_user_change_form()
+    print(f"Test 2 (UserChangeForm) passed: {test2_passed}")
+    
+    print(f"\nOverall test passed: {test1_passed and test2_passed}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..62e51e1590
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, '.')
+
+# Configure Django settings first
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-key-for-reproduction',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField
+
+def test_disabled_attribute_default():
+    """Test that disabled=True is set by default"""
+    print("Test 1: Default disabled attribute")
+    field = ReadOnlyPasswordHashField()
+    assert field.disabled is True, f"Expected disabled=True, got {field.disabled}"
+    print("✓ disabled=True by default")
+
+def test_disabled_attribute_explicit_false():
+    """Test that explicitly setting disabled=False works"""
+    print("Test 2: Explicitly setting disabled=False")
+    field = ReadOnlyPasswordHashField(disabled=False)
+    assert field.disabled is False, f"Expected disabled=False, got {field.disabled}"
+    print("✓ disabled=False when explicitly set")
+
+def test_disabled_attribute_explicit_true():
+    """Test that explicitly setting disabled=True works"""
+    print("Test 3: Explicitly setting disabled=True")
+    field = ReadOnlyPasswordHashField(disabled=True)
+    assert field.disabled is True, f"Expected disabled=True, got {field.disabled}"
+    print("✓ disabled=True when explicitly set")
+
+def test_bound_data_behavior():
+    """Test that bound_data still returns initial value"""
+    print("Test 4: bound_data behavior")
+    field = ReadOnlyPasswordHashField()
+    initial_hash = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+    tampered_data = "tampered_value"
+    
+    result = field.bound_data(tampered_data, initial_hash)
+    assert result == initial_hash, f"Expected {initial_hash}, got {result}"
+    print("✓ bound_data returns initial value")
+
+def test_has_changed_behavior():
+    """Test that has_changed returns False"""
+    print("Test 5: has_changed behavior")
+    field = ReadOnlyPasswordHashField()
+    initial_hash = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+    tampered_data = "tampered_value"
+    
+    changed = field.has_changed(initial_hash, tampered_data)
+    assert changed is False, f"Expected has_changed=False, got {changed}"
+    print("✓ has_changed returns False")
+
+if __name__ == "__main__":
+    print("Running comprehensive tests for ReadOnlyPasswordHashField fix...\n")
+    
+    try:
+        test_disabled_attribute_default()
+        test_disabled_attribute_explicit_false()
+        test_disabled_attribute_explicit_true()
+        test_bound_data_behavior()
+        test_has_changed_behavior()
+        
+        print("\n✅ All tests passed! The fix is working correctly.")
+        print("The ReadOnlyPasswordHashField now has disabled=True by default,")
+        print("which prevents user tampering and makes clean_password unnecessary.")
+        
+    except AssertionError as e:
+        print(f"\n❌ Test failed: {e}")
+        sys.exit(1)
+    except Exception as e:
+        print(f"\n❌ Unexpected error: {e}")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..0b4df95954
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, '.')
+
+# Configure Django settings first
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-key-for-reproduction',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField
+
+def test_backward_compatibility():
+    """Test that existing code continues to work"""
+    print("Testing backward compatibility...")
+    
+    # Test 1: Field without any arguments (should work as before)
+    field1 = ReadOnlyPasswordHashField()
+    assert field1.disabled is True
+    assert field1.required is False
+    print("✓ Default constructor works")
+    
+    # Test 2: Field with explicit disabled=False (should override default)
+    field2 = ReadOnlyPasswordHashField(disabled=False)
+    assert field2.disabled is False
+    assert field2.required is False
+    print("✓ Explicit disabled=False works")
+    
+    # Test 3: Field with explicit disabled=True (should work as expected)
+    field3 = ReadOnlyPasswordHashField(disabled=True)
+    assert field3.disabled is True
+    assert field3.required is False
+    print("✓ Explicit disabled=True works")
+    
+    # Test 4: Field with other kwargs (should still work)
+    field4 = ReadOnlyPasswordHashField(label="Password", help_text="Enter password")
+    assert field4.disabled is True
+    assert field4.required is False
+    assert field4.label == "Password"
+    print("✓ Other kwargs work correctly")
+    
+    # Test 5: Field with required=True (should override default)
+    field5 = ReadOnlyPasswordHashField(required=True)
+    assert field5.disabled is True
+    assert field5.required is True
+    print("✓ Explicit required=True works")
+
+def test_functionality():
+    """Test that the field functionality remains intact"""
+    print("Testing field functionality...")
+    
+    field = ReadOnlyPasswordHashField()
+    
+    # Test bound_data method
+    initial_value = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+    tampered_value = "tampered_value"
+    result = field.bound_data(tampered_value, initial_value)
+    assert result == initial_value
+    print("✓ bound_data returns initial value")
+    
+    # Test has_changed method
+    changed = field.has_changed(initial_value, tampered_value)
+    assert changed is False
+    print("✓ has_changed returns False")
+
+if __name__ == "__main__":
+    print("Testing edge cases and backward compatibility...\n")
+    
+    try:
+        test_backward_compatibility()
+        print()
+        test_functionality()
+        
+        print("\n✅ All edge case tests passed!")
+        print("The fix maintains backward compatibility and all existing functionality.")
+        
+    except AssertionError as e:
+        print(f"\n❌ Test failed: {e}")
+        sys.exit(1)
+    except Exception as e:
+        print(f"\n❌ Unexpected error: {e}")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_existing_behavior.py b/test_existing_behavior.py
new file mode 100644
index 0000000000..b388902a7c
--- /dev/null
+++ b/test_existing_behavior.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, '.')
+
+# Configure Django settings first
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-key-for-reproduction',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField
+from django.test import SimpleTestCase
+
+# This replicates the existing test from tests/auth_tests/test_forms.py
+class ReadOnlyPasswordHashTest(SimpleTestCase):
+    def test_readonly_field_has_changed(self):
+        field = ReadOnlyPasswordHashField()
+        self.assertFalse(field.has_changed('aaa', 'bbb'))
+
+if __name__ == "__main__":
+    import unittest
+    unittest.main(verbosity=2)
\ No newline at end of file
diff --git a/test_fix_verification.py b/test_fix_verification.py
new file mode 100644
index 0000000000..23b534041c
--- /dev/null
+++ b/test_fix_verification.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, '.')
+
+# Configure Django settings first
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-key-for-reproduction',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.contrib.auth.forms import ReadOnlyPasswordHashField
+from django.test import SimpleTestCase
+
+class TestReadOnlyPasswordHashFieldFix(SimpleTestCase):
+    """Test that the disabled attribute is properly set on ReadOnlyPasswordHashField"""
+    
+    def test_disabled_attribute_default(self):
+        """Test that disabled=True is set by default"""
+        field = ReadOnlyPasswordHashField()
+        self.assertTrue(field.disabled, "ReadOnlyPasswordHashField should have disabled=True by default")
+    
+    def test_disabled_attribute_explicit_false(self):
+        """Test that explicitly setting disabled=False works"""
+        field = ReadOnlyPasswordHashField(disabled=False)
+        self.assertFalse(field.disabled, "ReadOnlyPasswordHashField should respect disabled=False when explicitly set")
+    
+    def test_disabled_attribute_explicit_true(self):
+        """Test that explicitly setting disabled=True works"""
+        field = ReadOnlyPasswordHashField(disabled=True)
+        self.assertTrue(field.disabled, "ReadOnlyPasswordHashField should respect disabled=True when explicitly set")
+    
+    def test_has_changed_behavior(self):
+        """Test that has_changed still returns False (existing behavior)"""
+        field = ReadOnlyPasswordHashField()
+        self.assertFalse(field.has_changed('aaa', 'bbb'), "has_changed should return False")
+    
+    def test_bound_data_behavior(self):
+        """Test that bound_data still returns initial value (existing behavior)"""
+        field = ReadOnlyPasswordHashField()
+        initial_hash = "pbkdf2_sha256$150000$abc123$hashvalue1234567890"
+        tampered_data = "tampered_value"
+        
+        result = field.bound_data(tampered_data, initial_hash)
+        self.assertEqual(result, initial_hash, "bound_data should return initial value")
+
+if __name__ == "__main__":
+    import unittest
+    unittest.main(verbosity=2)
\ No newline at end of file