diff --git a/debug_ask.py b/debug_ask.py
new file mode 100644
index 0000000000..1e079024bb
--- /dev/null
+++ b/debug_ask.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Q, ask
+from sympy.assumptions.handlers.calculus import AskFiniteHandler
+
+# Create a symbol with even=True
+m = Symbol('m', even=True)
+
+print(f"m = {m}")
+print(f"m.is_even = {m.is_even}")
+print(f"m.is_finite = {m.is_finite}")
+
+# Test the ask function with different approaches
+print(f"\nTesting ask function:")
+
+# Test 1: Direct ask
+result1 = ask(Q.finite(m))
+print(f"ask(Q.finite(m)) = {result1}")
+
+# Test 2: Ask with explicit assumptions
+result2 = ask(Q.finite(m), Q.even(m))
+print(f"ask(Q.finite(m), Q.even(m)) = {result2}")
+
+# Test 3: Check what assumptions are stored
+print(f"\nAssumptions in symbol:")
+print(f"m._assumptions = {m._assumptions}")
+print(f"m.assumptions0 = {m.assumptions0}")
+
+# Test 4: Clear assumptions and try again
+print(f"\nAfter clearing assumptions:")
+m._assumptions.clear()
+result3 = ask(Q.finite(m))
+print(f"ask(Q.finite(m)) = {result3}")
+print(f"m.is_finite = {m.is_finite}")
+
+# Test 5: Check if the result is cached
+print(f"\nAfter asking, check assumptions:")
+print(f"m._assumptions = {m._assumptions}")
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..315f2c0744
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Q, ask
+from sympy.assumptions.handlers.calculus import AskFiniteHandler
+
+# Create a symbol with even=True
+m = Symbol('m', even=True)
+
+print(f"m = {m}")
+print(f"m.is_even = {m.is_even}")
+print(f"m.is_finite = {m.is_finite}")
+
+# Test the ask function directly
+print(f"\nDirect ask calls:")
+print(f"ask(Q.even(m)) = {ask(Q.even(m))}")
+print(f"ask(Q.finite(m)) = {ask(Q.finite(m))}")
+
+# Test the handler directly
+handler = AskFiniteHandler()
+print(f"\nHandler test:")
+print(f"handler.Symbol(m, Q.even(m)) = {handler.Symbol(m, Q.even(m))}")
+
+# Test with assumptions
+print(f"\nWith assumptions:")
+print(f"handler.Symbol(m, Q.even(m)) = {handler.Symbol(m, Q.even(m))}")
+
+# Let's also check what assumptions are stored in the symbol
+print(f"\nSymbol assumptions:")
+print(f"m.assumptions0 = {m.assumptions0}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f3cf96fac1
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol
+
+# Reproduce the issue described in the GitHub issue
+print("Reproducing the issue...")
+
+# Create a symbol with even=True
+m = Symbol('m', even=True)
+
+print(f"m = {m}")
+print(f"m.is_even = {m.is_even}")
+print(f"m.is_finite = {m.is_finite}")
+print(f"type(m.is_finite) = {type(m.is_finite)}")
+
+# Test what we expect: if a number is even, it should be finite
+print(f"\nExpected behavior: if m.is_even is True, then m.is_finite should also be True")
+print(f"Current behavior: m.is_even = {m.is_even}, m.is_finite = {m.is_finite}")
+
+if m.is_even and m.is_finite is not True:
+    print("ISSUE CONFIRMED: is_even=True but is_finite is not True")
+else:
+    print("No issue found")
\ No newline at end of file
diff --git a/sympy/assumptions/handlers/calculus.py b/sympy/assumptions/handlers/calculus.py
index aa0d00acad..fe495dc1aa 100644
--- a/sympy/assumptions/handlers/calculus.py
+++ b/sympy/assumptions/handlers/calculus.py
@@ -50,6 +50,12 @@ def Symbol(expr, assumptions):
             return expr.is_finite
         if Q.finite(expr) in conjuncts(assumptions):
             return True
+        
+        # Check if the symbol has assumptions that imply finiteness
+        # An even number must be finite
+        if ask(Q.even(expr), assumptions):
+            return True
+            
         return None
 
     @staticmethod
diff --git a/sympy/core/assumptions.py b/sympy/core/assumptions.py
index ce4dd30f2e..c3fe7f3ad9 100644
--- a/sympy/core/assumptions.py
+++ b/sympy/core/assumptions.py
@@ -174,6 +174,8 @@
 
     'odd            ==  integer & !even',
     'even           ==  integer & !odd',
+    'even           ->  finite',
+    'integer        ->  finite',
 
     'real           ==  negative | zero | positive',
     'transcendental ==  complex & !algebraic',
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..c2e8fb6734
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Q, ask
+
+print("Testing edge cases for the even -> finite fix:")
+
+# Test 1: Symbol with even=True
+print("\n1. Symbol with even=True:")
+m1 = Symbol('m1', even=True)
+print(f"m1.is_even = {m1.is_even}")
+print(f"m1.is_finite = {m1.is_finite}")
+print(f"m1.is_infinite = {m1.is_infinite}")
+
+# Test 2: Symbol with even=False
+print("\n2. Symbol with even=False:")
+m2 = Symbol('m2', even=False)
+print(f"m2.is_even = {m2.is_even}")
+print(f"m2.is_finite = {m2.is_finite}")
+print(f"m2.is_infinite = {m2.is_infinite}")
+
+# Test 3: Symbol with no even assumption
+print("\n3. Symbol with no even assumption:")
+m3 = Symbol('m3')
+print(f"m3.is_even = {m3.is_even}")
+print(f"m3.is_finite = {m3.is_finite}")
+print(f"m3.is_infinite = {m3.is_infinite}")
+
+# Test 4: Symbol with integer=True (should also be finite)
+print("\n4. Symbol with integer=True:")
+m4 = Symbol('m4', integer=True)
+print(f"m4.is_integer = {m4.is_integer}")
+print(f"m4.is_finite = {m4.is_finite}")
+print(f"m4.is_infinite = {m4.is_infinite}")
+
+# Test 5: Symbol with odd=True
+print("\n5. Symbol with odd=True:")
+m5 = Symbol('m5', odd=True)
+print(f"m5.is_odd = {m5.is_odd}")
+print(f"m5.is_finite = {m5.is_finite}")
+print(f"m5.is_infinite = {m5.is_infinite}")
+
+# Test 6: Direct ask calls
+print("\n6. Direct ask calls:")
+print(f"ask(Q.finite(m1)) = {ask(Q.finite(m1))}")
+print(f"ask(Q.finite(m2)) = {ask(Q.finite(m2))}")
+print(f"ask(Q.finite(m3)) = {ask(Q.finite(m3))}")
+print(f"ask(Q.finite(m4)) = {ask(Q.finite(m4))}")
+print(f"ask(Q.finite(m5)) = {ask(Q.finite(m5))}")
\ No newline at end of file
diff --git a/test_handler.py b/test_handler.py
new file mode 100644
index 0000000000..da4ed62fff
--- /dev/null
+++ b/test_handler.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol, Q, ask
+from sympy.assumptions.handlers.calculus import AskFiniteHandler
+
+# Create a symbol with even=True
+m = Symbol('m', even=True)
+
+print(f"m = {m}")
+print(f"m.is_even = {m.is_even}")
+print(f"m.is_finite = {m.is_finite}")
+
+# Test the handler directly
+handler = AskFiniteHandler()
+print(f"\nDirect handler test:")
+result = handler.Symbol(m, Q.even(m))
+print(f"handler.Symbol(m, Q.even(m)) = {result}")
+
+# Test with explicit assumptions
+print(f"\nWith explicit assumptions:")
+result = handler.Symbol(m, Q.even(m))
+print(f"handler.Symbol(m, Q.even(m)) = {result}")
+
+# Test the ask function
+print(f"\nAsk function test:")
+result = ask(Q.finite(m))
+print(f"ask(Q.finite(m)) = {result}")
+
+# Clear any cached assumptions and try again
+print(f"\nAfter clearing assumptions cache:")
+m._assumptions.clear()
+result = ask(Q.finite(m))
+print(f"ask(Q.finite(m)) = {result}")
+print(f"m.is_finite = {m.is_finite}")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..6cf1361a81
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+from sympy import Symbol
+
+# Reproduce the exact example from the GitHub issue
+print("Reproducing the exact GitHub issue example...")
+
+m = Symbol('m', even=True)
+
+print(f"In [1]: m = Symbol('m', even=True)")
+print(f"In [2]: m.is_finite")
+print(f"In [3]: print(m.is_finite)")
+print(f"Out[3]: {m.is_finite}")
+
+# The issue was that m.is_finite returned None, but it should return True
+if m.is_finite is True:
+    print("✓ ISSUE FIXED: m.is_finite now returns True as expected")
+else:
+    print("✗ ISSUE NOT FIXED: m.is_finite still returns", m.is_finite)
\ No newline at end of file