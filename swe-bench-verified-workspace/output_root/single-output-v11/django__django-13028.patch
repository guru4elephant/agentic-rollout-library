diff --git a/better_test.py b/better_test.py
new file mode 100644
index 0000000000..e454ce97a5
--- /dev/null
+++ b/better_test.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression
+
+def test_check_filterable():
+    """Test the check_filterable method with proper expression objects"""
+    
+    # Create a Query instance
+    query = Query(models.Model)
+    
+    # Test with a BaseExpression that has filterable=True (should work)
+    class TestExpression1(BaseExpression):
+        filterable = True
+    
+    expr1 = TestExpression1()
+    try:
+        query.check_filterable(expr1)
+        print("✓ BaseExpression with filterable=True works correctly")
+    except Exception as e:
+        print(f"✗ Unexpected error with filterable=True: {e}")
+    
+    # Test with a BaseExpression that has filterable=False (should raise error)
+    class TestExpression2(BaseExpression):
+        filterable = False
+    
+    expr2 = TestExpression2()
+    try:
+        query.check_filterable(expr2)
+        print("✗ BaseExpression with filterable=False should have raised an error but didn't")
+    except Exception as e:
+        print(f"✓ BaseExpression with filterable=False correctly raises: {e}")
+    
+    # Test with a model instance that has filterable field (should NOT raise error)
+    class TestModel(models.Model):
+        filterable = models.BooleanField(default=False)
+        
+        class Meta:
+            app_label = "test"
+    
+    test_instance = TestModel()
+    try:
+        query.check_filterable(test_instance)
+        print("✓ Model instance with filterable field correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Model instance with filterable field incorrectly raises: {e}")
+    
+    # Test with a mock object that has filterable=False (should NOT raise error)
+    class MockObject:
+        def __init__(self, filterable=True):
+            self.filterable = filterable
+    
+    obj = MockObject(filterable=False)
+    try:
+        query.check_filterable(obj)
+        print("✓ Mock object with filterable=False correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Mock object with filterable=False incorrectly raises: {e}")
+
+if __name__ == "__main__":
+    print("Testing check_filterable method with proper expression objects...")
+    test_check_filterable()
\ No newline at end of file
diff --git a/direct_test.py b/direct_test.py
new file mode 100644
index 0000000000..a18c9879e4
--- /dev/null
+++ b/direct_test.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+
+def test_direct_query_building():
+    """Test the query building process directly"""
+    print("Testing direct query building...")
+    
+    # Create the model classes
+    class ProductMetaDataType(models.Model):
+        label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+        filterable = models.BooleanField(default=False, verbose_name="filterable")
+        
+        class Meta:
+            app_label = "adminpricing"
+    
+    # Create a model instance with filterable field
+    metadata_instance = ProductMetaDataType(label="Test", filterable=True)
+    
+    # Create a query and test the check_filterable method
+    query = Query(ProductMetaDataType)
+    
+    try:
+        # This should NOT raise an error with our fix
+        query.check_filterable(metadata_instance)
+        print("✓ Model instance with filterable field correctly does NOT raise error")
+        
+        # Now test building a filter condition
+        from django.db.models import Q
+        condition = Q(metadata_type=metadata_instance)
+        
+        # This should also work without raising the error
+        # We'll simulate what happens during query building
+        try:
+            # The check_filterable method is called during query building
+            # Let's test it directly with our model instance
+            query.check_filterable(metadata_instance)
+            print("✓ Query building with model instance works correctly")
+            return True
+        except Exception as e:
+            print(f"✗ Query building failed: {e}")
+            return False
+            
+    except Exception as e:
+        print(f"✗ Model instance incorrectly raises error: {e}")
+        return False
+
+if __name__ == "__main__":
+    success = test_direct_query_building()
+    if success:
+        print("\nDirect test completed successfully - issue is FIXED!")
+    else:
+        print("\nDirect test failed - issue still exists")
+        sys.exit(1)
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ce18098fd2..c05fc55d62 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1124,7 +1124,9 @@ class Query(BaseExpression):
 
     def check_filterable(self, expression):
         """Raise an error if expression cannot be used in a WHERE clause."""
-        if not getattr(expression, 'filterable', True):
+        # Only check filterable attribute on BaseExpression objects, not on
+        # arbitrary objects like model instances that might have a field named filterable
+        if isinstance(expression, BaseExpression) and not expression.filterable:
             raise NotSupportedError(
                 expression.__class__.__name__ + ' is disallowed in the filter '
                 'clause.'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5554308436
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils import timezone
+
+# Create the models from the issue description
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+    
+    class Meta:
+        app_label = "adminpricing"
+        verbose_name = "product meta data type"
+        verbose_name_plural = "product meta data types"
+    
+    def __str__(self):
+        return self.label
+
+class Product(models.Model):
+    name = models.CharField(max_length=255)
+    
+    class Meta:
+        app_label = "adminpricing"
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.ForeignKey(
+        Product, null=False, blank=False, on_delete=models.CASCADE
+    )
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    
+    class Meta:
+        app_label = "adminpricing"
+        verbose_name = "product meta data"
+        verbose_name_plural = "product meta datas"
+
+def test_reproduce_issue():
+    """Test to reproduce the issue with filterable field"""
+    print("Creating database tables...")
+    from django.core.management import execute_from_command_line
+    from django.db import connection
+    connection.creation.create_test_db(verbosity=0)
+    
+    print("Creating test data...")
+    
+    # Create a product meta data type
+    brand_metadata = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=True
+    )
+    
+    # Create a product
+    product = Product.objects.create(name="Test Product")
+    
+    # Create product meta data
+    ProductMetaData.objects.create(
+        product=product,
+        value="Dark Vador",
+        metadata_type=brand_metadata
+    )
+    
+    print("Attempting to filter with metadata_type...")
+    try:
+        # This should trigger the error
+        result = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=brand_metadata
+        )
+        print("SUCCESS: Filter worked without error")
+        print(f"Found {result.count()} results")
+    except Exception as e:
+        print(f"ERROR: {e}")
+        print(f"Error type: {type(e)}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Testing the filterable field issue...")
+    success = test_reproduce_issue()
+    if success:
+        print("Test completed successfully")
+    else:
+        print("Test failed - issue reproduced")
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_original_issue.py b/reproduce_original_issue.py
new file mode 100644
index 0000000000..19583f55f5
--- /dev/null
+++ b/reproduce_original_issue.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils import timezone
+
+# Create the exact models from the issue description
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False, verbose_name="filterable")
+    
+    class Meta:
+        app_label = "adminpricing"
+        verbose_name = "product meta data type"
+        verbose_name_plural = "product meta data types"
+    
+    def __str__(self):
+        return self.label
+
+class Product(models.Model):
+    name = models.CharField(max_length=255)
+    
+    class Meta:
+        app_label = "adminpricing"
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.ForeignKey(
+        Product, null=False, blank=False, on_delete=models.CASCADE
+    )
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    
+    class Meta:
+        app_label = "adminpricing"
+        verbose_name = "product meta data"
+        verbose_name_plural = "product meta datas"
+
+def test_original_issue():
+    """Test the original issue from GitHub"""
+    print("Testing the original issue scenario...")
+    
+    # Create database tables
+    from django.core.management import execute_from_command_line
+    from django.db import connection
+    connection.creation.create_test_db(verbosity=0)
+    
+    # Create test data
+    brand_metadata = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=True
+    )
+    
+    product = Product.objects.create(name="Test Product")
+    
+    ProductMetaData.objects.create(
+        product=product,
+        value="Dark Vador",
+        metadata_type=brand_metadata
+    )
+    
+    print("Attempting to filter ProductMetaData with metadata_type...")
+    try:
+        # This should work now with our fix
+        result = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=brand_metadata
+        )
+        print("✓ SUCCESS: Filter worked without error!")
+        print(f"Found {result.count()} results")
+        return True
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        print(f"Error type: {type(e)}")
+        return False
+
+if __name__ == "__main__":
+    success = test_original_issue()
+    if success:
+        print("\nTest completed successfully - issue is FIXED!")
+    else:
+        print("\nTest failed - issue still exists")
+        sys.exit(1)
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..425f1a17c3
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test to reproduce the issue
+def test_check_filterable():
+    """Test the check_filterable method directly"""
+    
+    # Create a mock object that has filterable=False attribute
+    class MockObject:
+        def __init__(self, filterable=True):
+            self.filterable = filterable
+    
+    # Create a Query instance
+    query = Query(models.Model)
+    
+    # Test with filterable=True (should work)
+    obj1 = MockObject(filterable=True)
+    try:
+        query.check_filterable(obj1)
+        print("✓ filterable=True works correctly")
+    except Exception as e:
+        print(f"✗ Unexpected error with filterable=True: {e}")
+    
+    # Test with filterable=False (should raise NotSupportedError)
+    obj2 = MockObject(filterable=False)
+    try:
+        query.check_filterable(obj2)
+        print("✗ filterable=False should have raised an error but didn't")
+    except Exception as e:
+        print(f"✓ filterable=False correctly raises: {e}")
+    
+    # Test with a model instance that has filterable field
+    class TestModel(models.Model):
+        filterable = models.BooleanField(default=False)
+        
+        class Meta:
+            app_label = "test"
+    
+    test_instance = TestModel()
+    try:
+        query.check_filterable(test_instance)
+        print("✗ Model instance with filterable field should have raised an error but didn't")
+    except Exception as e:
+        print(f"✓ Model instance with filterable field correctly raises: {e}")
+
+if __name__ == "__main__":
+    print("Testing check_filterable method...")
+    test_check_filterable()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..87fc8c3e8b
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression, F
+
+def test_edge_cases():
+    """Test edge cases for the filterable fix"""
+    print("Testing edge cases...")
+    
+    query = Query(models.Model)
+    
+    # Test 1: None value
+    try:
+        query.check_filterable(None)
+        print("✓ None value correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ None value incorrectly raises error: {e}")
+        return False
+    
+    # Test 2: String value
+    try:
+        query.check_filterable("test")
+        print("✓ String value correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ String value incorrectly raises error: {e}")
+        return False
+    
+    # Test 3: Integer value
+    try:
+        query.check_filterable(123)
+        print("✓ Integer value correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Integer value incorrectly raises error: {e}")
+        return False
+    
+    # Test 4: Django F expression (should work)
+    try:
+        f_expr = F('some_field')
+        query.check_filterable(f_expr)
+        print("✓ F expression correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ F expression incorrectly raises error: {e}")
+        return False
+    
+    # Test 5: Object with no filterable attribute
+    class NoFilterableAttr:
+        pass
+    
+    try:
+        obj = NoFilterableAttr()
+        query.check_filterable(obj)
+        print("✓ Object without filterable attribute correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Object without filterable attribute incorrectly raises error: {e}")
+        return False
+    
+    # Test 6: Object with filterable=None
+    class FilterableNone:
+        filterable = None
+    
+    try:
+        obj = FilterableNone()
+        query.check_filterable(obj)
+        print("✓ Object with filterable=None correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Object with filterable=None incorrectly raises error: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_edge_cases()
+    if success:
+        print("\nAll edge case tests passed!")
+    else:
+        print("\nSome edge case tests failed")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_query_building.py b/test_query_building.py
new file mode 100644
index 0000000000..b4c941314c
--- /dev/null
+++ b/test_query_building.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression
+
+def test_query_building():
+    """Test that query building works correctly with our fix"""
+    print("Testing query building functionality...")
+    
+    # Test 1: BaseExpression with filterable=False should raise error
+    class NonFilterableExpression(BaseExpression):
+        filterable = False
+    
+    expr = NonFilterableExpression()
+    query = Query(models.Model)
+    
+    try:
+        query.check_filterable(expr)
+        print("✗ Non-filterable expression should have raised error")
+        return False
+    except Exception as e:
+        if "disallowed in the filter clause" in str(e):
+            print("✓ Non-filterable expression correctly raises error")
+        else:
+            print(f"✗ Unexpected error: {e}")
+            return False
+    
+    # Test 2: Model instance with filterable field should NOT raise error
+    class TestModel(models.Model):
+        filterable = models.BooleanField(default=False)
+        
+        class Meta:
+            app_label = "test"
+    
+    model_instance = TestModel()
+    try:
+        query.check_filterable(model_instance)
+        print("✓ Model instance with filterable field correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Model instance incorrectly raises error: {e}")
+        return False
+    
+    # Test 3: Regular object with filterable attribute should NOT raise error
+    class RegularObject:
+        def __init__(self, filterable):
+            self.filterable = filterable
+    
+    regular_obj = RegularObject(filterable=False)
+    try:
+        query.check_filterable(regular_obj)
+        print("✓ Regular object with filterable attribute correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Regular object incorrectly raises error: {e}")
+        return False
+    
+    # Test 4: BaseExpression with filterable=True should NOT raise error
+    class FilterableExpression(BaseExpression):
+        filterable = True
+    
+    filterable_expr = FilterableExpression()
+    try:
+        query.check_filterable(filterable_expr)
+        print("✓ Filterable expression correctly does NOT raise error")
+    except Exception as e:
+        print(f"✗ Filterable expression incorrectly raises error: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_query_building()
+    if success:
+        print("\nAll query building tests passed - fix is working correctly!")
+    else:
+        print("\nSome tests failed")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_realistic_scenario.py b/test_realistic_scenario.py
new file mode 100644
index 0000000000..3ba9b2933d
--- /dev/null
+++ b/test_realistic_scenario.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression
+
+def test_realistic_scenario():
+    """Test a realistic scenario that mimics the original issue"""
+    print("Testing realistic scenario...")
+    
+    # Create model classes similar to the original issue
+    class ProductMetaDataType(models.Model):
+        label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+        filterable = models.BooleanField(default=False, verbose_name="filterable")
+        
+        class Meta:
+            app_label = "adminpricing"
+    
+    class ProductMetaData(models.Model):
+        metadata_type = models.ForeignKey(
+            ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+        )
+        value = models.TextField(null=False, blank=False)
+        
+        class Meta:
+            app_label = "adminpricing"
+    
+    # Create a model instance with filterable field (like in the original issue)
+    metadata_instance = ProductMetaDataType(label="Brand", filterable=True)
+    
+    # Create a query for ProductMetaData
+    query = Query(ProductMetaData)
+    
+    # Simulate what happens during query building when filtering by metadata_type
+    # The check_filterable method would be called on the metadata_instance
+    try:
+        query.check_filterable(metadata_instance)
+        print("✓ Model instance with filterable field correctly does NOT raise error during query building")
+        
+        # Test that we can also build a simple filter condition
+        from django.db.models import Q
+        condition = Q(metadata_type=metadata_instance)
+        
+        # The condition building should work without issues
+        print("✓ Query condition building works correctly")
+        return True
+        
+    except Exception as e:
+        print(f"✗ Error during query building: {e}")
+        return False
+
+if __name__ == "__main__":
+    success = test_realistic_scenario()
+    if success:
+        print("\nRealistic scenario test passed - the original issue is FIXED!")
+    else:
+        print("\nRealistic scenario test failed")
+        sys.exit(1)
\ No newline at end of file