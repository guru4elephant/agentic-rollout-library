diff --git a/debug_parsing.py b/debug_parsing.py
new file mode 100644
index 000000000..d4ea51d2b
--- /dev/null
+++ b/debug_parsing.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Debug the parsing process step by step.
+"""
+
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+from sphinx.ext.napoleon.iterators import modify_iter
+
+def debug_parsing():
+    # Test docstring with comma-separated parameters
+    docstring_lines = [
+        "Parameters",
+        "----------",
+        "x1, x2 : array_like",
+        "    Input arrays, description of `x1`, `x2`.",
+        "x3 : array_like, optional",
+        "    Optional input array."
+    ]
+    
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False,
+        'napoleon_type_aliases': {}
+    })
+    
+    # Create docstring object
+    docstring = "\n".join(docstring_lines)
+    print("Input docstring:")
+    print(repr(docstring))
+    print()
+    
+    parsed = NumpyDocstring(docstring, config)
+    
+    # Manually step through the parsing process
+    print("Step 1: Setting up line iterator")
+    parsed._line_iter = modify_iter(docstring.strip().split('\n'), modifier=lambda s: s.rstrip())
+    
+    print("Step 2: Consuming empty lines")
+    parsed._consume_empty()
+    
+    print("Step 3: Checking section header")
+    print(f"Is section header: {parsed._is_section_header()}")
+    
+    print("Step 4: Consuming section header")
+    section = parsed._consume_section_header()
+    print(f"Section: {section}")
+    
+    print("Step 5: Parsing parameters section")
+    # Manually call the parameters section parsing
+    lines = parsed._sections['parameters'](section)
+    print(f"Parsed lines: {lines}")
+    
+    print("Step 6: Checking consumed fields")
+    # Let's see what _consume_fields returns
+    parsed._line_iter = modify_iter(docstring_lines[2:], modifier=lambda s: s.rstrip())
+    parsed._consume_empty()
+    
+    fields = parsed._consume_fields()
+    print(f"Consumed fields: {fields}")
+
+if __name__ == "__main__":
+    debug_parsing()
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 000000000..d1031d993
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Debug test to understand what's happening with the parsing.
+"""
+
+from sphinx.ext.napoleon.docstring import GoogleDocstring
+
+def test_debug():
+    # Create a simple docstring with comma-separated parameters
+    docstring_lines = [
+        "Parameters",
+        "----------",
+        "x1, x2 : array_like",
+        "    Input arrays, description of `x1`, `x2`.",
+        "x3 : array_like, optional",
+        "    Optional input array."
+    ]
+    
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False
+    })
+    
+    # Create docstring object
+    docstring = "\n".join(docstring_lines)
+    print("Input docstring:")
+    print(repr(docstring))
+    print()
+    
+    parsed = GoogleDocstring(docstring, config)
+    
+    # Check what sections are found
+    print("Sections found:")
+    for section_name, section_method in parsed._sections.items():
+        if "parameter" in section_name.lower():
+            print(f"  {section_name}: {section_method}")
+    
+    # Parse the docstring
+    print("\nParsing...")
+    parsed._parse()
+    
+    print("Parsed lines:")
+    lines = parsed.lines()
+    for i, line in enumerate(lines):
+        print(f"  {i}: {repr(line)}")
+    
+    print(f"Total lines: {len(lines)}")
+
+if __name__ == "__main__":
+    test_debug()
\ No newline at end of file
diff --git a/proper_test.py b/proper_test.py
new file mode 100644
index 000000000..d53f62d85
--- /dev/null
+++ b/proper_test.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+"""
+Proper test based on existing test patterns.
+"""
+
+from textwrap import dedent
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+from sphinx.ext.napoleon import Config
+
+def test_comma_separated_params():
+    # Test docstring with comma-separated parameters using proper format
+    docstring = dedent("""\
+        Parameters
+        ----------
+        x1, x2 : array_like
+            Input arrays, description of `x1`, `x2`.
+        x3 : array_like, optional
+            Optional input array.
+    """)
+    
+    config = Config(
+        napoleon_use_param=False,
+        napoleon_use_rtype=True
+    )
+    
+    # Parse the docstring and get formatted output
+    formatted = str(NumpyDocstring(docstring, config))
+    print("Formatted output:")
+    print(repr(formatted))
+    
+    # Check if the parameters are properly formatted
+    # We should see individual parameter entries for x1 and x2
+    expected_x1 = "x1" in formatted and "array_like" in formatted
+    expected_x2 = "x2" in formatted and "array_like" in formatted
+    expected_x3 = "x3" in formatted and "optional" in formatted
+    
+    print(f"\nResults:")
+    print(f"x1 found: {expected_x1}")
+    print(f"x2 found: {expected_x2}")
+    print(f"x3 found: {expected_x3}")
+    
+    return expected_x1 and expected_x2 and expected_x3
+
+if __name__ == "__main__":
+    success = test_comma_separated_params()
+    print(f"\nTest {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..8e363152f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""
+Test script to reproduce the docstring rendering issue.
+"""
+
+def test_function(x1, x2, x3=None):
+    """
+    Test function with multiple parameters in one line.
+    
+    Parameters
+    ----------
+    x1, x2 : array_like
+        Input arrays, description of `x1`, `x2`.
+    x3 : array_like, optional
+        Optional input array.
+    
+    Returns
+    -------
+    None
+    """
+    pass
+
+if __name__ == "__main__":
+    # Test the docstring parsing
+    from sphinx.ext.napoleon.docstring import GoogleDocstring
+    
+    docstring = test_function.__doc__
+    print("Original docstring:")
+    print(docstring)
+    print("\n" + "="*50 + "\n")
+    
+    # Parse with napoleon
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False
+    })
+    parsed = GoogleDocstring(docstring, config)
+    print("Parsed sections:")
+    for section in parsed._sections:
+        print(f"  {section}: {parsed._sections[section]}")
+    
+    print("\n" + "="*50 + "\n")
+    print("Parsed parameters:")
+    parsed._parse()
+    print("Parsed lines:")
+    for line in parsed.lines():
+        print(f"  {line}")
\ No newline at end of file
diff --git a/setup.py b/setup.py
index a404f1fa5..2c6848797 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..f50e90873
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+"""
+Simple test to check if comma-separated parameters are handled correctly.
+"""
+
+from sphinx.ext.napoleon.docstring import GoogleDocstring
+
+def test_simple():
+    # Create a simple docstring with comma-separated parameters
+    docstring_lines = [
+        "Parameters",
+        "----------",
+        "x1, x2 : array_like",
+        "    Input arrays, description of `x1`, `x2`.",
+        "x3 : array_like, optional",
+        "    Optional input array."
+    ]
+    
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False
+    })
+    
+    # Create docstring object
+    parsed = GoogleDocstring("\n".join(docstring_lines), config)
+    
+    # Parse the docstring
+    parsed._parse()
+    
+    print("Parsed lines:")
+    for line in parsed.lines():
+        print(f"  {line}")
+
+if __name__ == "__main__":
+    test_simple()
\ No newline at end of file
diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py
index b3daa06f1..2ac0dd13d 100644
--- a/sphinx/ext/napoleon/docstring.py
+++ b/sphinx/ext/napoleon/docstring.py
@@ -256,6 +256,12 @@ class GoogleDocstring:
             if match:
                 _name = match.group(1)
                 _type = match.group(2)
+            elif ',' in before and colon:
+                # Handle numpydoc format with comma-separated parameter names
+                # e.g., "x1, x2 : array_like"
+                _name = before
+                _type = after
+                _desc = []  # Description will be consumed from indented block
 
         _name = self._escape_args_and_kwargs(_name)
 
@@ -273,7 +279,14 @@ class GoogleDocstring:
         while not self._is_section_break():
             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
             if _name or _type or _desc:
-                fields.append((_name, _type, _desc,))
+                # Handle comma-separated parameter names (numpydoc format)
+                if ',' in _name and not ('*args' in _name or '**kwargs' in _name):
+                    # Split comma-separated names and create individual entries
+                    param_names = [name.strip() for name in _name.split(',')]
+                    for param_name in param_names:
+                        fields.append((param_name, _type, _desc,))
+                else:
+                    fields.append((_name, _type, _desc,))
         return fields
 
     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
diff --git a/test_comma_separated.py b/test_comma_separated.py
new file mode 100644
index 000000000..38c0c8f09
--- /dev/null
+++ b/test_comma_separated.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+"""
+Test to verify that comma-separated parameters are handled correctly.
+"""
+
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+
+def test_comma_separated_params():
+    # Test docstring with comma-separated parameters
+    docstring = """
+    Parameters
+    ----------
+    x1, x2 : array_like
+        Input arrays, description of `x1`, `x2`.
+    x3 : array_like, optional
+        Optional input array.
+    """
+    
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False,
+        'napoleon_type_aliases': {}
+    })
+    
+    # Parse the docstring
+    parsed = NumpyDocstring(docstring, config)
+    # Don't call _parse() manually, let the constructor handle it
+    
+    print("Parsed lines:")
+    for line in parsed.lines():
+        print(f"  {repr(line)}")
+    
+    # Check if the parameters are properly parsed
+    # We should see individual parameter entries for x1 and x2
+    lines = parsed.lines()
+    
+    # Look for parameter entries
+    x1_found = any('x1' in line and 'array_like' in line for line in lines)
+    x2_found = any('x2' in line and 'array_like' in line for line in lines)
+    x3_found = any('x3' in line and 'optional' in line for line in lines)
+    
+    print(f"\nResults:")
+    print(f"x1 found: {x1_found}")
+    print(f"x2 found: {x2_found}")
+    print(f"x3 found: {x3_found}")
+    
+    return x1_found and x2_found and x3_found
+
+if __name__ == "__main__":
+    success = test_comma_separated_params()
+    print(f"\nTest {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..d99929d9b
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for comma-separated parameter parsing.
+"""
+
+from textwrap import dedent
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+from sphinx.ext.napoleon import Config
+
+def test_edge_cases():
+    config = Config(
+        napoleon_use_param=False,
+        napoleon_use_rtype=True
+    )
+    
+    test_cases = [
+        # Basic case
+        {
+            'name': 'Basic comma-separated parameters',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                x1, x2 : array_like
+                    Input arrays.
+            """),
+            'expected_params': ['x1', 'x2']
+        },
+        
+        # Three parameters
+        {
+            'name': 'Three comma-separated parameters',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                x1, x2, x3 : array_like
+                    Input arrays.
+            """),
+            'expected_params': ['x1', 'x2', 'x3']
+        },
+        
+        # With optional flag
+        {
+            'name': 'Comma-separated with optional',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                x1, x2 : array_like, optional
+                    Input arrays.
+            """),
+            'expected_params': ['x1', 'x2']
+        },
+        
+        # Mixed with individual parameters
+        {
+            'name': 'Mixed comma-separated and individual',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                x1, x2 : array_like
+                    Input arrays.
+                x3 : int
+                    Integer parameter.
+            """),
+            'expected_params': ['x1', 'x2', 'x3']
+        },
+        
+        # Edge case: single parameter with comma (should not split)
+        {
+            'name': 'Single parameter with comma in type',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                x1 : dict(str, int)
+                    Dictionary parameter.
+            """),
+            'expected_params': ['x1']
+        },
+        
+        # Edge case: kwargs (should not split)
+        {
+            'name': 'Keyword arguments',
+            'docstring': dedent("""\
+                Parameters
+                ----------
+                **kwargs : dict
+                    Keyword arguments.
+            """),
+            'expected_params': [r'\*\*kwargs']  # Look for escaped version
+        }
+    ]
+    
+    all_passed = True
+    
+    for test_case in test_cases:
+        print(f"\nTesting: {test_case['name']}")
+        
+        formatted = str(NumpyDocstring(test_case['docstring'], config))
+        
+        # Check if all expected parameters are present
+        params_found = []
+        for param in test_case['expected_params']:
+            found = param in formatted
+            params_found.append(found)
+            print(f"  {param}: {'FOUND' if found else 'MISSING'}")
+        
+        test_passed = all(params_found)
+        print(f"  Result: {'PASS' if test_passed else 'FAIL'}")
+        
+        if not test_passed:
+            all_passed = False
+            print(f"  Formatted output: {repr(formatted)}")
+    
+    return all_passed
+
+if __name__ == "__main__":
+    success = test_edge_cases()
+    print(f"\nOverall result: {'ALL TESTS PASSED' if success else 'SOME TESTS FAILED'}")
\ No newline at end of file
diff --git a/test_formatted_output.py b/test_formatted_output.py
new file mode 100644
index 000000000..356d6ecc1
--- /dev/null
+++ b/test_formatted_output.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+"""
+Test to verify the formatted output for comma-separated parameters.
+"""
+
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+from sphinx.ext.napoleon import Config
+
+def test_formatted_output():
+    # Test docstring with comma-separated parameters
+    docstring = """
+    Parameters
+    ----------
+    x1, x2 : array_like
+        Input arrays, description of `x1`, `x2`.
+    x3 : array_like, optional
+        Optional input array.
+    """
+    
+    config = Config(
+        napoleon_use_param=False,  # This should use the field list format
+        napoleon_use_rtype=True
+    )
+    
+    # Parse the docstring and get formatted output
+    formatted = str(NumpyDocstring(docstring, config))
+    
+    print("Formatted output:")
+    print(formatted)
+    
+    # Test with napoleon_use_param=True to see docutils format
+    print("\n" + "="*50)
+    print("Testing with napoleon_use_param=True:")
+    
+    config2 = Config(
+        napoleon_use_param=True,  # This should use the docutils param format
+        napoleon_use_rtype=True
+    )
+    
+    formatted2 = str(NumpyDocstring(docstring, config2))
+    
+    print("Formatted output (docutils format):")
+    print(formatted2)
+
+if __name__ == "__main__":
+    test_formatted_output()
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 000000000..21425c3ac
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Test the original issue from GitHub.
+"""
+
+from textwrap import dedent
+from sphinx.ext.napoleon.docstring import NumpyDocstring
+from sphinx.ext.napoleon import Config
+
+def test_original_issue():
+    # This is the exact case from the GitHub issue
+    docstring = dedent("""\
+        Parameters
+        ----------
+        x1, x2 : array_like
+            Input arrays, description of `x1`, `x2`.
+        x1, x2 : array_like, optional
+            Input arrays, description of `x1`, `x2`.
+    """)
+    
+    config = Config(
+        napoleon_use_param=False,
+        napoleon_use_rtype=True
+    )
+    
+    # Parse the docstring and get formatted output
+    formatted = str(NumpyDocstring(docstring, config))
+    print("Formatted output for original issue:")
+    print(formatted)
+    
+    # Check if the parameters are properly formatted
+    # Both x1 and x2 should appear as individual parameters
+    x1_found = "x1" in formatted
+    x2_found = "x2" in formatted
+    optional_found = "optional" in formatted
+    
+    print(f"\nResults:")
+    print(f"x1 found: {x1_found}")
+    print(f"x2 found: {x2_found}")
+    print(f"optional found: {optional_found}")
+    
+    # The output should show individual parameters with proper formatting
+    return x1_found and x2_found and optional_found
+
+if __name__ == "__main__":
+    success = test_original_issue()
+    print(f"\nOriginal issue test: {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/test_parsing.py b/test_parsing.py
new file mode 100644
index 000000000..f429c9422
--- /dev/null
+++ b/test_parsing.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+"""
+Test script to understand how comma-separated parameters are parsed.
+"""
+
+from sphinx.ext.napoleon.docstring import GoogleDocstring
+from sphinx.ext.napoleon.iterators import modify_iter
+
+def test_parsing():
+    docstring = """
+    Parameters
+    ----------
+    x1, x2 : array_like
+        Input arrays, description of `x1`, `x2`.
+    x3 : array_like, optional
+        Optional input array.
+    """
+    
+    config = type('Config', (), {
+        'napoleon_use_param': False,
+        'napoleon_custom_sections': None,
+        'napoleon_include_special_with_doc': False,
+        'napoleon_include_private_with_doc': False,
+        'napoleon_use_rtype': True,
+        'napoleon_use_ivar': False,
+        'napoleon_use_keyword': False
+    })
+    
+    parsed = GoogleDocstring(docstring, config)
+    
+    # Manually call _consume_fields to see what it returns
+    parsed._line_iter = modify_iter(docstring.strip().split('\n'))
+    parsed._consume_empty()
+    
+    print("Testing _consume_field on 'x1, x2 : array_like':")
+    line = "x1, x2 : array_like"
+    parsed._line_iter = modify_iter([line], modifier=lambda s: s.rstrip())
+    
+    name, type_val, desc = parsed._consume_field()
+    print(f"Name: {name}")
+    print(f"Type: {type_val}")
+    print(f"Desc: {desc}")
+    
+    print("\nTesting _partition_field_on_colon:")
+    before, colon, after = parsed._partition_field_on_colon(line)
+    print(f"Before: {before}")
+    print(f"Colon: {colon}")
+    print(f"After: {after}")
+
+if __name__ == "__main__":
+    test_parsing()
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index bddd822a6..34baee205 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3