diff --git a/astropy/units/decorators.py b/astropy/units/decorators.py
index 8bece5a850..47b5430e07 100644
--- a/astropy/units/decorators.py
+++ b/astropy/units/decorators.py
@@ -221,6 +221,9 @@ class QuantityInput:
             with add_enabled_equivalencies(self.equivalencies):
                 return_ = wrapped_function(*func_args, **func_kwargs)
             if wrapped_signature.return_annotation is not inspect.Signature.empty:
+                # If the function returns None (e.g., constructors), don't try to convert it
+                if return_ is None:
+                    return return_
                 return return_.to(wrapped_signature.return_annotation)
             else:
                 return return_
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..fda94311af
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,45 @@
+import astropy.units as u
+
+
+class TestConstructor(object):
+    """Test class with constructor that has -> None return annotation"""
+
+    @u.quantity_input
+    def __init__(self, voltage: u.V) -> None:
+        self.voltage = voltage
+
+
+class TestNormalMethod(object):
+    """Test class with normal method that has return annotation"""
+
+    def __init__(self, voltage):
+        self.voltage = voltage
+
+    @u.quantity_input
+    def method_with_return(self, current: u.A) -> u.W:
+        return self.voltage * current
+
+
+if __name__ == '__main__':
+    # Test the original issue case
+    print("Testing constructor with -> None annotation...")
+    test1 = TestConstructor(5.0 * u.V)
+    print("✓ Constructor test passed")
+    
+    # Test normal method with return annotation
+    print("Testing normal method with return annotation...")
+    test2 = TestNormalMethod(5.0 * u.V)
+    result = test2.method_with_return(2.0 * u.A)
+    print(f"✓ Normal method test passed: {result}")
+    
+    # Test that None return values work with annotations
+    print("Testing explicit None return with annotation...")
+    
+    @u.quantity_input
+    def explicit_none_return(dummy: u.A) -> u.V:
+        return None
+    
+    result = explicit_none_return(1.0 * u.A)
+    print(f"✓ Explicit None return test passed: {result}")
+    
+    print("All tests completed successfully!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..cc943f0261
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,12 @@
+import astropy.units as u
+
+
+class PoC(object):
+
+    @u.quantity_input
+    def __init__(self, voltage: u.V) -> None:
+        pass
+
+
+if __name__ == '__main__':
+    poc = PoC(1.*u.V)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d152681a54
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,32 @@
+import astropy.units as u
+
+
+class TestClass(object):
+
+    @u.quantity_input
+    def __init__(self, voltage: u.V) -> None:
+        self.voltage = voltage
+
+    @u.quantity_input
+    def method_with_return(self, current: u.A) -> u.W:  # Change to watts (V*A)
+        return self.voltage * current
+
+    @u.quantity_input
+    def method_without_return_annotation(self, resistance: u.ohm):
+        return self.voltage / resistance
+
+
+if __name__ == '__main__':
+    # Test constructor with None return (should work now)
+    test_obj = TestClass(1.*u.V)
+    print("Constructor test passed")
+    
+    # Test method with return annotation (should still work)
+    result = test_obj.method_with_return(2.*u.A)
+    print(f"Method with return annotation test passed: {result}")
+    
+    # Test method without return annotation (should still work)
+    result2 = test_obj.method_without_return_annotation(0.5*u.ohm)
+    print(f"Method without return annotation test passed: {result2}")
+    
+    print("All tests passed!")
\ No newline at end of file
diff --git a/test_none_return.py b/test_none_return.py
new file mode 100644
index 0000000000..0f4f320102
--- /dev/null
+++ b/test_none_return.py
@@ -0,0 +1,34 @@
+import astropy.units as u
+
+
+class TestNoneReturn(object):
+
+    @u.quantity_input
+    def __init__(self, value: u.V) -> None:
+        self.value = value
+
+    @u.quantity_input
+    def explicit_none_return(self, dummy: u.A) -> u.V:
+        # This function explicitly returns None but has a return annotation
+        return None
+
+    @u.quantity_input
+    def normal_return(self, multiplier: u.dimensionless_unscaled) -> u.V:
+        # This function returns a value with the annotated unit
+        return self.value * multiplier
+
+
+if __name__ == '__main__':
+    # Test constructor
+    test_obj = TestNoneReturn(5.*u.V)
+    print("Constructor test passed")
+    
+    # Test explicit None return with annotation
+    result = test_obj.explicit_none_return(1.*u.A)
+    print(f"Explicit None return test passed: {result}")
+    
+    # Test normal return with annotation
+    result2 = test_obj.normal_return(2.0 * u.dimensionless_unscaled)
+    print(f"Normal return test passed: {result2}")
+    
+    print("All tests passed!")
\ No newline at end of file