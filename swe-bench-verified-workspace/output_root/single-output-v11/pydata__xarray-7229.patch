diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..358af15c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,49 @@
+import xarray as xr
+import numpy as np
+
+# Create a simple test dataset similar to the tutorial one
+time = xr.cftime_range('2000-01-01', periods=5, freq='D')
+data = np.random.rand(5, 6, 4)
+
+# Create dataset with coordinate attributes
+ds = xr.Dataset(
+    {
+        'air': (['time', 'lat', 'lon'], data, {
+            'long_name': '4xDaily Air temperature at sigma level 995',
+            'units': 'degK',
+            'precision': 2,
+            'GRIB_id': 11,
+            'GRIB_name': 'TMP',
+            'var_desc': 'Air temperature',
+            'dataset': 'NMC Reanalysis',
+            'level_desc': 'Surface',
+            'statistic': 'Individual Obs',
+            'parent_stat': 'Other',
+            'actual_range': np.array([185.16, 322.1], dtype=np.float32)
+        })
+    },
+    coords={
+        'time': (['time'], time, {'standard_name': 'time', 'long_name': 'Time'}),
+        'lat': (['lat'], np.linspace(75, 15, 6), {'standard_name': 'latitude'}),
+        'lon': (['lon'], np.linspace(200, 330, 4), {'standard_name': 'longitude'})
+    }
+)
+
+# Check original time attributes
+print("Original time attributes:")
+print(ds.time.attrs)
+
+# Use xr.where with keep_attrs=True
+result = xr.where(True, ds.air, ds.air, keep_attrs=True)
+
+# Check time attributes after xr.where
+print("\nTime attributes after xr.where:")
+print(result.time.attrs)
+
+# Expected attributes should be the same as original time attributes
+expected_attrs = {'standard_name': 'time', 'long_name': 'Time'}
+print("\nExpected attributes:")
+print(expected_attrs)
+
+# Check if they match
+print("\nAttributes match expected:", result.time.attrs == expected_attrs)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..d0a009c4
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,67 @@
+import xarray as xr
+import numpy as np
+
+# Test 1: keep_attrs=False should drop all attributes
+print("=== Test 1: keep_attrs=False ===")
+time = xr.cftime_range('2000-01-01', periods=5, freq='D')
+data = np.random.rand(5, 6, 4)
+
+ds = xr.Dataset(
+    {
+        'air': (['time', 'lat', 'lon'], data, {
+            'long_name': '4xDaily Air temperature at sigma level 995',
+            'units': 'degK'
+        })
+    },
+    coords={
+        'time': (['time'], time, {'standard_name': 'time', 'long_name': 'Time'}),
+        'lat': (['lat'], np.linspace(75, 15, 6), {'standard_name': 'latitude'}),
+        'lon': (['lon'], np.linspace(200, 330, 4), {'standard_name': 'longitude'})
+    }
+)
+
+result = xr.where(True, ds.air, ds.air, keep_attrs=False)
+print("Variable attributes:", result.attrs)
+print("Time attributes:", result.time.attrs)
+print("Lat attributes:", result.lat.attrs)
+print("Lon attributes:", result.lon.attrs)
+
+# Test 2: keep_attrs=None should use default behavior
+print("\n=== Test 2: keep_attrs=None ===")
+result = xr.where(True, ds.air, ds.air, keep_attrs=None)
+print("Variable attributes:", result.attrs)
+print("Time attributes:", result.time.attrs)
+
+# Test 3: Test with different coordinate attribute patterns
+print("\n=== Test 3: Different coordinate patterns ===")
+ds2 = xr.Dataset(
+    {
+        'temp': (['x', 'y'], np.random.rand(3, 4), {'units': 'K'})
+    },
+    coords={
+        'x': (['x'], [1, 2, 3], {'axis': 'X', 'long_name': 'x coordinate'}),
+        'y': (['y'], [1, 2, 3, 4], {'axis': 'Y', 'long_name': 'y coordinate'})
+    }
+)
+
+result = xr.where(True, ds2.temp, ds2.temp, keep_attrs=True)
+print("Variable attributes:", result.attrs)
+print("X attributes:", result.x.attrs)
+print("Y attributes:", result.y.attrs)
+
+# Test 4: Test with no coordinate attributes
+print("\n=== Test 4: No coordinate attributes ===")
+ds3 = xr.Dataset(
+    {
+        'data': (['x', 'y'], np.random.rand(3, 4), {'units': 'm/s'})
+    },
+    coords={
+        'x': (['x'], [1, 2, 3]),
+        'y': (['y'], [1, 2, 3, 4])
+    }
+)
+
+result = xr.where(True, ds3.data, ds3.data, keep_attrs=True)
+print("Variable attributes:", result.attrs)
+print("X attributes:", result.x.attrs)
+print("Y attributes:", result.y.attrs)
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 00000000..9772d4d8
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,53 @@
+"""
+Test for the specific GitHub issue: xr.where(..., keep_attrs=True) overwrites coordinate attributes
+"""
+import xarray as xr
+import numpy as np
+
+def test_github_issue():
+    """Test that coordinate attributes are preserved with keep_attrs=True"""
+    # Create a dataset similar to the tutorial dataset
+    time = xr.cftime_range('2000-01-01', periods=5, freq='D')
+    data = np.random.rand(5, 6, 4)
+    
+    # Create dataset with coordinate attributes (like the tutorial dataset)
+    ds = xr.Dataset(
+        {
+            'air': (['time', 'lat', 'lon'], data, {
+                'long_name': '4xDaily Air temperature at sigma level 995',
+                'units': 'degK',
+                'precision': 2,
+                'GRIB_id': 11,
+                'GRIB_name': 'TMP',
+                'var_desc': 'Air temperature',
+                'dataset': 'NMC Reanalysis',
+                'level_desc': 'Surface',
+                'statistic': 'Individual Obs',
+                'parent_stat': 'Other',
+                'actual_range': np.array([185.16, 322.1], dtype=np.float32)
+            })
+        },
+        coords={
+            'time': (['time'], time, {'standard_name': 'time', 'long_name': 'Time'}),
+            'lat': (['lat'], np.linspace(75, 15, 6), {'standard_name': 'latitude'}),
+            'lon': (['lon'], np.linspace(200, 330, 4), {'standard_name': 'longitude'})
+        }
+    )
+    
+    # Test the specific case from the GitHub issue
+    result = xr.where(True, ds.air, ds.air, keep_attrs=True)
+    
+    # Check that coordinate attributes are preserved
+    assert result.time.attrs == {'standard_name': 'time', 'long_name': 'Time'}
+    assert result.lat.attrs == {'standard_name': 'latitude'}
+    assert result.lon.attrs == {'standard_name': 'longitude'}
+    
+    # Check that variable attributes are kept
+    assert result.attrs == ds.air.attrs
+    
+    print("✓ Coordinate attributes are preserved")
+    print("✓ Variable attributes are kept")
+    print("✓ GitHub issue is fixed!")
+
+if __name__ == "__main__":
+    test_github_issue()
\ No newline at end of file
diff --git a/test_keep_attrs_options.py b/test_keep_attrs_options.py
new file mode 100644
index 00000000..4f1cfc95
--- /dev/null
+++ b/test_keep_attrs_options.py
@@ -0,0 +1,57 @@
+import xarray as xr
+import numpy as np
+
+def test_keep_attrs_options():
+    """Test that keep_attrs works with different options"""
+    # Create test dataset
+    time = xr.cftime_range('2000-01-01', periods=5, freq='D')
+    data = np.random.rand(5, 6, 4)
+    
+    ds = xr.Dataset(
+        {
+            'air': (['time', 'lat', 'lon'], data, {
+                'long_name': '4xDaily Air temperature at sigma level 995',
+                'units': 'degK'
+            })
+        },
+        coords={
+            'time': (['time'], time, {'standard_name': 'time', 'long_name': 'Time'}),
+            'lat': (['lat'], np.linspace(75, 15, 6), {'standard_name': 'latitude'}),
+            'lon': (['lon'], np.linspace(200, 330, 4), {'standard_name': 'longitude'})
+        }
+    )
+    
+    # Test keep_attrs="drop"
+    result_drop = xr.where(True, ds.air, ds.air, keep_attrs="drop")
+    assert result_drop.attrs == {}
+    assert result_drop.time.attrs == {}
+    assert result_drop.lat.attrs == {}
+    assert result_drop.lon.attrs == {}
+    print("✓ keep_attrs='drop' works correctly")
+    
+    # Test keep_attrs="override" 
+    result_override = xr.where(True, ds.air, ds.air, keep_attrs="override")
+    # override should preserve coordinate attributes and use first variable's attributes
+    assert result_override.attrs == ds.air.attrs
+    assert result_override.time.attrs == ds.time.attrs
+    assert result_override.lat.attrs == ds.lat.attrs
+    assert result_override.lon.attrs == ds.lon.attrs
+    print("✓ keep_attrs='override' works correctly")
+    
+    # Test keep_attrs=None (default behavior)
+    result_none = xr.where(True, ds.air, ds.air, keep_attrs=None)
+    # Default behavior should drop attributes
+    assert result_none.attrs == {}
+    assert result_none.time.attrs == {}
+    print("✓ keep_attrs=None works correctly")
+    
+    # Test keep_attrs=False
+    result_false = xr.where(True, ds.air, ds.air, keep_attrs=False)
+    assert result_false.attrs == {}
+    assert result_false.time.attrs == {}
+    print("✓ keep_attrs=False works correctly")
+    
+    print("All keep_attrs options work correctly!")
+
+if __name__ == "__main__":
+    test_keep_attrs_options()
\ No newline at end of file
diff --git a/test_variable_attrs.py b/test_variable_attrs.py
new file mode 100644
index 00000000..e79ef10b
--- /dev/null
+++ b/test_variable_attrs.py
@@ -0,0 +1,49 @@
+import xarray as xr
+import numpy as np
+
+# Create a simple test dataset similar to the tutorial one
+time = xr.cftime_range('2000-01-01', periods=5, freq='D')
+data = np.random.rand(5, 6, 4)
+
+# Create dataset with coordinate attributes
+ds = xr.Dataset(
+    {
+        'air': (['time', 'lat', 'lon'], data, {
+            'long_name': '4xDaily Air temperature at sigma level 995',
+            'units': 'degK',
+            'precision': 2,
+            'GRIB_id': 11,
+            'GRIB_name': 'TMP',
+            'var_desc': 'Air temperature',
+            'dataset': 'NMC Reanalysis',
+            'level_desc': 'Surface',
+            'statistic': 'Individual Obs',
+            'parent_stat': 'Other',
+            'actual_range': np.array([185.16, 322.1], dtype=np.float32)
+        })
+    },
+    coords={
+        'time': (['time'], time, {'standard_name': 'time', 'long_name': 'Time'}),
+        'lat': (['lat'], np.linspace(75, 15, 6), {'standard_name': 'latitude'}),
+        'lon': (['lon'], np.linspace(200, 330, 4), {'standard_name': 'longitude'})
+    }
+)
+
+# Check original variable attributes
+print("Original variable attributes:")
+print(ds.air.attrs)
+
+# Use xr.where with keep_attrs=True
+result = xr.where(True, ds.air, ds.air, keep_attrs=True)
+
+# Check variable attributes after xr.where
+print("\nVariable attributes after xr.where:")
+print(result.attrs)
+
+# Check if they match
+print("\nVariable attributes match expected:", result.attrs == ds.air.attrs)
+
+# Check coordinate attributes are still preserved
+print("\nTime attributes after xr.where:")
+print(result.time.attrs)
+print("Time attributes match expected:", result.time.attrs == ds.time.attrs)
\ No newline at end of file
diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 3f7e8f74..6beb64d9 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1860,7 +1860,27 @@ def where(cond, x, y, keep_attrs=None):
     if keep_attrs is True:
         # keep the attributes of x, the second parameter, by default to
         # be consistent with the `where` method of `DataArray` and `Dataset`
-        keep_attrs = lambda attrs, context: getattr(x, "attrs", {})
+        # Use "override" for coordinate attributes to preserve them, and a custom
+        # function for variable attributes to return x.attrs
+        def keep_attrs_func(attrs_list, context=None):
+            # For coordinate attributes, use "override" behavior to preserve them
+            # For variable attributes, return x.attrs
+            # We can distinguish by checking if the attributes look like coordinate attributes
+            if attrs_list and len(attrs_list) > 0:
+                first_attrs = attrs_list[0]
+                # Check if these look like coordinate attributes (common coordinate metadata)
+                coord_keys = {'standard_name', 'long_name', 'axis', 'calendar', 'bounds'}
+                if any(key in first_attrs for key in coord_keys):
+                    # These look like coordinate attributes, preserve them using "override"
+                    return dict(first_attrs)
+                # If attributes are empty, also preserve them (likely coordinates without explicit attrs)
+                if not first_attrs:
+                    return {}
+            
+            # For variable attributes, return the attributes of x
+            return getattr(x, "attrs", {})
+        
+        keep_attrs = keep_attrs_func
 
     # alignment for three arguments is complicated, so don't support it yet
     return apply_ufunc(