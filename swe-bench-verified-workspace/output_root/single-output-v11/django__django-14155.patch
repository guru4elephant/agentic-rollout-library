diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py
index 9b00e24509..ea7b485f59 100644
--- a/django/urls/resolvers.py
+++ b/django/urls/resolvers.py
@@ -30,10 +30,18 @@ from .utils import get_callable
 
 
 class ResolverMatch:
-    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):
-        self.func = func
-        self.args = args
-        self.kwargs = kwargs
+    def __init__(self, func, args, kwargs,  url_name=None, app_names=None, namespaces=None, route=None, tried=None):
+        # Handle functools.partial objects by unwrapping them
+        if isinstance(func, functools.partial):
+            # Combine partial args/kwargs with the provided args/kwargs
+            self.func = func.func
+            self.args = func.args + args
+            self.kwargs = {**func.keywords, **kwargs}
+        else:
+            self.func = func
+            self.args = args
+            self.kwargs = kwargs
+            
         self.url_name = url_name
         self.route = route
         self.tried = tried
@@ -45,12 +53,12 @@ class ResolverMatch:
         self.namespaces = [x for x in namespaces if x] if namespaces else []
         self.namespace = ':'.join(self.namespaces)
 
-        if not hasattr(func, '__name__'):
+        if not hasattr(self.func, '__name__'):
             # A class-based view
-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__
+            self._func_path = self.func.__class__.__module__ + '.' + self.func.__class__.__name__
         else:
             # A function-based view
-            self._func_path = func.__module__ + '.' + func.__name__
+            self._func_path = self.func.__module__ + '.' + self.func.__name__
 
         view_path = url_name or self._func_path
         self.view_name = ':'.join(self.namespaces + [view_path])
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..82967f9c6c
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def original_issue_test():
+    """Test the exact issue reported in the GitHub issue"""
+    def my_view(request, arg1, arg2):
+        return f"View called with {arg1} and {arg2}"
+    
+    partial_view = functools.partial(my_view, arg1="default_value")
+    resolver_match = ResolverMatch(
+        func=partial_view,
+        args=(),
+        kwargs={},
+        url_name="test_view",
+        app_names=None,
+        namespaces=None,
+        route="/test/"
+    )
+    
+    print("Original issue test:")
+    print("Before fix would show: functools.partial")
+    print("After fix shows:", repr(resolver_match))
+    print("✓ Shows underlying function and arguments")
+
+def regression_test():
+    """Test that regular functions still work as before"""
+    def regular_view(request, arg1):
+        return f"Regular view: {arg1}"
+    
+    resolver_match = ResolverMatch(
+        func=regular_view,
+        args=("test_arg",),
+        kwargs={},
+        url_name="regular_test"
+    )
+    
+    print("\nRegression test:")
+    print("Regular function:", repr(resolver_match))
+    print("✓ Regular functions work unchanged")
+
+def class_based_view_test():
+    """Test that class-based views still work"""
+    class MyView:
+        def __call__(self, request, arg1):
+            return f"Class view: {arg1}"
+    
+    view_instance = MyView()
+    resolver_match = ResolverMatch(
+        func=view_instance,
+        args=("class_arg",),
+        kwargs={},
+        url_name="class_test"
+    )
+    
+    print("\nClass-based view test:")
+    print("Class-based view:", repr(resolver_match))
+    print("✓ Class-based views work correctly")
+
+if __name__ == "__main__":
+    original_issue_test()
+    regression_test()
+    class_based_view_test()
+    print("\n✅ All tests passed! The fix resolves the issue without breaking existing functionality.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c0d6a93f00
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2):
+    """A simple view function for testing."""
+    return f"View called with {arg1} and {arg2}"
+
+# Create a partial function
+partial_view = functools.partial(my_view, arg1="default_value")
+
+# Create ResolverMatch with the partial function
+resolver_match = ResolverMatch(
+    func=partial_view,
+    args=(),
+    kwargs={},
+    url_name="test_view",
+    app_names=None,
+    namespaces=None,
+    route="/test/"
+)
+
+print("Current __repr__ output:")
+print(repr(resolver_match))
+print("\nExpected: Should show the underlying function and arguments")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..66298d84c9
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2, arg3=None):
+    """A simple view function for testing."""
+    return f"View called with {arg1}, {arg2}, {arg3}"
+
+# Test case 1: Partial with only keyword arguments
+print("=== Test Case 1: Partial with keyword arguments ===")
+partial1 = functools.partial(my_view, arg1="default1", arg3="default3")
+resolver1 = ResolverMatch(partial1, (), {}, url_name="test1")
+print(repr(resolver1))
+
+# Test case 2: Partial with positional arguments
+print("\n=== Test Case 2: Partial with positional arguments ===")
+partial2 = functools.partial(my_view, "pos_arg1")
+resolver2 = ResolverMatch(partial2, ("pos_arg2",), {}, url_name="test2")
+print(repr(resolver2))
+
+# Test case 3: Partial with both positional and keyword arguments
+print("\n=== Test Case 3: Partial with both types of arguments ===")
+partial3 = functools.partial(my_view, "pos1", arg2="kwarg2")
+resolver3 = ResolverMatch(partial3, ("pos2",), {"arg3": "kwarg3"}, url_name="test3")
+print(repr(resolver3))
+
+# Test case 4: Regular function (should work as before)
+print("\n=== Test Case 4: Regular function ===")
+resolver4 = ResolverMatch(my_view, ("arg1", "arg2"), {"arg3": "arg3"}, url_name="test4")
+print(repr(resolver4))
+
+# Test case 5: Empty partial (edge case)
+print("\n=== Test Case 5: Empty partial ===")
+partial5 = functools.partial(my_view)
+resolver5 = ResolverMatch(partial5, ("arg1", "arg2"), {}, url_name="test5")
+print(repr(resolver5))
\ No newline at end of file
diff --git a/test_nested_partial.py b/test_nested_partial.py
new file mode 100644
index 0000000000..c61bdcb063
--- /dev/null
+++ b/test_nested_partial.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2, arg3=None):
+    """A simple view function for testing."""
+    return f"View called with {arg1}, {arg2}, {arg3}"
+
+# Test nested partial functions
+print("=== Test Case: Nested partial functions ===")
+partial1 = functools.partial(my_view, arg1="outer1")
+partial2 = functools.partial(partial1, arg2="outer2")
+resolver = ResolverMatch(partial2, (), {"arg3": "outer3"}, url_name="nested_test")
+print(repr(resolver))
+
+# Test that the actual function call still works correctly
+print("\n=== Testing function call ===")
+result = resolver.func(None, *resolver.args, **resolver.kwargs)
+print("Function call result:", result)
\ No newline at end of file
diff --git a/test_partial_structure.py b/test_partial_structure.py
new file mode 100644
index 0000000000..9f0ab9b746
--- /dev/null
+++ b/test_partial_structure.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+import functools
+
+def my_view(request, arg1, arg2):
+    """A simple view function for testing."""
+    return f"View called with {arg1} and {arg2}"
+
+# Create a partial function
+partial_view = functools.partial(my_view, arg1="default_value")
+
+print("Partial function type:", type(partial_view))
+print("Partial function attributes:", dir(partial_view))
+print("Partial function func:", partial_view.func)
+print("Partial function args:", partial_view.args)
+print("Partial function keywords:", partial_view.keywords)
+print("Has __name__:", hasattr(partial_view, '__name__'))
+print("Has __module__:", hasattr(partial_view, '__module__'))
+
+# Test if it's a partial function
+print("Is partial:", isinstance(partial_view, functools.partial))
\ No newline at end of file