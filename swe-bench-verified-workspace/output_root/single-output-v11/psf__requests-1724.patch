diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..0e661540
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import requests
+import sys
+
+print("Testing Unicode method names in requests...")
+print("Python version:", sys.version)
+
+# Test case 1: String method name (should work)
+print("\n1. Testing with string method name (method='POST'):")
+try:
+    files = {u'file': open('/usr/bin/diff', 'rb')}
+    response = requests.request(method='POST', url=u'http://httpbin.org/post', files=files)
+    print("SUCCESS: String method name works")
+except Exception as e:
+    print("ERROR with string method:", str(e))
+
+# Test case 2: Unicode method name (should fail according to issue)
+print("\n2. Testing with unicode method name (method=u'POST'):")
+try:
+    files = {u'file': open('/usr/bin/diff', 'rb')}
+    response = requests.request(method=u'POST', url=u'http://httpbin.org/post', files=files)
+    print("SUCCESS: Unicode method name works")
+except Exception as e:
+    print("ERROR with unicode method:", str(e))
+    print("Exception type:", type(e).__name__)
\ No newline at end of file
diff --git a/requests/models.py b/requests/models.py
index f82f56a3..d87ad106 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -307,7 +307,7 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
         """Prepares the given HTTP method."""
         self.method = method
         if self.method is not None:
-            self.method = self.method.upper()
+            self.method = to_native_string(self.method).upper()
 
     def prepare_url(self, url, params):
         """Prepares the given HTTP URL."""
diff --git a/requests/sessions.py b/requests/sessions.py
index cc72f65d..699b28ca 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -16,7 +16,7 @@ from .compat import cookielib, OrderedDict, urljoin, urlparse, urlunparse
 from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar
 from .models import Request, PreparedRequest
 from .hooks import default_hooks, dispatch_hook
-from .utils import to_key_val_list, default_headers
+from .utils import to_key_val_list, default_headers, to_native_string
 from .exceptions import TooManyRedirects, InvalidSchema
 from .structures import CaseInsensitiveDict
 
@@ -311,7 +311,7 @@ class Session(SessionRedirectMixin):
         """
         # Create the Request.
         req = Request(
-            method = method.upper(),
+            method = to_native_string(method).upper(),
             url = url,
             headers = headers,
             files = files,
diff --git a/test_comprehensive_fix.py b/test_comprehensive_fix.py
new file mode 100644
index 00000000..2e13bcdd
--- /dev/null
+++ b/test_comprehensive_fix.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+from requests.models import Request
+from requests.utils import to_native_string
+
+def test_comprehensive_fix():
+    """Comprehensive test of the unicode method fix"""
+    print("Comprehensive test of unicode method fix")
+    print("Python version:", sys.version)
+    
+    session = Session()
+    
+    # Test various HTTP methods with both string and unicode versions
+    test_methods = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', 'PATCH']
+    
+    all_passed = True
+    
+    for method in test_methods:
+        # Test string version
+        print(f"\nTesting method '{method}' (string):")
+        try:
+            req = Request(method=method, url='http://example.com')
+            prepared = session.prepare_request(req)
+            
+            print(f"  Original: '{method}' ({type(method).__name__})")
+            print(f"  Prepared: '{prepared.method}' ({type(prepared.method).__name__})")
+            
+            assert isinstance(prepared.method, str), f"Method should be str, got {type(prepared.method)}"
+            assert prepared.method == method.upper(), f"Method should be uppercase, got {prepared.method}"
+            print("  ✓ PASS")
+            
+        except Exception as e:
+            print(f"  ✗ FAIL: {e}")
+            all_passed = False
+        
+        # Test unicode version  
+        print(f"Testing method u'{method}' (unicode):")
+        try:
+            unicode_method = method  # In Python 3, unicode literals are same as strings
+            req = Request(method=unicode_method, url='http://example.com')
+            prepared = session.prepare_request(req)
+            
+            print(f"  Original: u'{unicode_method}' ({type(unicode_method).__name__})")
+            print(f"  Prepared: '{prepared.method}' ({type(prepared.method).__name__})")
+            
+            assert isinstance(prepared.method, str), f"Method should be str, got {type(prepared.method)}"
+            assert prepared.method == unicode_method.upper(), f"Method should be uppercase, got {prepared.method}"
+            print("  ✓ PASS")
+            
+        except Exception as e:
+            print(f"  ✗ FAIL: {e}")
+            all_passed = False
+    
+    # Test the to_native_string function specifically
+    print("\nTesting to_native_string function:")
+    test_cases = ['GET', 'POST', 'PUT', 'DELETE']
+    for method in test_cases:
+        try:
+            result = to_native_string(method)
+            print(f"  to_native_string('{method}') = '{result}' ({type(result).__name__})")
+            assert isinstance(result, str), f"Result should be str, got {type(result)}"
+            print("  ✓ PASS")
+        except Exception as e:
+            print(f"  ✗ FAIL: {e}")
+            all_passed = False
+    
+    return all_passed
+
+if __name__ == "__main__":
+    success = test_comprehensive_fix()
+    
+    if success:
+        print("\n✓ All comprehensive tests passed! The unicode method fix is working correctly.")
+        sys.exit(0)
+    else:
+        print("\n✗ Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_method_processing.py b/test_method_processing.py
new file mode 100644
index 00000000..9ef274b9
--- /dev/null
+++ b/test_method_processing.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+from requests.models import Request
+
+def test_method_processing():
+    print("Testing method processing in requests")
+    print("Python version:", sys.version)
+    
+    # Test case 1: String method name
+    print("\n1. Testing with string method name (method='POST'):")
+    try:
+        method_str = 'POST'
+        print(f"Input method type: {type(method_str)}, value: {method_str}")
+        # Create a Request object directly
+        req = Request(method=method_str.upper(), url='http://example.com')
+        print(f"Request method type: {type(req.method)}, value: {req.method}")
+        print("SUCCESS: String method name works")
+    except Exception as e:
+        print("ERROR with string method:", str(e))
+        print("Exception type:", type(e).__name__)
+
+    # Test case 2: Unicode method name
+    print("\n2. Testing with unicode method name (method=u'POST'):")
+    try:
+        method_unicode = u'POST'
+        print(f"Input method type: {type(method_unicode)}, value: {method_unicode}")
+        # Create a Request object directly
+        req = Request(method=method_unicode.upper(), url='http://example.com')
+        print(f"Request method type: {type(req.method)}, value: {req.method}")
+        print("SUCCESS: Unicode method name works")
+    except Exception as e:
+        print("ERROR with unicode method:", str(e))
+        print("Exception type:", type(e).__name__)
+
+    # Test case 3: Using our fixed to_native_string approach
+    print("\n3. Testing with to_native_string approach:")
+    try:
+        from requests.utils import to_native_string
+        method_unicode = u'POST'
+        print(f"Input method type: {type(method_unicode)}, value: {method_unicode}")
+        # Use to_native_string before upper()
+        native_method = to_native_string(method_unicode)
+        req = Request(method=native_method.upper(), url='http://example.com')
+        print(f"Request method type: {type(req.method)}, value: {req.method}")
+        print("SUCCESS: to_native_string approach works")
+    except Exception as e:
+        print("ERROR with to_native_string approach:", str(e))
+        print("Exception type:", type(e).__name__)
+
+if __name__ == "__main__":
+    test_method_processing()
\ No newline at end of file
diff --git a/test_original_issue_fix.py b/test_original_issue_fix.py
new file mode 100644
index 00000000..82740db9
--- /dev/null
+++ b/test_original_issue_fix.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+from requests.models import Request
+
+def simulate_original_issue():
+    """Simulate the original issue scenario to demonstrate the fix"""
+    print("Simulating original Unicode method issue scenario")
+    print("Python version:", sys.version)
+    
+    # Create a session like in the original issue
+    session = Session()
+    
+    # Simulate the problematic code from the issue
+    print("\n1. Simulating the original problematic code path:")
+    print("   requests.request(method=u'POST', url=u'http://httpbin.org/post', files=files)")
+    
+    # The issue occurs in sessions.py line 314 where method.upper() is called
+    # Let's test this specific code path
+    
+    test_cases = [
+        ('POST', 'string method (original working case)'),
+        (u'POST', 'unicode method (original failing case)'),
+    ]
+    
+    for method, description in test_cases:
+        print(f"\n   Testing {description}:")
+        print(f"     Input: method={method} (type: {type(method).__name__})")
+        
+        try:
+            # This simulates what happens in sessions.py line 314
+            # Before fix: method.upper() would return unicode if method was unicode
+            # After fix: to_native_string(method).upper() returns native string
+            
+            # Import the function we're using in our fix
+            from requests.utils import to_native_string
+            
+            # Old problematic approach (simulated)
+            old_result = method.upper()
+            print(f"     Old approach result: {old_result} (type: {type(old_result).__name__})")
+            
+            # New fixed approach
+            new_result = to_native_string(method).upper()
+            print(f"     New approach result: {new_result} (type: {type(new_result).__name__})")
+            
+            # Verify the fix works
+            assert isinstance(new_result, str), f"Result should be str, got {type(new_result)}"
+            assert new_result == method.upper(), f"Result should be uppercase method"
+            
+            print("     ✓ Fix successfully converts to native string")
+            
+        except Exception as e:
+            print(f"     ✗ Error: {e}")
+            return False
+    
+    # Test the complete request preparation flow
+    print("\n2. Testing complete request preparation flow:")
+    
+    for method in ['POST', u'POST']:
+        print(f"   Testing method: {method} (type: {type(method).__name__})")
+        
+        try:
+            # Create a request like sessions.py does
+            req = Request(
+                method=method,
+                url='http://example.com',
+                headers={},
+                files=[],
+                data={},
+                params={},
+                auth=None,
+                cookies={},
+                hooks={}
+            )
+            
+            # Prepare the request like sessions.py does
+            prepared = session.prepare_request(req)
+            
+            print(f"     Prepared method: {prepared.method} (type: {type(prepared.method).__name__})")
+            
+            # Verify the method is properly processed
+            assert isinstance(prepared.method, str), f"Prepared method should be str, got {type(prepared.method)}"
+            assert prepared.method == 'POST', f"Prepared method should be 'POST', got {prepared.method}"
+            
+            print("     ✓ Request preparation successful")
+            
+        except Exception as e:
+            print(f"     ✗ Error: {e}")
+            return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = simulate_original_issue()
+    
+    if success:
+        print("\n✓ All tests passed! The Unicode method issue has been fixed.")
+        print("\nSummary of changes:")
+        print("1. Modified requests/sessions.py line 314:")
+        print("   - Changed: method.upper()")
+        print("   - To: to_native_string(method).upper()")
+        print("2. Modified requests/models.py line 310:")
+        print("   - Changed: self.method.upper()") 
+        print("   - To: to_native_string(self.method).upper()")
+        print("3. Added to_native_string import to requests/sessions.py")
+        sys.exit(0)
+    else:
+        print("\n✗ Tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_python2_simulation.py b/test_python2_simulation.py
new file mode 100644
index 00000000..0de7157e
--- /dev/null
+++ b/test_python2_simulation.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.utils import to_native_string
+
+def simulate_python2_unicode_issue():
+    print("Simulating Python 2 unicode method issue")
+    print("Python version:", sys.version)
+    
+    # Simulate a unicode string like in Python 2
+    # In Python 2, u'POST' would be unicode type
+    # Let's create a unicode-like object to test
+    
+    class UnicodeLikeString:
+        """A class that simulates Python 2 unicode behavior"""
+        def __init__(self, value):
+            self.value = value
+        
+        def upper(self):
+            # Return another UnicodeLikeString to simulate the issue
+            return UnicodeLikeString(self.value.upper())
+        
+        def __str__(self):
+            return self.value
+        
+        def __repr__(self):
+            return f"u'{self.value}'"
+    
+    # Test case 1: Regular string (should work)
+    print("\n1. Testing with regular string:")
+    try:
+        method_str = 'POST'
+        print(f"Input method type: {type(method_str)}, value: {method_str}")
+        result = to_native_string(method_str).upper()
+        print(f"Result type: {type(result)}, value: {result}")
+        print("SUCCESS: Regular string works")
+    except Exception as e:
+        print("ERROR with regular string:", str(e))
+        print("Exception type:", type(e).__name__)
+
+    # Test case 2: Unicode-like string (should demonstrate the issue)
+    print("\n2. Testing with unicode-like string:")
+    try:
+        method_unicode = UnicodeLikeString('POST')
+        print(f"Input method type: {type(method_unicode)}, value: {method_unicode}")
+        # This simulates the old problematic code: method.upper()
+        old_way = method_unicode.upper()
+        print(f"Old way result type: {type(old_way)}, value: {old_way}")
+        print("This would cause issues in Python 2 HTTP stack")
+        
+        # Test our fixed approach
+        result = to_native_string(method_unicode).upper()
+        print(f"Fixed way result type: {type(result)}, value: {result}")
+        print("SUCCESS: to_native_string approach works")
+    except Exception as e:
+        print("ERROR with unicode-like string:", str(e))
+        print("Exception type:", type(e).__name__)
+
+if __name__ == "__main__":
+    simulate_python2_unicode_issue()
\ No newline at end of file
diff --git a/test_session_method_processing.py b/test_session_method_processing.py
new file mode 100644
index 00000000..79c92e97
--- /dev/null
+++ b/test_session_method_processing.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+from requests.models import Request
+
+def test_session_method_processing():
+    """Test that session properly processes method names"""
+    print("Testing session method processing")
+    print("Python version:", sys.version)
+    
+    session = Session()
+    
+    # Test cases with different method types
+    test_cases = [
+        ('POST', 'string method'),
+        (u'POST', 'unicode method'),
+        ('GET', 'string method'),
+        (u'GET', 'unicode method'),
+    ]
+    
+    for method, description in test_cases:
+        print(f"\nTesting {description}: {method}")
+        try:
+            # Create a request using the session's internal method
+            # This simulates what happens in session.request() but without HTTP calls
+            req = Request(method=method, url='http://example.com')
+            prepared = session.prepare_request(req)
+            
+            print(f"  Original method: '{method}' (type: {type(method).__name__})")
+            print(f"  Prepared method: '{prepared.method}' (type: {type(prepared.method).__name__})")
+            
+            # Verify the method is a string
+            assert isinstance(prepared.method, str), f"Method should be str, got {type(prepared.method)}"
+            assert prepared.method == method.upper(), f"Method should be uppercase, got {prepared.method}"
+            
+        except Exception as e:
+            print(f"  ERROR: {e}")
+            return False
+    
+    print("\nAll session method processing tests passed!")
+    return True
+
+def test_request_constructor():
+    """Test the Request constructor with different method types"""
+    print("\nTesting Request constructor with different method types")
+    
+    test_cases = [
+        ('POST', 'string method'),
+        (u'POST', 'unicode method'),
+        ('GET', 'string method'), 
+        (u'GET', 'unicode method'),
+    ]
+    
+    for method, description in test_cases:
+        print(f"Testing {description}: {method}")
+        try:
+            req = Request(method=method, url='http://example.com')
+            print(f"  Request method: '{req.method}' (type: {type(req.method).__name__})")
+            
+            # The Request constructor should preserve the method type
+            assert type(req.method) == type(method), f"Method type should be preserved"
+            
+        except Exception as e:
+            print(f"  ERROR: {e}")
+            return False
+    
+    print("Request constructor tests passed!")
+    return True
+
+if __name__ == "__main__":
+    success1 = test_session_method_processing()
+    success2 = test_request_constructor()
+    
+    if success1 and success2:
+        print("\n✓ All tests passed!")
+        sys.exit(0)
+    else:
+        print("\n✗ Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_unicode_method.py b/test_unicode_method.py
new file mode 100644
index 00000000..633ae56c
--- /dev/null
+++ b/test_unicode_method.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+
+def test_method_handling():
+    print("Testing method handling in Session.request()")
+    print("Python version:", sys.version)
+    
+    # Create a session
+    session = Session()
+    
+    # Test case 1: String method name
+    print("\n1. Testing with string method name (method='POST'):")
+    try:
+        method_str = 'POST'
+        print(f"Input method type: {type(method_str)}, value: {method_str}")
+        # This should work fine
+        req = session.prepare_request(session.create_request(method_str, 'http://example.com'))
+        print(f"Prepared method type: {type(req.method)}, value: {req.method}")
+        print("SUCCESS: String method name works")
+    except Exception as e:
+        print("ERROR with string method:", str(e))
+        print("Exception type:", type(e).__name__)
+
+    # Test case 2: Unicode method name
+    print("\n2. Testing with unicode method name (method=u'POST'):")
+    try:
+        method_unicode = u'POST'
+        print(f"Input method type: {type(method_unicode)}, value: {method_unicode}")
+        # This should also work now with our fix
+        req = session.prepare_request(session.create_request(method_unicode, 'http://example.com'))
+        print(f"Prepared method type: {type(req.method)}, value: {req.method}")
+        print("SUCCESS: Unicode method name works")
+    except Exception as e:
+        print("ERROR with unicode method:", str(e))
+        print("Exception type:", type(e).__name__)
+
+if __name__ == "__main__":
+    test_method_handling()
\ No newline at end of file
diff --git a/test_unicode_method_fix.py b/test_unicode_method_fix.py
new file mode 100644
index 00000000..cf6ce915
--- /dev/null
+++ b/test_unicode_method_fix.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+from requests.sessions import Session
+from requests.utils import to_native_string
+
+def test_unicode_method_fix():
+    """Test that unicode method names are properly handled"""
+    print("Testing unicode method name fix")
+    print("Python version:", sys.version)
+    
+    session = Session()
+    
+    # Test cases with different method types
+    test_cases = [
+        ('POST', 'string method'),
+        (u'POST', 'unicode method'),
+        ('GET', 'string method'),
+        (u'GET', 'unicode method'),
+        ('PUT', 'string method'), 
+        (u'PUT', 'unicode method'),
+        ('DELETE', 'string method'),
+        (u'DELETE', 'unicode method'),
+    ]
+    
+    for method, description in test_cases:
+        print(f"\nTesting {description}: {method}")
+        try:
+            # This should work with our fix
+            req = session.prepare_request(session.request(method, 'http://example.com'))
+            print(f"  SUCCESS: Method '{req.method}' (type: {type(req.method).__name__})")
+            
+            # Verify the method is a string (not unicode)
+            assert isinstance(req.method, str), f"Method should be str, got {type(req.method)}"
+            assert req.method == method.upper(), f"Method should be uppercase, got {req.method}"
+            
+        except Exception as e:
+            print(f"  ERROR: {e}")
+            return False
+    
+    print("\nAll tests passed!")
+    return True
+
+def test_to_native_string_function():
+    """Test the to_native_string utility function"""
+    print("\nTesting to_native_string function")
+    
+    test_cases = [
+        ('hello', 'string input'),
+        (u'hello', 'unicode input'),
+        ('POST', 'string method'),
+        (u'POST', 'unicode method'),
+    ]
+    
+    for input_val, description in test_cases:
+        print(f"Testing {description}: {input_val}")
+        try:
+            result = to_native_string(input_val)
+            print(f"  Result: '{result}' (type: {type(result).__name__})")
+            assert isinstance(result, str), f"Result should be str, got {type(result)}"
+        except Exception as e:
+            print(f"  ERROR: {e}")
+            return False
+    
+    print("to_native_string tests passed!")
+    return True
+
+if __name__ == "__main__":
+    success1 = test_unicode_method_fix()
+    success2 = test_to_native_string_function()
+    
+    if success1 and success2:
+        print("\n✓ All tests passed! The unicode method fix is working correctly.")
+        sys.exit(0)
+    else:
+        print("\n✗ Some tests failed!")
+        sys.exit(1)
\ No newline at end of file