diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 88c9ca9f28..fcea1597ef 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):
         return NotImplemented
 
     def __hash__(self):
-        return hash((
-            self.creation_counter,
-            self.model._meta.app_label if hasattr(self, 'model') else None,
-            self.model._meta.model_name if hasattr(self, 'model') else None,
-        ))
+        return hash(self.creation_counter)
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2a90f2997b
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+"""Script to reproduce the Field.__hash__() issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("Testing Field.__hash__() immutability issue...")
+
+# Create a field instance
+f = models.CharField(max_length=200)
+
+# Store the field in a dictionary before assigning to a model class
+d = {f: 1}
+print(f"Field hash before assignment: {hash(f)}")
+print(f"Field in dictionary before assignment: {f in d}")
+
+# Assign the field to a model class
+class Book(models.Model):
+    title = f
+    
+    class Meta:
+        app_label = 'test'
+
+# Check if the field is still in the dictionary
+print(f"Field hash after assignment: {hash(f)}")
+print(f"Field in dictionary after assignment: {f in d}")
+
+# This should pass if the issue is fixed, but currently fails
+try:
+    assert f in d
+    print("✅ SUCCESS: Field hash is immutable")
+except AssertionError:
+    print("❌ FAILURE: Field hash changed after assignment to model class")
+    sys.exit(1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..3f5c1f6bef
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""Script to test edge cases for Field.__hash__() fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=['test'],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("Testing Field.__hash__() edge cases...")
+
+# Test 1: Multiple fields with same creation_counter (shouldn't happen in practice)
+f1 = models.CharField(max_length=200)
+f2 = models.CharField(max_length=200)
+
+print(f"Field 1 hash: {hash(f1)}")
+print(f"Field 2 hash: {hash(f2)}")
+print(f"Fields equal: {f1 == f2}")
+print(f"Fields have same hash: {hash(f1) == hash(f2)}")
+
+# Test 2: Same field in multiple dictionaries
+f = models.CharField(max_length=200)
+d1 = {f: 1}
+d2 = {f: 2}
+
+class Book(models.Model):
+    title = f
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"Field in dict1 before: {f in d1}")
+print(f"Field in dict2 before: {f in d2}")
+print(f"Field in dict1 after: {f in d1}")
+print(f"Field in dict2 after: {f in d2}")
+
+# Test 3: Field comparison after assignment
+f3 = models.CharField(max_length=200)
+f4 = models.CharField(max_length=200)
+
+class Author(models.Model):
+    name = f3
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"Field 3 hash: {hash(f3)}")
+print(f"Field 4 hash: {hash(f4)}")
+print(f"Fields equal: {f3 == f4}")
+
+print("✅ All edge case tests passed")
\ No newline at end of file
diff --git a/test_equality.py b/test_equality.py
new file mode 100644
index 0000000000..012aaeb88f
--- /dev/null
+++ b/test_equality.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""Test that equality comparison still works correctly after hash fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=['test'],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("Testing equality comparison after hash fix...")
+
+# Test 1: Same field should be equal to itself
+f1 = models.CharField(max_length=200)
+print(f"Field equals itself: {f1 == f1}")
+
+# Test 2: Different fields should not be equal
+f2 = models.CharField(max_length=200)
+print(f"Different fields equal: {f1 == f2}")
+
+# Test 3: Same field assigned to different models
+class Model1(models.Model):
+    field = f1
+    
+    class Meta:
+        app_label = 'test'
+
+class Model2(models.Model):
+    field = f1  # Same field instance
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"Same field in different models equal: {Model1._meta.get_field('field') == Model2._meta.get_field('field')}")
+
+# Test 4: Different fields assigned to models
+f3 = models.CharField(max_length=200)
+f4 = models.CharField(max_length=200)
+
+class Model3(models.Model):
+    field1 = f3
+    
+    class Meta:
+        app_label = 'test'
+
+class Model4(models.Model):
+    field2 = f4
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"Different fields in models equal: {Model3._meta.get_field('field1') == Model4._meta.get_field('field2')}")
+
+print("✅ All equality tests passed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..e61eaeab73
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+"""Test the exact scenario described in the GitHub issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("Testing the exact GitHub issue scenario...")
+
+# Exact code from the GitHub issue
+f = models.CharField(max_length=200)
+d = {f: 1}
+
+class Book(models.Model):
+    title = f
+    
+    class Meta:
+        app_label = 'test'
+
+# This assertion should now pass (it was failing before the fix)
+try:
+    assert f in d
+    print("✅ SUCCESS: assert f in d passed!")
+except AssertionError:
+    print("❌ FAILURE: assert f in d failed")
+    sys.exit(1)
+
+# Additional verification
+print(f"Field hash before assignment: {hash(f)}")
+print(f"Field hash after assignment: {hash(f)}")
+print(f"Field in dictionary: {f in d}")
+print(f"Dictionary value: {d[f]}")
+
+print("✅ GitHub issue is completely resolved!")
\ No newline at end of file
diff --git a/test_hash_equality_contract.py b/test_hash_equality_contract.py
new file mode 100644
index 0000000000..b7f8c2e52f
--- /dev/null
+++ b/test_hash_equality_contract.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""Test that the hash/equality contract is maintained."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=['test'],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("Testing hash/equality contract...")
+
+# Test 1: Same object should have same hash and be equal
+f1 = models.CharField(max_length=200)
+print(f"Same object - Equal: {f1 == f1}, Same hash: {hash(f1) == hash(f1)}")
+
+# Test 2: Equal objects should have same hash
+# (This is tricky since field equality is based on creation_counter and model)
+f2 = models.CharField(max_length=200)
+print(f"Different objects - Equal: {f1 == f2}, Same hash: {hash(f1) == hash(f2)}")
+
+# Test 3: Field assigned to model vs same field instance
+f3 = models.CharField(max_length=200)
+hash_before = hash(f3)
+
+class TestModel(models.Model):
+    field = f3
+    
+    class Meta:
+        app_label = 'test'
+
+hash_after = hash(f3)
+print(f"Same field instance - Equal: {f3 == f3}, Hash unchanged: {hash_before == hash_after}")
+
+# Test 4: Verify that if two fields are equal, they have the same hash
+# (This is the hash/equality contract)
+f4 = models.CharField(max_length=200)
+f5 = models.CharField(max_length=200)
+
+# For fields to be equal, they need same creation_counter and same model
+# Since they have different creation_counters, they shouldn't be equal
+if f4 == f5:
+    print(f"Equal fields have same hash: {hash(f4) == hash(f5)}")
+else:
+    print("Fields not equal (expected)")
+
+print("✅ Hash/equality contract tests passed!")
\ No newline at end of file