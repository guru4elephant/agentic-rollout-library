diff --git a/debug_tuple.py b/debug_tuple.py
new file mode 100644
index 0000000000..19140ca96c
--- /dev/null
+++ b/debug_tuple.py
@@ -0,0 +1,19 @@
+from sympy.printing.lambdarepr import LambdaPrinter
+
+# Create a single-element tuple
+single_tuple = (1,)
+multi_tuple = (1, 2)
+
+print("Single element tuple:", single_tuple)
+print("Multi element tuple:", multi_tuple)
+
+# Create a printer
+printer = LambdaPrinter()
+
+# Try to print them
+print("Single element printed:", printer.doprint(single_tuple))
+print("Multi element printed:", printer.doprint(multi_tuple))
+
+# Check what str() returns
+print("str(single_tuple):", str(single_tuple))
+print("str(multi_tuple):", str(multi_tuple))
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2289b105e5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+import inspect
+from sympy import lambdify
+
+# Test single element tuple
+result1 = inspect.getsource(lambdify([], tuple([1])))
+print("Single element tuple result:")
+print(repr(result1))
+print(result1)
+
+# Test multi-element tuple
+result2 = inspect.getsource(lambdify([], tuple([1, 2])))
+print("\nMulti-element tuple result:")
+print(repr(result2))
+print(result2)
+
+# Check if the single element tuple result is correct (should have comma)
+if ",)" in result1:
+    print("\n✓ Single element tuple is correctly formatted")
+else:
+    print("\n✗ Single element tuple is missing comma - this is the bug!")
\ No newline at end of file
diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py
index da67263b19..fe324bfad3 100644
--- a/sympy/utilities/lambdify.py
+++ b/sympy/utilities/lambdify.py
@@ -958,7 +958,10 @@ def _recursive_to_string(doprint, arg):
         if isinstance(arg, list):
             left, right = "[]"
         elif isinstance(arg, tuple):
-            left, right = "()"
+            left,  right = "()"
+            # Handle single-element tuple case
+            if len(arg) == 1:
+                return left + _recursive_to_string(doprint, arg[0]) + ',' + right
         else:
             raise NotImplementedError("unhandled type: %s, %s" % (type(arg), arg))
         return left +', '.join(_recursive_to_string(doprint, e) for e in arg) + right
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..433e6772b4
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,32 @@
+import inspect
+from sympy import lambdify
+
+# Test various tuple cases
+print("=== Testing various tuple cases ===")
+
+# Empty tuple
+empty_result = inspect.getsource(lambdify([], tuple([])))
+print("Empty tuple:", repr(empty_result))
+print(empty_result)
+
+# Single element tuple with different types
+single_int = inspect.getsource(lambdify([], tuple([1])))
+single_float = inspect.getsource(lambdify([], tuple([1.5])))
+single_str = inspect.getsource(lambdify([], tuple(["hello"])))
+single_expr = inspect.getsource(lambdify([], tuple([1+2])))
+
+print("\nSingle int:", repr(single_int))
+print("Single float:", repr(single_float)) 
+print("Single string:", repr(single_str))
+print("Single expression:", repr(single_expr))
+
+# Multi-element tuples
+double_tuple = inspect.getsource(lambdify([], tuple([1, 2])))
+triple_tuple = inspect.getsource(lambdify([], tuple([1, 2, 3])))
+
+print("\nDouble tuple:", repr(double_tuple))
+print("Triple tuple:", repr(triple_tuple))
+
+# Nested tuples
+nested_tuple = inspect.getsource(lambdify([], tuple([1, (2, 3)])))
+print("\nNested tuple:", repr(nested_tuple))
\ No newline at end of file
diff --git a/test_functionality.py b/test_functionality.py
new file mode 100644
index 0000000000..e54a5d60e3
--- /dev/null
+++ b/test_functionality.py
@@ -0,0 +1,37 @@
+import inspect
+from sympy import lambdify
+
+# Test that the generated functions work correctly
+print("=== Testing functionality of generated functions ===")
+
+# Generate functions
+single_func = lambdify([], tuple([1]))
+multi_func = lambdify([], tuple([1, 2]))
+
+# Get source code
+single_src = inspect.getsource(single_func)
+multi_src = inspect.getsource(multi_func)
+
+print("Single element function source:")
+print(single_src)
+
+print("Multi element function source:")
+print(multi_src)
+
+# Execute the functions
+single_result = single_func()
+multi_result = multi_func()
+
+print("\nResults:")
+print("Single element function returns:", single_result, "type:", type(single_result))
+print("Multi element function returns:", multi_result, "type:", type(multi_result))
+
+# Verify they are both tuples
+print("\nVerification:")
+print("Single element is tuple:", isinstance(single_result, tuple))
+print("Multi element is tuple:", isinstance(multi_result, tuple))
+
+# Test with actual values
+print("\nTesting with values:")
+print("single_result[0]:", single_result[0])
+print("multi_result[0]:", multi_result[0], "multi_result[1]:", multi_result[1])
\ No newline at end of file
diff --git a/test_syntax.py b/test_syntax.py
new file mode 100644
index 0000000000..e1431446ca
--- /dev/null
+++ b/test_syntax.py
@@ -0,0 +1,12 @@
+# Test if both syntaxes work
+def test1():
+    return (1,)
+
+def test2():
+    return (1, )
+
+print("test1():", test1())
+print("test2():", test2())
+print("type(test1()):", type(test1()))
+print("type(test2()):", type(test2()))
+print("test1() == test2():", test1() == test2())
\ No newline at end of file