diff --git a/debug_app_config.py b/debug_app_config.py
new file mode 100644
index 0000000000..58722a6af6
--- /dev/null
+++ b/debug_app_config.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Debugging app_config issue...")
+print(f"RegularModel._meta.app_config: {RegularModel._meta.app_config}")
+
+# The issue is that RegularModel._meta.app_config is None
+# Let's check what happens when app_config is None in the _check_default_pk method
+
+# Simulate the condition from _check_default_pk
+auto_created = RegularModel._meta.pk.auto_created
+is_overridden = settings.is_overridden('DEFAULT_AUTO_FIELD')
+app_config_overridden = RegularModel._meta.app_config and RegularModel._meta.app_config._is_default_auto_field_overridden
+is_inherited = False  # For RegularModel, this should be False
+
+print(f"\nConditions:")
+print(f"auto_created: {auto_created}")
+print(f"not is_overridden: {not is_overridden}")
+print(f"not app_config_overridden: {not app_config_overridden}")
+print(f"not is_inherited: {not is_inherited}")
+
+# The condition should be:
+condition = auto_created and not is_overridden and not app_config_overridden and not is_inherited
+print(f"Should trigger W042: {condition}")
+
+# The issue is that app_config_overridden is None, which evaluates to False
+# So not app_config_overridden is True
+
+# Let's check what the actual _check_default_pk method does
+from django.db.models.base import _check_default_pk, _is_inherited_pk
+
+print(f"\nTesting _check_default_pk directly:")
+result = _check_default_pk(RegularModel)
+print(f"_check_default_pk(RegularModel): {result}")
+
+print(f"_is_inherited_pk(RegularModel): {_is_inherited_pk(RegularModel)}")
+
+# Let's also check the settings.is_overridden
+print(f"settings.is_overridden('DEFAULT_AUTO_FIELD'): {settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+
+# The issue might be that settings.is_overridden('DEFAULT_AUTO_FIELD') returns True
+# because we explicitly set DEFAULT_AUTO_FIELD in our settings
\ No newline at end of file
diff --git a/debug_final.py b/debug_final.py
new file mode 100644
index 0000000000..8c5107700e
--- /dev/null
+++ b/debug_final.py
@@ -0,0 +1,114 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Debugging the real issue...")
+print(f"RegularModel._meta.pk.auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"settings.is_overridden('DEFAULT_AUTO_FIELD'): {settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+print(f"RegularModel._meta.app_config: {RegularModel._meta.app_config}")
+
+# The issue is that settings.is_overridden('DEFAULT_AUTO_FIELD') returns True
+# because we explicitly set DEFAULT_AUTO_FIELD in our settings.configure() call
+# This means the W042 warning is correctly NOT being triggered
+
+# Let's test with a different approach - use the same setup as the Django tests
+# where DEFAULT_AUTO_FIELD is not explicitly overridden
+
+# First, let's check what the actual condition should be
+auto_created = RegularModel._meta.pk.auto_created
+is_overridden = settings.is_overridden('DEFAULT_AUTO_FIELD')
+app_config_overridden = RegularModel._meta.app_config and RegularModel._meta.app_config._is_default_auto_field_overridden
+is_inherited = False  # For RegularModel, this should be False
+
+print(f"\nCurrent conditions:")
+print(f"auto_created: {auto_created}")
+print(f"not is_overridden: {not is_overridden}")
+print(f"not app_config_overridden: {not app_config_overridden}")
+print(f"not is_inherited: {not is_inherited}")
+
+condition = auto_created and not is_overridden and not app_config_overridden and not is_inherited
+print(f"Should trigger W042: {condition}")
+
+# The issue is that is_overridden is True because we set DEFAULT_AUTO_FIELD
+# Let's test without setting DEFAULT_AUTO_FIELD explicitly
+
+print(f"\nTesting without explicit DEFAULT_AUTO_FIELD setting...")
+
+# Reset and configure without DEFAULT_AUTO_FIELD
+django.reset()
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+django.setup()
+
+class RegularModel2(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test2'
+
+print(f"RegularModel2._meta.pk.auto_created: {RegularModel2._meta.pk.auto_created}")
+print(f"settings.is_overridden('DEFAULT_AUTO_FIELD'): {settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+print(f"settings.DEFAULT_AUTO_FIELD: {settings.DEFAULT_AUTO_FIELD}")
+
+# Now test the _check_default_pk method
+result = RegularModel2._check_default_pk()
+print(f"RegularModel2._check_default_pk(): {result}")
+
+# Also test inherited models
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test2'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test2'
+
+result = User._check_default_pk()
+print(f"User._check_default_pk(): {result}")
\ No newline at end of file
diff --git a/debug_inheritance.py b/debug_inheritance.py
new file mode 100644
index 0000000000..762a6d1ca9
--- /dev/null
+++ b/debug_inheritance.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Debugging inheritance...")
+print(f"Entity._meta.pk: {Entity._meta.pk}")
+print(f"User._meta.pk: {User._meta.pk}")
+print(f"Entity._meta.pk is User._meta.pk: {Entity._meta.pk is User._meta.pk}")
+print(f"Entity._meta.pk == User._meta.pk: {Entity._meta.pk == User._meta.pk}")
+print(f"type(Entity._meta.pk): {type(Entity._meta.pk)}")
+print(f"type(User._meta.pk): {type(User._meta.pk)}")
+print(f"Entity._meta.pk.name: {Entity._meta.pk.name}")
+print(f"User._meta.pk.name: {User._meta.pk.name}")
+print(f"Entity._meta.pk.auto_created: {Entity._meta.pk.auto_created}")
+print(f"User._meta.pk.auto_created: {User._meta.pk.auto_created}")
+
+# Check if they have the same field name and attributes
+print(f"\nField comparison:")
+print(f"Same name: {Entity._meta.pk.name == User._meta.pk.name}")
+print(f"Same type: {type(Entity._meta.pk) == type(User._meta.pk)}")
+print(f"Same primary_key: {Entity._meta.pk.primary_key == User._meta.pk.primary_key}")
+print(f"Same auto_created: {Entity._meta.pk.auto_created == User._meta.pk.auto_created}")
+
+# Check the parents
+print(f"\nParents:")
+print(f"User._meta.parents: {User._meta.parents}")
+for parent_name, parent_field in User._meta.parents.items():
+    print(f"  {parent_name}: {parent_field}")
+    print(f"  {parent_name}._meta.pk: {parent_field._meta.pk}")
+    print(f"  parent_field._meta.pk is User._meta.pk: {parent_field._meta.pk is User._meta.pk}")
\ No newline at end of file
diff --git a/debug_inheritance2.py b/debug_inheritance2.py
new file mode 100644
index 0000000000..01bc84af13
--- /dev/null
+++ b/debug_inheritance2.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Debugging inheritance...")
+print(f"Entity._meta.pk: {Entity._meta.pk}")
+print(f"User._meta.pk: {User._meta.pk}")
+print(f"Entity._meta.pk is User._meta.pk: {Entity._meta.pk is User._meta.pk}")
+print(f"Entity._meta.pk == User._meta.pk: {Entity._meta.pk == User._meta.pk}")
+print(f"type(Entity._meta.pk): {type(Entity._meta.pk)}")
+print(f"type(User._meta.pk): {type(User._meta.pk)}")
+print(f"Entity._meta.pk.name: {Entity._meta.pk.name}")
+print(f"User._meta.pk.name: {User._meta.pk.name}")
+print(f"Entity._meta.pk.auto_created: {Entity._meta.pk.auto_created}")
+print(f"User._meta.pk.auto_created: {User._meta.pk.auto_created}")
+
+# Check the parents
+print(f"\nParents:")
+print(f"User._meta.parents: {User._meta.parents}")
+for parent_class, parent_field in User._meta.parents.items():
+    print(f"  Parent class: {parent_class}")
+    print(f"  Parent field: {parent_field}")
+    print(f"  Parent class._meta.pk: {parent_class._meta.pk}")
+    print(f"  parent_class._meta.pk is User._meta.pk: {parent_class._meta.pk is User._meta.pk}")
+    print(f"  parent_class._meta.pk == User._meta.pk: {parent_class._meta.pk == User._meta.pk}")
+    
+    # Check if the parent field points to the same field as the parent's PK
+    print(f"  parent_field.related_model: {parent_field.related_model}")
+    print(f"  parent_field.related_model._meta.pk: {parent_field.related_model._meta.pk}")
+    print(f"  parent_field.related_model._meta.pk is parent_class._meta.pk: {parent_field.related_model._meta.pk is parent_class._meta.pk}")
+
+# Check if the User's PK field is a OneToOneField that points to Entity
+if hasattr(User._meta.pk, 'related_model'):
+    print(f"\nUser._meta.pk.related_model: {User._meta.pk.related_model}")
+    print(f"User._meta.pk.related_model._meta.pk: {User._meta.pk.related_model._meta.pk}")
+    print(f"User._meta.pk.related_model._meta.pk is Entity._meta.pk: {User._meta.pk.related_model._meta.pk is Entity._meta.pk}")
\ No newline at end of file
diff --git a/debug_inheritance_logic.py b/debug_inheritance_logic.py
new file mode 100644
index 0000000000..d0a629c8dd
--- /dev/null
+++ b/debug_inheritance_logic.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the _is_inherited_pk logic
+print("Debugging _is_inherited_pk logic...")
+
+print(f"User._meta.pk: {User._meta.pk}")
+print(f"type(User._meta.pk): {type(User._meta.pk)}")
+print(f"isinstance(User._meta.pk, models.OneToOneField): {isinstance(User._meta.pk, models.OneToOneField)}")
+
+if isinstance(User._meta.pk, models.OneToOneField):
+    print(f"User._meta.pk.related_model: {User._meta.pk.related_model}")
+    print(f"User._meta.pk.remote_field.parent_link: {User._meta.pk.remote_field.parent_link}")
+    print(f"Entity._meta.pk: {Entity._meta.pk}")
+    print(f"User._meta.pk.remote_field.parent_link: {User._meta.pk.remote_field.parent_link}")
+    
+    # The current logic: related_model._meta.pk is cls._meta.pk.remote_field.parent_link
+    print(f"Entity._meta.pk is User._meta.pk.remote_field.parent_link: {Entity._meta.pk is User._meta.pk.remote_field.parent_link}")
+    
+    # This should be the correct logic:
+    print(f"User._meta.pk.remote_field.parent_link: {User._meta.pk.remote_field.parent_link}")
+    print(f"type(User._meta.pk.remote_field.parent_link): {type(User._meta.pk.remote_field.parent_link)}")
+    
+    # The parent_link should be True for inherited primary keys
+    print(f"User._meta.pk.remote_field.parent_link is True: {User._meta.pk.remote_field.parent_link is True}")
+
+# Let's also check what the actual condition should be
+print(f"\nWhat should we check for inherited primary keys?")
+print(f"User._meta.pk.remote_field.parent_link: {User._meta.pk.remote_field.parent_link}")
+print(f"User._meta.pk.remote_field.parent_link is True: {User._meta.pk.remote_field.parent_link is True}")
+
+# For regular models, this should be different
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"\nRegularModel:")
+print(f"RegularModel._meta.pk: {RegularModel._meta.pk}")
+print(f"type(RegularModel._meta.pk): {type(RegularModel._meta.pk)}")
+if hasattr(RegularModel._meta.pk, 'remote_field'):
+    print(f"RegularModel._meta.pk.remote_field.parent_link: {RegularModel._meta.pk.remote_field.parent_link}")
+else:
+    print("RegularModel._meta.pk has no remote_field")
\ No newline at end of file
diff --git a/debug_is_inherited.py b/debug_is_inherited.py
new file mode 100644
index 0000000000..8df851680f
--- /dev/null
+++ b/debug_is_inherited.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Import and test the _is_inherited_pk function
+from django.db.models.base import _is_inherited_pk
+
+print("Testing _is_inherited_pk function...")
+
+print(f"\nEntity:")
+print(f"  _is_inherited_pk(Entity): {_is_inherited_pk(Entity)}")
+print(f"  Entity._meta.pk: {Entity._meta.pk}")
+print(f"  type(Entity._meta.pk): {type(Entity._meta.pk)}")
+
+print(f"\nUser:")
+print(f"  _is_inherited_pk(User): {_is_inherited_pk(User)}")
+print(f"  User._meta.pk: {User._meta.pk}")
+print(f"  type(User._meta.pk): {type(User._meta.pk)}")
+print(f"  isinstance(User._meta.pk, OneToOneField): {isinstance(User._meta.pk, models.OneToOneField)}")
+if isinstance(User._meta.pk, models.OneToOneField):
+    print(f"  User._meta.pk.related_model: {User._meta.pk.related_model}")
+    print(f"  User._meta.pk.remote_field.parent_link: {User._meta.pk.remote_field.parent_link}")
+
+print(f"\nRegularModel:")
+print(f"  _is_inherited_pk(RegularModel): {_is_inherited_pk(RegularModel)}")
+print(f"  RegularModel._meta.pk: {RegularModel._meta.pk}")
+print(f"  type(RegularModel._meta.pk): {type(RegularModel._meta.pk)}")
+print(f"  isinstance(RegularModel._meta.pk, OneToOneField): {isinstance(RegularModel._meta.pk, models.OneToOneField)}")
+
+# Test the _check_default_pk method
+print(f"\nTesting _check_default_pk:")
+print(f"  Entity._check_default_pk(): {Entity._check_default_pk()}")
+print(f"  User._check_default_pk(): {User._check_default_pk()}")
+print(f"  RegularModel._check_default_pk(): {RegularModel._check_default_pk()}")
\ No newline at end of file
diff --git a/debug_regular_model.py b/debug_regular_model.py
new file mode 100644
index 0000000000..5957e820b1
--- /dev/null
+++ b/debug_regular_model.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Debug the conditions in _check_default_pk
+print("Debugging RegularModel conditions...")
+print(f"RegularModel._meta.pk.auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"settings.is_overridden('DEFAULT_AUTO_FIELD'): {settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+print(f"RegularModel._meta.app_config._is_default_auto_field_overridden: {RegularModel._meta.app_config._is_default_auto_field_overridden}")
+print(f"_is_inherited_pk(RegularModel): {RegularModel._meta.app_config._is_default_auto_field_overridden}")
+
+# Check if the app_config exists
+print(f"RegularModel._meta.app_config: {RegularModel._meta.app_config}")
+if RegularModel._meta.app_config:
+    print(f"RegularModel._meta.app_config._is_default_auto_field_overridden: {RegularModel._meta.app_config._is_default_auto_field_overridden}")
+
+# Let's also check the settings
+print(f"\nSettings:")
+print(f"settings.DEFAULT_AUTO_FIELD: {settings.DEFAULT_AUTO_FIELD}")
+print(f"type(settings.DEFAULT_AUTO_FIELD): {type(settings.DEFAULT_AUTO_FIELD)}")
+
+# Check if the conditions should trigger the warning
+conditions = [
+    RegularModel._meta.pk.auto_created,
+    not settings.is_overridden('DEFAULT_AUTO_FIELD'),
+    not RegularModel._meta.app_config._is_default_auto_field_overridden,
+    not RegularModel._meta.app_config._is_default_auto_field_overridden  # This should be _is_inherited_pk(RegularModel)
+]
+
+print(f"\nConditions for W042 warning:")
+print(f"1. auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"2. not settings.is_overridden('DEFAULT_AUTO_FIELD'): {not settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+print(f"3. not app_config._is_default_auto_field_overridden: {not RegularModel._meta.app_config._is_default_auto_field_overridden}")
+print(f"4. not _is_inherited_pk(RegularModel): {not RegularModel._meta.app_config._is_default_auto_field_overridden}")  # This is wrong
+
+print(f"All conditions met: {all(conditions)}")
+
+# Let me import and use the correct function
+from django.db.models.base import _is_inherited_pk
+print(f"Correct _is_inherited_pk(RegularModel): {_is_inherited_pk(RegularModel)}")
+
+# Now check the correct conditions
+correct_conditions = [
+    RegularModel._meta.pk.auto_created,
+    not settings.is_overridden('DEFAULT_AUTO_FIELD'),
+    not RegularModel._meta.app_config._is_default_auto_field_overridden,
+    not _is_inherited_pk(RegularModel)
+]
+
+print(f"\nCorrect conditions for W042 warning:")
+print(f"1. auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"2. not settings.is_overridden('DEFAULT_AUTO_FIELD'): {not settings.is_overridden('DEFAULT_AUTO_FIELD')}")
+print(f"3. not app_config._is_default_auto_field_overridden: {not RegularModel._meta.app_config._is_default_auto_field_overridden}")
+print(f"4. not _is_inherited_pk(RegularModel): {not _is_inherited_pk(RegularModel)}")
+
+print(f"All correct conditions met: {all(correct_conditions)}")
\ No newline at end of file
diff --git a/django/db/models/base.py b/django/db/models/base.py
index 4038859cfa..821c3534cc 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -1300,7 +1300,9 @@ class Model(metaclass=ModelBase):
         if (
             cls._meta.pk.auto_created and
             not settings.is_overridden('DEFAULT_AUTO_FIELD') and
-            not cls._meta.app_config._is_default_auto_field_overridden
+            not (cls._meta.app_config and cls._meta.app_config._is_default_auto_field_overridden) and
+            # Don't warn if the primary key is inherited from a parent model
+            not _is_inherited_pk(cls)
         ):
             return [
                 checks.Warning(
@@ -1309,7 +1311,7 @@ class Model(metaclass=ModelBase):
                     f"'{settings.DEFAULT_AUTO_FIELD}'.",
                     hint=(
                         f"Configure the DEFAULT_AUTO_FIELD setting or the "
-                        f"{cls._meta.app_config.__class__.__qualname__}."
+                        f"{cls._meta.app_config.__class__.__qualname__ if cls._meta.app_config else 'AppConfig'}."
                         f"default_auto_field attribute to point to a subclass "
                         f"of AutoField, e.g. 'django.db.models.BigAutoField'."
                     ),
@@ -1319,6 +1321,7 @@ class Model(metaclass=ModelBase):
             ]
         return []
 
+
     @classmethod
     def _check_swappable(cls):
         """Check if the swapped model exists."""
@@ -2137,3 +2140,15 @@ def model_unpickle(model_id):
 
 
 model_unpickle.__safe_for_unpickle__ = True
+
+
+def _is_inherited_pk(cls):
+    """
+    Check if the primary key is inherited from a parent model.
+    """
+    # Check if the primary key is a OneToOneField that points to a parent model
+    from django.db.models.fields.related import OneToOneField
+    if isinstance(cls._meta.pk, OneToOneField):
+        # Check if this field is a parent link (inherited primary key)
+        return getattr(cls._meta.pk.remote_field, 'parent_link', False)
+    return False
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..59afc4eca8
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings without explicitly setting DEFAULT_AUTO_FIELD
+# This allows the W042 warning to be triggered for regular models
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+print("=== Final Verification of the Fix ===\n")
+
+# Test 1: Regular model without explicit primary key (should trigger W042)
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test 2: Model with explicit primary key (should not trigger W042)
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test 3: Model that inherits from Entity (should not trigger W042 due to our fix)
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test 4: Multi-level inheritance
+class BaseModel(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class IntermediateModel(BaseModel):
+    intermediate_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class FinalModel(IntermediateModel):
+    final_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Run the checks
+print("Testing _check_default_pk method:")
+print(f"  RegularModel: {len(RegularModel._check_default_pk())} warnings (should be 1)")
+print(f"  Entity: {len(Entity._check_default_pk())} warnings (should be 0)")
+print(f"  User: {len(User._check_default_pk())} warnings (should be 0)")
+print(f"  BaseModel: {len(BaseModel._check_default_pk())} warnings (should be 0)")
+print(f"  IntermediateModel: {len(IntermediateModel._check_default_pk())} warnings (should be 0)")
+print(f"  FinalModel: {len(FinalModel._check_default_pk())} warnings (should be 0)")
+
+# Verify the RegularModel actually has a W042 warning
+regular_errors = RegularModel._check_default_pk()
+if regular_errors and regular_errors[0].id == 'models.W042':
+    print("✅ RegularModel correctly triggers W042 warning")
+else:
+    print("❌ RegularModel does not trigger W042 warning (this might be due to settings)")
+
+# Verify inherited models don't have warnings
+inherited_models = [User, IntermediateModel, FinalModel]
+all_inherited_correct = all(len(model._check_default_pk()) == 0 for model in inherited_models)
+
+if all_inherited_correct:
+    print("✅ SUCCESS: Inherited models correctly do not trigger W042 warnings!")
+else:
+    print("❌ FAILURE: Some inherited models still trigger W042 warnings")
+
+# Test the _is_inherited_pk function directly
+from django.db.models.base import _is_inherited_pk
+
+print("\nTesting _is_inherited_pk function:")
+for model in [RegularModel, Entity, User, BaseModel, IntermediateModel, FinalModel]:
+    result = _is_inherited_pk(model)
+    expected = model.__name__ in ['User', 'IntermediateModel', 'FinalModel']
+    status = "✅" if result == expected else "❌"
+    print(f"  {status} {model.__name__}: {result} (expected: {expected})")
+
+print("\n=== Fix Summary ===")
+print("The fix successfully prevents W042 warnings for models that inherit primary keys")
+print("from parent models, while still showing warnings for regular models without")
+print("explicit primary keys.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2b4ab11a0f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+# Create a base model with explicit primary key
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create a model that inherits from Entity
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create a model that inherits from Entity but doesn't define its own primary key
+class ReservedUsername(Entity):
+    username = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Run checks
+print("Running checks on User model:")
+errors = checks.run_checks(app_configs=None)
+for error in errors:
+    if hasattr(error, 'obj') and error.obj.__name__ in ['User', 'ReservedUsername']:
+        print(f"  {error}")
+
+print("\nRunning checks on ReservedUsername model:")
+for error in errors:
+    if hasattr(error, 'obj') and error.obj.__name__ == 'ReservedUsername':
+        print(f"  {error}")
+
+# Check if the primary key is auto_created
+print(f"\nUser._meta.pk.auto_created: {User._meta.pk.auto_created}")
+print(f"ReservedUsername._meta.pk.auto_created: {ReservedUsername._meta.pk.auto_created}")
+print(f"Entity._meta.pk.auto_created: {Entity._meta.pk.auto_created}")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..dde1089cab
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class ReservedUsername(Entity):
+    username = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test that the fix works by directly calling _check_default_pk
+print("Testing _check_default_pk method directly...")
+
+# Test Entity (should return empty list)
+entity_errors = Entity._check_default_pk()
+print(f"Entity._check_default_pk(): {entity_errors}")
+print(f"Entity._meta.pk.auto_created: {Entity._meta.pk.auto_created}")
+print(f"Entity._meta.parents: {[p.__name__ for p in Entity._meta.parents] if Entity._meta.parents else 'None'}")
+
+# Test User (should return empty list due to our fix)
+user_errors = User._check_default_pk()
+print(f"\nUser._check_default_pk(): {user_errors}")
+print(f"User._meta.pk.auto_created: {User._meta.pk.auto_created}")
+print(f"User._meta.parents: {[p.__name__ for p in User._meta.parents] if User._meta.parents else 'None'}")
+
+# Test ReservedUsername (should return empty list due to our fix)
+reserved_errors = ReservedUsername._check_default_pk()
+print(f"\nReservedUsername._check_default_pk(): {reserved_errors}")
+print(f"ReservedUsername._meta.pk.auto_created: {ReservedUsername._meta.pk.auto_created}")
+print(f"ReservedUsername._meta.parents: {[p.__name__ for p in ReservedUsername._meta.parents] if ReservedUsername._meta.parents else 'None'}")
+
+# Test regular model without explicit PK (should return W042 warning)
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+regular_errors = RegularModel._check_default_pk()
+print(f"\nRegularModel._check_default_pk(): {regular_errors}")
+print(f"RegularModel._meta.pk.auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"RegularModel._meta.parents: {[p.__name__ for p in RegularModel._meta.parents] if RegularModel._meta.parents else 'None'}")
+
+# Verify our fix logic
+print(f"\nVerifying fix logic:")
+print(f"User._meta.pk.auto_created: {User._meta.pk.auto_created}")
+print(f"User._meta.parents: {[p.__name__ for p in User._meta.parents]}")
+print(f"any(parent._meta.pk is User._meta.pk for parent in User._meta.parents): {any(parent._meta.pk is User._meta.pk for parent in User._meta.parents)}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..c286cba3d0
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,130 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings without explicitly setting DEFAULT_AUTO_FIELD
+# This will allow the W042 warning to be triggered for regular models
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+print("=== Testing the fix for inherited primary keys ===\n")
+
+# Test case 1: Model with explicit primary key (should not trigger warning)
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 2: Model that inherits from Entity (should not trigger warning due to our fix)
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 3: Model that inherits from Entity but doesn't define its own primary key
+class ReservedUsername(Entity):
+    username = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 4: Regular model without explicit primary key (should trigger warning)
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 5: Multi-level inheritance
+class BaseModel(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class IntermediateModel(BaseModel):
+    intermediate_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class FinalModel(IntermediateModel):
+    final_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the _is_inherited_pk function directly
+from django.db.models.base import _is_inherited_pk
+
+print("Testing _is_inherited_pk function:")
+print(f"  Entity: {_is_inherited_pk(Entity)} (should be False)")
+print(f"  User: {_is_inherited_pk(User)} (should be True)")
+print(f"  ReservedUsername: {_is_inherited_pk(ReservedUsername)} (should be True)")
+print(f"  RegularModel: {_is_inherited_pk(RegularModel)} (should be False)")
+print(f"  BaseModel: {_is_inherited_pk(BaseModel)} (should be False)")
+print(f"  IntermediateModel: {_is_inherited_pk(IntermediateModel)} (should be True)")
+print(f"  FinalModel: {_is_inherited_pk(FinalModel)} (should be True)")
+
+print("\nTesting _check_default_pk method:")
+print(f"  Entity: {len(Entity._check_default_pk())} warnings (should be 0)")
+print(f"  User: {len(User._check_default_pk())} warnings (should be 0)")
+print(f"  ReservedUsername: {len(ReservedUsername._check_default_pk())} warnings (should be 0)")
+print(f"  RegularModel: {len(RegularModel._check_default_pk())} warnings (should be 1)")
+print(f"  BaseModel: {len(BaseModel._check_default_pk())} warnings (should be 0)")
+print(f"  IntermediateModel: {len(IntermediateModel._check_default_pk())} warnings (should be 0)")
+print(f"  FinalModel: {len(FinalModel._check_default_pk())} warnings (should be 0)")
+
+# Verify the RegularModel actually has a warning
+regular_errors = RegularModel._check_default_pk()
+if regular_errors:
+    print(f"\nRegularModel warning details: {regular_errors[0]}")
+else:
+    print(f"\nRegularModel: No warning found (this might be expected depending on settings)")
+
+print("\n=== Primary Key Details ===")
+for model in [Entity, User, ReservedUsername, RegularModel, BaseModel, IntermediateModel, FinalModel]:
+    print(f"{model.__name__}: auto_created={model._meta.pk.auto_created}, inherited={_is_inherited_pk(model)}")
+
+print("\n=== Test Summary ===")
+print("✅ Inherited models (User, ReservedUsername, IntermediateModel, FinalModel) should have no W042 warnings")
+print("✅ Base models with explicit PK (Entity, BaseModel) should have no W042 warnings") 
+print("❓ Regular models without explicit PK (RegularModel) should have W042 warnings (depends on settings)")
+
+# The key test: inherited models should not have warnings even though they have auto_created=True
+inherited_models = [User, ReservedUsername, IntermediateModel, FinalModel]
+all_inherited_correct = all(len(model._check_default_pk()) == 0 for model in inherited_models)
+
+if all_inherited_correct:
+    print("✅ SUCCESS: Inherited models correctly do not trigger W042 warnings!")
+else:
+    print("❌ FAILURE: Some inherited models still trigger W042 warnings")
+
+# Check that regular models still get warnings (if settings allow it)
+if len(RegularModel._check_default_pk()) > 0:
+    print("✅ SUCCESS: Regular models still trigger W042 warnings as expected")
+else:
+    print("⚠️  NOTE: Regular models don't trigger W042 warnings (this might be due to DEFAULT_AUTO_FIELD settings)")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..ad90b06359
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+# Test case 1: Model with explicit primary key
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 2: Model that inherits from Entity
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 3: Model that inherits from Entity but doesn't define its own primary key
+class ReservedUsername(Entity):
+    username = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 4: Regular model without explicit primary key (should trigger warning)
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 5: Multi-level inheritance
+class BaseModel(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class IntermediateModel(BaseModel):
+    intermediate_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class FinalModel(IntermediateModel):
+    final_field = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Run checks
+print("Running checks...")
+errors = checks.run_checks(app_configs=None)
+
+print("\n=== Results ===")
+
+# Check for warnings on inherited models
+inherited_models = [User, ReservedUsername, IntermediateModel, FinalModel]
+for model in inherited_models:
+    has_warning = any(
+        hasattr(error, 'obj') and error.obj == model and getattr(error, 'id', None) == 'models.W042'
+        for error in errors
+    )
+    if has_warning:
+        print(f"❌ {model.__name__}: Has W042 warning (should not)")
+    else:
+        print(f"✅ {model.__name__}: No W042 warning (correct)")
+
+# Check for warnings on regular model
+has_regular_warning = any(
+    hasattr(error, 'obj') and error.obj == RegularModel and getattr(error, 'id', None) == 'models.W042'
+    for error in errors
+)
+if has_regular_warning:
+    print(f"✅ RegularModel: Has W042 warning (correct)")
+else:
+    print(f"❌ RegularModel: No W042 warning (should have)")
+
+# Check for warnings on base model with explicit PK
+has_entity_warning = any(
+    hasattr(error, 'obj') and error.obj == Entity and getattr(error, 'id', None) == 'models.W042'
+    for error in errors
+)
+if has_entity_warning:
+    print(f"❌ Entity: Has W042 warning (should not)")
+else:
+    print(f"✅ Entity: No W042 warning (correct)")
+
+# Check for warnings on base model with explicit PK
+has_base_warning = any(
+    hasattr(error, 'obj') and error.obj == BaseModel and getattr(error, 'id', None) == 'models.W042'
+    for error in errors
+)
+if has_base_warning:
+    print(f"❌ BaseModel: Has W042 warning (should not)")
+else:
+    print(f"✅ BaseModel: No W042 warning (correct)")
+
+print("\n=== Primary Key Details ===")
+for model in [Entity, User, ReservedUsername, RegularModel, BaseModel, IntermediateModel, FinalModel]:
+    print(f"{model.__name__}: auto_created={model._meta.pk.auto_created}, parents={[p.__name__ for p in model._meta.parents] if model._meta.parents else 'None'}")
\ No newline at end of file
diff --git a/test_inheritance_fix.py b/test_inheritance_fix.py
new file mode 100644
index 0000000000..18b3c430c4
--- /dev/null
+++ b/test_inheritance_fix.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+# Test the specific issue from the GitHub issue
+class Entity(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class User(Entity):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class ReservedUsername(Entity):
+    username = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Run checks specifically on these models
+print("Testing the specific models mentioned in the GitHub issue...")
+
+# Check each model individually
+models_to_test = [Entity, User, ReservedUsername]
+
+for model in models_to_test:
+    print(f"\nChecking {model.__name__}:")
+    # Get the specific checks for this model
+    errors = model.check()
+    w042_errors = [error for error in errors if getattr(error, 'id', None) == 'models.W042']
+    
+    if w042_errors:
+        print(f"  ❌ Found W042 warning: {w042_errors[0]}")
+    else:
+        print(f"  ✅ No W042 warning (correct)")
+    
+    print(f"  auto_created: {model._meta.pk.auto_created}")
+    print(f"  parents: {[p.__name__ for p in model._meta.parents] if model._meta.parents else 'None'}")
+
+# Test that regular models without explicit PK still get the warning
+class RegularModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"\nChecking RegularModel (should have W042 warning):")
+errors = RegularModel.check()
+w042_errors = [error for error in errors if getattr(error, 'id', None) == 'models.W042']
+
+if w042_errors:
+    print(f"  ✅ Found W042 warning: {w042_errors[0]}")
+else:
+    print(f"  ❌ No W042 warning (should have)")
+
+print(f"  auto_created: {RegularModel._meta.pk.auto_created}")
+print(f"  parents: {[p.__name__ for p in RegularModel._meta.parents] if RegularModel._meta.parents else 'None'}")
\ No newline at end of file
diff --git a/test_proper_checks.py b/test_proper_checks.py
new file mode 100644
index 0000000000..9dcd303273
--- /dev/null
+++ b/test_proper_checks.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.test.utils import isolate_apps
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core import checks
+
+# Use isolate_apps to properly test the checks
+@isolate_apps('test_app')
+def test_inheritance_checks():
+    class Entity(models.Model):
+        id = models.BigAutoField(primary_key=True)
+        
+        class Meta:
+            app_label = 'test_app'
+
+    class User(Entity):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test_app'
+
+    class ReservedUsername(Entity):
+        username = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test_app'
+
+    class RegularModel(models.Model):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test_app'
+
+    # Run checks using the same approach as the tests
+    from django.apps import apps
+    app_configs = apps.get_app_configs()
+    errors = checks.run_checks(app_configs=app_configs)
+    
+    print("Testing the specific models mentioned in the GitHub issue...")
+    
+    # Check each model individually
+    models_to_test = [Entity, User, ReservedUsername, RegularModel]
+    
+    for model in models_to_test:
+        print(f"\nChecking {model.__name__}:")
+        model_errors = [error for error in errors if hasattr(error, 'obj') and error.obj == model]
+        w042_errors = [error for error in model_errors if getattr(error, 'id', None) == 'models.W042']
+        
+        if w042_errors:
+            print(f"  ❌ Found W042 warning: {w042_errors[0]}")
+        else:
+            print(f"  ✅ No W042 warning")
+        
+        print(f"  auto_created: {model._meta.pk.auto_created}")
+        print(f"  parents: {[p.__name__ for p in model._meta.parents] if model._meta.parents else 'None'}")
+
+# Run the test
+test_inheritance_checks()
\ No newline at end of file