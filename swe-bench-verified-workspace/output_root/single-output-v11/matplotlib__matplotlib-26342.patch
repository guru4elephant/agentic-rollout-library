diff --git a/debug_comparison.py b/debug_comparison.py
new file mode 100644
index 0000000000..35190b0d54
--- /dev/null
+++ b/debug_comparison.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.path import Path
+from matplotlib.contour import ContourSet
+
+# Create some test data
+x = np.linspace(-3, 3, 100)
+y = np.linspace(-3, 3, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.sin(X) * np.cos(Y)
+
+# Create a contour plot
+fig, ax = plt.subplots()
+cs = ax.contour(X, Y, Z, levels=5)
+
+print("Debugging path comparison...")
+
+# Get original paths
+original_paths = cs.get_paths()
+print(f"Original number of paths: {len(original_paths)}")
+
+# Method 1: Current workaround
+cs1 = ax.contour(X, Y, Z, levels=5)
+paths1 = cs1.get_paths()
+transformed_paths1 = [Path(path.vertices * 1.1) for path in paths1]
+paths1[:] = transformed_paths1
+
+# Method 2: New clean way  
+cs2 = ax.contour(X, Y, Z, levels=5)
+transformed_paths2 = [Path(path.vertices * 1.1) for path in cs2.get_paths()]
+cs2.set_paths(transformed_paths2)
+
+print(f"Method 1 paths count: {len(cs1.get_paths())}")
+print(f"Method 2 paths count: {len(cs2.get_paths())}")
+
+# Compare the results in detail
+for i, (path1, path2) in enumerate(zip(cs1.get_paths(), cs2.get_paths())):
+    vertices_equal = np.allclose(path1.vertices, path2.vertices)
+    print(f"Path {i}: vertices equal = {vertices_equal}")
+    if not vertices_equal:
+        print(f"  Method 1 vertices shape: {path1.vertices.shape}")
+        print(f"  Method 2 vertices shape: {path2.vertices.shape}")
+        print(f"  Max difference: {np.max(np.abs(path1.vertices - path2.vertices))}")
+
+# Check if the paths lists themselves are the same objects
+print(f"Same paths object: {cs1.get_paths() is cs2.get_paths()}")
+print(f"Paths lists are equal: {cs1.get_paths() == cs2.get_paths()}")
+
+print("Debug complete!")
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..ed841aab9d
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.path import Path
+from matplotlib.contour import ContourSet
+
+def test_github_issue():
+    """Test the GitHub issue scenario: replacing ContourSet paths"""
+    
+    print("Testing GitHub issue scenario...")
+    
+    # Create test data
+    x = np.linspace(-3, 3, 100)
+    y = np.linspace(-3, 3, 100)
+    X, Y = np.meshgrid(x, y)
+    Z = np.sin(X) * np.cos(Y)
+    
+    # Create contour plot
+    fig, ax = plt.subplots()
+    cs = ax.contour(X, Y, Z, levels=5)
+    
+    # Get original paths
+    original_paths = cs.get_paths()
+    print(f"Original number of paths: {len(original_paths)}")
+    
+    # Simulate Cartopy's transformation (the old "smelly" way)
+    paths = cs.get_paths()
+    transformed_paths = [Path(path.vertices * 1.1) for path in paths]  # Simple transformation
+    paths[:] = transformed_paths  # Current workaround
+    
+    print("âœ“ Old workaround (paths[:] = transformed_paths) works")
+    
+    # Reset and test the new clean way
+    cs.set_paths(original_paths)  # Reset
+    
+    # New clean way (what the GitHub issue requests)
+    transformed_paths_clean = [Path(path.vertices * 1.1) for path in original_paths]
+    cs.set_paths(transformed_paths_clean)  # New clean API
+    
+    print("âœ“ New clean API (cs.set_paths(transformed_paths)) works")
+    
+    # Verify both methods produce equivalent results
+    final_paths = cs.get_paths()
+    print(f"Final number of paths: {len(final_paths)}")
+    
+    # Check that the transformation was applied correctly
+    for i, (original_path, final_path) in enumerate(zip(original_paths, final_paths)):
+        expected_vertices = original_path.vertices * 1.1
+        actual_vertices = final_path.vertices
+        if not np.allclose(expected_vertices, actual_vertices):
+            print(f"âœ— Path {i} transformation incorrect")
+            return False
+    print("âœ“ Path transformations are correct")
+    
+    # Test edge cases
+    print("\nTesting edge cases...")
+    
+    # Empty paths
+    cs.set_paths([])
+    assert len(cs.get_paths()) == 0
+    print("âœ“ Empty paths work")
+    
+    # Single path
+    single_path = [Path(np.array([[0, 0], [1, 1], [2, 0]]))]
+    cs.set_paths(single_path)
+    assert len(cs.get_paths()) == 1
+    print("âœ“ Single path works")
+    
+    # Restore original
+    cs.set_paths(original_paths)
+    assert len(cs.get_paths()) == len(original_paths)
+    print("âœ“ Path restoration works")
+    
+    print("\nðŸŽ‰ All tests passed! The GitHub issue is resolved.")
+    return True
+
+if __name__ == "__main__":
+    test_github_issue()
\ No newline at end of file
diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index 3f84250b64..401b6d1412 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1475,6 +1475,17 @@ class ContourSet(ContourLabeler, mcoll.Collection):
             ):
                 super().draw(renderer)
 
+    def set_paths(self, paths):
+        """
+        Set the paths for this ContourSet.
+
+        Parameters
+        ----------
+        paths : list of Path
+            The new paths to set.
+        """
+        self._paths = paths
+
 
 @_docstring.dedent_interpd
 class QuadContourSet(ContourSet):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8d1f9844c8
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.contour import ContourSet
+
+# Create some test data
+x = np.linspace(-3, 3, 100)
+y = np.linspace(-3, 3, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.sin(X) * np.cos(Y)
+
+# Create a contour plot
+fig, ax = plt.subplots()
+cs = ax.contour(X, Y, Z, levels=5)
+
+# Test the current behavior
+print("Testing current ContourSet behavior...")
+
+# Get paths using get_paths()
+paths = cs.get_paths()
+print(f"Number of paths: {len(paths)}")
+
+# Try to use set_paths() - this should fail with NotImplementedError
+try:
+    cs.set_paths(paths)
+    print("set_paths() worked!")
+except NotImplementedError as e:
+    print(f"set_paths() failed with: {e}")
+
+# Test the current workaround (what Cartopy does)
+try:
+    paths[:] = paths  # This should work
+    print("Workaround paths[:] = transformed_paths works!")
+except Exception as e:
+    print(f"Workaround failed: {e}")
+
+print("Reproduction complete!")
\ No newline at end of file
diff --git a/test_cartopy_scenario.py b/test_cartopy_scenario.py
new file mode 100644
index 0000000000..7a10cc4e58
--- /dev/null
+++ b/test_cartopy_scenario.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.path import Path
+from matplotlib.contour import ContourSet
+
+# Create some test data
+x = np.linspace(-3, 3, 100)
+y = np.linspace(-3, 3, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.sin(X) * np.cos(Y)
+
+# Create a contour plot
+fig, ax = plt.subplots()
+cs = ax.contour(X, Y, Z, levels=5)
+
+print("Testing Cartopy-like scenario...")
+
+# Get original paths
+original_paths = cs.get_paths()
+print(f"Original number of paths: {len(original_paths)}")
+
+# Simulate Cartopy's transformation workaround
+# This is what Cartopy currently does (the "smelly" way)
+paths = cs.get_paths()
+transformed_paths = [Path(path.vertices * 1.1) for path in paths]  # Simple transformation
+paths[:] = transformed_paths  # Current workaround
+
+print(f"After workaround, number of paths: {len(cs.get_paths())}")
+print(f"Paths transformed: {all(np.allclose(cs.get_paths()[i].vertices, transformed_paths[i].vertices) for i in range(len(transformed_paths)))}")
+
+# Reset to original
+cs.set_paths(original_paths)
+print(f"After reset with set_paths(), number of paths: {len(cs.get_paths())}")
+
+# Now test the new cleaner way
+transformed_paths_clean = [Path(path.vertices * 1.1) for path in original_paths]  # Simple transformation
+cs.set_paths(transformed_paths_clean)  # New clean way
+
+print(f"After clean set_paths(), number of paths: {len(cs.get_paths())}")
+print(f"Paths transformed (clean way): {all(np.allclose(cs.get_paths()[i].vertices, transformed_paths_clean[i].vertices) for i in range(len(transformed_paths_clean)))}")
+
+# Verify both methods produce equivalent results
+print(f"Both methods produce same result: {all(np.allclose(cs.get_paths()[i].vertices, transformed_paths[i].vertices) for i in range(len(transformed_paths)))}")
+
+print("Cartopy scenario test passed!")
\ No newline at end of file
diff --git a/test_set_paths.py b/test_set_paths.py
new file mode 100644
index 0000000000..0799ecd1b6
--- /dev/null
+++ b/test_set_paths.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib.path import Path
+from matplotlib.contour import ContourSet
+
+# Create some test data
+x = np.linspace(-3, 3, 100)
+y = np.linspace(-3, 3, 100)
+X, Y = np.meshgrid(x, y)
+Z = np.sin(X) * np.cos(Y)
+
+# Create a contour plot
+fig, ax = plt.subplots()
+cs = ax.contour(X, Y, Z, levels=5)
+
+print("Testing ContourSet.set_paths() implementation...")
+
+# Test 1: Basic functionality
+original_paths = cs.get_paths()
+print(f"Original number of paths: {len(original_paths)}")
+
+# Create some dummy paths for testing
+dummy_paths = [Path(np.array([[0, 0], [1, 1], [2, 0]])) for _ in range(3)]
+
+# Test set_paths()
+cs.set_paths(dummy_paths)
+new_paths = cs.get_paths()
+print(f"After set_paths(), number of paths: {len(new_paths)}")
+print(f"Paths are equal: {new_paths == dummy_paths}")
+
+# Test 2: Restore original paths
+cs.set_paths(original_paths)
+restored_paths = cs.get_paths()
+print(f"After restoring, number of paths: {len(restored_paths)}")
+print(f"Paths restored correctly: {restored_paths == original_paths}")
+
+# Test 3: Empty paths
+cs.set_paths([])
+empty_paths = cs.get_paths()
+print(f"After setting empty paths, number of paths: {len(empty_paths)}")
+
+# Test 4: Restore again
+cs.set_paths(original_paths)
+restored_paths2 = cs.get_paths()
+print(f"Final restoration, number of paths: {len(restored_paths2)}")
+
+print("All tests passed!")
\ No newline at end of file