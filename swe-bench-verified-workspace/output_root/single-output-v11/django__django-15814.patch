diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..a6936e11ee
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Define various proxy model scenarios
+class BaseModel(models.Model):
+    name = models.CharField(max_length=16)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class ProxyModel1(BaseModel):
+    class Meta:
+        proxy = True
+        app_label = 'test'
+
+class ProxyModel2(BaseModel):
+    class Meta:
+        proxy = True
+        app_label = 'test'
+
+class RegularModel(models.Model):
+    proxy1 = models.ForeignKey(ProxyModel1, on_delete=models.CASCADE)
+    proxy2 = models.ForeignKey(ProxyModel2, on_delete=models.CASCADE, null=True, blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Testing various proxy model scenarios...")
+
+# Test 1: Basic select_related with only on proxy model
+try:
+    query1 = RegularModel.objects.select_related("proxy1").only("proxy1__name")
+    sql1 = str(query1.query)
+    print("✓ Test 1 passed: Basic select_related with only on proxy model")
+except Exception as e:
+    print("✗ Test 1 failed:", e)
+
+# Test 2: Multiple select_related with only on proxy models
+try:
+    query2 = RegularModel.objects.select_related("proxy1", "proxy2").only("proxy1__name", "proxy2__description")
+    sql2 = str(query2.query)
+    print("✓ Test 2 passed: Multiple select_related with only on proxy models")
+except Exception as e:
+    print("✗ Test 2 failed:", e)
+
+# Test 3: Deep select_related chain with proxy models
+try:
+    query3 = RegularModel.objects.select_related("proxy1").only("proxy1__name", "proxy1__description")
+    sql3 = str(query3.query)
+    print("✓ Test 3 passed: Deep select_related chain with proxy models")
+except Exception as e:
+    print("✗ Test 3 failed:", e)
+
+# Test 4: Mixed regular and proxy models
+class RegularRelated(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'test'
+
+class MixedModel(models.Model):
+    proxy = models.ForeignKey(ProxyModel1, on_delete=models.CASCADE)
+    regular = models.ForeignKey(RegularRelated, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+try:
+    query4 = MixedModel.objects.select_related("proxy", "regular").only("proxy__name", "regular__name")
+    sql4 = str(query4.query)
+    print("✓ Test 4 passed: Mixed regular and proxy models")
+except Exception as e:
+    print("✗ Test 4 failed:", e)
+
+print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 33cc636b22..5036335bec 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -748,7 +748,7 @@ class Query(BaseExpression):
                     cur_model = source.related_model
                 else:
                     cur_model = source.remote_field.model
-                opts = cur_model._meta
+                opts = cur_model._meta.concrete_model._meta
                 # Even if we're "just passing through" this model, we must add
                 # both the current model's pk and the related reference field
                 # (if it's not a reverse relation) to the things we select.
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..7d765a8c0e
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix for QuerySet.only() after select_related() crash on proxy models.
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Define the models as described in the issue
+class CustomModel(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'test'
+
+class ProxyCustomModel(CustomModel):
+    class Meta:
+        proxy = True
+        app_label = 'test'
+
+class AnotherModel(models.Model):
+    custom = models.ForeignKey(
+        ProxyCustomModel,
+        on_delete=models.SET_NULL,
+        null=True,
+        blank=True,
+    )
+    
+    class Meta:
+        app_label = 'test'
+
+print("Testing the fix for QuerySet.only() after select_related() crash on proxy models...")
+
+# Test 1: Query compilation (this was the original issue)
+try:
+    query = AnotherModel.objects.select_related("custom").only("custom__name")
+    sql = str(query.query)
+    print("✓ Query compilation successful")
+    print(f"Generated SQL: {sql}")
+except Exception as e:
+    print(f"✗ Query compilation failed: {e}")
+    import traceback
+    traceback.print_exc()
+    sys.exit(1)
+
+# Test 2: Verify the fix addresses the specific issue mentioned
+# The original error was: ValueError: 'id' is not in list
+# This occurred in get_related_populators -> RelatedPopulator.__init__
+try:
+    # This should trigger the related populator initialization
+    from django.db.models.query import get_related_populators
+    
+    # Create a mock scenario to test the RelatedPopulator
+    query = AnotherModel.objects.select_related("custom").only("custom__name")
+    compiler = query.query.get_compiler('default')
+    select, klass_info, _ = compiler.get_select()
+    
+    # This should work without the 'id' is not in list error
+    related_populators = get_related_populators(klass_info, select, 'default')
+    print("✓ Related populator creation successful")
+    
+except ValueError as e:
+    if "'id' is not in list" in str(e):
+        print(f"✗ Original error still occurs: {e}")
+        sys.exit(1)
+    else:
+        print(f"✗ Different ValueError: {e}")
+        sys.exit(1)
+except Exception as e:
+    print(f"✗ Unexpected error: {e}")
+    import traceback
+    traceback.print_exc()
+    sys.exit(1)
+
+print("\n✅ All tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..11d29b3f2f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Define the models as described in the issue
+class CustomModel(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'django.contrib.contenttypes'
+
+class ProxyCustomModel(CustomModel):
+    class Meta:
+        proxy = True
+        app_label = 'django.contrib.contenttypes'
+
+class AnotherModel(models.Model):
+    custom = models.ForeignKey(
+        ProxyCustomModel,
+        on_delete=models.SET_NULL,
+        null=True,
+        blank=True,
+    )
+    
+    class Meta:
+        app_label = 'django.contrib.contenttypes'
+
+# Try to reproduce the issue - actually executing the query
+try:
+    objs = list(AnotherModel.objects.select_related("custom").only("custom__name").all())
+    print("SUCCESS: Query executed without error!")
+except Exception as e:
+    print(f"ERROR: {type(e).__name__}: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_comprehensive_fix.py b/test_comprehensive_fix.py
new file mode 100644
index 0000000000..2c52ea17b7
--- /dev/null
+++ b/test_comprehensive_fix.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix works for both query compilation and execution.
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+from django.test import TestCase
+
+class ComprehensiveProxyFixTest(TestCase):
+    
+    def setUp(self):
+        # Create tables
+        self.create_tables()
+    
+    def create_tables(self):
+        """Create the necessary tables for testing"""
+        with connection.schema_editor() as schema_editor:
+            schema_editor.create_model(CustomModel)
+            schema_editor.create_model(AnotherModel)
+    
+    def test_query_compilation(self):
+        """Test that query compilation works without error"""
+        try:
+            query = AnotherModel.objects.select_related("custom").only("custom__name")
+            sql = str(query.query)
+            self.assertIn("SELECT", sql)
+            print("✓ Query compilation works")
+        except Exception as e:
+            self.fail(f"Query compilation failed: {e}")
+    
+    def test_query_execution(self):
+        """Test that query execution works without error"""
+        try:
+            # This should not raise any errors
+            objs = list(AnotherModel.objects.select_related("custom").only("custom__name").all())
+            print("✓ Query execution works (empty result set expected)")
+        except Exception as e:
+            self.fail(f"Query execution failed: {e}")
+
+# Define the models as described in the issue
+class CustomModel(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'test_proxy_fix'
+
+class ProxyCustomModel(CustomModel):
+    class Meta:
+        proxy = True
+        app_label = 'test_proxy_fix'
+
+class AnotherModel(models.Model):
+    custom = models.ForeignKey(
+        ProxyCustomModel,
+        on_delete=models.SET_NULL,
+        null=True,
+        blank=True,
+    )
+    
+    class Meta:
+        app_label = 'test_proxy_fix'
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_proxy_fix.py b/test_proxy_fix.py
new file mode 100644
index 0000000000..0a0245756e
--- /dev/null
+++ b/test_proxy_fix.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Define the models as described in the issue
+class CustomModel(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'test'
+
+class ProxyCustomModel(CustomModel):
+    class Meta:
+        proxy = True
+        app_label = 'test'
+
+class AnotherModel(models.Model):
+    custom = models.ForeignKey(
+        ProxyCustomModel,
+        on_delete=models.SET_NULL,
+        null=True,
+        blank=True,
+    )
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the specific issue: QuerySet.only() after select_related() on proxy models
+print("Testing QuerySet.only() after select_related() on proxy models...")
+
+# This should trigger the error mentioned in the issue
+try:
+    # Create the query - this should trigger the issue during query compilation
+    query = AnotherModel.objects.select_related("custom").only("custom__name")
+    
+    # Try to get the SQL - this should trigger the error in get_related_populators
+    sql = str(query.query)
+    
+    print("SUCCESS: Query compilation worked without error!")
+    print("SQL:", sql)
+    
+except ValueError as e:
+    if "'id' is not in list" in str(e):
+        print("FAILED: The original error still occurs:", e)
+    else:
+        print("FAILED: Different ValueError:", e)
+    import traceback
+    traceback.print_exc()
+    
+except Exception as e:
+    print("FAILED: Unexpected error:", e)
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_proxy_only_fix.py b/test_proxy_only_fix.py
new file mode 100644
index 0000000000..8ad00de515
--- /dev/null
+++ b/test_proxy_only_fix.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python3
+"""
+Test to verify the fix for QuerySet.only() after select_related() crash on proxy models.
+This test reproduces the exact issue described in the GitHub issue.
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.test import TestCase
+
+class ProxyOnlyFixTest(TestCase):
+    
+    def test_select_related_only_proxy_model(self):
+        """
+        Test that QuerySet.only() after select_related() works correctly on proxy models.
+        This reproduces the exact issue from the GitHub issue.
+        """
+        
+        # Define the models as described in the issue
+        class CustomModel(models.Model):
+            name = models.CharField(max_length=16)
+            
+            class Meta:
+                app_label = 'test_proxy_fix'
+        
+        class ProxyCustomModel(CustomModel):
+            class Meta:
+                proxy = True
+                app_label = 'test_proxy_fix'
+        
+        class AnotherModel(models.Model):
+            custom = models.ForeignKey(
+                ProxyCustomModel,
+                on_delete=models.SET_NULL,
+                null=True,
+                blank=True,
+            )
+            
+            class Meta:
+                app_label = 'test_proxy_fix'
+        
+        # This should not raise ValueError: 'id' is not in list
+        try:
+            query = AnotherModel.objects.select_related("custom").only("custom__name")
+            # Just creating the query should work without error
+            sql = str(query.query)
+            self.assertIn("SELECT", sql)
+            # The important thing is that no ValueError is raised
+            print("✓ Test passed: QuerySet.only() after select_related() works on proxy models")
+        except ValueError as e:
+            if "'id' is not in list" in str(e):
+                self.fail(f"Original error still occurs: {e}")
+            else:
+                raise
+        except Exception as e:
+            self.fail(f"Unexpected error: {e}")
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_regular_models.py b/test_regular_models.py
new file mode 100644
index 0000000000..5dbe503136
--- /dev/null
+++ b/test_regular_models.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test with regular models (non-proxy)
+class RegularModel1(models.Model):
+    name = models.CharField(max_length=16)
+    
+    class Meta:
+        app_label = 'test'
+
+class RegularModel2(models.Model):
+    regular = models.ForeignKey(RegularModel1, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+print("Testing regular models (non-proxy) to ensure no regression...")
+
+try:
+    query = RegularModel2.objects.select_related("regular").only("regular__name")
+    sql = str(query.query)
+    print("✓ Regular models work correctly: No regression")
+    print("SQL:", sql)
+except Exception as e:
+    print("✗ Regression detected:", e)
+    import traceback
+    traceback.print_exc()
\ No newline at end of file