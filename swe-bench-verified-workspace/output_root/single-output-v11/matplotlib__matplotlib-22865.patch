diff --git a/before_fix.png b/before_fix.png
new file mode 100644
index 0000000000..f709a281f3
Binary files /dev/null and b/before_fix.png differ
diff --git a/debug_edges.py b/debug_edges.py
new file mode 100644
index 0000000000..a862f197d5
--- /dev/null
+++ b/debug_edges.py
@@ -0,0 +1,42 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+# Test with extend='both'
+my_cmap = mpl.cm.viridis
+bounds = np.arange(10)
+nb_colors = len(bounds) + 1
+colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+plt.figure(figsize=(5, 1))
+ax = plt.subplot(111)
+cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, orientation='horizontal', drawedges=True)
+
+# Get detailed info about boundaries and edges
+print("cbar._boundaries:", cbar._boundaries)
+print("cbar._inside:", cbar._inside)
+print("Main boundaries (cbar._boundaries[cbar._inside]):", cbar._boundaries[cbar._inside])
+
+# Get X and Y from _mesh
+X, Y = cbar._mesh()
+print("X shape:", X.shape)
+print("Y shape:", Y.shape)
+
+# Check what segments would be created
+segments = np.dstack([X, Y])
+print("segments shape:", segments.shape)
+print("Number of segments:", len(segments))
+
+# Test different slicing approaches
+print("\nTesting different segment slicing:")
+print("segments (all):", len(segments), "segments")
+print("segments[1:-1]:", len(segments[1:-1]), "segments")
+print("segments[:-1]:", len(segments[:-1]), "segments")  
+print("segments[1:]:", len(segments[1:]), "segments")
+
+# The segments should correspond to boundaries
+print("\nSegments should correspond to boundaries:")
+for i, segment in enumerate(segments):
+    print(f"Segment {i}: {segment} -> should correspond to boundary {cbar._boundaries[i]}")
\ No newline at end of file
diff --git a/debug_segments.py b/debug_segments.py
new file mode 100644
index 0000000000..52d9eccfc0
--- /dev/null
+++ b/debug_segments.py
@@ -0,0 +1,42 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+# Test with extend='both'
+my_cmap = mpl.cm.viridis
+bounds = np.arange(10)
+nb_colors = len(bounds) + 1
+colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+plt.figure(figsize=(5, 1))
+ax = plt.subplot(111)
+cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, orientation='horizontal', drawedges=True)
+
+# Get detailed info
+print("cbar._boundaries:", cbar._boundaries)
+print("Number of boundaries:", len(cbar._boundaries))
+print("cbar._inside:", cbar._inside)
+
+# Get X and Y from _mesh
+X, Y = cbar._mesh()
+print("X shape:", X.shape)
+print("Y shape:", Y.shape)
+
+# Check segments
+segments = np.dstack([X, Y])
+print("segments shape:", segments.shape)
+print("Number of segments:", len(segments))
+
+# Check what the dividers actually contain
+divider_segments = cbar.dividers.get_segments()
+print("Number of divider segments:", len(divider_segments))
+
+# The issue might be in how _mesh() works
+print("cbar._y:", cbar._y)
+print("Length of cbar._y:", len(cbar._y))
+
+# Let's see what _process_values() does
+print("cbar._values:", cbar._values)
+print("Length of cbar._values:", len(cbar._values))
\ No newline at end of file
diff --git a/debug_structure.py b/debug_structure.py
new file mode 100644
index 0000000000..6197b57921
--- /dev/null
+++ b/debug_structure.py
@@ -0,0 +1,35 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+my_cmap = mpl.cm.viridis
+bounds = np.arange(10)
+nb_colors = len(bounds) + 1
+colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+plt.figure(figsize=(5, 1))
+ax = plt.subplot(111)
+cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, orientation='horizontal', drawedges=True)
+
+# Let's access the internal state to understand the structure
+print("cbar._boundaries:", cbar._boundaries)
+print("cbar._values:", cbar._values)
+print("cbar._inside:", cbar._inside)
+
+# Get X and Y from _mesh
+X, Y = cbar._mesh()
+print("X shape:", X.shape)
+print("Y shape:", Y.shape)
+print("X:", X)
+print("Y:", Y)
+
+# Check what np.dstack([X, Y]) produces
+stacked = np.dstack([X, Y])
+print("np.dstack([X, Y]) shape:", stacked.shape)
+print("np.dstack([X, Y]):", stacked)
+
+# Check what [1:-1] removes
+print("np.dstack([X, Y])[1:-1] shape:", stacked[1:-1].shape)
+print("np.dstack([X, Y])[1:-1]:", stacked[1:-1])
\ No newline at end of file
diff --git a/extend_neither.png b/extend_neither.png
new file mode 100644
index 0000000000..8884a67edb
Binary files /dev/null and b/extend_neither.png differ
diff --git a/fixed_extend_both.png b/fixed_extend_both.png
new file mode 100644
index 0000000000..e5118533f7
Binary files /dev/null and b/fixed_extend_both.png differ
diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py
index c59b0ac815..e38261436b 100644
--- a/lib/matplotlib/colorbar.py
+++ b/lib/matplotlib/colorbar.py
@@ -651,8 +651,11 @@ class Colorbar:
             if not self.drawedges:
                 if len(self._y) >= self.n_rasterize:
                     self.solids.set_rasterized(True)
-        self.dividers.set_segments(
-            np.dstack([X, Y])[1:-1] if self.drawedges else [])
+        if self.drawedges:
+            # Draw edges for all boundaries
+            self.dividers.set_segments(np.dstack([X, Y]))
+        else:
+            self.dividers.set_segments([])
 
     def _add_solids_patches(self, X, Y, C, mappable):
         hatches = mappable.hatches * len(C)  # Have enough hatches.
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8ec5f8985d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,17 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+my_cmap = mpl.cm.viridis
+bounds = np.arange(10)
+nb_colors = len(bounds) + 1
+colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+plt.figure(figsize=(5, 1))
+ax = plt.subplot(111)
+cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, orientation='horizontal', drawedges=True)
+plt.subplots_adjust(left=0.05, bottom=0.4, right=0.95, top=0.9)
+plt.savefig('before_fix.png')
+plt.show()
\ No newline at end of file
diff --git a/test_default.png b/test_default.png
new file mode 100644
index 0000000000..dcbd94e4e0
Binary files /dev/null and b/test_default.png differ
diff --git a/test_drawedges_fix.py b/test_drawedges_fix.py
new file mode 100644
index 0000000000..2bd7c25b25
--- /dev/null
+++ b/test_drawedges_fix.py
@@ -0,0 +1,74 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+def test_drawedges_with_extend_both():
+    """Test that drawedges=True works with extend='both'"""
+    my_cmap = mpl.cm.viridis
+    bounds = np.arange(10)
+    nb_colors = len(bounds) + 1
+    colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+    my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+    plt.figure(figsize=(5, 1))
+    ax = plt.subplot(111)
+    cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, 
+                                    orientation='horizontal', drawedges=True)
+    
+    # Check that dividers are properly set
+    assert len(cbar.dividers.get_segments()) > 0, "No divider segments found"
+    
+    # For extend='both', we should have edges at extremities
+    segments = cbar.dividers.get_segments()
+    print(f"Number of divider segments: {len(segments)}")
+    
+    # The segments should correspond to all boundaries including extended ones
+    print(f"Boundaries: {cbar._boundaries}")
+    print(f"Number of boundaries: {len(cbar._boundaries)}")
+    
+    # For extend='both', number of segments should equal number of boundaries - 1
+    # (since each segment is between two boundaries)
+    expected_segments = len(cbar._boundaries) - 1
+    assert len(segments) == expected_segments, \
+        f"Expected {expected_segments} segments, got {len(segments)}"
+    
+    plt.close()
+    print("✓ Test passed: drawedges=True with extend='both' works correctly")
+
+def test_drawedges_with_other_extend_modes():
+    """Test that drawedges=True works with other extend modes"""
+    extend_modes = ['neither', 'min', 'max']
+    
+    for extend_mode in extend_modes:
+        my_cmap = mpl.cm.viridis
+        bounds = np.arange(10)
+        
+        # Number of colors depends on extend mode
+        if extend_mode == 'neither':
+            nb_colors = len(bounds) - 1
+        else:  # 'min' or 'max'
+            nb_colors = len(bounds)
+            
+        colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+        my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend=extend_mode)
+
+        plt.figure(figsize=(5, 1))
+        ax = plt.subplot(111)
+        cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, 
+                                        orientation='horizontal', drawedges=True)
+        
+        # Check that dividers are properly set
+        assert len(cbar.dividers.get_segments()) > 0, f"No divider segments found for extend='{extend_mode}'"
+        
+        segments = cbar.dividers.get_segments()
+        print(f"extend='{extend_mode}': {len(segments)} segments")
+        
+        plt.close()
+    
+    print("✓ Test passed: drawedges=True works with all extend modes")
+
+if __name__ == "__main__":
+    test_drawedges_with_extend_both()
+    test_drawedges_with_other_extend_modes()
+    print("All tests passed!")
\ No newline at end of file
diff --git a/test_extend_modes.png b/test_extend_modes.png
new file mode 100644
index 0000000000..ec5e7e2d24
Binary files /dev/null and b/test_extend_modes.png differ
diff --git a/test_extend_modes.py b/test_extend_modes.py
new file mode 100644
index 0000000000..f590ed41b1
--- /dev/null
+++ b/test_extend_modes.py
@@ -0,0 +1,39 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+# Test all extend modes
+extend_modes = ['neither', 'both', 'min', 'max']
+
+fig, axes = plt.subplots(2, 2, figsize=(10, 6))
+axes = axes.flatten()
+
+for i, extend_mode in enumerate(extend_modes):
+    my_cmap = mpl.cm.viridis
+    bounds = np.arange(10)
+    # Number of colors depends on extend mode
+    if extend_mode == 'neither':
+        nb_colors = len(bounds) - 1
+    elif extend_mode == 'both':
+        nb_colors = len(bounds) + 1
+    else:  # 'min' or 'max'
+        nb_colors = len(bounds)
+    colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+    my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend=extend_mode)
+    
+    ax = axes[i]
+    cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, 
+                                    orientation='horizontal', drawedges=True)
+    ax.set_title(f'extend="{extend_mode}"')
+    
+    # Print debug info
+    print(f"extend='{extend_mode}':")
+    print(f"  cbar.extend: {cbar.extend}")
+    print(f"  cbar._inside: {cbar._inside}")
+    print(f"  cbar._extend_lower(): {cbar._extend_lower()}")
+    print(f"  cbar._extend_upper(): {cbar._extend_upper()}")
+
+plt.tight_layout()
+plt.savefig('test_extend_modes.png')
+plt.show()
\ No newline at end of file
diff --git a/visual_test.py b/visual_test.py
new file mode 100644
index 0000000000..daf021332c
--- /dev/null
+++ b/visual_test.py
@@ -0,0 +1,31 @@
+import matplotlib as mpl
+import numpy as np
+import matplotlib.pyplot as plt  
+from matplotlib.colors import from_levels_and_colors
+
+# Test the original issue: extend='both' with drawedges=True
+my_cmap = mpl.cm.viridis
+bounds = np.arange(10)
+nb_colors = len(bounds) + 1
+colors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))
+my_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')
+
+plt.figure(figsize=(8, 2))
+ax = plt.subplot(111)
+cbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, 
+                                orientation='horizontal', drawedges=True)
+plt.subplots_adjust(left=0.05, bottom=0.4, right=0.95, top=0.9)
+plt.savefig('fixed_extend_both.png', dpi=150, bbox_inches='tight')
+plt.show()
+
+# Compare with extend='neither' to see the difference
+plt.figure(figsize=(8, 2))
+ax = plt.subplot(111)
+my_cmap2, my_norm2 = from_levels_and_colors(bounds, colors[:-2], extend='neither')
+cbar2 = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap2, norm=my_norm2, 
+                                 orientation='horizontal', drawedges=True)
+plt.subplots_adjust(left=0.05, bottom=0.4, right=0.95, top=0.9)
+plt.savefig('extend_neither.png', dpi=150, bbox_inches='tight')
+plt.show()
+
+print("Test completed. Check the saved images to verify the fix.")
\ No newline at end of file