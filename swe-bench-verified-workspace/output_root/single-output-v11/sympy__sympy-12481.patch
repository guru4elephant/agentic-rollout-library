diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..3d540429d2
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation, Cycle
+
+def test_comprehensive():
+    """Comprehensive test of non-disjoint cycles"""
+    print("=== Comprehensive test of non-disjoint cycles ===")
+    
+    # Test cases from the GitHub issue
+    test_cases = [
+        # (input, expected_array_form, description)
+        ([[0,1],[0,1]], [0, 1], "Identity: (0,1)(0,1)"),
+        ([[0,1],[1,2]], [2, 0, 1], "Composition: (0,1)(1,2)"),
+        ([[1],[1,2]], [0, 2, 1], "Singleton + cycle: [1](1,2)"),
+        ([[0,1],[1,0]], [0, 1], "Inverse cycles: (0,1)(1,0)"),
+        ([[0,1,2],[1,3,4]], [3, 2, 0, 4, 1], "Complex composition"),
+    ]
+    
+    for i, (cycles, expected, desc) in enumerate(test_cases):
+        try:
+            p = Permutation(cycles)
+            success = p.array_form == expected
+            print(f"\nTest {i+1}: {desc}")
+            print(f"  Input: {cycles}")
+            print(f"  Result: {p.array_form}")
+            print(f"  Expected: {expected}")
+            print(f"  ✓ PASS" if success else f"  ✗ FAIL")
+            if not success:
+                print(f"  ERROR: Expected {expected}, got {p.array_form}")
+        except Exception as e:
+            print(f"\nTest {i+1}: {desc}")
+            print(f"  Input: {cycles}")
+            print(f"  ✗ ERROR: {type(e).__name__}: {e}")
+    
+    # Test that duplicate elements in array form still raise errors
+    print("\n=== Testing that array form duplicates still raise errors ===")
+    try:
+        p = Permutation([0, 1, 1])  # Should fail
+        print(f"✗ UNEXPECTED SUCCESS: [0, 1, 1] = {p}")
+    except ValueError as e:
+        print(f"✓ EXPECTED ERROR: [0, 1, 1] -> {e}")
+    except Exception as e:
+        print(f"? UNEXPECTED ERROR: [0, 1, 1] -> {type(e).__name__}: {e}")
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/debug_test_case.py b/debug_test_case.py
new file mode 100644
index 0000000000..1262c3c962
--- /dev/null
+++ b/debug_test_case.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation, Cycle
+
+# Test the specific case that's failing in the test
+try:
+    p = Permutation([[1], [1, 2]])
+    print(f"Permutation([[1], [1, 2]]) = {p}")
+    print(f"Array form: {p.array_form}")
+    print(f"Is identity: {p.is_Identity}")
+except Exception as e:
+    print(f"Error: {type(e).__name__}: {e}")
+
+# Let's also see what Cycle does with this
+try:
+    c = Cycle()
+    c = c(*[1])
+    c = c(*[1, 2])
+    print(f"\nCycle composition: {c}")
+    print(f"Cycle list: {c.list()}")
+except Exception as e:
+    print(f"Cycle error: {type(e).__name__}: {e}")
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..60908e60ef
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+def test_github_issue():
+    """Test the exact case from the GitHub issue"""
+    print("Testing the exact GitHub issue case...")
+    
+    # This is the exact case from the GitHub issue
+    try:
+        p = Permutation([[0,1],[0,1]])
+        print(f"✓ SUCCESS: Permutation([[0,1],[0,1]]) = {p}")
+        print(f"  Array form: {p.array_form}")
+        print(f"  Is identity: {p.is_Identity}")
+        
+        # Verify it's actually the identity permutation
+        expected_identity = Permutation([0, 1])
+        if p == expected_identity and p.is_Identity:
+            print("  ✓ Confirmed: This is indeed the identity permutation")
+        else:
+            print("  ✗ ERROR: Expected identity permutation")
+            
+    except Exception as e:
+        print(f"✗ FAILED: {type(e).__name__}: {e}")
+        
+    # Test that the error message suggestion from the old code actually works
+    print("\nTesting that the old error message suggestion works...")
+    try:
+        from sympy.combinatorics.permutations import Cycle
+        c = Cycle(*[[0,1],[0,1]])
+        p_from_cycle = Permutation(c)
+        print(f"✓ Cycle([[0,1],[0,1]]) = {p_from_cycle}")
+        print(f"  Array form: {p_from_cycle.array_form}")
+    except Exception as e:
+        print(f"✗ Cycle failed: {type(e).__name__}: {e}")
+
+if __name__ == "__main__":
+    test_github_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..4ebdd331d5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,31 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+def test_non_disjoint_cycles():
+    """Test the issue with non-disjoint cycles in Permutation constructor"""
+    print("Testing Permutation with non-disjoint cycles...")
+    
+    # This should create the identity permutation since (0,1)(0,1) = identity
+    try:
+        p = Permutation([[0,1],[0,1]])
+        print(f"Success: {p}")
+        print(f"Array form: {p.array_form}")
+        print(f"Is identity: {p.is_Identity}")
+    except Exception as e:
+        print(f"Error: {type(e).__name__}: {e}")
+    
+    # Test another case with overlapping cycles
+    try:
+        p2 = Permutation([[0,1],[1,2]])
+        print(f"\nSuccess: {p2}")
+        print(f"Array form: {p2.array_form}")
+    except Exception as e:
+        print(f"Error with [[0,1],[1,2]]: {type(e).__name__}: {e}")
+    
+    # Test what should be the expected result for [[0,1],[0,1]]
+    # This should be the identity permutation [0, 1, 2, ...]
+    print(f"\nExpected identity permutation: {Permutation([0, 1])}")
+
+if __name__ == "__main__":
+    test_non_disjoint_cycles()
\ No newline at end of file
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..4854a07853 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -896,10 +896,7 @@ def __new__(cls, *args, **kwargs):
 
         temp = flatten(args)
         if has_dups(temp):
-            if is_cycle:
-                raise ValueError('there were repeated elements; to resolve '
-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))
-            else:
+            if not is_cycle:
                 raise ValueError('there were repeated elements.')
         temp = set(temp)
 
diff --git a/test_cycle_consistency.py b/test_cycle_consistency.py
new file mode 100644
index 0000000000..5960967c6a
--- /dev/null
+++ b/test_cycle_consistency.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation, Cycle
+
+def test_cycle_consistency():
+    """Test that Permutation and Cycle handle non-disjoint cycles consistently"""
+    print("Testing consistency between Permutation and Cycle classes...")
+    
+    # Test cases where both should behave the same way
+    test_cases = [
+        [[0,1],[0,1]],
+        [[0,1],[1,2]],
+        [[1],[1,2]],
+        [[0,1],[1,0]],
+    ]
+    
+    for cycles in test_cases:
+        try:
+            # Create using Permutation constructor
+            p = Permutation(cycles)
+            
+            # Create using Cycle composition then convert to Permutation
+            c = Cycle()
+            for cycle in cycles:
+                c = c(*cycle)
+            p_from_cycle = Permutation(c)
+            
+            # They should be equal
+            if p == p_from_cycle:
+                print(f"✓ CONSISTENT: {cycles} -> {p}")
+            else:
+                print(f"✗ INCONSISTENT: {cycles}")
+                print(f"  Permutation: {p}")
+                print(f"  From Cycle: {p_from_cycle}")
+                
+        except Exception as e:
+            print(f"✗ ERROR with {cycles}: {type(e).__name__}: {e}")
+
+if __name__ == "__main__":
+    test_cycle_consistency()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..1445c3e669
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+def test_edge_cases():
+    """Test edge cases for non-disjoint cycles"""
+    print("Testing edge cases for non-disjoint cycles...")
+    
+    # Test case 1: Multiple overlapping cycles
+    try:
+        p1 = Permutation([[0,1],[1,2],[2,3]])
+        print(f"Success [[0,1],[1,2],[2,3]]: {p1}")
+        print(f"Array form: {p1.array_form}")
+    except Exception as e:
+        print(f"Error: {type(e).__name__}: {e}")
+    
+    # Test case 2: Cycles that cancel each other out
+    try:
+        p2 = Permutation([[0,1],[1,0]])
+        print(f"\nSuccess [[0,1],[1,0]]: {p2}")
+        print(f"Array form: {p2.array_form}")
+        print(f"Is identity: {p2.is_Identity}")
+    except Exception as e:
+        print(f"Error: {type(e).__name__}: {e}")
+    
+    # Test case 3: Complex overlapping cycles
+    try:
+        p3 = Permutation([[0,1,2],[1,3,4]])
+        print(f"\nSuccess [[0,1,2],[1,3,4]]: {p3}")
+        print(f"Array form: {p3.array_form}")
+    except Exception as e:
+        print(f"Error: {type(e).__name__}: {e}")
+    
+    # Test case 4: Verify that duplicate elements in array form still raise error
+    try:
+        p4 = Permutation([0, 1, 1])  # This should still fail
+        print(f"\nUnexpected success [0,1,1]: {p4}")
+    except Exception as e:
+        print(f"\nExpected error [0,1,1]: {type(e).__name__}: {e}")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file