diff --git a/django/forms/fields.py b/django/forms/fields.py
index 03cd8af8d7..18007accab 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -199,6 +199,7 @@ class Field:
         result = copy.copy(self)
         memo[id(self)] = result
         result.widget = copy.deepcopy(self.widget, memo)
+        result.error_messages = copy.deepcopy(self.error_messages, memo)
         result.validators = self.validators[:]
         return result
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c60c69d226
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the deepcopy issue with form field error messages.
+"""
+
+import os
+import sys
+import copy
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Minimal Django configuration
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+
+django.setup()
+
+from django.forms import CharField
+
+def test_deepcopy_error_messages():
+    print("Testing deepcopy of form field error messages...")
+    
+    # Create a field instance
+    field1 = CharField()
+    
+    # Make a deep copy
+    field2 = copy.deepcopy(field1)
+    
+    # Check if they share the same error_messages dictionary
+    print(f"field1.error_messages is field2.error_messages: {field1.error_messages is field2.error_messages}")
+    print(f"field1.error_messages id: {id(field1.error_messages)}")
+    print(f"field2.error_messages id: {id(field2.error_messages)}")
+    
+    # Modify error messages on one field
+    print("\nModifying error_messages on field1...")
+    field1.error_messages['required'] = 'Custom required message'
+    
+    # Check if the change affects the other field
+    print(f"field1.error_messages['required']: {field1.error_messages['required']}")
+    print(f"field2.error_messages['required']: {field2.error_messages['required']}")
+    
+    # Test with different error messages initially
+    print("\n" + "="*50)
+    print("Testing with different initial error messages...")
+    
+    field3 = CharField(error_messages={'required': 'Original required'})
+    field4 = copy.deepcopy(field3)
+    
+    print(f"field3.error_messages is field4.error_messages: {field3.error_messages is field4.error_messages}")
+    
+    # Modify field3
+    field3.error_messages['required'] = 'Modified required'
+    print(f"field3.error_messages['required']: {field3.error_messages['required']}")
+    print(f"field4.error_messages['required']: {field4.error_messages['required']}")
+
+if __name__ == "__main__":
+    test_deepcopy_error_messages()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..21099a60d1
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the deepcopy fix of form field error messages.
+"""
+
+import os
+import sys
+import copy
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Minimal Django configuration
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+
+django.setup()
+
+from django.forms import CharField, Form
+
+def test_comprehensive_deepcopy():
+    print("Comprehensive deepcopy test for form field error messages...")
+    
+    # Test 1: Basic deepcopy functionality
+    print("\n1. Testing basic deepcopy...")
+    field1 = CharField(error_messages={'required': 'Custom required', 'invalid': 'Invalid input'})
+    field2 = copy.deepcopy(field1)
+    
+    print(f"   Original and copy share error_messages: {field1.error_messages is field2.error_messages}")
+    print(f"   Original error_messages: {dict(field1.error_messages)}")
+    print(f"   Copy error_messages: {dict(field2.error_messages)}")
+    
+    # Modify original
+    field1.error_messages['required'] = 'Changed required'
+    field1.error_messages['new_key'] = 'New message'
+    
+    print(f"   After modifying original:")
+    print(f"   Original error_messages: {dict(field1.error_messages)}")
+    print(f"   Copy error_messages: {dict(field2.error_messages)}")
+    
+    # Test 2: Nested dictionary in error messages
+    print("\n2. Testing nested dictionaries...")
+    field3 = CharField(error_messages={'nested': {'level1': 'value1'}})
+    field4 = copy.deepcopy(field3)
+    
+    print(f"   Original nested: {field3.error_messages['nested']}")
+    print(f"   Copy nested: {field4.error_messages['nested']}")
+    print(f"   Nested objects are same: {field3.error_messages['nested'] is field4.error_messages['nested']}")
+    
+    # Modify nested in original
+    field3.error_messages['nested']['level1'] = 'modified_value'
+    print(f"   After modifying nested in original:")
+    print(f"   Original nested: {field3.error_messages['nested']}")
+    print(f"   Copy nested: {field4.error_messages['nested']}")
+    
+    # Test 3: Empty error messages
+    print("\n3. Testing empty error messages...")
+    field5 = CharField(error_messages={})
+    field6 = copy.deepcopy(field5)
+    
+    print(f"   Empty error_messages are same object: {field5.error_messages is field6.error_messages}")
+    field5.error_messages['test'] = 'test_value'
+    print(f"   After adding to original empty:")
+    print(f"   Original: {dict(field5.error_messages)}")
+    print(f"   Copy: {dict(field6.error_messages)}")
+    
+    # Test 4: Multiple levels of deepcopy
+    print("\n4. Testing multiple deepcopy levels...")
+    field7 = CharField(error_messages={'multi': 'level'})
+    field8 = copy.deepcopy(field7)
+    field9 = copy.deepcopy(field8)
+    
+    print(f"   All have different error_messages: "
+          f"{field7.error_messages is not field8.error_messages is not field9.error_messages}")
+    
+    field7.error_messages['multi'] = 'changed'
+    print(f"   After modifying original:")
+    print(f"   Original: {dict(field7.error_messages)}")
+    print(f"   First copy: {dict(field8.error_messages)}")
+    print(f"   Second copy: {dict(field9.error_messages)}")
+    
+    print("\nAll tests completed successfully!")
+
+if __name__ == "__main__":
+    test_comprehensive_deepcopy()
\ No newline at end of file
diff --git a/test_deepcopy_error_messages.py b/test_deepcopy_error_messages.py
new file mode 100644
index 0000000000..8035021063
--- /dev/null
+++ b/test_deepcopy_error_messages.py
@@ -0,0 +1,99 @@
+#!/usr/bin/env python3
+"""
+Test to verify the deepcopy fix for error_messages works correctly.
+This can be run as a Django test.
+"""
+
+import os
+import sys
+import copy
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+from django.test import SimpleTestCase
+
+# Minimal Django configuration
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+        INSTALLED_APPS=[],
+    )
+
+django.setup()
+
+from django.forms import Field
+
+class FieldDeepcopyTests(SimpleTestCase):
+    
+    def test_deepcopy_error_messages_isolation(self):
+        """
+        Test that deepcopy creates isolated error_messages dictionaries.
+        """
+        # Create field with custom error messages
+        field1 = Field(error_messages={'required': 'Custom required', 'invalid': 'Invalid input'})
+        field2 = copy.deepcopy(field1)
+        
+        # They should not share the same error_messages object
+        self.assertIsNot(field1.error_messages, field2.error_messages)
+        
+        # Modify error messages on original field
+        field1.error_messages['required'] = 'Changed required'
+        field1.error_messages['new_key'] = 'New message'
+        
+        # Copy should remain unchanged
+        self.assertEqual(field2.error_messages['required'], 'Custom required')
+        self.assertNotIn('new_key', field2.error_messages)
+        
+        # Original should have the changes
+        self.assertEqual(field1.error_messages['required'], 'Changed required')
+        self.assertEqual(field1.error_messages['new_key'], 'New message')
+    
+    def test_deepcopy_nested_error_messages(self):
+        """
+        Test that nested dictionaries in error_messages are also deepcopied.
+        """
+        field1 = Field(error_messages={'nested': {'level1': 'value1'}})
+        field2 = copy.deepcopy(field1)
+        
+        # Nested dictionaries should be different objects
+        self.assertIsNot(field1.error_messages['nested'], field2.error_messages['nested'])
+        
+        # Modify nested dictionary in original
+        field1.error_messages['nested']['level1'] = 'modified_value'
+        
+        # Copy should remain unchanged
+        self.assertEqual(field2.error_messages['nested']['level1'], 'value1')
+        self.assertEqual(field1.error_messages['nested']['level1'], 'modified_value')
+    
+    def test_deepcopy_empty_error_messages(self):
+        """
+        Test that empty error_messages dictionaries are properly handled.
+        """
+        field1 = Field(error_messages={})
+        field2 = copy.deepcopy(field1)
+        
+        # They should not share the same dictionary
+        self.assertIsNot(field1.error_messages, field2.error_messages)
+        
+        # Add to original
+        original_length = len(field1.error_messages)
+        field1.error_messages['test'] = 'test_value'
+        
+        # Copy should remain unchanged (only default messages)
+        self.assertEqual(len(field2.error_messages), original_length)
+        self.assertEqual(field1.error_messages['test'], 'test_value')
+        self.assertNotIn('test', field2.error_messages)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_form_functionality.py b/test_form_functionality.py
new file mode 100644
index 0000000000..b7a38a24b8
--- /dev/null
+++ b/test_form_functionality.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Test to ensure form functionality still works after the deepcopy fix.
+"""
+
+import os
+import sys
+import copy
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+
+# Minimal Django configuration
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+    )
+
+django.setup()
+
+from django.forms import Form, CharField
+
+class TestForm(Form):
+    name = CharField(error_messages={'required': 'Name is required'})
+    email = CharField(error_messages={'required': 'Email is required'})
+
+def test_form_functionality():
+    print("Testing form functionality after deepcopy fix...")
+    
+    # Create form instances
+    form1 = TestForm()
+    form2 = TestForm()
+    
+    # Check if fields are properly isolated
+    print(f"Form1 name field error_messages id: {id(form1.fields['name'].error_messages)}")
+    print(f"Form2 name field error_messages id: {id(form2.fields['name'].error_messages)}")
+    print(f"Same error_messages object: {form1.fields['name'].error_messages is form2.fields['name'].error_messages}")
+    
+    # Modify error messages on one form
+    form1.fields['name'].error_messages['required'] = 'Custom name required'
+    
+    # Check if the other form is unaffected
+    print(f"Form1 name required message: {form1.fields['name'].error_messages['required']}")
+    print(f"Form2 name required message: {form2.fields['name'].error_messages['required']}")
+    
+    # Test form validation
+    print("\nTesting form validation...")
+    form3 = TestForm({})  # Empty data
+    form3.is_valid()  # This should trigger validation
+    
+    print(f"Form3 name errors: {form3.errors.get('name', [])}")
+    print(f"Form3 email errors: {form3.errors.get('email', [])}")
+    
+    print("\nForm functionality test completed successfully!")
+
+if __name__ == "__main__":
+    test_form_functionality()
\ No newline at end of file
diff --git a/test_github_issue_fix.py b/test_github_issue_fix.py
new file mode 100644
index 0000000000..c63e61decd
--- /dev/null
+++ b/test_github_issue_fix.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+"""
+Test that reproduces and verifies the fix for the GitHub issue:
+Form Field's __deepcopy__ does not (deep)copy the error messages.
+"""
+
+import os
+import sys
+import copy
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings
+from django.test import SimpleTestCase
+
+# Minimal Django configuration
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        USE_I18N=False,
+        USE_L10N=False,
+        USE_TZ=False,
+        INSTALLED_APPS=[],
+    )
+
+django.setup()
+
+from django.forms import Form, CharField
+
+class ProfileForm(Form):
+    name = CharField(error_messages={'required': 'Please enter your name'})
+    email = CharField(error_messages={'required': 'Please enter your email'})
+
+class GitHubIssueFixTest(SimpleTestCase):
+    """
+    Test that demonstrates the original issue is fixed.
+    
+    The issue was that multiple form instances shared the same error_messages
+    dictionary, so modifying error messages on one form would affect all others.
+    """
+    
+    def test_form_instances_have_isolated_error_messages(self):
+        """Test that different form instances have isolated error_messages."""
+        
+        # Create multiple form instances
+        form1 = ProfileForm()
+        form2 = ProfileForm()
+        
+        # They should have different error_messages dictionaries
+        self.assertIsNot(form1.fields['name'].error_messages, form2.fields['name'].error_messages)
+        self.assertIsNot(form1.fields['email'].error_messages, form2.fields['email'].error_messages)
+        
+        # Modify error messages on form1
+        form1.fields['name'].error_messages['required'] = 'Custom name required'
+        form1.fields['email'].error_messages['required'] = 'Custom email required'
+        form1.fields['name'].error_messages['invalid'] = 'Invalid name format'
+        
+        # form2 should remain unchanged
+        self.assertEqual(form2.fields['name'].error_messages['required'], 'Please enter your name')
+        self.assertEqual(form2.fields['email'].error_messages['required'], 'Please enter your email')
+        self.assertNotIn('invalid', form2.fields['name'].error_messages)
+        
+        # form1 should have the changes
+        self.assertEqual(form1.fields['name'].error_messages['required'], 'Custom name required')
+        self.assertEqual(form1.fields['email'].error_messages['required'], 'Custom email required')
+        self.assertEqual(form1.fields['name'].error_messages['invalid'], 'Invalid name format')
+    
+    def test_dynamic_error_message_modification(self):
+        """Test that dynamic error message modification works correctly."""
+        
+        # Create a base form class
+        class BaseForm(Form):
+            field1 = CharField(error_messages={'required': 'Base required'})
+        
+        # Create multiple instances
+        instance1 = BaseForm()
+        instance2 = BaseForm()
+        
+        # Dynamically modify error messages on instance1
+        instance1.fields['field1'].error_messages['required'] = 'Instance1 required'
+        instance1.fields['field1'].error_messages['custom'] = 'Custom error'
+        
+        # instance2 should remain unchanged
+        self.assertEqual(instance2.fields['field1'].error_messages['required'], 'Base required')
+        self.assertNotIn('custom', instance2.fields['field1'].error_messages)
+        
+        # instance1 should have the changes
+        self.assertEqual(instance1.fields['field1'].error_messages['required'], 'Instance1 required')
+        self.assertEqual(instance1.fields['field1'].error_messages['custom'], 'Custom error')
+    
+    def test_deepcopy_preserves_other_attributes(self):
+        """Test that deepcopy still works correctly for other attributes."""
+        
+        field1 = CharField(required=True, label='Test Field')
+        field2 = copy.deepcopy(field1)
+        
+        # Basic attributes should be copied
+        self.assertEqual(field1.required, field2.required)
+        self.assertEqual(field1.label, field2.label)
+        
+        # Error messages should be deepcopied
+        self.assertIsNot(field1.error_messages, field2.error_messages)
+        
+        # Widget should be deepcopied
+        self.assertIsNot(field1.widget, field2.widget)
+        
+        # Validators should be copied (shallow copy as before)
+        self.assertEqual(field1.validators, field2.validators)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file