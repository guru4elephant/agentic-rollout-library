diff --git a/debug_draw_issue.py b/debug_draw_issue.py
new file mode 100644
index 0000000000..1bfb19ef6f
--- /dev/null
+++ b/debug_draw_issue.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def debug_draw_issue():
+    """Debug the issue that occurs during drawing/saving"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    # Create the figure and image like the test
+    fig, ax = plt.subplots()
+    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),
+                   interpolation='nearest', cmap='viridis')
+    
+    print("Image created successfully")
+    
+    # Now try to simulate what happens during draw
+    try:
+        # Get the norm object
+        norm = im.norm
+        print(f"Norm vmin: {norm.vmin}, vmax: {norm.vmax}")
+        
+        # Simulate what might happen during resampling
+        # The error shows a masked array with negative values and huge values
+        test_data = np.ma.masked_array(data, mask=(data < 0))
+        test_data.fill_value = 1e20
+        print(f"Test data (masked): {test_data}")
+        print(f"Test data mask: {test_data.mask}")
+        
+        # Try to apply the norm to this masked data
+        try:
+            result = norm(test_data)
+            print("Norm applied successfully to masked data")
+        except Exception as e:
+            print(f"Error applying norm to masked data: {e}")
+            print(f"Error type: {type(e)}")
+            
+            # Let's check the transform values specifically
+            try:
+                t_vmin, t_vmax = norm._trf.transform([norm.vmin, norm.vmax])
+                print(f"Transformed vmin: {t_vmin}")
+                print(f"Transformed vmax: {t_vmax}")
+                print(f"Are both finite? {np.isfinite([t_vmin, t_vmax]).all()}")
+            except Exception as e2:
+                print(f"Error checking transform: {e2}")
+                
+    except Exception as e:
+        print(f"Error during debug: {e}")
+    
+    plt.close(fig)
+
+if __name__ == "__main__":
+    debug_draw_issue()
\ No newline at end of file
diff --git a/debug_draw_process.py b/debug_draw_process.py
new file mode 100644
index 0000000000..93aba42109
--- /dev/null
+++ b/debug_draw_process.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def debug_draw_process():
+    """Debug the exact draw process that's failing"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    # Create the figure and image like the test
+    fig, ax = plt.subplots()
+    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),
+                   interpolation='nearest', cmap='viridis')
+    
+    print("Image created successfully")
+    
+    # Let's manually call the draw process to see what happens
+    try:
+        # Force a draw to trigger the error
+        fig.canvas.draw()
+        print("Draw completed successfully")
+    except Exception as e:
+        print(f"Draw error: {e}")
+        print(f"Error type: {type(e)}")
+        
+        # Let's examine the norm object more closely
+        norm = im.norm
+        print(f"Norm vmin: {norm.vmin}, vmax: {norm.vmax}")
+        print(f"Norm vmin type: {type(norm.vmin)}")
+        print(f"Norm vmin is masked: {norm.vmin is np.ma.masked}")
+        print(f"Norm vmax is masked: {norm.vmax is np.ma.masked}")
+        
+        # Check if autoscale_None is being called with problematic data
+        try:
+            # Simulate what autoscale_None might see
+            test_data = np.ma.masked_less_equal(data, 0, copy=False)
+            print(f"Test data for autoscale: {test_data}")
+            print(f"Test data mask: {test_data.mask}")
+            
+            # Call autoscale_None manually
+            norm.autoscale_None(test_data)
+            print(f"After autoscale_None - vmin: {norm.vmin}, vmax: {norm.vmax}")
+            
+        except Exception as e2:
+            print(f"Error in autoscale debug: {e2}")
+    
+    plt.close(fig)
+
+if __name__ == "__main__":
+    debug_draw_process()
\ No newline at end of file
diff --git a/debug_make_image.py b/debug_make_image.py
new file mode 100644
index 0000000000..531c0913db
--- /dev/null
+++ b/debug_make_image.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def debug_make_image():
+    """Debug the _make_image method specifically"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    # Create the figure and image like the test
+    fig, ax = plt.subplots()
+    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),
+                   interpolation='nearest', cmap='viridis')
+    
+    print("Image created successfully")
+    
+    # Let's try to simulate what happens in _make_image
+    # We need to understand what resampled_masked looks like
+    try:
+        # Get the image object and try to access its internal state
+        print(f"Image data shape: {im._A.shape}")
+        print(f"Image data type: {im._A.dtype}")
+        
+        # Let's see what the norm sees during the call
+        norm = im.norm
+        print(f"Norm before draw - vmin: {norm.vmin}, vmax: {norm.vmax}")
+        
+        # Force a partial draw to see what happens
+        # We'll try to call make_image directly
+        renderer = fig.canvas.get_renderer()
+        bbox = im.get_window_extent(renderer)
+        
+        print(f"Bbox: {bbox}")
+        
+        # Try to call make_image with a simple bbox
+        try:
+            result = im.make_image(renderer)
+            print("make_image succeeded")
+        except Exception as e:
+            print(f"make_image error: {e}")
+            print(f"Error type: {type(e)}")
+            
+    except Exception as e:
+        print(f"Error in debug: {e}")
+        print(f"Error type: {type(e)}")
+    
+    plt.close(fig)
+
+if __name__ == "__main__":
+    debug_make_image()
\ No newline at end of file
diff --git a/debug_masked_condition.py b/debug_masked_condition.py
new file mode 100644
index 0000000000..cc2ffa6be7
--- /dev/null
+++ b/debug_masked_condition.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+import numpy as np
+from matplotlib import colors
+
+def debug_masked_condition():
+    """Debug when vmin becomes np.ma.masked"""
+    # Simulate the data from the test
+    A = np.full((5, 5), -1, dtype=np.float64)
+    A[0:2, :] = 1E20
+    
+    # Create LogNorm with autoscaling disabled
+    norm = colors.LogNorm(vmin=100, vmax=A.max())
+    
+    # Check if vmin could be masked in some scenarios
+    print(f"norm.vmin: {norm.vmin}")
+    print(f"norm.vmin is np.ma.masked: {norm.vmin is np.ma.masked}")
+    
+    # Let's see what happens if we autoscale the data
+    norm2 = colors.LogNorm()
+    norm2.autoscale(A)
+    print(f"norm2.vmin after autoscale: {norm2.vmin}")
+    print(f"norm2.vmin is np.ma.masked: {norm2.vmin is np.ma.masked}")
+    
+    # Let's see what happens if we autoscale data with only negative values
+    A_negative = np.full((5, 5), -1, dtype=np.float64)
+    norm3 = colors.LogNorm()
+    norm3.autoscale(A_negative)
+    print(f"norm3.vmin after autoscale negative data: {norm3.vmin}")
+    print(f"norm3.vmin is np.ma.masked: {norm3.vmin is np.ma.masked}")
+    print(f"norm3.vmax after autoscale negative data: {norm3.vmax}")
+    print(f"norm3.vmax is np.ma.masked: {norm3.vmax is np.ma.masked}")
+
+if __name__ == "__main__":
+    debug_masked_condition()
\ No newline at end of file
diff --git a/debug_negative_values.py b/debug_negative_values.py
new file mode 100644
index 0000000000..a3f80e480f
--- /dev/null
+++ b/debug_negative_values.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+import numpy as np
+from matplotlib import colors
+
+def debug_negative_values():
+    """Debug what happens with negative values in LogTransform"""
+    # Create a LogNorm with the same parameters as the test
+    norm = colors.LogNorm(vmin=100, vmax=1e20)
+    
+    # Create test data similar to what might happen during resampling
+    # The error shows masked array with negative values and fill_value=1e20
+    data = np.array([[-1, -2, 1e20], [0, 100, 1e19]])
+    masked_data = np.ma.masked_less_equal(data, 0)
+    masked_data.fill_value = 1e20
+    
+    print(f"Original data: {data}")
+    print(f"Masked data: {masked_data}")
+    print(f"Mask: {masked_data.mask}")
+    print(f"Fill value: {masked_data.fill_value}")
+    
+    # Try to apply the norm to this data
+    try:
+        result = norm(masked_data)
+        print(f"Result: {result}")
+    except Exception as e:
+        print(f"Error: {e}")
+        print(f"Error type: {type(e)}")
+        
+        # Let's debug the transform step by step
+        try:
+            # Check what transform does to the values
+            transformed = norm._trf.transform(masked_data)
+            print(f"Transformed data: {transformed}")
+            
+            # Check boundary values
+            t_vmin, t_vmax = norm._trf.transform([norm.vmin, norm.vmax])
+            print(f"Transformed vmin: {t_vmin}, vmax: {t_vmax}")
+            print(f"Are both finite? {np.isfinite([t_vmin, t_vmax]).all()}")
+            
+        except Exception as e2:
+            print(f"Error in transform debug: {e2}")
+
+if __name__ == "__main__":
+    debug_negative_values()
\ No newline at end of file
diff --git a/debug_vrange_issue.py b/debug_vrange_issue.py
new file mode 100644
index 0000000000..d3d1dd83a8
--- /dev/null
+++ b/debug_vrange_issue.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+
+import numpy as np
+from matplotlib import colors
+
+def debug_vrange_issue():
+    """Debug the vrange issue in detail"""
+    # Simulate the data from the test
+    A = np.full((5, 5), -1, dtype=np.float64)
+    A[0:2, :] = 1E20
+    
+    print(f"Original data A: {A}")
+    print(f"A.min(): {A.min()}")
+    print(f"A.max(): {A.max()}")
+    
+    # Simulate what happens in the image processing code
+    a_min = A.min()  # This will be -1.0
+    a_max = A.max()  # This will be 1e20
+    
+    print(f"a_min: {a_min}, a_max: {a_max}")
+    
+    # Simulate the vrange computation
+    norm = colors.LogNorm(vmin=100, vmax=A.max())
+    vmin, vmax = norm.vmin, norm.vmax
+    print(f"norm.vmin: {vmin}, norm.vmax: {vmax}")
+    
+    # This is what happens in the image processing
+    if vmin is np.ma.masked:
+        vmin, vmax = a_min, a_max
+    
+    # The issue: vrange includes negative values from a_min
+    scaled_dtype = np.float64
+    vrange = np.array([vmin, vmax], dtype=scaled_dtype)
+    print(f"vrange: {vrange}")
+    
+    # Now let's see what happens when we transform this vrange
+    try:
+        t_vmin, t_vmax = norm._trf.transform([vmin, vmax])
+        print(f"Transformed vrange: [{t_vmin}, {t_vmax}]")
+        print(f"Are both finite? {np.isfinite([t_vmin, t_vmax]).all()}")
+    except Exception as e:
+        print(f"Error transforming vrange: {e}")
+        
+    # The fix should be: when using LogNorm, we should ensure vmin doesn't include negative values
+    # Let's check what the current fix does
+    if isinstance(norm, colors.LogNorm):
+        if vmin < 0:
+            vmin_fixed = max(vmin, np.finfo(scaled_dtype).eps)
+            print(f"Fixed vmin: {vmin} -> {vmin_fixed}")
+            
+            # Test the fixed version
+            vrange_fixed = np.array([vmin_fixed, vmax], dtype=scaled_dtype)
+            t_vmin_fixed, t_vmax_fixed = norm._trf.transform([vmin_fixed, vmax])
+            print(f"Fixed transformed vrange: [{t_vmin_fixed}, {t_vmax_fixed}]")
+            print(f"Are both finite? {np.isfinite([t_vmin_fixed, t_vmax_fixed]).all()}")
+
+if __name__ == "__main__":
+    debug_vrange_issue()
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 0000000000..436d313e6d
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def debug_transform_issue():
+    """Debug the transform issue in detail"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    # Create LogNorm with the same parameters
+    norm = colors.LogNorm(vmin=100, vmax=data.max())
+    
+    print(f"vmin: {norm.vmin}, vmax: {norm.vmax}")
+    
+    # Let's see what the transform is
+    print(f"Transform type: {type(norm._trf)}")
+    
+    # Test the transform on the boundary values
+    try:
+        t_vmin = norm._trf.transform(norm.vmin)
+        t_vmax = norm._trf.transform(norm.vmax)
+        print(f"Transformed vmin: {t_vmin}")
+        print(f"Transformed vmax: {t_vmax}")
+        print(f"Are both finite? {np.isfinite([t_vmin, t_vmax]).all()}")
+    except Exception as e:
+        print(f"Error transforming boundary values: {e}")
+    
+    # Let's see what happens with some extreme values
+    test_values = [100, 1e20, 1e30, 1e50]
+    for val in test_values:
+        try:
+            transformed = norm._trf.transform(val)
+            print(f"Value {val} -> {transformed} (finite: {np.isfinite(transformed)})")
+        except Exception as e:
+            print(f"Error transforming {val}: {e}")
+    
+    # Let's also check what happens with the scale itself
+    try:
+        scale_obj = norm._scale
+        print(f"Scale type: {type(scale_obj)}")
+        print(f"Scale base: {getattr(scale_obj, 'base', 'unknown')}")
+    except Exception as e:
+        print(f"Error examining scale: {e}")
+
+if __name__ == "__main__":
+    debug_transform_issue()
\ No newline at end of file
diff --git a/lib/matplotlib/image.py b/lib/matplotlib/image.py
index 95bb42d75c..969c22c681 100644
--- a/lib/matplotlib/image.py
+++ b/lib/matplotlib/image.py
@@ -472,6 +472,9 @@ class _ImageBase(martist.Artist, cm.ScalarMappable):
                 vmin, vmax = self.norm.vmin, self.norm.vmax
                 if vmin is np.ma.masked:
                     vmin, vmax = a_min, a_max
+                # For LogNorm, ensure vmin is not negative to avoid non-finite transforms
+                if isinstance(self.norm, mcolors.LogNorm) and vmin < 0:
+                    vmin = max(vmin, np.finfo(scaled_dtype).eps)
                 vrange = np.array([vmin, vmax], dtype=scaled_dtype)
 
                 A_scaled -= a_min
@@ -532,9 +535,10 @@ class _ImageBase(martist.Artist, cm.ScalarMappable):
                 # we have re-set the vmin/vmax to account for small errors
                 # that may have moved input values in/out of range
                 s_vmin, s_vmax = vrange
+                # For LogNorm, ensure s_vmin is not negative or zero to avoid non-finite transforms
                 if isinstance(self.norm, mcolors.LogNorm):
-                    if s_vmin < 0:
-                        s_vmin = max(s_vmin, np.finfo(scaled_dtype).eps)
+                    if s_vmin <= 0:
+                        s_vmin = np.finfo(scaled_dtype).eps
                 with cbook._setattr_cm(self.norm,
                                        vmin=s_vmin,
                                        vmax=s_vmax,
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e718e2c33a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def test_huge_range_log():
+    """Reproduce the failing test case"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    print("Data shape:", data.shape)
+    print("Data:", data)
+    print("Data min:", data.min())
+    print("Data max:", data.max())
+    
+    # This is what the test is doing
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),
+                       interpolation='nearest', cmap='viridis')
+        print("Plot created successfully")
+        plt.close(fig)
+    except Exception as e:
+        print(f"Error: {e}")
+        print(f"Error type: {type(e)}")
+        return False
+    
+    return True
+
+def debug_log_norm():
+    """Debug the LogNorm transformation specifically"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    data[0:2, :] = 1E20
+    
+    # Create LogNorm with the same parameters as the test
+    norm = colors.LogNorm(vmin=100, vmax=data.max())
+    
+    print("vmin:", norm.vmin)
+    print("vmax:", norm.vmax)
+    
+    # Try to transform the values to see what happens
+    try:
+        result = norm(data)
+        print("Transformation successful")
+        print("Result shape:", result.shape)
+    except Exception as e:
+        print(f"Transformation error: {e}")
+        print(f"Error type: {type(e)}")
+        
+        # Let's check what _trf.transform does with the boundary values
+        try:
+            t_vmin, t_vmax = norm._trf.transform([norm.vmin, norm.vmax])
+            print(f"Transformed vmin: {t_vmin}")
+            print(f"Transformed vmax: {t_vmax}")
+            print(f"Are both finite? {np.isfinite([t_vmin, t_vmax]).all()}")
+        except Exception as e2:
+            print(f"Error checking transform: {e2}")
+
+if __name__ == "__main__":
+    print("=== Testing huge range log reproduction ===")
+    test_huge_range_log()
+    
+    print("\n=== Debugging LogNorm ===")
+    debug_log_norm()
\ No newline at end of file
diff --git a/test_all_negative_expected.py b/test_all_negative_expected.py
new file mode 100644
index 0000000000..7b8023059a
--- /dev/null
+++ b/test_all_negative_expected.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def test_all_negative_expected():
+    """Test what happens with all negative values (expected behavior)"""
+    data = np.full((5, 5), -1, dtype=np.float64)
+    
+    # Test without drawing first
+    norm = colors.LogNorm()
+    norm.autoscale(data)
+    
+    print(f"After autoscaling all negative data:")
+    print(f"vmin: {norm.vmin}")
+    print(f"vmax: {norm.vmax}")
+    print(f"vmin is masked: {norm.vmin is np.ma.masked}")
+    print(f"vmax is masked: {norm.vmax is np.ma.masked}")
+    
+    # This should fail because there's no valid data for LogNorm
+    try:
+        result = norm(data)
+        print(f"Norm result: {result}")
+    except Exception as e:
+        print(f"Norm failed as expected: {e}")
+
+if __name__ == "__main__":
+    test_all_negative_expected()
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..4c6540d173
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import matplotlib.pyplot as plt
+from matplotlib import colors
+
+def test_fix_comprehensive():
+    """Test the fix with various edge cases"""
+    
+    print("=== Testing various edge cases for LogNorm fix ===")
+    
+    # Test case 1: Original failing case
+    print("\n1. Original failing case:")
+    data1 = np.full((5, 5), -1, dtype=np.float64)
+    data1[0:2, :] = 1E20
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data1, norm=colors.LogNorm(vmin=100, vmax=data1.max()),
+                       interpolation='nearest', cmap='viridis')
+        fig.canvas.draw()
+        plt.close(fig)
+        print("   ✓ PASSED")
+    except Exception as e:
+        print(f"   ✗ FAILED: {e}")
+    
+    # Test case 2: All negative values
+    print("\n2. All negative values:")
+    data2 = np.full((5, 5), -1, dtype=np.float64)
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data2, norm=colors.LogNorm(), interpolation='nearest', cmap='viridis')
+        fig.canvas.draw()
+        plt.close(fig)
+        print("   ✓ PASSED")
+    except Exception as e:
+        print(f"   ✗ FAILED: {e}")
+    
+    # Test case 3: Mixed positive and negative with autoscaling
+    print("\n3. Mixed positive and negative with autoscaling:")
+    data3 = np.array([[1, 2, -1], [3, -2, 4], [-3, 5, 6]])
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data3, norm=colors.LogNorm(), interpolation='nearest', cmap='viridis')
+        fig.canvas.draw()
+        plt.close(fig)
+        print("   ✓ PASSED")
+    except Exception as e:
+        print(f"   ✗ FAILED: {e}")
+    
+    # Test case 4: Very small positive values
+    print("\n4. Very small positive values:")
+    data4 = np.array([[1e-10, 2e-10], [3e-10, 4e-10]])
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data4, norm=colors.LogNorm(), interpolation='nearest', cmap='viridis')
+        fig.canvas.draw()
+        plt.close(fig)
+        print("   ✓ PASSED")
+    except Exception as e:
+        print(f"   ✗ FAILED: {e}")
+    
+    # Test case 5: Zero values mixed with positive
+    print("\n5. Zero values mixed with positive:")
+    data5 = np.array([[0, 1, 2], [3, 0, 4], [5, 6, 0]])
+    try:
+        fig, ax = plt.subplots()
+        im = ax.imshow(data5, norm=colors.LogNorm(), interpolation='nearest', cmap='viridis')
+        fig.canvas.draw()
+        plt.close(fig)
+        print("   ✓ PASSED")
+    except Exception as e:
+        print(f"   ✗ FAILED: {e}")
+    
+    print("\n=== All tests completed ===")
+
+if __name__ == "__main__":
+    test_fix_comprehensive()
\ No newline at end of file