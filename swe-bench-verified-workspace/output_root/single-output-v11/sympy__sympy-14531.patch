diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2426f7cece
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.printing import sstr
+
+# Test case 1: Basic expression with sympy_integers=True
+x = symbols('x')
+expr1 = x + S(1)/2
+result1 = sstr(expr1, sympy_integers=True)
+print("Test 1 - x + S(1)/2:")
+print(f"Result: {result1}")
+print(f"Expected: 'x + S(1)/2'")
+print(f"Match: {result1 == 'x + S(1)/2'}\n")
+
+# Test case 2: Eq expression with sympy_integers=True
+expr2 = Eq(x, S(1)/2)
+result2 = sstr(expr2, sympy_integers=True)
+print("Test 2 - Eq(x, S(1)/2):")
+print(f"Result: {result2}")
+print(f"Expected: 'Eq(x, S(1)/2)'")
+print(f"Match: {result2 == 'Eq(x, S(1)/2)'}\n")
+
+# Test case 3: Limit expression with sympy_integers=True
+expr3 = Limit(x, x, S(1)/2)
+result3 = sstr(expr3, sympy_integers=True)
+print("Test 3 - Limit(x, x, S(1)/2):")
+print(f"Result: {result3}")
+print(f"Expected: 'Limit(x, x, S(1)/2)'")
+print(f"Match: {result3 == 'Limit(x, x, S(1)/2)'}\n")
+
+# Test case 4: Code generation
+y = symbols('y')
+expr4 = Eq(x, y)
+result4 = python(expr4)
+print("Test 4 - python(Eq(x, y)):")
+print(f"Result: {repr(result4)}")
+expected4 = "x = Symbol('x')\ny = Symbol('y')\ne = Eq(x, y)"
+print(f"Expected: {repr(expected4)}")
+print(f"Match: {result4 == expected4}\n")
\ No newline at end of file
diff --git a/sympy/printing/python.py b/sympy/printing/python.py
index dc6d8ffe59..7e7ef3a747 100644
--- a/sympy/printing/python.py
+++ b/sympy/printing/python.py
@@ -6,6 +6,7 @@
 import sympy
 from .repr import ReprPrinter
 from .str import StrPrinter
+from .printer import Printer
 
 # A list of classes that should be printed using StrPrinter
 STRPRINT = ("Add", "Infinity", "Integer", "Mul", "NegativeInfinity",
@@ -14,10 +15,17 @@
 
 class PythonPrinter(ReprPrinter, StrPrinter):
     """A printer which converts an expression into its Python interpretation."""
+    
+    _default_settings = {
+        "order": None,
+        "full_prec": "auto",
+        "sympy_integers": False,
+        "abbrev": False,
+    }
 
     def __init__(self, settings=None):
-        ReprPrinter.__init__(self)
-        StrPrinter.__init__(self, settings)
+        # Initialize with combined default settings to avoid validation errors
+        Printer.__init__(self, settings)
         self.symbols = []
         self.functions = []
 
@@ -83,7 +91,9 @@ def python(expr, **settings):
 
     if not len(renamings) == 0:
         exprp = expr.subs(renamings)
-    result += 'e = ' + printer._str(exprp)
+    else:
+        exprp = expr
+    result += 'e = ' + printer.doprint(exprp)
     return result
 
 
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index cc1d19fcce..1f4eef5c08 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -216,9 +216,9 @@ def _print_LatticeOp(self, expr):
     def _print_Limit(self, expr):
         e, z, z0, dir = expr.args
         if str(dir) == "+":
-            return "Limit(%s, %s, %s)" % (e, z, z0)
+            return "Limit(%s, %s, %s)" % (self._print(e), self._print(z), self._print(z0))
         else:
-            return "Limit(%s, %s, %s, dir='%s')" % (e, z, z0, dir)
+            return "Limit(%s, %s, %s, dir='%s')" % (self._print(e), self._print(z), self._print(z0), dir)
 
     def _print_list(self, expr):
         return "[%s]" % self.stringify(expr, ", ")
@@ -630,7 +630,7 @@ def _print_Relational(self, expr):
         }
 
         if expr.rel_op in charmap:
-            return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)
+            return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs), self._print(expr.rhs))
 
         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
                            self._relationals.get(expr.rel_op) or expr.rel_op,
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..3d11836abd
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.printing import sstr, python
+
+# Test various expressions with sympy_integers=True
+x, y = symbols('x y')
+
+print("=== Comprehensive Test of sympy_integers=True ===")
+
+# Test 1: Basic arithmetic
+expr1 = x + S(1)/2
+result1 = sstr(expr1, sympy_integers=True)
+print(f"1. x + S(1)/2: {result1}")
+assert result1 == "x + S(1)/2", f"Expected 'x + S(1)/2', got '{result1}'"
+
+# Test 2: Equation
+expr2 = Eq(x, S(1)/2)
+result2 = sstr(expr2, sympy_integers=True)
+print(f"2. Eq(x, S(1)/2): {result2}")
+assert result2 == "Eq(x, S(1)/2)", f"Expected 'Eq(x, S(1)/2)', got '{result2}'"
+
+# Test 3: Limit
+expr3 = Limit(x, x, S(1)/2)
+result3 = sstr(expr3, sympy_integers=True)
+print(f"3. Limit(x, x, S(1)/2): {result3}")
+assert result3 == "Limit(x, x, S(1)/2)", f"Expected 'Limit(x, x, S(1)/2)', got '{result3}'"
+
+# Test 4: Derivative
+expr4 = Derivative(x**2 + S(1)/2, x)
+result4 = sstr(expr4, sympy_integers=True)
+print(f"4. Derivative(x**2 + S(1)/2, x): {result4}")
+assert "S(1)/2" in result4, f"Expected S(1)/2 in result, got '{result4}'"
+
+# Test 5: Integral
+expr5 = Integral(x + S(1)/2, x)
+result5 = sstr(expr5, sympy_integers=True)
+print(f"5. Integral(x + S(1)/2, x): {result5}")
+assert "S(1)/2" in result5, f"Expected S(1)/2 in result, got '{result5}'"
+
+# Test 6: Sum
+expr6 = Sum(x + S(1)/2, (x, 1, 10))
+result6 = sstr(expr6, sympy_integers=True)
+print(f"6. Sum(x + S(1)/2, (x, 1, 10)): {result6}")
+assert "S(1)/2" in result6, f"Expected S(1)/2 in result, got '{result6}'"
+
+# Test 7: Product
+expr7 = Product(x + S(1)/2, (x, 1, 10))
+result7 = sstr(expr7, sympy_integers=True)
+print(f"7. Product(x + S(1)/2, (x, 1, 10)): {result7}")
+assert "S(1)/2" in result7, f"Expected S(1)/2 in result, got '{result7}'"
+
+# Test 8: Function with rational argument
+expr8 = sin(S(1)/2)
+result8 = sstr(expr8, sympy_integers=True)
+print(f"8. sin(S(1)/2): {result8}")
+assert result8 == "sin(S(1)/2)", f"Expected 'sin(S(1)/2)', got '{result8}'"
+
+# Test 9: Nested expressions
+expr9 = Eq(x + S(1)/2, y + S(1)/3)
+result9 = sstr(expr9, sympy_integers=True)
+print(f"9. Eq(x + S(1)/2, y + S(1)/3): {result9}")
+assert "S(1)/2" in result9 and "S(1)/3" in result9, f"Expected S(1)/2 and S(1)/3 in result, got '{result9}'"
+
+# Test 10: Python code generation
+expr10 = Eq(x, y)
+result10 = python(expr10, sympy_integers=True)
+expected10 = "x = Symbol('x')\ny = Symbol('y')\ne = Eq(x, y)"
+print(f"10. python(Eq(x, y), sympy_integers=True): {repr(result10)}")
+assert result10 == expected10, f"Expected '{expected10}', got '{result10}'"
+
+print("\n=== All tests passed! ===")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..c396432bd6
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.printing import sstr, python
+
+print("=== Edge Case Tests ===")
+
+# Test 1: Empty settings
+x = symbols('x')
+expr1 = Eq(x, S(1)/2)
+result1 = sstr(expr1)
+print(f"1. sstr(Eq(x, S(1)/2)): {result1}")
+assert result1 == "Eq(x, 1/2)", f"Expected 'Eq(x, 1/2)', got '{result1}'"
+
+# Test 2: sympy_integers=False explicitly
+result2 = sstr(expr1, sympy_integers=False)
+print(f"2. sstr(Eq(x, S(1)/2), sympy_integers=False): {result2}")
+assert result2 == "Eq(x, 1/2)", f"Expected 'Eq(x, 1/2)', got '{result2}'"
+
+# Test 3: sympy_integers=True
+result3 = sstr(expr1, sympy_integers=True)
+print(f"3. sstr(Eq(x, S(1)/2), sympy_integers=True): {result3}")
+assert result3 == "Eq(x, S(1)/2)", f"Expected 'Eq(x, S(1)/2)', got '{result3}'"
+
+# Test 4: Limit with sympy_integers=False
+expr2 = Limit(x, x, S(1)/2)
+result4 = sstr(expr2, sympy_integers=False)
+print(f"4. sstr(Limit(x, x, S(1)/2), sympy_integers=False): {result4}")
+assert result4 == "Limit(x, x, 1/2)", f"Expected 'Limit(x, x, 1/2)', got '{result4}'"
+
+# Test 5: Limit with sympy_integers=True
+result5 = sstr(expr2, sympy_integers=True)
+print(f"5. sstr(Limit(x, x, S(1)/2), sympy_integers=True): {result5}")
+assert result5 == "Limit(x, x, S(1)/2)", f"Expected 'Limit(x, x, S(1)/2)', got '{result5}'"
+
+# Test 6: Python code generation with sympy_integers=False
+y = symbols('y')
+expr3 = Eq(x, y)
+result6 = python(expr3, sympy_integers=False)
+expected6 = "x = Symbol('x')\ny = Symbol('y')\ne = Eq(x, y)"
+print(f"6. python(Eq(x, y), sympy_integers=False): {repr(result6)}")
+assert result6 == expected6, f"Expected '{expected6}', got '{result6}'"
+
+# Test 7: Python code generation with sympy_integers=True
+result7 = python(expr3, sympy_integers=True)
+expected7 = "x = Symbol('x')\ny = Symbol('y')\ne = Eq(x, y)"
+print(f"7. python(Eq(x, y), sympy_integers=True): {repr(result7)}")
+assert result7 == expected7, f"Expected '{expected7}', got '{result7}'"
+
+print("\n=== All edge case tests passed! ===")
\ No newline at end of file