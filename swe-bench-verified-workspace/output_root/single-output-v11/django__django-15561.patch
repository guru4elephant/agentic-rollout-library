diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..4832d7b322
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the choices migration fix works correctly.
+Tests various scenarios to ensure the fix doesn't break anything.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField, IntegerField, BooleanField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_comprehensive_scenarios():
+    """Test various field alteration scenarios."""
+    
+    connection = connections['default']
+    
+    test_cases = [
+        # (test_name, old_field_kwargs, new_field_kwargs, should_alter)
+        ("Only choices changed", 
+         {'max_length': 10, 'choices': [('a', 'A'), ('b', 'B')]},
+         {'max_length': 10, 'choices': [('a', 'A'), ('b', 'B'), ('c', 'C')]},
+         False),
+        
+        ("Max length changed", 
+         {'max_length': 10, 'choices': [('a', 'A')]},
+         {'max_length': 20, 'choices': [('a', 'A')]},
+         True),
+        
+        ("Field type changed", 
+         {'max_length': 10, 'choices': [('a', 'A')]},
+         {'choices': [(1, 'One')]},  # IntegerField
+         True),
+        
+        ("No choices attribute", 
+         {'max_length': 10},
+         {'max_length': 10},
+         False),
+        
+        ("Add choices to field", 
+         {'max_length': 10},
+         {'max_length': 10, 'choices': [('a', 'A')]},
+         False),
+        
+        ("Remove choices from field", 
+         {'max_length': 10, 'choices': [('a', 'A')]},
+         {'max_length': 10},
+         False),
+        
+        ("Null attribute changed", 
+         {'max_length': 10, 'null': False, 'choices': [('a', 'A')]},
+         {'max_length': 10, 'null': True, 'choices': [('a', 'A')]},
+         True),
+        
+        ("Blank attribute changed", 
+         {'max_length': 10, 'blank': False, 'choices': [('a', 'A')]},
+         {'max_length': 10, 'blank': True, 'choices': [('a', 'A')]},
+         False),  # blank is non-database
+        
+        ("Multiple non-database attrs changed", 
+         {'max_length': 10, 'blank': False, 'verbose_name': 'Old', 'choices': [('a', 'A')]},
+         {'max_length': 10, 'blank': True, 'verbose_name': 'New', 'choices': [('b', 'B')]},
+         False),
+    ]
+    
+    results = []
+    
+    with connection.schema_editor() as schema_editor:
+        for test_name, old_kwargs, new_kwargs, expected_should_alter in test_cases:
+            # Create field instances
+            old_field = CharField(**old_kwargs)
+            old_field.column = 'test_field'  # Simulate column attribute
+            
+            # Handle different field types
+            if 'choices' in new_kwargs and any(isinstance(choice[0], int) for choice in new_kwargs['choices']):
+                new_field = IntegerField(**new_kwargs)
+            else:
+                new_field = CharField(**new_kwargs)
+            new_field.column = 'test_field'  # Simulate column attribute
+            
+            # Test alteration
+            should_alter = schema_editor._field_should_be_altered(old_field, new_field)
+            
+            # Check result
+            passed = should_alter == expected_should_alter
+            results.append((test_name, passed, should_alter, expected_should_alter))
+            
+            status = "‚úÖ PASS" if passed else "‚ùå FAIL"
+            print(f"{status} {test_name}: got {should_alter}, expected {expected_should_alter}")
+    
+    # Summary
+    print(f"\n{'='*60}")
+    print("SUMMARY:")
+    print(f"{'='*60}")
+    
+    passed_count = sum(1 for _, passed, _, _ in results if passed)
+    total_count = len(results)
+    
+    print(f"Passed: {passed_count}/{total_count}")
+    
+    if passed_count == total_count:
+        print("üéâ ALL TESTS PASSED! The fix is working correctly.")
+        return True
+    else:
+        print("üí• SOME TESTS FAILED! The fix needs more work.")
+        
+        # Show failed tests
+        print("\nFailed tests:")
+        for test_name, passed, got, expected in results:
+            if not passed:
+                print(f"  {test_name}: got {got}, expected {expected}")
+        
+        return False
+
+if __name__ == '__main__':
+    success = test_comprehensive_scenarios()
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/demonstrate_fix.py b/demonstrate_fix.py
new file mode 100644
index 0000000000..b141530e9f
--- /dev/null
+++ b/demonstrate_fix.py
@@ -0,0 +1,99 @@
+#!/usr/bin/env python3
+"""
+Demonstration script showing that the SQLite choices migration issue is fixed.
+This script demonstrates the before and after behavior described in the GitHub issue.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def demonstrate_fix():
+    """Demonstrate that the SQLite choices migration issue is fixed."""
+    
+    print("üêõ GitHub Issue: AlterField operation should be noop when adding/changing choices on SQLite")
+    print("=" * 80)
+    
+    # Create the scenario described in the issue
+    print("üìã Scenario: Adding a choice to a CharField")
+    print("   - Before: choices=[('active', 'Active'), ('inactive', 'Inactive')]")
+    print("   - After:  choices=[('active', 'Active'), ('inactive', 'Inactive'), ('pending', 'Pending')]")
+    print()
+    
+    # Create field instances
+    old_field = CharField(max_length=10)
+    old_field.choices = [('active', 'Active'), ('inactive', 'Inactive')]
+    old_field.column = 'status'
+    
+    new_field = CharField(max_length=10)
+    new_field.choices = [('active', 'Active'), ('inactive', 'Inactive'), ('pending', 'Pending')]
+    new_field.column = 'status'
+    
+    connection = connections['default']
+    
+    with connection.schema_editor() as schema_editor:
+        # Test if the field should be altered
+        should_alter = schema_editor._field_should_be_altered(old_field, new_field)
+        
+        print("üîç Testing if SQLite will generate unnecessary SQL...")
+        print(f"   Result: should_alter = {should_alter}")
+        
+        if should_alter:
+            print("‚ùå BUG: SQLite would generate unnecessary SQL (new table + insert + drop + rename)")
+            print("   This would happen even though choices changes don't affect the database schema")
+            return False
+        else:
+            print("‚úÖ FIXED: SQLite will NOT generate unnecessary SQL")
+            print("   The AlterField operation will be a no-op for choices changes")
+            print("   This matches the behavior of PostgreSQL and other databases")
+            return True
+
+def explain_the_fix():
+    """Explain what the fix does."""
+    
+    print("\nüí° The Fix:")
+    print("=" * 80)
+    print("Added 'choices' to the non_database_attrs list in:")
+    print("   django/db/backends/base/schema.py::_field_should_be_altered()")
+    print()
+    print("This tells Django that changes to the 'choices' attribute:")
+    print("   ‚úÖ Do not affect the database schema")
+    print("   ‚úÖ Are purely application-level validation constraints")
+    print("   ‚úÖ Should not trigger SQL operations during migrations")
+    print()
+    print("The fix is consistent with other validation attributes:")
+    print("   - limit_choices_to (already was in the list)")
+    print("   - validators (already was in the list)")
+    print("   - choices (now added to the list)")
+
+if __name__ == '__main__':
+    print("üîß SQLite Choices Migration Fix Demonstration")
+    print("=" * 80)
+    
+    success = demonstrate_fix()
+    explain_the_fix()
+    
+    if success:
+        print("\nüéØ RESULT: Issue FIXED!")
+        print("   SQLite will no longer generate unnecessary SQL for choices changes")
+    else:
+        print("\nüí• RESULT: Issue NOT Fixed!")
+    
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 9d6952df21..85d53e3b1a 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -1378,6 +1378,7 @@ class BaseDatabaseSchemaEditor:
         # - adding only a db_column and the column name is not changed
         non_database_attrs = [
             "blank",
+            "choices",
             "db_column",
             "editable",
             "error_messages",
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..6b65f7fcec
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+"""
+Final verification test to ensure the choices migration fix is complete and correct.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def verify_fix():
+    """Verify that the fix is working correctly and completely."""
+    
+    print("üîç Verifying the choices migration fix...")
+    print("=" * 50)
+    
+    # Test 1: Basic choices change
+    old_field = CharField(max_length=10, choices=[('a', 'A'), ('b', 'B')])
+    old_field.column = 'test'
+    
+    new_field = CharField(max_length=10, choices=[('a', 'A'), ('b', 'B'), ('c', 'C')])
+    new_field.column = 'test'
+    
+    connection = connections['default']
+    with connection.schema_editor() as schema_editor:
+        should_alter = schema_editor._field_should_be_altered(old_field, new_field)
+        
+        if should_alter:
+            print("‚ùå FAIL: Basic choices change still triggers alteration")
+            return False
+        else:
+            print("‚úÖ PASS: Basic choices change does NOT trigger alteration")
+    
+    # Test 2: Verify the fix is in the right place
+    print("\nüîç Checking that 'choices' is in non_database_attrs...")
+    
+    # Look at the current non_database_attrs list
+    non_database_attrs = [
+        "blank", "choices", "db_column", "editable", "error_messages",
+        "help_text", "limit_choices_to", "on_delete", "related_name",
+        "related_query_name", "validators", "verbose_name",
+    ]
+    
+    if "choices" in non_database_attrs:
+        print("‚úÖ PASS: 'choices' is in non_database_attrs list")
+    else:
+        print("‚ùå FAIL: 'choices' is NOT in non_database_attrs list")
+        return False
+    
+    # Test 3: Verify consistency with other validation attributes
+    validation_attrs = ["choices", "limit_choices_to", "validators"]
+    all_present = all(attr in non_database_attrs for attr in validation_attrs)
+    
+    if all_present:
+        print("‚úÖ PASS: All validation attributes are consistently treated as non-database")
+    else:
+        print("‚ùå FAIL: Inconsistent treatment of validation attributes")
+        return False
+    
+    # Test 4: Edge case - empty choices vs non-empty choices
+    print("\nüîç Testing edge cases...")
+    
+    old_field_empty = CharField(max_length=10, choices=[])
+    old_field_empty.column = 'test'
+    
+    new_field_with_choices = CharField(max_length=10, choices=[('a', 'A')])
+    new_field_with_choices.column = 'test'
+    
+    should_alter_edge = schema_editor._field_should_be_altered(old_field_empty, new_field_with_choices)
+    
+    if should_alter_edge:
+        print("‚ùå FAIL: Adding choices to empty choices triggers alteration")
+        return False
+    else:
+        print("‚úÖ PASS: Adding choices to empty choices does NOT trigger alteration")
+    
+    print("\n" + "=" * 50)
+    print("üéâ ALL VERIFICATIONS PASSED!")
+    print("The choices migration fix is complete and correct.")
+    
+    return True
+
+if __name__ == '__main__':
+    success = verify_fix()
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d342457fbc
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,99 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the SQLite choices migration issue.
+This script demonstrates that adding/changing choices on SQLite
+generates unnecessary SQL operations.
+"""
+
+import os
+import tempfile
+from django.conf import settings
+from django.db import connections, models
+from django.db.migrations import Migration, operations
+from django.db.migrations.state import ProjectState
+
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+def test_choices_migration():
+    """Test that choices changes don't generate SQL on SQLite."""
+    
+    # Create a simple model with choices
+    class TestModel(models.Model):
+        status = models.CharField(max_length=10, choices=[
+            ('active', 'Active'),
+            ('inactive', 'Inactive'),
+        ])
+        
+        class Meta:
+            app_label = 'testapp'
+    
+    # Create initial state
+    initial_state = ProjectState()
+    initial_state.add_model(TestModel._meta)
+    
+    # Create altered state with changed choices
+    class TestModelAltered(models.Model):
+        status = models.CharField(max_length=10, choices=[
+            ('active', 'Active'),
+            ('inactive', 'Inactive'),
+            ('pending', 'Pending'),  # Added choice
+        ])
+        
+        class Meta:
+            app_label = 'testapp'
+    
+    altered_state = ProjectState()
+    altered_state.add_model(TestModelAltered._meta)
+    
+    # Create AlterField operation
+    old_field = TestModel._meta.get_field('status')
+    new_field = TestModelAltered._meta.get_field('status')
+    
+    alter_op = operations.AlterField(
+        model_name='testmodel',
+        name='status',
+        field=new_field
+    )
+    
+    # Get SQL for the operation
+    connection = connections['default']
+    with connection.schema_editor() as schema_editor:
+        sql_statements = []
+        
+        def collect_sql(sql, params=()):
+            sql_statements.append(str(sql))
+        
+        schema_editor.execute = collect_sql
+        
+        try:
+            alter_op.database_forwards('testapp', schema_editor, initial_state, altered_state)
+            print("SQL generated for choices change:")
+            for i, sql in enumerate(sql_statements, 1):
+                print(f"{i}: {sql}")
+                
+            if not sql_statements:
+                print("No SQL generated - this is correct behavior!")
+            else:
+                print("SQL was generated - this indicates the bug!")
+                
+        except Exception as e:
+            print(f"Error during migration: {e}")
+
+if __name__ == '__main__':
+    test_choices_migration()
\ No newline at end of file
diff --git a/reproduce_issue_fixed.py b/reproduce_issue_fixed.py
new file mode 100644
index 0000000000..3a8647cf02
--- /dev/null
+++ b/reproduce_issue_fixed.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the SQLite choices migration issue.
+This script demonstrates that adding/changing choices on SQLite
+generates unnecessary SQL operations.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_choices_migration():
+    """Test that choices changes don't generate SQL on SQLite."""
+    
+    # Create fields directly instead of using model classes
+    old_field = CharField(
+        max_length=10,
+        choices=[
+            ('active', 'Active'),
+            ('inactive', 'Inactive'),
+        ]
+    )
+    
+    new_field = CharField(
+        max_length=10,
+        choices=[
+            ('active', 'Active'),
+            ('inactive', 'Inactive'),
+            ('pending', 'Pending'),  # Added choice
+        ]
+    )
+    
+    # Check the deconstructed field representations
+    _, old_path, old_args, old_kwargs = old_field.deconstruct()
+    _, new_path, new_args, new_kwargs = new_field.deconstruct()
+    
+    print(f"Old field kwargs: {old_kwargs}")
+    print(f"New field kwargs: {new_kwargs}")
+    
+    # Check if choices is considered a database attribute
+    non_database_attrs_before_fix = [
+        "blank", "db_column", "editable", "error_messages",
+        "help_text", "limit_choices_to", "on_delete", "related_name",
+        "related_query_name", "validators", "verbose_name",
+    ]
+    
+    non_database_attrs_after_fix = [
+        "blank", "choices", "db_column", "editable", "error_messages",
+        "help_text", "limit_choices_to", "on_delete", "related_name",
+        "related_query_name", "validators", "verbose_name",
+    ]
+    
+    print("Before fix - Non-database attributes:")
+    print(non_database_attrs_before_fix)
+    print("'choices' is NOT in non-database attributes - this is the bug!")
+    
+    # Simulate what _field_should_be_altered does BEFORE the fix
+    old_kwargs_before = old_kwargs.copy()
+    new_kwargs_before = new_kwargs.copy()
+    for attr in non_database_attrs_before_fix:
+        old_kwargs_before.pop(attr, None)
+        new_kwargs_before.pop(attr, None)
+    
+    # Check if the field definitions are different after removing non-database attrs
+    fields_different_before = (old_path, old_args, old_kwargs_before) != (new_path, new_args, new_kwargs_before)
+    print(f"Before fix - Are fields different? {fields_different_before}")
+    
+    print("\nAfter fix - Non-database attributes:")
+    print(non_database_attrs_after_fix)
+    print("'choices' IS in non-database attributes - this is the fix!")
+    
+    # Simulate what _field_should_be_altered does AFTER the fix
+    old_kwargs_after = old_kwargs.copy()
+    new_kwargs_after = new_kwargs.copy()
+    for attr in non_database_attrs_after_fix:
+        old_kwargs_after.pop(attr, None)
+        new_kwargs_after.pop(attr, None)
+    
+    # Check if the field definitions are different after removing non-database attrs
+    fields_different_after = (old_path, old_args, old_kwargs_after) != (new_path, new_args, new_kwargs_after)
+    print(f"After fix - Are fields different? {fields_different_after}")
+    
+    if not fields_different_after:
+        print("SUCCESS: No SQL will be generated for choices changes after the fix!")
+
+if __name__ == '__main__':
+    test_choices_migration()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..207b34a6ce
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify the _field_should_be_altered method fix.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_field_alteration_direct():
+    """Test field alteration detection directly."""
+    
+    # Create field instances with different choices
+    old_field = CharField(max_length=10)
+    old_field.choices = [('active', 'Active'), ('inactive', 'Inactive')]
+    old_field.column = 'status'  # Simulate column attribute
+    
+    new_field = CharField(max_length=10)
+    new_field.choices = [('active', 'Active'), ('inactive', 'Inactive'), ('pending', 'Pending')]
+    new_field.column = 'status'  # Simulate column attribute
+    
+    # Create field with different max_length (should trigger alteration)
+    new_field_max_length = CharField(max_length=20)
+    new_field_max_length.choices = [('active', 'Active'), ('inactive', 'Inactive')]
+    new_field_max_length.column = 'status'  # Simulate column attribute
+    
+    connection = connections['default']
+    
+    with connection.schema_editor() as schema_editor:
+        # Test case 1: Only choices changed
+        should_alter_choices = schema_editor._field_should_be_altered(old_field, new_field)
+        print(f"Only choices changed: Should alter? {should_alter_choices}")
+        
+        # Test case 2: Max length changed (should trigger alteration)
+        should_alter_max_length = schema_editor._field_should_be_altered(old_field, new_field_max_length)
+        print(f"Max length changed: Should alter? {should_alter_max_length}")
+        
+        # Verify results
+        success = True
+        if should_alter_choices:
+            print("‚ùå FAIL: Choices-only change should NOT trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Choices-only change correctly does NOT trigger alteration")
+            
+        if not should_alter_max_length:
+            print("‚ùå FAIL: Max length change should trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Max length change correctly triggers alteration")
+            
+        return success
+
+if __name__ == '__main__':
+    success = test_field_alteration_direct()
+    if success:
+        print("\nüéâ ALL TESTS PASSED: The fix is working correctly!")
+    else:
+        print("\nüí• SOME TESTS FAILED: The fix needs more work!")
\ No newline at end of file
diff --git a/test_field_alteration.py b/test_field_alteration.py
new file mode 100644
index 0000000000..b3bcfeb7ac
--- /dev/null
+++ b/test_field_alteration.py
@@ -0,0 +1,85 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the _field_should_be_altered method works correctly
+after adding 'choices' to non-database attributes.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField, IntegerField
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_choices_field_alteration():
+    """Test that choices changes don't trigger field alteration."""
+    
+    # Test case 1: Changing choices only
+    old_field1 = CharField(max_length=10, choices=[('a', 'A'), ('b', 'B')])
+    new_field1 = CharField(max_length=10, choices=[('a', 'A'), ('b', 'B'), ('c', 'C')])
+    
+    # Test case 2: Changing max_length (should trigger alteration)
+    old_field2 = CharField(max_length=10, choices=[('a', 'A')])
+    new_field2 = CharField(max_length=20, choices=[('a', 'A')])
+    
+    # Test case 3: Changing field type (should trigger alteration)
+    old_field3 = CharField(max_length=10, choices=[('a', 'A')])
+    new_field3 = IntegerField(choices=[(1, 'One')])
+    
+    connection = connections['default']
+    
+    with connection.schema_editor() as schema_editor:
+        # Test case 1: Only choices changed
+        should_alter1 = schema_editor._field_should_be_altered(old_field1, new_field1)
+        print(f"Test 1 - Only choices changed: Should alter? {should_alter1}")
+        
+        # Test case 2: Max length changed
+        should_alter2 = schema_editor._field_should_be_altered(old_field2, new_field2)
+        print(f"Test 2 - Max length changed: Should alter? {should_alter2}")
+        
+        # Test case 3: Field type changed
+        should_alter3 = schema_editor._field_should_be_altered(old_field3, new_field3)
+        print(f"Test 3 - Field type changed: Should alter? {should_alter3}")
+        
+        # Verify results
+        success = True
+        if should_alter1:
+            print("‚ùå FAIL: Choices-only change should NOT trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Choices-only change correctly does NOT trigger alteration")
+            
+        if not should_alter2:
+            print("‚ùå FAIL: Max length change should trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Max length change correctly triggers alteration")
+            
+        if not should_alter3:
+            print("‚ùå FAIL: Field type change should trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Field type change correctly triggers alteration")
+            
+        return success
+
+if __name__ == '__main__':
+    success = test_choices_field_alteration()
+    if success:
+        print("\nüéâ ALL TESTS PASSED: The fix is working correctly!")
+    else:
+        print("\nüí• SOME TESTS FAILED: The fix needs more work!")
\ No newline at end of file
diff --git a/test_postgresql.py b/test_postgresql.py
new file mode 100644
index 0000000000..de7d302811
--- /dev/null
+++ b/test_postgresql.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Test to verify the choices migration fix works for PostgreSQL backend as well.
+This simulates the behavior mentioned in the GitHub issue.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+
+# Configure minimal Django settings with PostgreSQL
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.postgresql',
+                'NAME': 'test_db',
+                'USER': 'test_user',
+                'PASSWORD': 'test_pass',
+                'HOST': 'localhost',
+                'PORT': '5432',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_postgresql_choices_migration():
+    """Test that PostgreSQL also handles choices correctly."""
+    
+    try:
+        connection = connections['default']
+        
+        # Create field instances with different choices
+        old_field = CharField(max_length=10)
+        old_field.choices = [('active', 'Active'), ('inactive', 'Inactive')]
+        old_field.column = 'status'
+        
+        new_field = CharField(max_length=10)
+        new_field.choices = [('active', 'Active'), ('inactive', 'Inactive'), ('pending', 'Pending')]
+        new_field.column = 'status'
+        
+        with connection.schema_editor() as schema_editor:
+            # Test if the field should be altered
+            should_alter = schema_editor._field_should_be_altered(old_field, new_field)
+            print(f"PostgreSQL - Only choices changed: Should alter? {should_alter}")
+            
+            if should_alter:
+                print("‚ùå FAIL: PostgreSQL should NOT alter field for choices changes")
+                return False
+            else:
+                print("‚úÖ PASS: PostgreSQL correctly does NOT alter field for choices changes")
+                return True
+                
+    except Exception as e:
+        print(f"‚ö†Ô∏è  Could not test PostgreSQL (connection issue): {e}")
+        print("This is expected in a test environment without PostgreSQL running.")
+        return True  # Skip this test if PostgreSQL is not available
+
+if __name__ == '__main__':
+    success = test_postgresql_choices_migration()
+    if success:
+        print("\n‚úÖ PostgreSQL test passed or skipped (as expected)!")
+    else:
+        print("\n‚ùå PostgreSQL test failed!")
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_proper.py b/test_proper.py
new file mode 100644
index 0000000000..2ce5d73270
--- /dev/null
+++ b/test_proper.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python3
+"""
+Proper test script to verify the _field_should_be_altered method fix.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections
+from django.db.models import CharField
+from django.db.migrations.state import ProjectState
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_field_alteration_with_choices():
+    """Test field alteration detection with choices changes."""
+    
+    # Create model states with different choices
+    initial_state = ProjectState()
+    altered_state = ProjectState()
+    
+    # Add initial model
+    initial_state.add_model('testapp', 'TestModel', {
+        'name': 'django.db.models.CharField',
+        'status': 'django.db.models.CharField',
+        '__module__': 'testapp.models'
+    }, {
+        'name': {'max_length': 100},
+        'status': {'max_length': 10, 'choices': [('active', 'Active'), ('inactive', 'Inactive')]},
+    })
+    
+    # Add altered model with changed choices
+    altered_state.add_model('testapp', 'TestModel', {
+        'name': 'django.db.models.CharField',
+        'status': 'django.db.models.CharField',
+        '__module__': 'testapp.models'
+    }, {
+        'name': {'max_length': 100},
+        'status': {'max_length': 10, 'choices': [('active', 'Active'), ('inactive', 'Inactive'), ('pending', 'Pending')]},
+    })
+    
+    # Add altered model with changed max_length (should trigger alteration)
+    altered_state_max_length = ProjectState()
+    altered_state_max_length.add_model('testapp', 'TestModel', {
+        'name': 'django.db.models.CharField',
+        'status': 'django.db.models.CharField',
+        '__module__': 'testapp.models'
+    }, {
+        'name': {'max_length': 100},
+        'status': {'max_length': 20, 'choices': [('active', 'Active'), ('inactive', 'Inactive')]},
+    })
+    
+    # Get the field objects
+    initial_model = initial_state.apps.get_model('testapp', 'TestModel')
+    altered_model = altered_state.apps.get_model('testapp', 'TestModel')
+    altered_model_max_length = altered_state_max_length.apps.get_model('testapp', 'TestModel')
+    
+    old_field = initial_model._meta.get_field('status')
+    new_field_choices = altered_model._meta.get_field('status')
+    new_field_max_length = altered_model_max_length._meta.get_field('status')
+    
+    connection = connections['default']
+    
+    with connection.schema_editor() as schema_editor:
+        # Test case 1: Only choices changed
+        should_alter_choices = schema_editor._field_should_be_altered(old_field, new_field_choices)
+        print(f"Only choices changed: Should alter? {should_alter_choices}")
+        
+        # Test case 2: Max length changed (should trigger alteration)
+        should_alter_max_length = schema_editor._field_should_be_altered(old_field, new_field_max_length)
+        print(f"Max length changed: Should alter? {should_alter_max_length}")
+        
+        # Verify results
+        success = True
+        if should_alter_choices:
+            print("‚ùå FAIL: Choices-only change should NOT trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Choices-only change correctly does NOT trigger alteration")
+            
+        if not should_alter_max_length:
+            print("‚ùå FAIL: Max length change should trigger alteration")
+            success = False
+        else:
+            print("‚úÖ PASS: Max length change correctly triggers alteration")
+            
+        return success
+
+if __name__ == '__main__':
+    success = test_field_alteration_with_choices()
+    if success:
+        print("\nüéâ ALL TESTS PASSED: The fix is working correctly!")
+    else:
+        print("\nüí• SOME TESTS FAILED: The fix needs more work!")
\ No newline at end of file
diff --git a/test_sqlite_choices.py b/test_sqlite_choices.py
new file mode 100644
index 0000000000..8f3143641f
--- /dev/null
+++ b/test_sqlite_choices.py
@@ -0,0 +1,120 @@
+#!/usr/bin/env python3
+"""
+Test script to verify SQLite choices migration fix.
+This creates a simple Django app and tests that AlterField operations
+with choices changes don't generate SQL on SQLite.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.db import connections, models
+from django.db.migrations import Migration, operations
+from django.db.migrations.state import ProjectState
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+    django.setup()
+
+def test_sqlite_choices_migration():
+    """Test that SQLite doesn't generate SQL for choices changes."""
+    
+    # Create a simple model
+    class TestModel(models.Model):
+        name = models.CharField(max_length=100)
+        status = models.CharField(
+            max_length=10,
+            choices=[
+                ('active', 'Active'),
+                ('inactive', 'Inactive'),
+            ]
+        )
+        
+        class Meta:
+            app_label = 'testapp'
+    
+    # Create initial state
+    initial_state = ProjectState()
+    initial_state.add_model(TestModel._meta)
+    
+    # Create altered state with changed choices
+    class TestModelAltered(models.Model):
+        name = models.CharField(max_length=100)
+        status = models.CharField(
+            max_length=10,
+            choices=[
+                ('active', 'Active'),
+                ('inactive', 'Inactive'),
+                ('pending', 'Pending'),  # Added choice
+            ]
+        )
+        
+        class Meta:
+            app_label = 'testapp'
+    
+    altered_state = ProjectState()
+    altered_state.add_model(TestModelAltered._meta)
+    
+    # Create AlterField operation
+    old_field = TestModel._meta.get_field('status')
+    new_field = TestModelAltered._meta.get_field('status')
+    
+    alter_op = operations.AlterField(
+        model_name='testmodel',
+        name='status',
+        field=new_field
+    )
+    
+    # Get SQL for the operation
+    connection = connections['default']
+    with connection.schema_editor() as schema_editor:
+        sql_statements = []
+        
+        def collect_sql(sql, params=()):
+            sql_statements.append(str(sql))
+        
+        schema_editor.execute = collect_sql
+        
+        # Test if the field should be altered
+        should_alter = schema_editor._field_should_be_altered(old_field, new_field)
+        print(f"Should field be altered? {should_alter}")
+        
+        if not should_alter:
+            print("SUCCESS: Field should NOT be altered for choices changes!")
+            return True
+        
+        # If it should be altered, let's see what SQL would be generated
+        try:
+            alter_op.database_forwards('testapp', schema_editor, initial_state, altered_state)
+            print("SQL generated for choices change:")
+            for i, sql in enumerate(sql_statements, 1):
+                print(f"{i}: {sql}")
+                
+            if not sql_statements:
+                print("No SQL generated - this is correct behavior!")
+                return True
+            else:
+                print("SQL was generated - this indicates the bug!")
+                return False
+                
+        except Exception as e:
+            print(f"Error during migration: {e}")
+            return False
+
+if __name__ == '__main__':
+    success = test_sqlite_choices_migration()
+    if success:
+        print("\n‚úÖ TEST PASSED: SQLite choices migration fix is working!")
+    else:
+        print("\n‚ùå TEST FAILED: SQLite choices migration fix is not working!")
\ No newline at end of file