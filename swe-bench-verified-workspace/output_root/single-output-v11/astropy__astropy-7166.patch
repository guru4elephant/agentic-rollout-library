diff --git a/astropy/utils/misc.py b/astropy/utils/misc.py
index de3fb01d18..cceaeb957f 100644
--- a/astropy/utils/misc.py
+++ b/astropy/utils/misc.py
@@ -528,7 +528,7 @@ class InheritDocstrings(type):
                 not key.startswith('_'))
 
         for key, val in dct.items():
-            if (inspect.isfunction(val) and
+            if ((inspect.isfunction(val) or isinstance(val, property)) and
                 is_public_member(key) and
                 val.__doc__ is None):
                 for base in cls.__mro__[1:]:
diff --git a/debug_descriptors.py b/debug_descriptors.py
new file mode 100644
index 0000000000..4483194649
--- /dev/null
+++ b/debug_descriptors.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand different descriptor types.
+"""
+
+import inspect
+
+class TestClass:
+    @property
+    def my_property(self):
+        """Property docstring."""
+        return "value"
+    
+    @classmethod
+    def my_classmethod(cls):
+        """Classmethod docstring."""
+        pass
+    
+    @staticmethod
+    def my_staticmethod():
+        """Staticmethod docstring."""
+        pass
+    
+    def my_method(self):
+        """Method docstring."""
+        pass
+
+# Test different descriptor types
+prop = TestClass.my_property
+classmethod_obj = TestClass.my_classmethod
+staticmethod_obj = TestClass.my_staticmethod
+method = TestClass.my_method
+
+print("Property:")
+print(f"  Type: {type(prop)}")
+print(f"  isinstance(property): {isinstance(prop, property)}")
+print(f"  inspect.isfunction: {inspect.isfunction(prop)}")
+print(f"  has __doc__: {hasattr(prop, '__doc__')}")
+print(f"  Doc: {prop.__doc__}")
+
+print("\nClassmethod:")
+print(f"  Type: {type(classmethod_obj)}")
+print(f"  inspect.isfunction: {inspect.isfunction(classmethod_obj)}")
+print(f"  inspect.isroutine: {inspect.isroutine(classmethod_obj)}")
+print(f"  has __doc__: {hasattr(classmethod_obj, '__doc__')}")
+print(f"  Doc: {classmethod_obj.__doc__}")
+
+print("\nStaticmethod:")
+print(f"  Type: {type(staticmethod_obj)}")
+print(f"  inspect.isfunction: {inspect.isfunction(staticmethod_obj)}")
+print(f"  inspect.isroutine: {inspect.isroutine(staticmethod_obj)}")
+print(f"  has __doc__: {hasattr(staticmethod_obj, '__doc__')}")
+print(f"  Doc: {staticmethod_obj.__doc__}")
+
+print("\nMethod:")
+print(f"  Type: {type(method)}")
+print(f"  inspect.isfunction: {inspect.isfunction(method)}")
+print(f"  inspect.isroutine: {inspect.isroutine(method)}")
+print(f"  has __doc__: {hasattr(method, '__doc__')}")
+print(f"  Doc: {method.__doc__}")
\ No newline at end of file
diff --git a/debug_properties.py b/debug_properties.py
new file mode 100644
index 0000000000..f783accc2f
--- /dev/null
+++ b/debug_properties.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand what properties look like.
+"""
+
+import inspect
+
+class TestClass:
+    @property
+    def my_property(self):
+        """This is a property docstring."""
+        return "value"
+    
+    def my_method(self):
+        """This is a method docstring."""
+        pass
+
+# Test what properties look like
+prop = TestClass.my_property
+method = TestClass.my_method
+
+print("Property analysis:")
+print(f"Type: {type(prop)}")
+print(f"isinstance(prop, property): {isinstance(prop, property)}")
+print(f"inspect.isfunction(prop): {inspect.isfunction(prop)}")
+print(f"inspect.isroutine(prop): {inspect.isroutine(prop)}")
+print(f"hasattr(prop, '__doc__'): {hasattr(prop, '__doc__')}")
+print(f"prop.__doc__: {prop.__doc__}")
+
+print("\nMethod analysis:")
+print(f"Type: {type(method)}")
+print(f"inspect.isfunction(method): {inspect.isfunction(method)}")
+print(f"inspect.isroutine(method): {inspect.isroutine(method)}")
+print(f"hasattr(method, '__doc__'): {hasattr(method, '__doc__')}")
+print(f"method.__doc__: {method.__doc__}")
+
+# Test the property getter function
+prop_func = prop.fget
+print("\nProperty getter function analysis:")
+print(f"Type: {type(prop_func)}")
+print(f"inspect.isfunction(prop_func): {inspect.isfunction(prop_func)}")
+print(f"inspect.isroutine(prop_func): {inspect.isroutine(prop_func)}")
+print(f"hasattr(prop_func, '__doc__'): {hasattr(prop_func, '__doc__')}")
+print(f"prop_func.__doc__: {prop_func.__doc__}")
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..6ad9599d4d
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test for the InheritDocstrings property fix.
+"""
+
+from astropy.utils.misc import InheritDocstrings
+
+def test_property_inheritance():
+    """Test that properties inherit docstrings correctly."""
+    
+    class BaseWithProperty(metaclass=InheritDocstrings):
+        @property
+        def my_prop(self):
+            """This is a property docstring."""
+            return "base"
+    
+    class DerivedWithProperty(BaseWithProperty):
+        @property
+        def my_prop(self):
+            # Should inherit docstring from base
+            return "derived"
+    
+    # Test inheritance
+    assert DerivedWithProperty.my_prop.__doc__ == "This is a property docstring."
+    print("‚úÖ Property docstring inheritance works")
+
+def test_method_inheritance():
+    """Test that regular methods still work."""
+    
+    class BaseWithMethod(metaclass=InheritDocstrings):
+        def my_method(self):
+            """This is a method docstring."""
+            pass
+    
+    class DerivedWithMethod(BaseWithMethod):
+        def my_method(self):
+            # Should inherit docstring from base
+            pass
+    
+    # Test inheritance
+    assert DerivedWithMethod.my_method.__doc__ == "This is a method docstring."
+    print("‚úÖ Method docstring inheritance still works")
+
+def test_existing_docstring_preserved():
+    """Test that existing docstrings are not overridden."""
+    
+    class Base(metaclass=InheritDocstrings):
+        @property
+        def prop(self):
+            """Base docstring."""
+            return "base"
+    
+    class Derived(Base):
+        @property
+        def prop(self):
+            """Derived docstring."""
+            return "derived"
+    
+    # Should preserve the derived docstring
+    assert Derived.prop.__doc__ == "Derived docstring."
+    print("‚úÖ Existing docstrings are preserved")
+
+def test_no_docstring_in_base():
+    """Test that properties without docstrings in base remain None."""
+    
+    class Base(metaclass=InheritDocstrings):
+        @property
+        def prop(self):
+            return "base"
+    
+    class Derived(Base):
+        @property
+        def prop(self):
+            return "derived"
+    
+    # Should remain None since base has no docstring
+    assert Derived.prop.__doc__ is None
+    print("‚úÖ Properties without base docstrings remain None")
+
+def test_multiple_inheritance():
+    """Test docstring inheritance with multiple inheritance."""
+    
+    class BaseA(metaclass=InheritDocstrings):
+        @property
+        def prop(self):
+            """BaseA docstring."""
+            return "A"
+    
+    class BaseB(metaclass=InheritDocstrings):
+        @property
+        def prop(self):
+            """BaseB docstring."""
+            return "B"
+    
+    class Derived(BaseA, BaseB):
+        @property
+        def prop(self):
+            # Should inherit from first base (BaseA)
+            return "derived"
+    
+    # Should inherit from first base class
+    assert Derived.prop.__doc__ == "BaseA docstring."
+    print("‚úÖ Multiple inheritance works correctly")
+
+if __name__ == "__main__":
+    test_property_inheritance()
+    test_method_inheritance()
+    test_existing_docstring_preserved()
+    test_no_docstring_in_base()
+    test_multiple_inheritance()
+    print("\nüéâ All tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b8e3a161fa
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the InheritDocstrings issue with properties.
+"""
+
+from astropy.utils.misc import InheritDocstrings
+
+class BaseClass(metaclass=InheritDocstrings):
+    """Base class with a property that has a docstring."""
+    
+    @property
+    def my_property(self):
+        """This is the docstring for my_property."""
+        return "base_value"
+
+class DerivedClass(BaseClass):
+    """Derived class that overrides the property without a docstring."""
+    
+    @property
+    def my_property(self):
+        # This should inherit the docstring from BaseClass.my_property
+        return "derived_value"
+
+# Test the issue
+print("Testing InheritDocstrings with properties:")
+print(f"BaseClass.my_property.__doc__: {BaseClass.my_property.__doc__}")
+print(f"DerivedClass.my_property.__doc__: {DerivedClass.my_property.__doc__}")
+
+# Check if the docstring was inherited
+if DerivedClass.my_property.__doc__ is None:
+    print("‚ùå ISSUE CONFIRMED: Docstring was not inherited for property!")
+else:
+    print("‚úÖ Docstring was inherited correctly")
+
+# Let's also test with a regular method for comparison
+class BaseWithMethod(metaclass=InheritDocstrings):
+    def my_method(self):
+        """This is the docstring for my_method."""
+        pass
+
+class DerivedWithMethod(BaseWithMethod):
+    def my_method(self):
+        pass
+
+print(f"\nTesting with regular method for comparison:")
+print(f"BaseWithMethod.my_method.__doc__: {BaseWithMethod.my_method.__doc__}")
+print(f"DerivedWithMethod.my_method.__doc__: {DerivedWithMethod.my_method.__doc__}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..b1207ff1a2
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the InheritDocstrings fix.
+"""
+
+from astropy.utils.misc import InheritDocstrings
+
+# Test 1: Property with existing docstring (should not be overridden)
+class Base1(metaclass=InheritDocstrings):
+    @property
+    def prop_with_doc(self):
+        """Base docstring."""
+        return "base"
+
+class Derived1(Base1):
+    @property
+    def prop_with_doc(self):
+        """Derived docstring."""
+        return "derived"
+
+# Test 2: Property without docstring in base (should remain None)
+class Base2(metaclass=InheritDocstrings):
+    @property
+    def prop_no_doc(self):
+        return "base"
+
+class Derived2(Base2):
+    @property
+    def prop_no_doc(self):
+        return "derived"
+
+# Test 3: Mixed inheritance (property from first base class should be used)
+class BaseA(metaclass=InheritDocstrings):
+    @property
+    def mixed_prop(self):
+        """BaseA docstring."""
+        return "A"
+
+class BaseB(metaclass=InheritDocstrings):
+    @property
+    def mixed_prop(self):
+        """BaseB docstring."""
+        return "B"
+
+class DerivedMixed(BaseA, BaseB):
+    @property
+    def mixed_prop(self):
+        return "mixed"
+
+# Test 4: Regular methods should still work
+class BaseMethod(metaclass=InheritDocstrings):
+    def regular_method(self):
+        """Regular method doc."""
+        pass
+
+class DerivedMethod(BaseMethod):
+    def regular_method(self):
+        pass
+
+# Run tests
+print("Test 1: Property with existing docstring")
+print(f"  Derived1.prop_with_doc.__doc__: {Derived1.prop_with_doc.__doc__}")
+assert Derived1.prop_with_doc.__doc__ == "Derived docstring.", "Should preserve existing docstring"
+
+print("\nTest 2: Property without docstring in base")
+print(f"  Derived2.prop_no_doc.__doc__: {Derived2.prop_no_doc.__doc__}")
+assert Derived2.prop_no_doc.__doc__ is None, "Should remain None when base has no docstring"
+
+print("\nTest 3: Mixed inheritance")
+print(f"  DerivedMixed.mixed_prop.__doc__: {DerivedMixed.mixed_prop.__doc__}")
+assert DerivedMixed.mixed_prop.__doc__ == "BaseA docstring.", "Should inherit from first base class"
+
+print("\nTest 4: Regular methods")
+print(f"  DerivedMethod.regular_method.__doc__: {DerivedMethod.regular_method.__doc__}")
+assert DerivedMethod.regular_method.__doc__ == "Regular method doc.", "Regular methods should still work"
+
+print("\n‚úÖ All edge case tests passed!")
\ No newline at end of file