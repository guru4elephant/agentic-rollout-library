diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..86a69555e8
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '.')
+
+import sympy as sp
+
+def test_comprehensive():
+    print("=== Comprehensive Test of NotImplemented Fix ===")
+    
+    x = sp.Symbol('x')
+    y = sp.Symbol('y')
+    
+    # Test case from the original GitHub issue
+    class Foo:
+        def __init__(self, value):
+            self.value = value
+            
+        def __eq__(self, other):
+            if isinstance(other, sp.Basic):
+                return self.value == str(other)
+            return NotImplemented
+    
+    foo = Foo('x')
+    
+    print(f"foo == x: {foo == x}")  # Should be True
+    print(f"x == foo: {x == foo}")  # Should now be True (was False before fix)
+    
+    # Test inequality as well
+    print(f"foo != x: {foo != x}")  # Should be False
+    print(f"x != foo: {x != foo}")  # Should be False
+    
+    # Test with different symbol
+    print(f"foo == y: {foo == y}")  # Should be False
+    print(f"y == foo: {y == foo}")  # Should be False
+    
+    # Test that normal sympy comparisons still work
+    print(f"x == y: {x == y}")     # Should be False
+    print(f"x == x: {x == x}")     # Should be True
+    
+    # Test with completely unrelated type
+    class Bar:
+        pass
+    
+    bar = Bar()
+    print(f"x == bar: {x == bar}")  # Should be False
+    print(f"bar == x: {bar == x}")  # Should be False
+    
+    print("\n=== All tests passed! The fix is working correctly. ===")
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b7ea8fcc35
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+import sympy as sp
+
+# Create a custom class that implements __eq__
+class Foo:
+    def __init__(self, value):
+        self.value = value
+        
+    def __eq__(self, other):
+        if isinstance(other, sp.Basic):
+            # For demonstration, compare with a simple sympy symbol
+            return self.value == str(other)
+        return NotImplemented
+
+# Create sympy objects
+x = sp.Symbol('x')
+y = sp.Symbol('y')
+
+# Create custom object
+foo = Foo('x')
+
+print("Testing comparison behavior:")
+print(f"foo == x: {foo == x}")  # This should work (Foo.__eq__ is called)
+print(f"x == foo: {x == foo}")  # This currently returns False, but should return True via NotImplemented
+
+print("\nTesting with different type:")
+class Bar:
+    pass
+
+bar = Bar()
+print(f"x == bar: {x == bar}")  # This should return False (both sides return NotImplemented)
+print(f"bar == x: {bar == x}")  # This should return False (both sides return NotImplemented)
+
+print("\nTesting with different sympy symbol:")
+print(f"x == y: {x == y}")  # This should work normally
\ No newline at end of file
diff --git a/run_tests.py b/run_tests.py
new file mode 100644
index 0000000000..bd6d806ce8
--- /dev/null
+++ b/run_tests.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+import unittest
+import sys
+import os
+
+# Add the current directory to the path
+sys.path.insert(0, '.')
+
+# Import the test module
+from sympy.core.tests.test_basic import *
+
+# Create a test suite and run it
+loader = unittest.TestLoader()
+suite = loader.loadTestsFromModule(sys.modules['sympy.core.tests.test_basic'])
+runner = unittest.TextTestRunner(verbosity=2)
+result = runner.run(suite)
+
+print(f"\nTests run: {result.testsRun}")
+print(f"Errors: {len(result.errors)}")
+print(f"Failures: {len(result.failures)}")
\ No newline at end of file
diff --git a/sympy/core/basic.py b/sympy/core/basic.py
index db4e971848..c172a6ccb5 100644
--- a/sympy/core/basic.py
+++ b/sympy/core/basic.py
@@ -313,7 +313,7 @@ def __eq__(self, other):
             try:
                 other = _sympify(other)
             except SympifyError:
-                return False    # sympy != other
+                return NotImplemented    # sympy != other
 
             if type(self) != type(other):
                 return False
@@ -329,7 +329,10 @@ def __ne__(self, other):
 
            but faster
         """
-        return not self.__eq__(other)
+        eq_result = self.__eq__(other)
+        if eq_result is NotImplemented:
+            return NotImplemented
+        return not eq_result
 
     def dummy_eq(self, other, symbol=None):
         """
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..877a440a55
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '.')
+
+import sympy as sp
+
+# Test edge cases for the NotImplemented fix
+def test_edge_cases():
+    x = sp.Symbol('x')
+    
+    # Test 1: Custom class that always returns NotImplemented
+    class AlwaysNotImplemented:
+        def __eq__(self, other):
+            return NotImplemented
+    
+    ani = AlwaysNotImplemented()
+    print(f"x == AlwaysNotImplemented: {x == ani}")
+    print(f"AlwaysNotImplemented == x: {ani == x}")
+    
+    # Test 2: Custom class that returns False for sympy objects
+    class ReturnFalse:
+        def __eq__(self, other):
+            if isinstance(other, sp.Basic):
+                return False
+            return NotImplemented
+    
+    rf = ReturnFalse()
+    print(f"x == ReturnFalse: {x == rf}")
+    print(f"ReturnFalse == x: {rf == x}")
+    
+    # Test 3: Custom class that returns True for sympy objects
+    class ReturnTrue:
+        def __eq__(self, other):
+            if isinstance(other, sp.Basic):
+                return True
+            return NotImplemented
+    
+    rt = ReturnTrue()
+    print(f"x == ReturnTrue: {x == rt}")
+    print(f"ReturnTrue == x: {rt == x}")
+    
+    # Test 4: Both sides return NotImplemented
+    class AnotherNotImplemented:
+        def __eq__(self, other):
+            return NotImplemented
+    
+    ani1 = AlwaysNotImplemented()
+    ani2 = AnotherNotImplemented()
+    print(f"AlwaysNotImplemented == AnotherNotImplemented: {ani1 == ani2}")
+    print(f"AnotherNotImplemented == AlwaysNotImplemented: {ani2 == ani1}")
+    
+    print("All edge case tests completed!")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_equality.py b/test_equality.py
new file mode 100644
index 0000000000..80b2f4c4f0
--- /dev/null
+++ b/test_equality.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '.')
+
+from sympy.core.basic import Basic
+from sympy.core.singleton import S
+
+# Test basic equality functionality
+def test_basic_equality():
+    b1 = Basic()
+    b2 = Basic(b1)
+    b3 = Basic(b2)
+    b21 = Basic(b2, b1)
+    
+    # Test basic equality
+    assert b1 == b1
+    assert b2 == b2
+    assert b1 != b2
+    
+    # Test comparison with non-Basic objects
+    assert b1 != []
+    assert b1 != 0
+    assert b1 != "string"
+    assert b1 != None
+    
+    # Test that NotImplemented is handled correctly
+    class CustomClass:
+        def __eq__(self, other):
+            if isinstance(other, Basic):
+                return True  # For testing purposes
+            return NotImplemented
+    
+    custom_obj = CustomClass()
+    
+    # This should now work correctly with our fix
+    result = b1 == custom_obj
+    print(f"b1 == custom_obj: {result}")
+    
+    # The reverse should also work through NotImplemented delegation
+    result2 = custom_obj == b1
+    print(f"custom_obj == b1: {result2}")
+    
+    # Both should be the same
+    assert result == result2, f"Equality should be symmetric: {result} vs {result2}"
+    
+    print("All equality tests passed!")
+
+if __name__ == "__main__":
+    test_basic_equality()
\ No newline at end of file