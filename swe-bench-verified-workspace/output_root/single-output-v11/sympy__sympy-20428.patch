diff --git a/debug_clear_denoms.py b/debug_clear_denoms.py
new file mode 100644
index 0000000000..c10f59630d
--- /dev/null
+++ b/debug_clear_denoms.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.densetools import dup_clear_denoms
+
+# Create a simple test case
+x = symbols("x")
+simple_zero = Poly(0, x, domain="EX")
+print("Simple zero poly representation:", simple_zero.rep)
+
+# Test what happens with a zero poly in clear_denoms
+try:
+    coeff, result = simple_zero.clear_denoms()
+    print("Simple zero clear_denoms result:", result.rep)
+except Exception as e:
+    print("Simple zero clear_denoms error:", e)
+
+# Let's also test the underlying dup_clear_denoms function
+from sympy.polys.domains import EX
+
+# Test with an empty list (proper zero)
+empty_f = []
+coeff1, result1 = dup_clear_denoms(empty_f, EX, EX)
+print("Empty list result:", result1)
+
+# Test with a list containing [0] (the problematic case)
+zero_f = [EX(0)]
+coeff2, result2 = dup_clear_denoms(zero_f, EX, EX)
+print("Single zero result:", result2)
+print("Type of result:", type(result2))
+print("Length of result:", len(result2) if hasattr(result2, '__len__') else 'N/A')
+
+# Check what dup_mul_ground does with [0]
+from sympy.polys.densearith import dup_mul_ground
+test_mul = dup_mul_ground([EX(0)], EX(1), EX)
+print("dup_mul_ground([EX(0)], EX(1), EX):", test_mul)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b2f2b7946a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Reproduce the issue described in the GitHub issue
+x = symbols("x")
+f = Poly(sympify("-117968192370600*18**(1/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) - 15720318185*2**(2/3)*3**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 15720318185*12**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 117968192370600*2**(1/3)*3**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3))"), x)
+
+print("Original polynomial f:")
+print(f)
+print()
+
+coeff, bad_poly = f.clear_denoms()
+print("Coefficient from clear_denoms():")
+print(coeff)
+print()
+
+print("Resulting polynomial from clear_denoms():")
+print(bad_poly)
+print()
+
+print("bad_poly representation:")
+print(repr(bad_poly))
+print()
+
+print("bad_poly.is_zero:")
+print(bad_poly.is_zero)
+print()
+
+print("bad_poly.as_expr():")
+print(bad_poly.as_expr())
+print()
+
+print("bad_poly.as_expr().is_zero:")
+print(bad_poly.as_expr().is_zero)
+print()
+
+print("bad_poly.rep:")
+print(bad_poly.rep)
+print()
+
+print("Expected representation for zero poly in EX domain:")
+expected_zero = Poly(0, x, domain="EX")
+print(expected_zero.rep)
+print()
+
+print("Compare with proper zero poly:")
+print("Proper zero poly .is_zero:", expected_zero.is_zero)
+print("Proper zero poly .as_expr().is_zero:", expected_zero.as_expr().is_zero)
+
+# Test terms_gcd method
+print("\nTesting terms_gcd():")
+try:
+    result = bad_poly.terms_gcd()
+    print("terms_gcd() succeeded:", result)
+except Exception as e:
+    print("terms_gcd() failed with error:", type(e).__name__, ":", e)
+
+# Test primitive method
+print("\nTesting primitive():")
+try:
+    result = bad_poly.primitive()
+    print("primitive() succeeded:", result)
+except Exception as e:
+    print("primitive() failed with error:", type(e).__name__, ":", e)
\ No newline at end of file
diff --git a/sympy/polys/densebasic.py b/sympy/polys/densebasic.py
index 1caeb8f629..b3cc2243c4 100644
--- a/sympy/polys/densebasic.py
+++ b/sympy/polys/densebasic.py
@@ -273,6 +273,10 @@ def dup_strip(f):
         else:
             i += 1
 
+    # If all coefficients are zero, return empty list
+    if i == len(f):
+        return []
+    
     return f[i:]
 
 
diff --git a/sympy/polys/densetools.py b/sympy/polys/densetools.py
index f057824642..8bbf89d185 100644
--- a/sympy/polys/densetools.py
+++ b/sympy/polys/densetools.py
@@ -1198,6 +1198,9 @@ def dup_clear_denoms(f, K0, K1=None, convert=False):
     if not K1.is_one(common):
         f = dup_mul_ground(f, common, K0)
 
+    # Strip leading zeros after multiplication
+    f = dup_strip(f)
+
     if not convert:
         return common, f
     else:
@@ -1252,6 +1255,9 @@ def dmp_clear_denoms(f, u, K0, K1=None, convert=False):
     if not K1.is_one(common):
         f = dmp_mul_ground(f, common, u, K0)
 
+    # Strip leading zeros after multiplication
+    f = dmp_strip(f, u)
+
     if not convert:
         return common, f
     else:
diff --git a/test_ex_zero.py b/test_ex_zero.py
new file mode 100644
index 0000000000..14750af91c
--- /dev/null
+++ b/test_ex_zero.py
@@ -0,0 +1,24 @@
+#!/usr/bin/env python3
+
+from sympy.polys.domains import EX
+
+# Test what EX(0) evaluates to in boolean context
+ex_zero = EX(0)
+print("EX(0):", ex_zero)
+print("bool(EX(0)):", bool(ex_zero))
+print("EX(0) == 0:", ex_zero == 0)
+# print("EX(0).is_zero:", ex_zero.is_zero)  # AttributeError
+
+# Test what happens in dup_mul_ground conditions
+from sympy.polys.densearith import dup_mul_ground
+
+# Test the condition that should trigger empty return
+f = [EX(0)]
+c = EX(1)
+print("not c:", not c)
+print("not f:", not f)
+print("not c or not f:", not c or not f)
+
+# Test the actual function
+result = dup_mul_ground([EX(0)], EX(1), EX)
+print("dup_mul_ground result:", result)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..924897f9f3
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Test 1: Normal case (should still work)
+x = symbols("x")
+f = Poly(x/2 + 1/3, x, domain=QQ)
+coeff, result = f.clear_denoms()
+print("Test 1 - Normal case:")
+print("coeff:", coeff)
+print("result:", result)
+print("result.rep:", result.rep)
+print()
+
+# Test 2: Zero polynomial (should work correctly now)
+zero_poly = Poly(0, x, domain=QQ)
+coeff, result = zero_poly.clear_denoms()
+print("Test 2 - Zero polynomial:")
+print("coeff:", coeff)
+print("result:", result)
+print("result.rep:", result.rep)
+print("result.is_zero:", result.is_zero)
+print()
+
+# Test 3: Multivariate case
+x, y = symbols("x y")
+f = Poly(x/2 + y/3, x, y, domain=QQ)
+coeff, result = f.clear_denoms()
+print("Test 3 - Multivariate case:")
+print("coeff:", coeff)
+print("result:", result)
+print("result.rep:", result.rep)
+print()
+
+# Test 4: Multivariate zero
+zero_poly = Poly(0, x, y, domain=QQ)
+coeff, result = zero_poly.clear_denoms()
+print("Test 4 - Multivariate zero:")
+print("coeff:", coeff)
+print("result:", result)
+print("result.rep:", result.rep)
+print("result.is_zero:", result.is_zero)
+print()
+
+# Test 5: Original issue case
+x = symbols("x")
+f = Poly(sympify("-117968192370600*18**(1/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) - 15720318185*2**(2/3)*3**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 15720318185*12**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 117968192370600*2**(1/3)*3**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3))"), x)
+coeff, bad_poly = f.clear_denoms()
+print("Test 5 - Original issue case:")
+print("bad_poly.is_zero:", bad_poly.is_zero)
+print("bad_poly.rep:", bad_poly.rep)
+print("terms_gcd() works:", bad_poly.terms_gcd() is not None)
+print("primitive() works:", bad_poly.primitive() is not None)
\ No newline at end of file