diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..6e07ff564b
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+import sympy
+from sympy.parsing.latex import parse_latex
+
+# Test the specific case step by step
+print("=== Step 1: Parse denominator ===")
+denom_expr = parse_latex(r'\frac{1}{c^2}')
+print('Denominator:', denom_expr)
+print('Denominator type:', type(denom_expr))
+print('Denominator args:', denom_expr.args)
+
+print("\n=== Step 2: Parse numerator ===")
+num_expr = parse_latex(r'\frac{a^3+b}{c}')
+print('Numerator:', num_expr)
+print('Numerator type:', type(num_expr))
+print('Numerator args:', num_expr.args)
+
+print("\n=== Step 3: Parse full expression ===")
+full_expr = parse_latex(r'\frac{\frac{a^3+b}{c}}{\frac{1}{c^2}}')
+print('Full expression:', full_expr)
+print('Full expression type:', type(full_expr))
+print('Full expression args:', full_expr.args)
+
+print("\n=== Step 4: Analyze structure ===")
+# The full expression should be: numerator / denominator
+# But let's see what it actually is
+arg1 = full_expr.args[0]
+arg2 = full_expr.args[1]
+print('Arg1 (should be numerator):', arg1)
+print('Arg2 (should be 1/denominator):', arg2)
+
+print("\n=== Step 5: Check mathematical correctness ===")
+a, b, c = sympy.symbols('a b c')
+test_values = {a: 1, b: 2, c: 3}
+
+# Current result value
+current_value = full_expr.subs(test_values)
+print('Current value:', current_value)
+
+# Expected value based on manual calculation
+expected_value = (num_expr / denom_expr).subs(test_values)
+print('Expected value:', expected_value)
+
+print('Values match:', current_value == expected_value)
+
+# The issue is that current_value should be the same as expected_value
+# If they're different, then the parsing is mathematically wrong
\ No newline at end of file
diff --git a/debug_frac.py b/debug_frac.py
new file mode 100644
index 0000000000..8d69309098
--- /dev/null
+++ b/debug_frac.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.latex import parse_latex
+from sympy.parsing.latex._parse_latex_antlr import convert_frac
+from sympy import sympify
+
+# Test the problematic latex expression
+latex_expr = r"\frac{\frac{a^3+b}{c}}{\frac{1}{c^2}}"
+result = parse_latex(latex_expr)
+
+print("LaTeX expression:", latex_expr)
+print("Parsed result:", result)
+print("Expected: ((a**3 + b)/c)/(1/(c**2))")
+print("Actual:", result)
+
+# Let's also test just the denominator part
+denom_expr = r"\frac{1}{c^2}"
+denom_result = parse_latex(denom_expr)
+print("\nDenominator part:", denom_expr)
+print("Denominator result:", denom_result)
+print("Denominator type:", type(denom_result))
+
+# Check if the denominator is a Mul or Pow object
+if hasattr(denom_result, 'args'):
+    print("Denominator args:", denom_result.args)
+    print("Denominator func:", denom_result.func)
+
+# Let's see what happens when we manually create the correct expression
+expected_expr = sympify("((a**3 + b)/c)/(1/(c**2))")
+print("\nExpected expression:", expected_expr)
+print("Expected type:", type(expected_expr))
+if hasattr(expected_expr, 'args'):
+    print("Expected args:", expected_expr.args)
+    print("Expected func:", expected_expr.func)
+
+# Compare structures
+print("\nStructure comparison:")
+print("Actual structure:", result.func, result.args)
+print("Expected structure:", expected_expr.func, expected_expr.args)
+
+# Let's manually break down the actual result
+print("\nActual result breakdown:")
+for i, arg in enumerate(result.args):
+    print(f"  Arg {i}: {arg} (type: {type(arg)})")
+    if hasattr(arg, 'args'):
+        print(f"    Sub-args: {arg.args}")
+
+# Let's also check what the numerator looks like
+num_expr = r"\frac{a^3+b}{c}"
+num_result = parse_latex(num_expr)
+print("\nNumerator part:", num_expr)
+print("Numerator result:", num_result)
+print("Numerator type:", type(num_result))
+if hasattr(num_result, 'args'):
+    print("Numerator args:", num_result.args)
+    print("Numerator func:", num_result.func)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..3c103ed488
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.latex import parse_latex
+
+# Test the problematic latex expression
+latex_expr = r"\frac{\frac{a^3+b}{c}}{\frac{1}{c^2}}"
+result = parse_latex(latex_expr)
+
+print("LaTeX expression:", latex_expr)
+print("Parsed result:", result)
+print("Expected: ((a**3 + b)/c)/(1/(c**2))")
+print("Actual:", result)
+
+# Check if the result matches the expected form
+expected_str = "((a**3 + b)/c)/(1/(c**2))"
+actual_str = str(result)
+
+print("\nString comparison:")
+print("Expected:", expected_str)
+print("Actual:  ", actual_str)
+print("Match:", expected_str == actual_str)
\ No newline at end of file
diff --git a/sympy/parsing/latex/_parse_latex_antlr.py b/sympy/parsing/latex/_parse_latex_antlr.py
index 2e4a45ad20..c0ed094745 100644
--- a/sympy/parsing/latex/_parse_latex_antlr.py
+++ b/sympy/parsing/latex/_parse_latex_antlr.py
@@ -382,11 +382,24 @@ def convert_frac(frac):
 
     expr_top = convert_expr(frac.upper)
     expr_bot = convert_expr(frac.lower)
-    inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)
-    if expr_top == 1:
-        return inverse_denom
+    
+    # If the denominator is itself a fraction (a Pow object with negative exponent),
+    # we need to handle it specially to maintain proper precedence
+    if isinstance(expr_bot, sympy.Pow) and expr_bot.exp == -1:
+        # For fractions in the denominator, we need to ensure proper precedence
+        # by creating a division expression that treats the denominator as a single unit
+        # We'll simplify (1/(expr))**(-1) to expr to avoid double inversion
+        # but only if it won't change the mathematical meaning
+        if expr_top == 1:
+            return expr_bot.args[0]  # Return the base (undo the fraction)
+        else:
+            return sympy.Mul(expr_top, expr_bot.args[0], evaluate=False)
     else:
-        return sympy.Mul(expr_top, inverse_denom, evaluate=False)
+        inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)
+        if expr_top == 1:
+            return inverse_denom
+        else:
+            return sympy.Mul(expr_top, inverse_denom, evaluate=False)
 
 def convert_binom(binom):
     expr_n = convert_expr(binom.n)