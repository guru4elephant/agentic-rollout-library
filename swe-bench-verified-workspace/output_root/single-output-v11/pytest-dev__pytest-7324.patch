diff --git a/debug_ast.py b/debug_ast.py
new file mode 100644
index 000000000..0c550edbb
--- /dev/null
+++ b/debug_ast.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+"""Debug the AST transformation"""
+
+from src._pytest.mark.expression import Expression, Scanner, expression
+import ast
+
+def main():
+    print("Debugging AST transformation...")
+    
+    # Test simple False
+    scanner = Scanner("False")
+    astexpr = expression(scanner)
+    print(f"Original AST: {ast.dump(astexpr)}")
+    
+    # Apply transformation
+    transformed_ast = Expression._transform_ast(astexpr)
+    print(f"Transformed AST: {ast.dump(transformed_ast)}")
+    
+    # Test compilation
+    try:
+        code = compile(transformed_ast, filename="<test>", mode="eval")
+        print(f"Compilation successful")
+        
+        # Test evaluation
+        def matcher(x):
+            print(f"Matcher called with: {x}")
+            return x == "some_variable"
+            
+        def handle_reserved(keyword):
+            print(f"Reserved handler called with: {keyword}")
+            return matcher(keyword)
+            
+        class CombinedMapping:
+            def __init__(self, matcher, reserved_handler):
+                self.matcher = matcher
+                self.reserved_handler = reserved_handler
+            
+            def __getitem__(self, key: str):
+                print(f"Mapping called with key: {key}")
+                if key == '__pytest_reserved__':
+                    return self.reserved_handler
+                return self.matcher(key)
+            
+            def __contains__(self, key: str) -> bool:
+                return True
+        
+        locals_dict = CombinedMapping(matcher, handle_reserved)
+        
+        result = eval(code, {"__builtins__": {}}, locals_dict)
+        print(f"Evaluation result: {result}")
+        
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/debug_evaluation.py b/debug_evaluation.py
new file mode 100644
index 000000000..295300b70
--- /dev/null
+++ b/debug_evaluation.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+"""Debug the evaluation issue"""
+
+from src._pytest.mark.expression import Expression
+
+def main():
+    print("Testing evaluation...")
+    
+    # Test simple False
+    try:
+        expr = Expression.compile("False")
+        print(f"Compiled successfully: {expr}")
+        
+        # Test evaluation with different matchers
+        result = expr.evaluate(lambda x: True)
+        print(f"Evaluation result (matcher returns True): {result}")
+        
+        result = expr.evaluate(lambda x: False)
+        print(f"Evaluation result (matcher returns False): {result}")
+        
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 000000000..00064a283
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+"""Final test to confirm the original issue is fixed"""
+
+from src._pytest.mark.expression import Expression
+
+def main():
+    print("Testing the original issue: Expression.compile('False')")
+    
+    # This should not crash the interpreter
+    try:
+        expr = Expression.compile("False")
+        print("âœ“ Successfully compiled 'False' without crashing")
+        
+        # Test evaluation
+        result = expr.evaluate(lambda x: True)  # Matcher returns True for everything
+        print(f"âœ“ Evaluation result when matcher returns True: {result}")
+        
+        result = expr.evaluate(lambda x: False)  # Matcher returns False for everything  
+        print(f"âœ“ Evaluation result when matcher returns False: {result}")
+        
+        # Test with specific matcher that matches "False"
+        result = expr.evaluate(lambda x: x == "False")
+        print(f"âœ“ Evaluation result when matcher matches 'False': {result}")
+        
+        # Test other reserved keywords
+        expr_true = Expression.compile("True")
+        print("âœ“ Successfully compiled 'True'")
+        
+        expr_none = Expression.compile("None")  
+        print("âœ“ Successfully compiled 'None'")
+        
+        print("\nðŸŽ‰ All tests passed! The issue has been fixed.")
+        
+    except Exception as e:
+        print(f"âœ— Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..0ddee4569
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""Script to reproduce the issue with Expression.compile("False")"""
+
+import sys
+from src._pytest.mark.expression import Expression, Scanner, expression
+
+def main():
+    print(f"Python version: {sys.version}")
+    print("Testing Expression.compile with 'False'...")
+    
+    # Let's debug step by step
+    try:
+        # First, let's see what tokens are generated
+        scanner = Scanner("False")
+        print("Tokens:")
+        for token in scanner.tokens:
+            print(f"  {token.type}: {repr(token.value)} at pos {token.pos}")
+        
+        # Now let's see what AST is generated
+        astexpr = expression(Scanner("False"))
+        import ast
+        print(f"AST: {ast.dump(astexpr)}")
+        print(f"AST body: {ast.dump(astexpr.body)}")
+        
+        # Test False
+        expr_false = Expression.compile("False")
+        print(f"Successfully compiled False: {expr_false}")
+        print(f"False code object: {expr_false.code}")
+        
+        # Test True
+        expr_true = Expression.compile("True")
+        print(f"Successfully compiled True: {expr_true}")
+        print(f"True code object: {expr_true.code}")
+        
+        # Test None
+        expr_none = Expression.compile("None")
+        print(f"Successfully compiled None: {expr_none}")
+        print(f"None code object: {expr_none.code}")
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py
index 04c73411a..46a45af7f 100644
--- a/src/_pytest/mark/expression.py
+++ b/src/_pytest/mark/expression.py
@@ -199,11 +199,46 @@ class Expression:
         :param input: The input expression - one line.
         """
         astexpr = expression(Scanner(input))
+        
+        # Transform AST to handle Python reserved keywords as identifiers
+        astexpr = self._transform_ast(astexpr)
+        
         code = compile(
             astexpr, filename="<pytest match expression>", mode="eval",
         )  # type: types.CodeType
         return Expression(code)
 
+    @classmethod
+    def _transform_ast(cls, node: ast.AST) -> ast.AST:
+        """Transform AST to handle Python reserved keywords as identifiers.
+        
+        Replaces Name nodes with id 'False', 'True', or 'None' with function calls
+        that can be handled by the evaluation environment.
+        """
+        if isinstance(node, ast.Name):
+            if node.id in ("False", "True", "None"):
+                # Transform into a function call that will be handled by MatcherAdapter
+                return ast.Call(
+                    func=ast.Name(id='__pytest_reserved__', ctx=ast.Load(), lineno=0, col_offset=0),
+                    args=[ast.Constant(value=node.id, lineno=0, col_offset=0)],
+                    keywords=[],
+                    lineno=node.lineno if hasattr(node, 'lineno') else 0,
+                    col_offset=node.col_offset if hasattr(node, 'col_offset') else 0
+                )
+        elif hasattr(node, '_fields'):
+            # Recursively transform child nodes
+            for field in node._fields:
+                if field == 'lineno' or field == 'col_offset':
+                    continue
+                value = getattr(node, field)
+                if isinstance(value, list):
+                    for i, item in enumerate(value):
+                        if isinstance(item, ast.AST):
+                            value[i] = cls._transform_ast(item)
+                elif isinstance(value, ast.AST):
+                    setattr(node, field, cls._transform_ast(value))
+        return node
+
     def evaluate(self, matcher: Callable[[str], bool]) -> bool:
         """Evaluate the match expression.
 
@@ -212,7 +247,27 @@ class Expression:
 
         Returns whether the expression matches or not.
         """
+        # Create a special function to handle reserved keywords
+        def handle_reserved(keyword: str) -> bool:
+            return matcher(keyword)
+        
+        # Create a custom mapping that combines both functionalities
+        class CombinedMapping:
+            def __init__(self, matcher, reserved_handler):
+                self.matcher = matcher
+                self.reserved_handler = reserved_handler
+            
+            def __getitem__(self, key: str):
+                if key == '__pytest_reserved__':
+                    return self.reserved_handler
+                return self.matcher(key)
+            
+            def __contains__(self, key: str) -> bool:
+                return True  # All keys are "present" since matcher handles arbitrary strings
+        
+        locals_dict = CombinedMapping(matcher, handle_reserved)
+        
         ret = eval(
-            self.code, {"__builtins__": {}}, MatcherAdapter(matcher)
+            self.code, {"__builtins__": {}}, locals_dict
         )  # type: bool
         return ret
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..d91e2a2eb
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+"""Test edge cases for the Python constants fix"""
+
+from src._pytest.mark.expression import Expression
+
+def main():
+    print("Testing edge cases...")
+    
+    test_cases = [
+        "False",
+        "True", 
+        "None",
+        "false",  # lowercase should be treated as regular identifier
+        "true",   # lowercase should be treated as regular identifier
+        "none",   # lowercase should be treated as regular identifier
+        "False or True",
+        "True and not False",
+        "None or some_variable",
+        "False and True or None"
+    ]
+    
+    for case in test_cases:
+        try:
+            expr = Expression.compile(case)
+            print(f"âœ“ Successfully compiled: '{case}'")
+            
+            # Test evaluation with a simple matcher
+            result = expr.evaluate(lambda x: x == "some_variable")
+            print(f"  Evaluation result: {result}")
+            
+        except Exception as e:
+            print(f"âœ— Error compiling '{case}': {e}")
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/test_regular_identifiers.py b/test_regular_identifiers.py
new file mode 100644
index 000000000..59c30c57a
--- /dev/null
+++ b/test_regular_identifiers.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+"""Test that regular identifiers still work after the fix"""
+
+from src._pytest.mark.expression import Expression
+
+def main():
+    print("Testing regular identifiers...")
+    
+    # Test regular identifier
+    try:
+        expr = Expression.compile("some_variable")
+        print(f"Successfully compiled 'some_variable': {expr}")
+        print(f"Code object: {expr.code}")
+        
+        # Test evaluation
+        result = expr.evaluate(lambda x: x == "some_variable")
+        print(f"Evaluation result when matcher returns True: {result}")
+        
+        result = expr.evaluate(lambda x: x == "different_variable")
+        print(f"Evaluation result when matcher returns False: {result}")
+        
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file