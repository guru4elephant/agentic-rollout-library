diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py
index 1ba093e51f..095ad0ccf0 100644
--- a/django/core/management/__init__.py
+++ b/django/core/management/__init__.py
@@ -344,7 +344,12 @@ class ManagementUtility:
         # Preprocess options to extract --settings and --pythonpath.
         # These options could affect the commands that are available, so they
         # must be processed early.
-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)
+        parser = CommandParser(
+            prog=self.prog_name,
+            usage='%(prog)s subcommand [options] [args]',
+            add_help=False,
+            allow_abbrev=False
+        )
         parser.add_argument('--settings')
         parser.add_argument('--pythonpath')
         parser.add_argument('args', nargs='*')  # catch-all
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..3e15092b75
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+"""
+Final verification test for the ManagementUtility fix
+This test demonstrates the exact issue mentioned in the GitHub issue
+"""
+
+import sys
+import os
+from django.core.management import ManagementUtility
+from django.core.management.base import CommandParser
+
+def test_github_issue():
+    """
+    Test the exact scenario described in the GitHub issue:
+    - ManagementUtility computes prog_name from argv[0] 
+    - But CommandParser was using sys.argv[0] instead of prog_name
+    - This caused issues when sys.argv[0] was None or incorrect
+    """
+    
+    print("=== Testing GitHub Issue Scenario ===")
+    
+    # Simulate the problematic environment mentioned in the issue
+    # where sys.argv[0] is incorrectly None in an embedded environment
+    original_sys_argv = sys.argv[:]
+    
+    # Create a scenario where sys.argv[0] is None (as mentioned in the issue)
+    sys.argv[0] = None
+    
+    try:
+        # This should work now with our fix
+        fake_argv = ['custom_program_name', 'help']
+        utility = ManagementUtility(argv=fake_argv)
+        
+        print(f"Computed prog_name: {utility.prog_name}")
+        print(f"sys.argv[0]: {sys.argv[0]}")
+        
+        # Test the parser creation from execute() method
+        # This is what was fixed
+        parser = CommandParser(
+            prog=utility.prog_name,
+            usage='%(prog)s subcommand [options] [args]', 
+            add_help=False, 
+            allow_abbrev=False
+        )
+        
+        print(f"Parser usage: {parser.format_usage()}")
+        print("✓ SUCCESS: Parser correctly uses computed prog_name instead of sys.argv[0]")
+        
+    except Exception as e:
+        print(f"✗ FAILED: {e}")
+    
+    finally:
+        # Restore original sys.argv
+        sys.argv = original_sys_argv
+    
+    print("\n=== Testing Edge Cases ===")
+    
+    # Test with empty string argv[0]
+    utility2 = ManagementUtility(['', 'help'])
+    parser2 = CommandParser(
+        prog=utility2.prog_name,
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    print(f"Empty argv[0] -> prog_name: '{utility2.prog_name}' -> usage: {parser2.format_usage()}")
+    
+    # Test with normal case
+    utility3 = ManagementUtility(['manage.py', 'help'])
+    parser3 = CommandParser(
+        prog=utility3.prog_name,
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    print(f"Normal argv[0] -> prog_name: '{utility3.prog_name}' -> usage: {parser3.format_usage()}")
+
+if __name__ == '__main__':
+    test_github_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0715f9c397
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the ManagementUtility issue where CommandParser
+doesn't use the computed prog_name but instead uses sys.argv[0]
+"""
+
+import sys
+import os
+from django.core.management import ManagementUtility
+
+def test_prog_name_issue():
+    # Create a fake argv where argv[0] is an empty string (simulating the issue)
+    fake_argv = ['', 'help']
+    
+    # Create ManagementUtility with custom argv
+    utility = ManagementUtility(argv=fake_argv)
+    
+    print(f"Computed prog_name: {utility.prog_name}")
+    print(f"sys.argv[0]: {sys.argv[0]}")
+    
+    # The issue is that when CommandParser is created in execute(),
+    # it uses sys.argv[0] instead of utility.prog_name for %(prog)s
+    
+    # Let's simulate what happens in execute() method
+    from django.core.management.base import CommandParser
+    
+    # Current behavior (incorrect) - doesn't pass prog argument
+    parser1 = CommandParser(
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    
+    # Fixed behavior (correct) - passes prog argument
+    parser2 = CommandParser(
+        prog=utility.prog_name,
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    
+    print("\nComparison:")
+    print(f"Current parser usage: {parser1.format_usage()}")
+    print(f"Fixed parser usage: {parser2.format_usage()}")
+
+if __name__ == '__main__':
+    test_prog_name_issue()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..df2a8916ff
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify ManagementUtility works correctly after our fix
+"""
+
+import os
+import sys
+from django.core.management import ManagementUtility
+
+def test_basic_functionality():
+    """Test that ManagementUtility still works for basic cases"""
+    
+    # Test 1: Normal usage
+    print("=== Test 1: Normal argv ===")
+    utility = ManagementUtility(['manage.py', 'help'])
+    print(f"prog_name: {utility.prog_name}")
+    
+    # Test 2: Custom argv
+    print("\n=== Test 2: Custom argv ===")
+    utility2 = ManagementUtility(['custom_prog', 'help'])
+    print(f"prog_name: {utility2.prog_name}")
+    
+    # Test 3: Empty argv[0]
+    print("\n=== Test 3: Empty argv[0] ===")
+    utility3 = ManagementUtility(['', 'help'])
+    print(f"prog_name: {utility3.prog_name}")
+    
+    # Test 4: Edge case - __main__.py
+    print("\n=== Test 4: __main__.py conversion ===")
+    utility4 = ManagementUtility(['__main__.py', 'help'])
+    print(f"prog_name: {utility4.prog_name}")
+    
+    print("\n=== All tests completed successfully ===")
+
+if __name__ == '__main__':
+    test_basic_functionality()
\ No newline at end of file
diff --git a/test_execute_fix.py b/test_execute_fix.py
new file mode 100644
index 0000000000..a0f840c34e
--- /dev/null
+++ b/test_execute_fix.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the ManagementUtility.execute() fix
+"""
+
+import sys
+import os
+from django.core.management import ManagementUtility
+from django.core.management.base import CommandParser
+
+def test_execute_fix():
+    # Test the parser creation that happens inside execute() method
+    print("=== Testing parser creation in execute() method ===")
+    
+    # Create ManagementUtility with custom argv
+    fake_argv = ['custom_prog', 'help']
+    utility = ManagementUtility(argv=fake_argv)
+    
+    print(f"Computed prog_name: {utility.prog_name}")
+    print(f"sys.argv[0]: {sys.argv[0]}")
+    
+    # Simulate the parser creation from execute() method
+    # BEFORE fix (what it used to be):
+    parser_old = CommandParser(
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    
+    # AFTER fix (what it is now):
+    parser_new = CommandParser(
+        prog=utility.prog_name,
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    
+    print(f"\nOld parser usage: {parser_old.format_usage()}")
+    print(f"New parser usage: {parser_new.format_usage()}")
+    
+    # Test with empty string (edge case from the issue)
+    print("\n=== Testing with empty argv[0] ===")
+    fake_argv2 = ['', 'help']
+    utility2 = ManagementUtility(argv=fake_argv2)
+    
+    print(f"Computed prog_name: {utility2.prog_name}")
+    
+    parser_new2 = CommandParser(
+        prog=utility2.prog_name,
+        usage='%(prog)s subcommand [options] [args]', 
+        add_help=False, 
+        allow_abbrev=False
+    )
+    
+    print(f"Fixed parser usage: {parser_new2.format_usage()}")
+
+if __name__ == '__main__':
+    test_execute_fix()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..73f97990d2
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the ManagementUtility fix
+"""
+
+import sys
+import os
+from django.core.management import ManagementUtility
+
+def test_fix():
+    # Test case 1: Normal case with custom argv
+    print("=== Test Case 1: Custom argv ===")
+    fake_argv = ['custom_prog_name', 'help']
+    utility = ManagementUtility(argv=fake_argv)
+    
+    print(f"Computed prog_name: {utility.prog_name}")
+    print(f"sys.argv[0]: {sys.argv[0]}")
+    
+    # Test case 2: Edge case with empty string (simulating the issue)
+    print("\n=== Test Case 2: Empty argv[0] ===")
+    fake_argv2 = ['', 'help']
+    utility2 = ManagementUtility(argv=fake_argv2)
+    
+    print(f"Computed prog_name: {utility2.prog_name}")
+    print(f"sys.argv[0]: {sys.argv[0]}")
+    
+    # Test case 3: Edge case with None (should be handled gracefully)
+    print("\n=== Test Case 3: None argv[0] ===")
+    try:
+        fake_argv3 = [None, 'help']
+        utility3 = ManagementUtility(argv=fake_argv3)
+        print(f"Computed prog_name: {utility3.prog_name}")
+    except Exception as e:
+        print(f"Exception (expected): {e}")
+    
+    print(f"sys.argv[0]: {sys.argv[0]}")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file