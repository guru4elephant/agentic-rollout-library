diff --git a/debug_bounds.py b/debug_bounds.py
new file mode 100644
index 0000000000..1842a1b11f
--- /dev/null
+++ b/debug_bounds.py
@@ -0,0 +1,35 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Get the inner sum result
+inner_sum = Sum(e[i, j], (i, 0, n-1))
+inner_result = inner_sum.doit()
+print("Inner result:", inner_result)
+
+# Check the bounds
+if isinstance(inner_result, Piecewise) and len(inner_result.args) == 2:
+    expr1, cond1 = inner_result.args[0]
+    expr2, cond2 = inner_result.args[1]
+    print("expr1:", expr1)
+    print("cond1:", cond1)
+    print("expr2:", expr2)
+    print("cond2:", cond2)
+    
+    if isinstance(cond1, And) and len(cond1.args) == 2:
+        print("cond1 args:", cond1.args)
+        for arg in cond1.args:
+            print("  arg:", arg)
+            print("  type:", type(arg))
+            print("  args:", arg.args)
+
+# Check what n-1 looks like
+print("n-1:", n-1)
+print("type(n-1):", type(n-1))
+print("n-1 == n-1:", n-1 == n-1)
\ No newline at end of file
diff --git a/debug_entry.py b/debug_entry.py
new file mode 100644
index 0000000000..4723a626a8
--- /dev/null
+++ b/debug_entry.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+
+# Create a proper identity matrix
+I_matrix = Identity(n)
+print("Identity(n):", I_matrix)
+
+# Test the _entry method directly
+print("I_matrix._entry(i, j):", I_matrix._entry(i, j))
+print("I_matrix._entry(0, 0):", I_matrix._entry(0, 0))
+print("I_matrix._entry(0, 1):", I_matrix._entry(0, 1))
+
+# Let's see what happens with equality comparison
+print("i == j:", i == j)
+print("i == i:", i == i)
+print("0 == 0:", 0 == 0)
+print("0 == 1:", 0 == 1)
+
+# Test KroneckerDelta
+from sympy.functions import KroneckerDelta
+print("KroneckerDelta(i, j):", KroneckerDelta(i, j))
+print("KroneckerDelta(0, 0):", KroneckerDelta(0, 0))
+print("KroneckerDelta(0, 1):", KroneckerDelta(0, 1))
\ No newline at end of file
diff --git a/debug_expand.py b/debug_expand.py
new file mode 100644
index 0000000000..353d38607d
--- /dev/null
+++ b/debug_expand.py
@@ -0,0 +1,32 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("Original e:", e)
+print("Type:", type(e))
+
+# Test expand
+expanded = e.expand()
+print("Expanded e:", expanded)
+print("Type after expand:", type(expanded))
+
+# Test doit on expanded
+doit_result = expanded.doit()
+print("Doit on expanded:", doit_result)
+print("Type after doit:", type(doit_result))
+
+# Let's see what the Sum looks like
+sum_expr = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1))
+print("Sum expression:", sum_expr)
+print("Sum expression type:", type(sum_expr))
+
+# Test expand on the sum
+sum_expanded = sum_expr.expand()
+print("Sum expanded:", sum_expanded)
+print("Type after sum expand:", type(sum_expanded))
\ No newline at end of file
diff --git a/debug_identity.py b/debug_identity.py
new file mode 100644
index 0000000000..62eaf00f0b
--- /dev/null
+++ b/debug_identity.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("Type of e:", type(e))
+print("e:", e)
+print("e.is_zero:", e.is_zero)
+print("e.free_symbols:", e.free_symbols)
+
+# Let's see what happens when we access individual elements
+print("e[0,0]:", e[0,0])
+print("type(e[0,0]):", type(e[0,0]))
+print("e[0,1]:", e[0,1])
+print("type(e[0,1]):", type(e[0,1]))
+
+# Test the summation manually
+print("Manual sum test:")
+for i_val in range(3):
+    for j_val in range(3):
+        print(f"e[{i_val},{j_val}]:", e[i_val, j_val])
\ No newline at end of file
diff --git a/debug_identity_indexing.py b/debug_identity_indexing.py
new file mode 100644
index 0000000000..4092c369f1
--- /dev/null
+++ b/debug_identity_indexing.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+
+# Create a proper identity matrix
+I_matrix = Identity(n)
+print("Identity(n):", I_matrix)
+print("type(Identity(n)):", type(I_matrix))
+print("Identity(n)[i, j]:", I_matrix[i, j])
+print("Identity(n)[0, 0]:", I_matrix[0, 0])
+print("Identity(n)[0, 1]:", I_matrix[0, 1])
+
+# Compare with our refined matrix
+M = MatrixSymbol('M', n, n)
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("Refined e:", e)
+print("e[i, j]:", e[i, j])
+
+# Check if they are the same
+print("Are they equal?", I_matrix == e)
+print("I_matrix.is_Identity:", I_matrix.is_Identity)
+print("e.is_Identity:", e.is_Identity)
\ No newline at end of file
diff --git a/debug_index_types.py b/debug_index_types.py
new file mode 100644
index 0000000000..3062951cc2
--- /dev/null
+++ b/debug_index_types.py
@@ -0,0 +1,22 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+
+# Create a proper identity matrix
+I_matrix = Identity(n)
+
+# Test different types of indices
+print("Type of 0:", type(0))
+print("Type of Integer(0):", type(Integer(0)))
+print("Type of i:", type(i))
+
+# Test is_Number property
+print("0 is Number?", hasattr(0, 'is_Number'))
+print("Integer(0).is_Number:", Integer(0).is_Number)
+print("i.is_Number:", i.is_Number)
+
+# Test sympify
+print("sympify(0):", sympify(0))
+print("sympify(0).is_Number:", sympify(0).is_Number)
\ No newline at end of file
diff --git a/debug_indexing.py b/debug_indexing.py
new file mode 100644
index 0000000000..b4046e67a3
--- /dev/null
+++ b/debug_indexing.py
@@ -0,0 +1,28 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("e:", e)
+print("e[i, j]:", e[i, j])
+print("type(e[i, j]):", type(e[i, j]))
+
+# Let's test with specific indices
+print("e[0, 0]:", e[0, 0])
+print("e[0, 1]:", e[0, 1])
+print("e[i, i]:", e[i, i])
+
+# Let's see what happens when we substitute values
+print("e[i, j].subs(i, 0).subs(j, 0):", e[i, j].subs(i, 0).subs(j, 0))
+print("e[i, j].subs(i, 0).subs(j, 1):", e[i, j].subs(i, 0).subs(j, 1))
+
+# Test KroneckerDelta behavior
+from sympy.functions import KroneckerDelta
+print("KroneckerDelta(i, j):", KroneckerDelta(i, j))
+print("KroneckerDelta(0, 0):", KroneckerDelta(0, 0))
+print("KroneckerDelta(0, 1):", KroneckerDelta(0, 1))
\ No newline at end of file
diff --git a/debug_matmul.py b/debug_matmul.py
new file mode 100644
index 0000000000..ecccebeda9
--- /dev/null
+++ b/debug_matmul.py
@@ -0,0 +1,24 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("e:", e)
+print("type(e):", type(e))
+print("dir(e):", [attr for attr in dir(e) if not attr.startswith('_')])
+
+# Check if it's an identity matrix
+print("e.is_Identity:", hasattr(e, 'is_Identity') and e.is_Identity)
+
+# Let's see what happens when we try to sum matrix elements directly
+try:
+    sum_result = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1))
+    print("Sum expression:", sum_result)
+    print("Sum doit result:", sum_result.doit())
+except Exception as ex:
+    print("Error in sum:", ex)
\ No newline at end of file
diff --git a/debug_outer_sum.py b/debug_outer_sum.py
new file mode 100644
index 0000000000..21ac76e3d1
--- /dev/null
+++ b/debug_outer_sum.py
@@ -0,0 +1,28 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Get the inner sum result
+inner_sum = Sum(e[i, j], (i, 0, n-1))
+inner_result = inner_sum.doit()
+print("Inner result:", inner_result)
+
+# Now try to sum the inner result over j
+outer_sum = Sum(inner_result, (j, 0, n-1))
+print("Outer sum:", outer_sum)
+print("Outer sum doit:", outer_sum.doit())
+
+# Let's see what happens if we substitute a specific value for n
+n_val = 3
+inner_result_sub = inner_result.subs(n, n_val)
+print(f"Inner result with n={n_val}:", inner_result_sub)
+
+outer_sum_sub = Sum(inner_result_sub, (j, 0, n_val-1))
+print(f"Outer sum with n={n_val}:", outer_sum_sub)
+print(f"Outer sum doit with n={n_val}:", outer_sum_sub.doit())
\ No newline at end of file
diff --git a/debug_piecewise.py b/debug_piecewise.py
new file mode 100644
index 0000000000..1d9efe0809
--- /dev/null
+++ b/debug_piecewise.py
@@ -0,0 +1,32 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Get the inner sum result
+inner_sum = Sum(e[i, j], (i, 0, n-1))
+inner_result = inner_sum.doit()
+print("Inner result:", inner_result)
+print("Type:", type(inner_result))
+
+# Check the Piecewise structure
+if isinstance(inner_result, Piecewise):
+    print("Piecewise args:")
+    for arg in inner_result.args:
+        print("  Expression:", arg.expr)
+        print("  Condition:", arg.cond)
+        print("  Condition free symbols:", arg.cond.free_symbols)
+        print("  j in condition free symbols:", j in arg.cond.free_symbols)
+
+# Check if the condition depends on the summation variable
+if isinstance(inner_result, Piecewise):
+    for arg in inner_result.args:
+        if j in arg.cond.free_symbols:
+            print(f"Condition {arg.cond} depends on j")
+        else:
+            print(f"Condition {arg.cond} does not depend on j")
\ No newline at end of file
diff --git a/debug_test_failure.py b/debug_test_failure.py
new file mode 100644
index 0000000000..26a89909e4
--- /dev/null
+++ b/debug_test_failure.py
@@ -0,0 +1,29 @@
+from sympy import *
+from sympy.concrete.summations import eval_sum
+
+# Reproduce the failing test case
+nmax = symbols('N', integer=True, positive=True)
+n = symbols('n', integer=True)
+pw = Piecewise((1, And(S(1) <= n, n <= nmax)), (0, True))
+
+print("pw:", pw)
+print("Sum(pw, (n, 1, nmax)):", Sum(pw, (n, 1, nmax)))
+print("Sum(pw, (n, 1, nmax)).doit():", Sum(pw, (n, 1, nmax)).doit())
+
+# Check if our special case should apply
+print("\nChecking special case conditions:")
+print("len(pw.args) == 2:", len(pw.args) == 2)
+if len(pw.args) == 2:
+    expr1, cond1 = pw.args[0]
+    expr2, cond2 = pw.args[1]
+    print("expr1 == 1:", expr1 == 1)
+    print("expr2 == 0:", expr2 == 0)
+    print("cond2 == True:", cond2 == True)
+    print("isinstance(cond1, And):", isinstance(cond1, And))
+    if isinstance(cond1, And):
+        print("len(cond1.args) == 2:", len(cond1.args) == 2)
+
+# Test eval_sum directly
+print("\nTesting eval_sum directly:")
+result = eval_sum(pw, (n, 1, nmax))
+print("eval_sum result:", result)
\ No newline at end of file
diff --git a/debug_valid_index.py b/debug_valid_index.py
new file mode 100644
index 0000000000..d075ae06f2
--- /dev/null
+++ b/debug_valid_index.py
@@ -0,0 +1,32 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+
+# Create a proper identity matrix
+I_matrix = Identity(n)
+print("Identity(n):", I_matrix)
+print("valid_index(i, j):", I_matrix.valid_index(i, j))
+print("valid_index(0, 0):", I_matrix.valid_index(0, 0))
+print("valid_index(0, 1):", I_matrix.valid_index(0, 1))
+
+# Test what happens when valid_index returns False
+try:
+    result = I_matrix[i, j]
+    print("I_matrix[i, j]:", result)
+except Exception as e:
+    print("Error accessing I_matrix[i, j]:", e)
+
+# Test with concrete indices
+print("I_matrix[0, 0]:", I_matrix[0, 0])
+print("I_matrix[0, 1]:", I_matrix[0, 1])
+
+# Let's see what the refine function returns
+M = MatrixSymbol('M', n, n)
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+print("Refined e:", e)
+print("type(e):", type(e))
+print("e.valid_index(i, j):", e.valid_index(i, j))
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b24c69bf85
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+e = None
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Correct: M.T * M is an identity matrix.
+print("Matrix e:", e)
+print("Elements:", e[0, 0], e[0, 1], e[1, 0], e[1, 1])
+
+# Correct: The output is True True
+print("Is diagonal:", ask(Query.diagonal(e)))
+print("Has integer elements:", ask(Query.integer_elements(e)))
+
+# Correct: The sum of the diagonal elements is n
+print("Sum of diagonal:", Sum(e[i, i], (i, 0, n-1)).doit())
+
+# So far so good
+# Total sum of the elements is expected to be 'n' but the answer is 0!
+print("Total sum of elements:", Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
\ No newline at end of file
diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py
index 372487664c..196f4e961b 100644
--- a/sympy/concrete/summations.py
+++ b/sympy/concrete/summations.py
@@ -3,7 +3,7 @@
 from sympy.concrete.expr_with_limits import AddWithLimits
 from sympy.concrete.expr_with_intlimits import ExprWithIntLimits
 from sympy.core.function import Derivative
-from sympy.core.relational import Eq
+from sympy.core.relational import Eq, Le, Lt
 from sympy.core.singleton import S
 from sympy.core.symbol import Dummy, Wild, Symbol
 from sympy.core.add import Add
@@ -866,6 +866,29 @@ def eval_sum(f, limits):
                     return None
                 newargs.append((newexpr, arg.cond))
             return f.func(*newargs)
+        else:
+            # Special case for Piecewise expressions that represent range indicators
+            # like Piecewise((1, (a <= i) & (i <= b)), (0, True))
+            # The sum over i from a to b should be (b - a + 1)
+            if len(f.args) == 2:
+                expr1, cond1 = f.args[0]
+                expr2, cond2 = f.args[1]
+                if (expr1 == 1 and expr2 == 0 and cond2 == True and 
+                    isinstance(cond1, And) and len(cond1.args) == 2):
+                    # Check if the Piecewise represents a range indicator that matches
+                    # the summation bounds. This handles cases like KroneckerDelta sums.
+                    lower_constraint, upper_constraint = None, None
+                    for arg in cond1.args:
+                        if isinstance(arg, (Le, Lt)):
+                            # Check for a <= i constraint
+                            if arg.args[0] == a and arg.args[1] == i:
+                                lower_constraint = True
+                            # Check for i <= b constraint  
+                            elif arg.args[0] == i and arg.args[1] == b:
+                                upper_constraint = True
+                    if lower_constraint is not None and upper_constraint is not None:
+                        # The constraints match the summation limits
+                        return b - a + 1
 
     if f.has(KroneckerDelta) and _has_simple_delta(f, limits[0]):
         return deltasummation(f, limits)
diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py
index b4d759836e..580fb73b5e 100644
--- a/sympy/matrices/expressions/matexpr.py
+++ b/sympy/matrices/expressions/matexpr.py
@@ -476,10 +476,19 @@ def conjugate(self):
         return self
 
     def _entry(self, i, j):
-        if i == j:
-            return S.One
+        from sympy.functions import KroneckerDelta
+        from sympy.core.sympify import sympify
+        
+        # Ensure i and j are SymPy objects
+        i, j = sympify(i), sympify(j)
+        
+        if i.is_Number and j.is_Number:
+            if i == j:
+                return S.One
+            else:
+                return S.Zero
         else:
-            return S.Zero
+            return KroneckerDelta(i, j)
 
     def _eval_determinant(self):
         return S.One
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..7f72d7919c
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,30 @@
+from sympy import *
+from sympy import Q as Query
+
+# Test 1: Regular identity matrix
+print("=== Test 1: Regular identity matrix ===")
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+I_matrix = Identity(n)
+print("Identity matrix sum:", Sum(Sum(I_matrix[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
+
+# Test 2: Different summation bounds
+print("\n=== Test 2: Different summation bounds ===")
+print("Sum from 1 to n-1:", Sum(Sum(I_matrix[i, j], (i, 1, n-1)), (j, 1, n-1)).doit())
+
+# Test 3: Concrete values
+print("\n=== Test 3: Concrete values ===")
+I3 = Identity(3)
+print("3x3 identity sum:", Sum(Sum(I3[i, j], (i, 0, 2)), (j, 0, 2)).doit())
+
+# Test 4: Non-identity matrix (should not use our special case)
+print("\n=== Test 4: Non-identity matrix ===")
+M = MatrixSymbol('M', n, n)
+print("Non-identity sum:", Sum(Sum(M[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
+
+# Test 5: Original issue reproduction
+print("\n=== Test 5: Original issue reproduction ===")
+M = MatrixSymbol('M', n, n)
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+print("Refined orthogonal matrix sum:", Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
\ No newline at end of file
diff --git a/test_kronecker_sum.py b/test_kronecker_sum.py
new file mode 100644
index 0000000000..05e7dee2db
--- /dev/null
+++ b/test_kronecker_sum.py
@@ -0,0 +1,25 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+
+# Test KroneckerDelta summation
+print("=== KroneckerDelta summation ===")
+kd_sum = Sum(KroneckerDelta(i, j), (i, 0, n-1))
+print("KroneckerDelta sum:", kd_sum)
+print("KroneckerDelta sum doit:", kd_sum.doit())
+
+# Test identity matrix
+print("\n=== Identity matrix summation ===")
+I_matrix = Identity(n)
+print("Identity matrix sum:", Sum(Sum(I_matrix[i, j], (i, 0, n-1)), (j, 0, n-1)))
+print("Identity matrix sum doit:", Sum(Sum(I_matrix[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
+
+# Test refined orthogonal matrix
+print("\n=== Refined orthogonal matrix summation ===")
+M = MatrixSymbol('M', n, n)
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+print("Refined matrix sum:", Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)))
+print("Refined matrix sum doit:", Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
\ No newline at end of file
diff --git a/test_simplify.py b/test_simplify.py
new file mode 100644
index 0000000000..c2977cbc8a
--- /dev/null
+++ b/test_simplify.py
@@ -0,0 +1,24 @@
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+with assuming(Query.orthogonal(M)):
+    e = refine((M.T * M).doit())
+
+# Total sum of elements
+sum_expr = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1))
+result = sum_expr.doit()
+print("Raw result:", result)
+
+# Try to simplify it
+simplified = simplify(result)
+print("Simplified:", simplified)
+
+# Let's see what the inner sum looks like
+inner_sum = Sum(e[i, j], (i, 0, n-1))
+inner_result = inner_sum.doit()
+print("Inner sum:", inner_result)
+print("Inner sum simplified:", simplify(inner_result))
\ No newline at end of file