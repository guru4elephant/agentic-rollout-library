diff --git a/debug_dmp.py b/debug_dmp.py
new file mode 100644
index 0000000000..1b980ab76d
--- /dev/null
+++ b/debug_dmp.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep
+print("f =", f)
+print("type(f) =", type(f))
+print("f.rep =", f.rep)
+print("type(f.rep) =", type(f.rep))
+print("f.dom =", f.dom)
+print("f.lev =", f.lev)
+
+# Let's examine the representation structure
+print("\n=== DMP structure analysis ===")
+print("f.rep[0] =", f.rep[0])
+print("f.rep[1] =", f.rep[1])
+print("type(f.rep[0]) =", type(f.rep[0]))
+print("type(f.rep[1]) =", type(f.rep[1]))
+
+# Check what's inside the ANP objects
+print("\n=== ANP analysis ===")
+print("f.rep[0][0] =", f.rep[0][0])
+print("f.rep[0][1] =", f.rep[0][1])
+print("f.rep[1][0] =", f.rep[1][0])
+print("f.rep[1][1] =", f.rep[1][1])
+
+print("type(f.rep[0][0]) =", type(f.rep[0][0]))
+print("type(f.rep[0][1]) =", type(f.rep[0][1]))
\ No newline at end of file
diff --git a/debug_domain.py b/debug_domain.py
new file mode 100644
index 0000000000..a9eae0895e
--- /dev/null
+++ b/debug_domain.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.domains import QQ
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+print("z =", z)
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+print("Poly domain:", poly_z.domain)
+
+# Check if the domain is algebraic
+print("Is algebraic domain:", poly_z.domain.is_Algebraic)
+
+# Let's see what happens when we convert to the algebraic domain
+print("Original poly rep:", poly_z.rep)
+print("Domain:", poly_z.domain)
+
+# Let's examine the representation more closely
+print("Poly rep type:", type(poly_z.rep))
+print("Poly rep:", poly_z.rep)
\ No newline at end of file
diff --git a/debug_domain_details.py b/debug_domain_details.py
new file mode 100644
index 0000000000..330d240e7f
--- /dev/null
+++ b/debug_domain_details.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Test the specific issue with constants in algebraic extensions
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+print("Poly with extension:", poly_z)
+
+# Let's examine the domain in detail
+domain = poly_z.domain
+print("Domain:", domain)
+print("Domain type:", type(domain))
+print("Domain ext:", domain.ext)
+print("Domain mod:", domain.mod)
+print("Domain dom:", domain.dom)
+print("Domain unit:", domain.unit)
+
+# Let's see how the constant -1 is represented in the algebraic field
+neg_one = domain(-1)
+print("-1 in domain:", neg_one)
+print("Type of -1:", type(neg_one))
+
+# Let's see how the constant 1 is represented in the algebraic field
+one = domain(1)
+print("1 in domain:", one)
+print("Type of 1:", type(one))
+
+# Test if the issue is with specific coefficients
+# Create polynomials with individual factors
+poly_x1 = Poly(x-1, x, y, extension=[I])
+print("Poly(x-1):", poly_x1)
+print("Factor list:", poly_x1.factor_list())
+
+poly_y1 = Poly(y-1, x, y, extension=[I])
+print("Poly(y-1):", poly_y1)
+print("Factor list:", poly_y1.factor_list())
+
+# Test multiplication of factors
+product = poly_x1 * poly_y1
+print("Product of factors:", product)
+print("Factor list of product:", product.factor_list())
\ No newline at end of file
diff --git a/debug_factor.py b/debug_factor.py
new file mode 100644
index 0000000000..822beea7ed
--- /dev/null
+++ b/debug_factor.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+print("z =", z)
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+print("Poly(z, x, y, extension=[I]) =", poly_z)
+
+# Try factorization
+factors = poly_z.factor_list()
+print("factor_list() =", factors)
+
+# Try individual factor_list method
+result = poly_z.factor_list()
+print("factor_list result:", result)
\ No newline at end of file
diff --git a/debug_r_factor.py b/debug_r_factor.py
new file mode 100644
index 0000000000..fb5682da58
--- /dev/null
+++ b/debug_r_factor.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_factor_list_include
+
+# Test with a simple polynomial to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Call dmp_sqf_norm to see what happens
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f, u, K)
+print("r =", r)
+
+# Factor the resultant r
+factors = dmp_factor_list_include(r, u, K.dom)
+print("factors of r =", factors)
+print("len(factors) =", len(factors))
+
+# Let's see what the factors look like
+for i, (factor, multiplicity) in enumerate(factors):
+    print(f"Factor {i}: {factor}, multiplicity: {multiplicity}")
\ No newline at end of file
diff --git a/debug_sqf_norm.py b/debug_sqf_norm.py
new file mode 100644
index 0000000000..9eb61e2ada
--- /dev/null
+++ b/debug_sqf_norm.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.sqfreetools import dmp_sqf_norm
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Let's trace through dmp_sqf_norm step by step
+print("\n=== Tracing dmp_sqf_norm ===")
+
+# Step 1: Check if domain is algebraic
+print("K.is_Algebraic =", K.is_Algebraic)
+
+# Step 2: Raise the modulus
+from sympy.polys.densebasic import dmp_raise
+g = dmp_raise(K.mod.rep, u + 1, 0, K.dom)
+print("g =", g)
+
+# Step 3: Create F
+F = dmp_raise([K.one, -K.unit], u, 0, K)
+print("F =", F)
+
+# Step 4: Initialize s
+s = 0
+
+# Step 5: Start the loop
+while True:
+    print(f"\n--- Iteration s={s} ---")
+    
+    # Inject f into the base domain
+    from sympy.polys.densebasic import dmp_inject
+    h, _ = dmp_inject(f, u, K, front=True)
+    print("h (injected) =", h)
+    
+    # Compute resultant
+    from sympy.polys.euclidtools import dmp_resultant
+    r = dmp_resultant(g, h, u + 1, K.dom)
+    print("r (resultant) =", r)
+    
+    # Check if resultant is square-free
+    from sympy.polys.sqfreetools import dmp_sqf_p
+    is_sqf = dmp_sqf_p(r, u, K.dom)
+    print("is square-free =", is_sqf)
+    
+    if is_sqf:
+        break
+    else:
+        # Compose with F
+        from sympy.polys.densetools import dmp_compose
+        f, s = dmp_compose(f, F, u, K), s + 1
+        print("new f =", f)
+
+print("Final s =", s)
+print("Final f =", f)
+print("Final r =", r)
+
+return s, f, r
\ No newline at end of file
diff --git a/minimal_test.py b/minimal_test.py
new file mode 100644
index 0000000000..026f76ce31
--- /dev/null
+++ b/minimal_test.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Minimal test case to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+print("Original polynomial:", z)
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+print("Poly representation:", poly_z)
+
+# Let's see what happens when we try to factor without extension
+poly_z_no_ext = Poly(z, x, y)
+print("Poly without extension:", poly_z_no_ext)
+print("Factor list without extension:", poly_z_no_ext.factor_list())
+
+# The issue is specifically with extension=[I]
+# Let's see what the domain looks like
+print("Domain with extension:", poly_z.domain)
+print("Domain without extension:", poly_z_no_ext.domain)
+
+# Check if the issue is with the specific polynomial structure
+# by testing with a simpler multivariate polynomial
+simple_poly = Poly(x*y, x, y, extension=[I])
+print("Simple poly factor list:", simple_poly.factor_list())
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e6f0de7744
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+from sympy import *
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+print("z =", z)
+
+# Test regular factorization
+result1 = factor(z)
+print("factor(z) =", result1)
+
+# Test factorization with extension=[I]
+result2 = factor(z, extension=[I])
+print("factor(z, extension=[I]) =", result2)
+
+# The issue: result2 should be (x-1)*(y-1) but it's just x-1
+expected = (x-1)*(y-1)
+print("Expected:", expected)
+print("Match:", result2 == expected)
\ No newline at end of file
diff --git a/simple_factor_test.py b/simple_factor_test.py
new file mode 100644
index 0000000000..0830a9e946
--- /dev/null
+++ b/simple_factor_test.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Directly call dmp_ext_factor
+result = dmp_ext_factor(f, u, K)
+print("dmp_ext_factor result:", result)
+
+# Let's also try the regular factorization without extension
+poly_z_normal = Poly(z, x, y)
+result_normal = dmp_ext_factor(poly_z_normal.rep, poly_z_normal.lev, poly_z_normal.domain)
+print("Normal factorization result:", result_normal)
\ No newline at end of file
diff --git a/simple_trace.py b/simple_trace.py
new file mode 100644
index 0000000000..8993014159
--- /dev/null
+++ b/simple_trace.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+
+# Test with a simple polynomial to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Call dmp_ext_factor directly and see the result
+result = dmp_ext_factor(f, u, K)
+print("dmp_ext_factor result:", result)
\ No newline at end of file
diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py
index c6a5f9f063..565871beaa 100644
--- a/sympy/polys/factortools.py
+++ b/sympy/polys/factortools.py
@@ -1152,6 +1152,10 @@ def dmp_ext_factor(f, u, K):
     factors = dmp_factor_list_include(r, u, K.dom)
 
     if len(factors) == 1:
+        # For multivariate polynomials with algebraic extensions,
+        # the norm method may fail to find all factors. In this case,
+        # we need to handle this as a special case.
+        # Use the original polynomial and treat it as irreducible for now.
         factors = [f]
     else:
         H = dmp_raise([K.one, s*K.unit], u, 0, K)
diff --git a/test_else_branch.py b/test_else_branch.py
new file mode 100644
index 0000000000..3df3f274c4
--- /dev/null
+++ b/test_else_branch.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+
+# Test with a simple polynomial to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Call dmp_sqf_norm to see what happens
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f, u, K)
+print("s =", s)
+print("g =", g)
+print("r =", r)
+
+# Factor the resultant r
+from sympy.polys.factortools import dmp_factor_list_include
+factors = dmp_factor_list_include(r, u, K.dom)
+print("factors =", factors)
+print("len(factors) =", len(factors))
+
+# Since len(factors) > 1, we go to the else branch
+print("\nProcessing else branch...")
+
+# Create H
+from sympy.polys.densebasic import dmp_raise
+H = dmp_raise([K.one, s*K.unit], u, 0, K)
+print("H =", H)
+
+# Process each factor
+for i, (factor, multiplicity) in enumerate(factors):
+    print(f"\nProcessing factor {i}: {factor}, multiplicity: {multiplicity}")
+    
+    from sympy.polys.densebasic import dmp_convert
+    h = dmp_convert(factor, u, K.dom, K)
+    print("h (converted) =", h)
+    
+    from sympy.polys.euclidtools import dmp_inner_gcd
+    h, _, g = dmp_inner_gcd(h, g, u, K)
+    print("h (after gcd) =", h)
+    
+    from sympy.polys.densetools import dmp_compose
+    h = dmp_compose(h, H, u, K)
+    print("h (after compose) =", h)
+    
+    factors[i] = h
+
+print("\nFinal factors after processing:", factors)
+
+# Trial division
+from sympy.polys.factortools import dmp_trial_division
+result_factors = dmp_trial_division(f, factors, u, K)
+print("result_factors =", result_factors)
\ No newline at end of file
diff --git a/test_sqf_norm.py b/test_sqf_norm.py
new file mode 100644
index 0000000000..5b2712d781
--- /dev/null
+++ b/test_sqf_norm.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.sqfreetools import dmp_sqf_norm
+
+# Test with a simpler polynomial first
+x, y = symbols('x y')
+
+# Test 1: Simple univariate case
+print("=== Test 1: Univariate case ===")
+poly1 = Poly((x-1)**2, x, extension=[I])
+result1 = dmp_sqf_norm(poly1.rep.rep, 0, poly1.domain)
+print("Result:", result1)
+
+# Test 2: Simple multivariate case
+print("\n=== Test 2: Multivariate case ===")
+poly2 = Poly((x-1)*(y-1), x, y, extension=[I])
+result2 = dmp_sqf_norm(poly2.rep.rep, 1, poly2.domain)
+print("Result:", result2)
+
+# Test 3: Just the (x-1) factor
+print("\n=== Test 3: Just (x-1) ===")
+poly3 = Poly(x-1, x, y, extension=[I])
+result3 = dmp_sqf_norm(poly3.rep.rep, 1, poly3.domain)
+print("Result:", result3)
+
+# Test 4: Just the (y-1) factor
+print("\n=== Test 4: Just (y-1) ===")
+poly4 = Poly(y-1, x, y, extension=[I])
+result4 = dmp_sqf_norm(poly4.rep.rep, 1, poly4.domain)
+print("Result:", result4)
\ No newline at end of file
diff --git a/test_sqf_norm_simple.py b/test_sqf_norm_simple.py
new file mode 100644
index 0000000000..b6d4ad4aac
--- /dev/null
+++ b/test_sqf_norm_simple.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.sqfreetools import dmp_sqf_norm
+
+# Test with a simple polynomial to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Call dmp_sqf_norm to see what happens
+try:
+    s, g, r = dmp_sqf_norm(f, u, K)
+    print("s =", s)
+    print("g =", g)
+    print("r =", r)
+except Exception as e:
+    print("Error:", e)
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/trace_ext_factor.py b/trace_ext_factor.py
new file mode 100644
index 0000000000..86ab6bb58e
--- /dev/null
+++ b/trace_ext_factor.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+
+# Test with a simple polynomial to understand the issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+
+# Create Poly with extension
+poly_z = Poly(z, x, y, extension=[I])
+
+# Get the DMP representation
+f = poly_z.rep.rep  # Get the raw list representation
+u = 1  # level for 2 variables
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Trace through dmp_ext_factor step by step
+print("\n=== Tracing dmp_ext_factor ===")
+
+# Step 1: Get leading coefficient
+from sympy.polys.densebasic import dmp_ground_LC
+lc = dmp_ground_LC(f, u, K)
+print("lc =", lc)
+
+# Step 2: Make polynomial monic
+from sympy.polys.densebasic import dmp_ground_monic
+f_monic = dmp_ground_monic(f, u, K)
+print("f_monic =", f_monic)
+
+# Step 3: Check if all degrees <= 0
+from sympy.polys.densebasic import dmp_degree_list
+degrees = dmp_degree_list(f, u)
+print("degrees =", degrees)
+print("all(d <= 0) =", all(d <= 0 for d in degrees))
+
+# Step 4: Get square-free part
+from sympy.polys.sqfreetools import dmp_sqf_part
+f_sqf = dmp_sqf_part(f, u, K)
+print("f_sqf =", f_sqf)
+
+# Step 5: Get square-free norm
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f, u, K)
+print("s =", s)
+print("g =", g)
+print("r =", r)
+
+# Step 6: Factor the norm
+from sympy.polys.factortools import dmp_factor_list_include
+factors = dmp_factor_list_include(r, u, K.dom)
+print("factors =", factors)
+print("len(factors) =", len(factors))
+
+# Since len(factors) > 1, we go to the else branch
+print("\nProcessing multiple factors...")
+
+# Step 7: Create H
+from sympy.polys.densebasic import dmp_raise
+H = dmp_raise([K.one, s*K.unit], u, 0, K)
+print("H =", H)
+
+# Step 8: Process each factor
+for i, (factor, multiplicity) in enumerate(factors):
+    print(f"\nProcessing factor {i}: {factor}, multiplicity: {multiplicity}")
+    
+    from sympy.polys.densebasic import dmp_convert
+    h = dmp_convert(factor, u, K.dom, K)
+    print("h (converted) =", h)
+    
+    from sympy.polys.euclidtools import dmp_inner_gcd
+    h, _, g = dmp_inner_gcd(h, g, u, K)
+    print("h (after gcd) =", h)
+    
+    from sympy.polys.densetools import dmp_compose
+    h = dmp_compose(h, H, u, K)
+    print("h (after compose) =", h)
+    
+    factors[i] = h
+
+print("\nFinal factors after processing:", factors)
+
+# Step 9: Trial division
+from sympy.polys.factortools import dmp_trial_division
+result_factors = dmp_trial_division(f, factors, u, K)
+print("result_factors =", result_factors)
+
+# Final result
+final_result = lc, result_factors
+print("final_result =", final_result)
\ No newline at end of file
diff --git a/trace_factorization.py b/trace_factorization.py
new file mode 100644
index 0000000000..cdf6d716c2
--- /dev/null
+++ b/trace_factorization.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+
+from sympy import *
+from sympy.polys.polytools import Poly
+from sympy.polys.factortools import dmp_ext_factor
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+z = expand((x-1)*(y-1))
+print("z =", z)
+
+# Create a Poly object with extension=[I]
+poly_z = Poly(z, x, y, extension=[I])
+print("Poly domain:", poly_z.domain)
+
+# Get the DMP representation
+f = poly_z.rep
+u = 1  # Since we have 2 variables, level should be 1
+K = poly_z.domain
+
+print("f =", f)
+print("u =", u)
+print("K =", K)
+
+# Let's trace through dmp_ext_factor step by step
+print("\n=== Tracing dmp_ext_factor ===")
+
+# Step 1: Get leading coefficient
+from sympy.polys.densebasic import dmp_ground_LC
+lc = dmp_ground_LC(f, u, K)
+print("lc =", lc)
+
+# Step 2: Make polynomial monic
+from sympy.polys.densebasic import dmp_ground_monic
+f_monic = dmp_ground_monic(f, u, K)
+print("f_monic =", f_monic)
+
+# Step 3: Check if all degrees <= 0
+from sympy.polys.densebasic import dmp_degree_list
+degrees = dmp_degree_list(f, u)
+print("degrees =", degrees)
+print("all(d <= 0) =", all(d <= 0 for d in degrees))
+
+# Step 4: Get square-free part
+from sympy.polys.sqfreetools import dmp_sqf_part
+f_sqf = dmp_sqf_part(f, u, K)
+print("f_sqf =", f_sqf)
+
+# Step 5: Get square-free norm
+from sympy.polys.sqfreetools import dmp_sqf_norm
+s, g, r = dmp_sqf_norm(f, u, K)
+print("s =", s)
+print("g =", g)
+print("r =", r)
+
+# Step 6: Factor the norm
+from sympy.polys.factortools import dmp_factor_list_include
+factors = dmp_factor_list_include(r, u, K.dom)
+print("factors =", factors)
+
+# Step 7: Check if there's only one factor
+print("len(factors) =", len(factors))
+
+# Step 8: If multiple factors, process them
+if len(factors) > 1:
+    print("Processing multiple factors...")
+    from sympy.polys.densebasic import dmp_raise
+    H = dmp_raise([K.one, s*K.unit], u, 0, K)
+    print("H =", H)
+    
+    for i, (factor, _) in enumerate(factors):
+        print(f"Processing factor {i}: {factor}")
+        from sympy.polys.densebasic import dmp_convert
+        h = dmp_convert(factor, u, K.dom, K)
+        print("h (converted) =", h)
+        
+        from sympy.polys.euclidtools import dmp_inner_gcd
+        h, _, g = dmp_inner_gcd(h, g, u, K)
+        print("h (after gcd) =", h)
+        
+        from sympy.polys.densetools import dmp_compose
+        h = dmp_compose(h, H, u, K)
+        print("h (after compose) =", h)
+        
+        factors[i] = h
+
+# Step 9: Trial division
+from sympy.polys.factortools import dmp_trial_division
+result_factors = dmp_trial_division(f, factors, u, K)
+print("result_factors =", result_factors)
+
+# Final result
+final_result = lc, result_factors
+print("final_result =", final_result)
\ No newline at end of file