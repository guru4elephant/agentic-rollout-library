diff --git a/bug_demo.png b/bug_demo.png
new file mode 100644
index 0000000000..c608e7a1eb
Binary files /dev/null and b/bug_demo.png differ
diff --git a/comprehensive_test.png b/comprehensive_test.png
new file mode 100644
index 0000000000..c608e7a1eb
Binary files /dev/null and b/comprehensive_test.png differ
diff --git a/edge_cases_test.png b/edge_cases_test.png
new file mode 100644
index 0000000000..36a27a4421
Binary files /dev/null and b/edge_cases_test.png differ
diff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py
index d4922fc517..e15838a91e 100644
--- a/lib/matplotlib/text.py
+++ b/lib/matplotlib/text.py
@@ -1456,7 +1456,11 @@ class _AnnotationBase:
                  xycoords='data',
                  annotation_clip=None):
 
-        self.xy = xy
+        # Make a copy of xy if it's a numpy array to prevent reference issues
+        if hasattr(xy, 'copy'):
+            self.xy = xy.copy()
+        else:
+            self.xy = xy
         self.xycoords = xycoords
         self.set_annotation_clip(annotation_clip)
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bf0357f43d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,32 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+# this annotation is messed by later changing the array passed as xy kwarg
+ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3  # <-- this updates the arrow position
+
+xy_0 = np.array((1, 1))
+xy_f = np.array((4, 1))
+# using a copy of the array helps spoting where the problem is
+ax.annotate('', xy=xy_0.copy(), xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3
+
+plt.savefig('bug_demo.png')
+print("Figure saved as bug_demo.png")
+
+# Let's also check the actual data stored in the annotations
+annotations = ax.texts
+for i, ann in enumerate(annotations):
+    print(f"Annotation {i}: xy={ann.xy}")
+    # Check if the annotation has xytext attribute
+    if hasattr(ann, 'xytext'):
+        print(f"  xytext={ann.xytext}")
+    else:
+        print(f"  No xytext attribute found")
\ No newline at end of file
diff --git a/test_annotation_array_reference.py b/test_annotation_array_reference.py
new file mode 100644
index 0000000000..5a31747a44
--- /dev/null
+++ b/test_annotation_array_reference.py
@@ -0,0 +1,68 @@
+"""
+Test for the annotation array reference issue fix.
+This test ensures that modifying the original numpy array used as xy parameter
+does not affect the annotation position.
+"""
+import matplotlib.pyplot as plt
+import numpy as np
+
+
+def test_annotation_array_reference():
+    """Test that annotation xy parameter copies numpy arrays instead of keeping references."""
+    fig = plt.figure()
+    ax = fig.add_subplot(111)
+    
+    # Create numpy arrays for annotation
+    xy_0 = np.array([-4, 1])
+    xy_f = np.array([-1, 1])
+    
+    # Create annotation with numpy arrays
+    ann = ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+    
+    # Modify the original arrays
+    xy_0[1] = 3
+    xy_f[1] = 3
+    
+    # Check that the annotation positions are unchanged
+    assert np.array_equal(ann.xy, np.array([-4, 1])), \
+        f"Annotation xy position changed from [-4, 1] to {ann.xy}"
+    
+    # Check text position (should also be unchanged)
+    text_pos = ann.get_position()
+    assert np.array_equal(text_pos, np.array([-1, 1])), \
+        f"Annotation text position changed from [-1, 1] to {text_pos}"
+    
+    plt.close(fig)
+    print("Test passed: Annotation positions are not affected by original array modifications")
+
+
+def test_annotation_xytext_none():
+    """Test that xytext=None correctly uses copied xy values."""
+    fig = plt.figure()
+    ax = fig.add_subplot(111)
+    
+    # Create numpy array for annotation
+    xy_0 = np.array([-4, 1])
+    
+    # Create annotation with xytext=None
+    ann = ax.annotate('Test', xy=xy_0, xytext=None, arrowprops=dict(arrowstyle='<->'))
+    
+    # Modify the original array
+    xy_0[1] = 3
+    
+    # Check that both xy and text positions are unchanged
+    assert np.array_equal(ann.xy, np.array([-4, 1])), \
+        f"Annotation xy position changed from [-4, 1] to {ann.xy}"
+    
+    text_pos = ann.get_position()
+    assert np.array_equal(text_pos, np.array([-4, 1])), \
+        f"Annotation text position changed from [-4, 1] to {text_pos}"
+    
+    plt.close(fig)
+    print("Test passed: xytext=None correctly uses copied xy values")
+
+
+if __name__ == "__main__":
+    test_annotation_array_reference()
+    test_annotation_xytext_none()
+    print("All tests passed!")
\ No newline at end of file
diff --git a/test_copy_method_edge_cases.py b/test_copy_method_edge_cases.py
new file mode 100644
index 0000000000..d023e22ab6
--- /dev/null
+++ b/test_copy_method_edge_cases.py
@@ -0,0 +1,68 @@
+"""
+Test edge cases for the copy method detection in annotation fix.
+"""
+import matplotlib.pyplot as plt
+import numpy as np
+
+
+def test_numpy_array_copy_behavior():
+    """Test that numpy arrays are properly copied."""
+    fig = plt.figure()
+    ax = fig.add_subplot(111)
+    
+    # Create numpy array
+    xy_numpy = np.array([1, 2])
+    
+    # Create annotation
+    ann = ax.annotate('Test', xy=xy_numpy)
+    
+    # Modify original array
+    xy_numpy[0] = 999
+    
+    # Annotation should not be affected
+    assert np.array_equal(ann.xy, np.array([1, 2])), \
+        f"Annotation xy position changed from [1, 2] to {ann.xy}"
+    
+    plt.close(fig)
+    print("Test passed: Numpy array copy behavior works correctly")
+
+
+def test_regular_tuple():
+    """Test that regular tuples work correctly (no copy method)."""
+    fig = plt.figure()
+    ax = fig.add_subplot(111)
+    
+    # Regular tuple
+    xy_tuple = (1, 2)
+    
+    ann = ax.annotate('Test', xy=xy_tuple)
+    
+    # Should store the tuple directly
+    assert ann.xy == xy_tuple, f"Expected {xy_tuple}, got {ann.xy}"
+    
+    plt.close(fig)
+    print("Test passed: Regular tuple handled correctly")
+
+
+def test_regular_list():
+    """Test that regular lists work correctly (no copy method)."""
+    fig = plt.figure()
+    ax = fig.add_subplot(111)
+    
+    # Regular list
+    xy_list = [1, 2]
+    
+    ann = ax.annotate('Test', xy=xy_list)
+    
+    # Should store the list directly
+    assert ann.xy == xy_list, f"Expected {xy_list}, got {ann.xy}"
+    
+    plt.close(fig)
+    print("Test passed: Regular list handled correctly")
+
+
+if __name__ == "__main__":
+    test_numpy_array_copy_behavior()
+    test_regular_tuple()
+    test_regular_list()
+    print("All edge case tests passed!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..8e2842e0dc
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,39 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+# Test 1: Regular tuple instead of numpy array
+xy_tuple = (-4, 1)
+ax.annotate('Tuple test', xy=xy_tuple)
+print(f"Tuple test: xy={xy_tuple}")
+
+# Test 2: List instead of numpy array
+xy_list = [-3, 2]
+ax.annotate('List test', xy=xy_list)
+print(f"List test: xy={xy_list}")
+
+# Test 3: Regular numpy array (should be copied)
+xy_numpy = np.array([-2, 1])
+ax.annotate('Numpy test', xy=xy_numpy)
+xy_numpy[1] = 5  # Should not affect the annotation
+print(f"Numpy test: original={xy_numpy}")
+
+# Test 4: Numpy array with xytext
+xy_numpy2 = np.array([-1, 1])
+xytext_numpy = np.array([1, 2])
+ax.annotate('Numpy xytext test', xy=xy_numpy2, xytext=xytext_numpy)
+xytext_numpy[1] = 5  # Should not affect the annotation
+print(f"Numpy xytext test: original xytext={xytext_numpy}")
+
+plt.savefig('edge_cases_test.png')
+print("Figure saved as edge_cases_test.png")
+
+# Check all annotations
+annotations = ax.texts
+for i, ann in enumerate(annotations):
+    print(f"Annotation {i}: xy={ann.xy}")
+    print(f"  Text position: {ann.get_position()}")
\ No newline at end of file
diff --git a/test_xytext_comprehensive.py b/test_xytext_comprehensive.py
new file mode 100644
index 0000000000..3285bfedff
--- /dev/null
+++ b/test_xytext_comprehensive.py
@@ -0,0 +1,29 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+# Test 1: xy reference issue (should be fixed)
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3  # <-- this should NOT update the arrow position
+
+# Test 2: xytext reference issue (might still be present)
+xy_2 = np.array((1, 1))
+xy_f2 = np.array((4, 1))
+ax.annotate('', xy=xy_2, xytext=xy_f2, arrowprops=dict(arrowstyle='<->'))
+xy_f2[1] = 3  # <-- this might update the arrow position if not fixed
+
+plt.savefig('comprehensive_test.png')
+print("Figure saved as comprehensive_test.png")
+
+# Check the annotation data
+annotations = ax.texts
+for i, ann in enumerate(annotations):
+    print(f"Annotation {i}: xy={ann.xy}")
+    # For xytext, we need to check the text position
+    print(f"  Text position: {ann.get_position()}")
\ No newline at end of file
diff --git a/test_xytext_issue.py b/test_xytext_issue.py
new file mode 100644
index 0000000000..7e70d211e8
--- /dev/null
+++ b/test_xytext_issue.py
@@ -0,0 +1,24 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+xy_0 = np.array((-4, 1))
+xy_f = np.array((-1, 1))
+# Test xytext reference issue
+ax.annotate('', xy=xy_0, xytext=xy_f, arrowprops=dict(arrowstyle='<->'))
+xy_f[1] = 3  # <-- this should NOT update the arrow position if fixed
+
+plt.savefig('xytext_test.png')
+print("Figure saved as xytext_test.png")
+
+# Check the annotation data
+annotations = ax.texts
+for i, ann in enumerate(annotations):
+    print(f"Annotation {i}: xy={ann.xy}")
+    # Check the actual arrow endpoint positions
+    if hasattr(ann, 'arrow_patch') and ann.arrow_patch is not None:
+        print(f"  Arrow patch: A={ann.arrow_patch.get_path().vertices[0]}, B={ann.arrow_patch.get_path().vertices[-1]}")
\ No newline at end of file
diff --git a/test_xytext_none.py b/test_xytext_none.py
new file mode 100644
index 0000000000..994937e597
--- /dev/null
+++ b/test_xytext_none.py
@@ -0,0 +1,21 @@
+import matplotlib.pyplot as plt
+import numpy as np
+
+fig = plt.figure("test")
+ax = fig.add_axes([0.13, 0.15, .8, .8])
+ax.set_xlim(-5, 5)
+ax.set_ylim(-3, 3)
+
+# Test: xytext=None should use self.xy, which should be a copy
+xy_0 = np.array((-4, 1))
+ax.annotate('Test', xy=xy_0, xytext=None, arrowprops=dict(arrowstyle='<->'))
+xy_0[1] = 3  # <-- this should NOT update the arrow position
+
+plt.savefig('xytext_none_test.png')
+print("Figure saved as xytext_none_test.png")
+
+# Check the annotation data
+annotations = ax.texts
+for i, ann in enumerate(annotations):
+    print(f"Annotation {i}: xy={ann.xy}")
+    print(f"  Text position: {ann.get_position()}")
\ No newline at end of file
diff --git a/xytext_none_test.png b/xytext_none_test.png
new file mode 100644
index 0000000000..344c03e2b3
Binary files /dev/null and b/xytext_none_test.png differ
diff --git a/xytext_test.png b/xytext_test.png
new file mode 100644
index 0000000000..0c71cb8b2a
Binary files /dev/null and b/xytext_test.png differ