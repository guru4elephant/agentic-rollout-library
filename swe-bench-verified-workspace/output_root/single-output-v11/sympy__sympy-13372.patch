diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b773e1fd87
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Max, symbols
+
+print("Testing the issue...")
+
+# First case - this should work
+x, y = symbols('x y')
+
+print("Testing: Mul(x, Max(0, y), evaluate=False).evalf()")
+try:
+    result1 = Mul(x, Max(0, y), evaluate=False).evalf()
+    print(f"Result: {result1}")
+except Exception as e:
+    print(f"Error: {e}")
+
+print("\n" + "="*50 + "\n")
+
+# Second case - this should fail with UnboundLocalError
+print("Testing: Mul(Max(0, y), x, evaluate=False).evalf()")
+try:
+    result2 = Mul(Max(0, y), x, evaluate=False).evalf()
+    print(f"Result: {result2}")
+except Exception as e:
+    print(f"Error: {type(e).__name__}: {e}")
\ No newline at end of file
diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py
index 72a5fbae52..f34908710a 100644
--- a/sympy/core/evalf.py
+++ b/sympy/core/evalf.py
@@ -1301,12 +1301,16 @@ def evalf(x, prec, options):
             elif re.is_number:
                 re = re._to_mpmath(prec, allow_ints=False)._mpf_
                 reprec = prec
+            else:
+                raise NotImplementedError
             if im == 0:
                 im = None
                 imprec = None
             elif im.is_number:
                 im = im._to_mpmath(prec, allow_ints=False)._mpf_
                 imprec = prec
+            else:
+                raise NotImplementedError
             r = re, im, reprec, imprec
         except AttributeError:
             raise NotImplementedError
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..dfebece2a1
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Max, Min, symbols, Add, S
+
+def test_case(expr, description):
+    print(f"Testing: {description}")
+    try:
+        result = expr.evalf()
+        print(f"✓ Success: {result}")
+        return True
+    except Exception as e:
+        print(f"✗ Error: {type(e).__name__}: {e}")
+        return False
+
+x, y, z = symbols('x y z')
+
+print("Testing various cases to ensure the fix works correctly...\n")
+
+# Test cases that should work
+test_cases = [
+    (Mul(x, Max(0, y), evaluate=False), "Mul(x, Max(0, y), evaluate=False)"),
+    (Mul(Max(0, y), x, evaluate=False), "Mul(Max(0, y), x, evaluate=False)"),
+    (Mul(Min(1, y), x, evaluate=False), "Mul(Min(1, y), x, evaluate=False)"),
+    (Mul(x, Min(1, y), evaluate=False), "Mul(x, Min(1, y), evaluate=False)"),
+    (Mul(Max(0, y), Min(1, z), evaluate=False), "Mul(Max(0, y), Min(1, z), evaluate=False)"),
+]
+
+print("="*60)
+all_passed = True
+for expr, desc in test_cases:
+    passed = test_case(expr, desc)
+    all_passed = all_passed and passed
+    print()
+
+print("="*60)
+if all_passed:
+    print("✓ All tests passed!")
+else:
+    print("✗ Some tests failed!")
+
+# Test some numeric cases to ensure they still work
+print("\nTesting numeric cases...")
+numeric_cases = [
+    (Mul(2, 3, evaluate=False), "Mul(2, 3, evaluate=False)"),
+    (Mul(2.5, 3.5, evaluate=False), "Mul(2.5, 3.5, evaluate=False)"),
+    (Mul(S(1)/2, S(1)/3, evaluate=False), "Mul(1/2, 1/3, evaluate=False)"),
+]
+
+for expr, desc in numeric_cases:
+    test_case(expr, desc)
+    print()
\ No newline at end of file
diff --git a/test_direct_notimplemented.py b/test_direct_notimplemented.py
new file mode 100644
index 0000000000..0c65d172f1
--- /dev/null
+++ b/test_direct_notimplemented.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, symbols, re, im, Function
+
+# Create a function that returns something that would fail both conditions
+class BadEvalfFunc(Function):
+    def _eval_evalf(self, prec):
+        # Return a tuple where re is not 0 and not a number
+        # and im is not 0 and not a number
+        return (self.args[0], self.args[0])  # Return a tuple of symbols
+
+x, y = symbols('x y')
+
+print("Testing direct NotImplementedError trigger...")
+
+try:
+    # This should trigger the NotImplementedError because
+    # BadEvalfFunc(x)._eval_evalf() returns (x, x)
+    # which would make re = x, im = x
+    # x is not 0 and not a number, so it should go to the else clause
+    result = Mul(BadEvalfFunc(x), y, evaluate=False).evalf()
+    print(f"Unexpected success: {result}")
+except NotImplementedError:
+    print("✓ Correctly raised NotImplementedError")
+except Exception as e:
+    print(f"✗ Unexpected error: {type(e).__name__}: {e}")
+
+print("\nTest completed!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..c4a8a21ee1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Function, symbols
+
+# Test edge cases where NotImplementedError should be raised
+x, y = symbols('x y')
+
+# Create a custom function that doesn't have evalf support
+class CustomFunc(Function):
+    pass
+
+print("Testing edge cases...")
+
+# Test case that should raise NotImplementedError
+print("Testing CustomFunc case (should raise NotImplementedError):")
+try:
+    result = Mul(CustomFunc(x), y, evaluate=False).evalf()
+    print(f"Unexpected success: {result}")
+except NotImplementedError:
+    print("✓ Correctly raised NotImplementedError")
+except Exception as e:
+    print(f"✗ Unexpected error: {type(e).__name__}: {e}")
+
+print()
+
+# Test another case that should raise NotImplementedError
+print("Testing another unsupported case:")
+try:
+    result = Mul(x, CustomFunc(y), evaluate=False).evalf()
+    print(f"Unexpected success: {result}")
+except NotImplementedError:
+    print("✓ Correctly raised NotImplementedError")
+except Exception as e:
+    print(f"✗ Unexpected error: {type(e).__name__}: {e}")
+
+print("\nEdge case testing completed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..de2dd1326a
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Max, symbols
+
+# Exact test cases from the GitHub issue
+x, y = symbols('x y')
+
+print("Testing exact GitHub issue cases...")
+
+# First case - should work
+print("Case 1: Mul(x, Max(0, y), evaluate=False).evalf()")
+try:
+    result1 = Mul(x, Max(0, y), evaluate=False).evalf()
+    print(f"✓ Result: {result1}")
+except Exception as e:
+    print(f"✗ Error: {type(e).__name__}: {e}")
+
+print()
+
+# Second case - was failing with UnboundLocalError, should now work
+print("Case 2: Mul(Max(0, y), x, evaluate=False).evalf()")
+try:
+    result2 = Mul(Max(0, y), x, evaluate=False).evalf()
+    print(f"✓ Result: {result2}")
+except Exception as e:
+    print(f"✗ Error: {type(e).__name__}: {e}")
+
+print()
+
+# Verify both results are the same
+if str(result1) == str(result2):
+    print("✓ Both cases produce identical results!")
+else:
+    print("✗ Results differ!")
+
+print("\nGitHub issue has been resolved!")
\ No newline at end of file
diff --git a/test_mul_basic.py b/test_mul_basic.py
new file mode 100644
index 0000000000..44c73d106e
--- /dev/null
+++ b/test_mul_basic.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, symbols, S
+
+def test_basic_mul():
+    x, y = symbols('x y')
+    
+    # Test basic multiplication
+    print("Testing basic Mul operations...")
+    
+    # Numeric multiplication
+    m1 = Mul(2, 3, evaluate=False)
+    print(f"Mul(2, 3, evaluate=False).evalf() = {m1.evalf()}")
+    
+    # Symbolic multiplication
+    m2 = Mul(x, y, evaluate=False)
+    print(f"Mul(x, y, evaluate=False).evalf() = {m2.evalf()}")
+    
+    # Mixed multiplication
+    m3 = Mul(2, x, evaluate=False)
+    print(f"Mul(2, x, evaluate=False).evalf() = {m3.evalf()}")
+    
+    # Fractions
+    m4 = Mul(S(1)/2, S(1)/3, evaluate=False)
+    print(f"Mul(1/2, 1/3, evaluate=False).evalf() = {m4.evalf()}")
+    
+    print("All basic Mul tests passed!")
+
+if __name__ == "__main__":
+    test_basic_mul()
\ No newline at end of file
diff --git a/test_notimplemented.py b/test_notimplemented.py
new file mode 100644
index 0000000000..89105d4661
--- /dev/null
+++ b/test_notimplemented.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Function, symbols, re, im
+
+# Create a custom function that returns non-numeric real/imag parts
+class ProblematicFunc(Function):
+    def _eval_evalf(self, prec):
+        # Return something that has re() or im() functions in it
+        # which would trigger the has(re_) or has(im_) check
+        return re(self.args[0]) + im(self.args[0])
+
+x, y = symbols('x y')
+
+print("Testing case that should trigger NotImplementedError...")
+
+# This should trigger the NotImplementedError because ProblematicFunc(x)
+# returns an expression containing re(x) and im(x) functions
+try:
+    result = Mul(ProblematicFunc(x), y, evaluate=False).evalf()
+    print(f"Unexpected success: {result}")
+except NotImplementedError:
+    print("✓ Correctly raised NotImplementedError")
+except Exception as e:
+    print(f"✗ Unexpected error: {type(e).__name__}: {e}")
+
+print("\nTest completed!")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..917ed307ac
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+from sympy import Mul, Max, symbols
+
+# Exact reproduction of the GitHub issue
+x, y = symbols('x y')
+
+print("Testing the exact GitHub issue scenario...")
+
+# The issue was specifically about the order of arguments in Mul
+# causing different behavior due to different evaluation paths
+
+print("Case that worked:")
+result1 = Mul(x, Max(0, y), evaluate=False).evalf()
+print(f"  Mul(x, Max(0, y), evaluate=False).evalf() = {result1}")
+
+print("Case that failed with UnboundLocalError:")
+result2 = Mul(Max(0, y), x, evaluate=False).evalf()
+print(f"  Mul(Max(0, y), x, evaluate=False).evalf() = {result2}")
+
+# The key insight from the GitHub issue is that the argument order
+# affects which evaluation path is taken, and one path was missing
+# the else clause that should raise NotImplementedError
+
+print("\nBoth cases now work correctly!")
+print("The UnboundLocalError has been fixed by adding the missing else clauses.")
\ No newline at end of file