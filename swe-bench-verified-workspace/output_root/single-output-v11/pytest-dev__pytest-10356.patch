diff --git a/debug_markers.py b/debug_markers.py
new file mode 100644
index 000000000..2d9c5f50c
--- /dev/null
+++ b/debug_markers.py
@@ -0,0 +1,59 @@
+import pytest
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both markers, foo and bar
+        assert True
+
+# Let's debug what happens during collection
+def test_debug_markers():
+    # Import the necessary components
+    from _pytest.python import Class
+    from _pytest.mark.structures import get_unpacked_marks
+    
+    # Create a mock class collector
+    class MockClass(Class):
+        def __init__(self, cls_obj):
+            self.obj = cls_obj
+            self.own_markers = []
+            
+        def collect_markers(self):
+            self.own_markers.extend(get_unpacked_marks(self.obj))
+    
+    # Test with our classes
+    print("Testing Foo:")
+    foo_collector = MockClass(Foo)
+    foo_collector.collect_markers()
+    print("Markers:", [m.name for m in foo_collector.own_markers])
+    
+    print("\nTesting Bar:")
+    bar_collector = MockClass(Bar)
+    bar_collector.collect_markers()
+    print("Markers:", [m.name for m in bar_collector.own_markers])
+    
+    print("\nTesting TestDings:")
+    testdings_collector = MockClass(TestDings)
+    testdings_collector.collect_markers()
+    print("Markers:", [m.name for m in testdings_collector.own_markers])
+    
+    # Check MRO
+    print("\nTestDings MRO:", [cls.__name__ for cls in TestDings.__mro__])
+    
+    # Check markers on each class in MRO
+    for cls in TestDings.__mro__:
+        if hasattr(cls, 'pytestmark'):
+            marks = list(get_unpacked_marks(cls))
+            print(f"Markers on {cls.__name__}:", [mark.name for mark in marks])
+        else:
+            print(f"No pytestmark on {cls.__name__}")
+
+if __name__ == "__main__":
+    test_debug_markers()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..15f70ed4e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,31 @@
+import pytest
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both markers, foo and bar
+        pass
+
+if __name__ == "__main__":
+    # Let's see what markers are collected for TestDings
+    from _pytest.mark.structures import get_unpacked_marks
+    marks = list(get_unpacked_marks(TestDings))
+    print("Markers on TestDings:", [mark.name for mark in marks])
+    
+    # Also check the MRO
+    print("TestDings MRO:", TestDings.__mro__)
+    
+    # Check markers on each class in MRO
+    for cls in TestDings.__mro__:
+        if hasattr(cls, 'pytestmark'):
+            marks = list(get_unpacked_marks(cls))
+            print(f"Markers on {cls.__name__}:", [mark.name for mark in marks])
+        else:
+            print(f"No pytestmark on {cls.__name__}")
\ No newline at end of file
diff --git a/simple_debug.py b/simple_debug.py
new file mode 100644
index 000000000..8c7ffee57
--- /dev/null
+++ b/simple_debug.py
@@ -0,0 +1,34 @@
+import pytest
+from _pytest.mark.structures import get_unpacked_marks
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both markers, foo and bar
+        assert True
+
+# Test the current behavior
+print("Current behavior:")
+print("Foo markers:", [m.name for m in get_unpacked_marks(Foo)])
+print("Bar markers:", [m.name for m in get_unpacked_marks(Bar)])
+print("TestDings markers:", [m.name for m in get_unpacked_marks(TestDings)])
+
+# Check MRO
+print("\nTestDings MRO:", [cls.__name__ for cls in TestDings.__mro__])
+
+# Check what markers should be collected according to MRO
+expected_marks = []
+for cls in TestDings.__mro__:
+    if hasattr(cls, 'pytestmark'):
+        marks = list(get_unpacked_marks(cls))
+        expected_marks.extend(marks)
+        print(f"Markers on {cls.__name__}:", [mark.name for mark in marks])
+
+print("\nExpected markers for TestDings:", [mark.name for mark in expected_marks])
\ No newline at end of file
diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py
index 800a25c92..020275eb2 100644
--- a/src/_pytest/mark/structures.py
+++ b/src/_pytest/mark/structures.py
@@ -360,6 +360,17 @@ def get_unpacked_marks(obj: object) -> Iterable[Mark]:
     mark_list = getattr(obj, "pytestmark", [])
     if not isinstance(mark_list, list):
         mark_list = [mark_list]
+    
+    # For classes, also collect markers from base classes according to MRO
+    if inspect.isclass(obj):
+        # Traverse the MRO and collect markers from all base classes
+        for base_class in obj.__mro__[1:]:  # Skip the class itself (first in MRO)
+            if hasattr(base_class, 'pytestmark'):
+                base_mark_list = getattr(base_class, "pytestmark", [])
+                if not isinstance(base_mark_list, list):
+                    base_mark_list = [base_mark_list]
+                mark_list.extend(base_mark_list)
+    
     return normalize_mark_list(mark_list)
 
 
diff --git a/test_reproduce_issue.py b/test_reproduce_issue.py
new file mode 100644
index 000000000..57db7b88f
--- /dev/null
+++ b/test_reproduce_issue.py
@@ -0,0 +1,33 @@
+import pytest
+
+@pytest.mark.foo
+class Foo:
+    pass
+
+@pytest.mark.bar
+class Bar:
+    pass
+
+class TestDings(Foo, Bar):
+    def test_dings(self):
+        # This test should have both markers, foo and bar
+        assert True
+
+if __name__ == "__main__":
+    # Run pytest to see what markers are collected
+    import subprocess
+    import sys
+    
+    # Run with verbose output to see markers
+    result = subprocess.run([
+        sys.executable, "-m", "pytest", 
+        __file__, 
+        "-v", 
+        "--collect-only"
+    ], capture_output=True, text=True)
+    
+    print("STDOUT:")
+    print(result.stdout)
+    print("STDERR:")
+    print(result.stderr)
+    print("Return code:", result.returncode)
\ No newline at end of file