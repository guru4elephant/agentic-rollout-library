diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py
index c395b0bde2..2c90dedc31 100644
--- a/django/contrib/admin/checks.py
+++ b/django/contrib/admin/checks.py
@@ -771,10 +771,11 @@ class BaseModelAdminChecks:
             except FieldDoesNotExist:
                 return [
                     checks.Error(
-                        "The value of '%s' is not a callable, an attribute of "
-                        "'%s', or an attribute of '%s'."
+                        "The value of '%s' refers to '%s', which is not a callable, "
+                        "an attribute of '%s', or an attribute of '%s'."
                         % (
                             label,
+                            field_name,
                             obj.__class__.__name__,
                             obj.model._meta.label,
                         ),
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..fb4d312e43
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the readonly_fields error message issue.
+"""
+
+import os
+import sys
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'django'))
+
+from django.contrib import admin
+from django.db import models
+from django.core import checks
+
+
+# Create a simple test model
+class City(models.Model):
+    name = models.CharField(max_length=100)
+    population = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+
+# Create a ModelAdmin with an invalid readonly_field
+class CityAdmin(admin.ModelAdmin):
+    readonly_fields = ['invalid_field']  # This field doesn't exist
+
+
+def test_readonly_fields_error():
+    """Test the current readonly_fields error message"""
+    print("Testing readonly_fields error message...")
+    
+    # Create an instance of the admin
+    admin_obj = CityAdmin(City, admin.site)
+    
+    # Run checks
+    errors = admin_obj.check()
+    
+    # Filter for readonly_fields errors
+    readonly_errors = [e for e in errors if 'readonly_fields' in str(e)]
+    
+    for error in readonly_errors:
+        print(f"Current error message: {error.msg}")
+        print(f"Error ID: {error.id}")
+
+
+def test_list_editable_error():
+    """Test list_editable error message for comparison"""
+    print("\nTesting list_editable error message for comparison...")
+    
+    class CityAdminCompare(admin.ModelAdmin):
+        list_display = ['name']
+        list_editable = ['invalid_field']  # This field doesn't exist in list_display
+    
+    admin_obj = CityAdminCompare(City, admin.site)
+    errors = admin_obj.check()
+    
+    list_editable_errors = [e for e in errors if 'list_editable' in str(e)]
+    
+    for error in list_editable_errors:
+        print(f"list_editable error message: {error.msg}")
+        print(f"Error ID: {error.id}")
+
+
+if __name__ == '__main__':
+    test_readonly_fields_error()
+    test_list_editable_error()
\ No newline at end of file
diff --git a/test_fix_verification.py b/test_fix_verification.py
new file mode 100644
index 0000000000..4ee979e9c6
--- /dev/null
+++ b/test_fix_verification.py
@@ -0,0 +1,140 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the readonly_fields error message fix.
+This test verifies that the error message now includes both the index and field name,
+making it consistent with other field validation error messages.
+"""
+
+import os
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth', 
+            'django.contrib.contenttypes',
+            'tests.admin_checks',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.contrib import admin
+from tests.admin_checks.models import Song, City, State
+from django.contrib.admin.sites import AdminSite
+
+def test_readonly_fields_error_message():
+    """Test that readonly_fields error message includes field name"""
+    print("=== Testing readonly_fields error message ===")
+    
+    class SongAdmin(admin.ModelAdmin):
+        readonly_fields = ["title", "nonexistent_field"]
+    
+    errors = SongAdmin(Song, AdminSite()).check()
+    readonly_errors = [e for e in errors if 'readonly_fields' in str(e)]
+    
+    print(f"Found {len(readonly_errors)} readonly_fields error(s)")
+    
+    for error in readonly_errors:
+        print(f"Error message: {error.msg}")
+        # Verify the error message includes both index and field name
+        assert '[1]' in error.msg, "Error should include index"
+        assert 'nonexistent_field' in error.msg, "Error should include field name"
+        assert 'refers to' in error.msg, "Error should use 'refers to' phrasing"
+        print("âœ“ Error message correctly includes index and field name")
+
+def test_list_editable_error_message():
+    """Test that list_editable error message includes field name (for comparison)"""
+    print("\n=== Testing list_editable error message (for comparison) ===")
+    
+    class SongAdmin(admin.ModelAdmin):
+        list_display = ["title"]
+        list_editable = ["nonexistent_field"]
+    
+    errors = SongAdmin(Song, AdminSite()).check()
+    list_editable_errors = [e for e in errors if 'list_editable' in str(e)]
+    
+    print(f"Found {len(list_editable_errors)} list_editable error(s)")
+    
+    for error in list_editable_errors:
+        print(f"Error message: {error.msg}")
+        # Verify the error message includes both index and field name
+        assert '[0]' in error.msg, "Error should include index"
+        assert 'nonexistent_field' in error.msg, "Error should include field name"
+        assert 'refers to' in error.msg, "Error should use 'refers to' phrasing"
+        print("âœ“ Error message correctly includes index and field name")
+
+def test_raw_id_fields_error_message():
+    """Test that raw_id_fields error message includes field name (for comparison)"""
+    print("\n=== Testing raw_id_fields error message (for comparison) ===")
+    
+    class SongAdmin(admin.ModelAdmin):
+        raw_id_fields = ["nonexistent_field"]
+    
+    errors = SongAdmin(Song, AdminSite()).check()
+    raw_id_errors = [e for e in errors if 'raw_id_fields' in str(e)]
+    
+    print(f"Found {len(raw_id_errors)} raw_id_fields error(s)")
+    
+    for error in raw_id_errors:
+        print(f"Error message: {error.msg}")
+        # Verify the error message includes both index and field name
+        assert '[0]' in error.msg, "Error should include index"
+        assert 'nonexistent_field' in error.msg, "Error should include field name"
+        assert 'refers to' in error.msg, "Error should use 'refers to' phrasing"
+        print("âœ“ Error message correctly includes index and field name")
+
+def test_consistency_across_fields():
+    """Test that all field validation error messages are consistent"""
+    print("\n=== Testing consistency across field validation error messages ===")
+    
+    # Test readonly_fields
+    class Admin1(admin.ModelAdmin):
+        readonly_fields = ["invalid_field"]
+    
+    errors1 = Admin1(Song, AdminSite()).check()
+    readonly_error = [e for e in errors1 if 'readonly_fields' in str(e)][0]
+    
+    # Test list_editable
+    class Admin2(admin.ModelAdmin):
+        list_display = ["title"]
+        list_editable = ["invalid_field"]
+    
+    errors2 = Admin2(Song, AdminSite()).check()
+    list_editable_error = [e for e in errors2 if 'list_editable' in str(e)][0]
+    
+    # Test raw_id_fields
+    class Admin3(admin.ModelAdmin):
+        raw_id_fields = ["invalid_field"]
+    
+    errors3 = Admin3(Song, AdminSite()).check()
+    raw_id_error = [e for e in errors3 if 'raw_id_fields' in str(e)][0]
+    
+    print("readonly_fields error:", readonly_error.msg)
+    print("list_editable error:", list_editable_error.msg)
+    print("raw_id_fields error:", raw_id_error.msg)
+    
+    # All errors should include both index and field name
+    for error in [readonly_error, list_editable_error, raw_id_error]:
+        assert '[' in error.msg and ']' in error.msg, "Error should include index"
+        assert 'invalid_field' in error.msg, "Error should include field name"
+        assert 'refers to' in error.msg, "Error should use 'refers to' phrasing"
+    
+    print("âœ“ All field validation error messages are consistent")
+
+if __name__ == '__main__':
+    test_readonly_fields_error_message()
+    test_list_editable_error_message()
+    test_raw_id_fields_error_message()
+    test_consistency_across_fields()
+    print("\nðŸŽ‰ All tests passed! The readonly_fields error message fix is working correctly.")
\ No newline at end of file
diff --git a/tests/admin_checks/tests.py b/tests/admin_checks/tests.py
index 4d171ed737..c2b476877e 100644
--- a/tests/admin_checks/tests.py
+++ b/tests/admin_checks/tests.py
@@ -798,8 +798,8 @@ class SystemChecksTestCase(SimpleTestCase):
         errors = SongAdmin(Song, AdminSite()).check()
         expected = [
             checks.Error(
-                "The value of 'readonly_fields[1]' is not a callable, an attribute "
-                "of 'SongAdmin', or an attribute of 'admin_checks.Song'.",
+                "The value of 'readonly_fields[1]' refers to 'nonexistent', which is not a callable, "
+                "an attribute of 'SongAdmin', or an attribute of 'admin_checks.Song'.",
                 obj=SongAdmin,
                 id="admin.E035",
             )
@@ -814,8 +814,8 @@ class SystemChecksTestCase(SimpleTestCase):
         errors = CityInline(State, AdminSite()).check()
         expected = [
             checks.Error(
-                "The value of 'readonly_fields[0]' is not a callable, an attribute "
-                "of 'CityInline', or an attribute of 'admin_checks.City'.",
+                "The value of 'readonly_fields[0]' refers to 'i_dont_exist', which is not a callable, "
+                "an attribute of 'CityInline', or an attribute of 'admin_checks.City'.",
                 obj=CityInline,
                 id="admin.E035",
             )