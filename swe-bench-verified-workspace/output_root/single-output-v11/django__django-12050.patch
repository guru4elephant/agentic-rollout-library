diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ea51912e8b..5cbb1bd4ef 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1073,7 +1073,8 @@ class Query(BaseExpression):
                         ))
                 else:
                     resolved_values.append(sub_value)
-            value = tuple(resolved_values)
+            # Preserve the original iterable type (list or tuple)
+            value = type(value)(resolved_values)
         return value
 
     def solve_lookup_type(self, lookup):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a89da6e9c3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where Query.resolve_lookup_value 
+coerces list values to tuples.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+
+# Create a simple model with a PickledField-like field
+class TestModel(models.Model):
+    data = models.BinaryField()  # Simulating PickledField
+    
+    class Meta:
+        app_label = 'test'
+
+def test_resolve_lookup_value():
+    """Test the resolve_lookup_value method behavior"""
+    
+    # Create a Query instance
+    query = Query(TestModel)
+    
+    # Test with list input
+    test_list = [1, 2, 3]
+    result = query.resolve_lookup_value(test_list, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"Input type: {type(test_list)}")
+    print(f"Input value: {test_list}")
+    print(f"Output type: {type(result)}")
+    print(f"Output value: {result}")
+    print(f"Types match: {type(test_list) == type(result)}")
+    
+    # Test with tuple input
+    test_tuple = (1, 2, 3)
+    result2 = query.resolve_lookup_value(test_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nInput type: {type(test_tuple)}")
+    print(f"Input value: {test_tuple}")
+    print(f"Output type: {type(result2)}")
+    print(f"Output value: {result2}")
+    print(f"Types match: {type(test_tuple) == type(result2)}")
+
+if __name__ == '__main__':
+    test_resolve_lookup_value()
\ No newline at end of file
diff --git a/test_basic_functionality.py b/test_basic_functionality.py
new file mode 100644
index 0000000000..1015f158ec
--- /dev/null
+++ b/test_basic_functionality.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+"""
+Test basic Django functionality to ensure our fix doesn't break anything.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a simple model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_basic_orm_operations():
+    """Test that basic ORM operations still work"""
+    
+    # Create the table
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Test basic create and query operations
+    try:
+        # Create objects
+        obj1 = TestModel.objects.create(name="test1", value=42)
+        obj2 = TestModel.objects.create(name="test2", value=99)
+        
+        # Query with exact lookups
+        results1 = list(TestModel.objects.filter(value=42))
+        results2 = list(TestModel.objects.filter(value=99))
+        
+        print(f"Query 1 found {len(results1)} objects")
+        print(f"Query 2 found {len(results2)} objects")
+        
+        # Test that we can retrieve the objects
+        retrieved1 = TestModel.objects.get(name="test1")
+        retrieved2 = TestModel.objects.get(name="test2")
+        
+        print(f"Retrieved obj1 value: {retrieved1.value}")
+        print(f"Retrieved obj2 value: {retrieved2.value}")
+        
+        return True
+        
+    except Exception as e:
+        print(f"Error during ORM operations: {e}")
+        return False
+    finally:
+        # Clean up
+        with connection.schema_editor() as schema_editor:
+            schema_editor.delete_model(TestModel)
+
+if __name__ == '__main__':
+    success = test_basic_orm_operations()
+    print(f"Basic functionality test: {'PASSED' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..bdb91df7ed
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the resolve_lookup_value fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models import F
+
+# Create a simple model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_comprehensive():
+    """Test various edge cases for resolve_lookup_value"""
+    
+    query = Query(TestModel)
+    
+    print("=== Test 1: Basic list and tuple preservation ===")
+    # Test with list
+    test_list = [1, 2, 3]
+    result = query.resolve_lookup_value(test_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"List input: {type(test_list)} -> {type(result)} | Match: {type(test_list) == type(result)}")
+    
+    # Test with tuple
+    test_tuple = (1, 2, 3)
+    result2 = query.resolve_lookup_value(test_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Tuple input: {type(test_tuple)} -> {type(result2)} | Match: {type(test_tuple) == type(result2)}")
+    
+    print("\n=== Test 2: Empty iterables ===")
+    # Empty list
+    empty_list = []
+    result3 = query.resolve_lookup_value(empty_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Empty list: {type(empty_list)} -> {type(result3)} | Match: {type(empty_list) == type(result3)}")
+    
+    # Empty tuple
+    empty_tuple = ()
+    result4 = query.resolve_lookup_value(empty_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Empty tuple: {type(empty_tuple)} -> {type(result4)} | Match: {type(empty_tuple) == type(result4)}")
+    
+    print("\n=== Test 3: Single element iterables ===")
+    # Single element list
+    single_list = [42]
+    result5 = query.resolve_lookup_value(single_list, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Single list: {type(single_list)} -> {type(result5)} | Match: {type(single_list) == type(result5)}")
+    
+    # Single element tuple
+    single_tuple = (42,)
+    result6 = query.resolve_lookup_value(single_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Single tuple: {type(single_tuple)} -> {type(result6)} | Match: {type(single_tuple) == type(result6)}")
+    
+    print("\n=== Test 4: Non-iterable values (should remain unchanged) ===")
+    # String
+    test_string = "hello"
+    result7 = query.resolve_lookup_value(test_string, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"String: {type(test_string)} -> {type(result7)} | Match: {type(test_string) == type(result7)}")
+    
+    # Integer
+    test_int = 42
+    result8 = query.resolve_lookup_value(test_int, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"Integer: {type(test_int)} -> {type(result8)} | Match: {type(test_int) == type(result8)}")
+    
+    # None
+    test_none = None
+    result9 = query.resolve_lookup_value(test_none, can_reuse=None, allow_joins=True, simple_col=False)
+    print(f"None: {type(test_none)} -> {type(result9)} | Match: {type(test_none) == type(result9)}")
+
+if __name__ == '__main__':
+    test_comprehensive()
\ No newline at end of file
diff --git a/test_pickledfield_scenario.py b/test_pickledfield_scenario.py
new file mode 100644
index 0000000000..bc98d6b83b
--- /dev/null
+++ b/test_pickledfield_scenario.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+"""
+Test simulating the PickledField scenario mentioned in the issue.
+This demonstrates that list values are no longer coerced to tuples.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+
+# Simulate a PickledField-like scenario where exact type matching matters
+class TestModel(models.Model):
+    # In a real PickledField, the exact type (list vs tuple) matters for comparison
+    data = models.BinaryField()  # This would store pickled data
+    
+    class Meta:
+        app_label = 'test'
+
+def test_pickledfield_scenario():
+    """Test that demonstrates the fix for PickledField-like scenarios"""
+    
+    query = Query(TestModel)
+    
+    print("=== Testing PickledField-like scenario ===")
+    print("Before the fix, lists were coerced to tuples, breaking exact matching.")
+    print("After the fix, the original iterable type should be preserved.")
+    
+    # Test with list input (this was the problematic case)
+    test_list = [1, 2, 3]
+    result = query.resolve_lookup_value(test_list, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nInput: {test_list} (type: {type(test_list)})")
+    print(f"Output: {result} (type: {type(result)})")
+    print(f"Type preserved: {type(test_list) == type(result)}")
+    
+    # Test that the values can be used for exact matching
+    print(f"Values match: {test_list == result}")
+    
+    # Test with tuple input (this should work the same as before)
+    test_tuple = (1, 2, 3)
+    result2 = query.resolve_lookup_value(test_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nInput: {test_tuple} (type: {type(test_tuple)})")
+    print(f"Output: {result2} (type: {type(result2)})")
+    print(f"Type preserved: {type(test_tuple) == type(result2)}")
+    print(f"Values match: {test_tuple == result2}")
+    
+    # Test edge case: empty lists and tuples
+    empty_list = []
+    empty_result = query.resolve_lookup_value(empty_list, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nEmpty list input: {empty_list} (type: {type(empty_list)})")
+    print(f"Empty list output: {empty_result} (type: {type(empty_result)})")
+    print(f"Type preserved: {type(empty_list) == type(empty_result)}")
+    
+    empty_tuple = ()
+    empty_result2 = query.resolve_lookup_value(empty_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nEmpty tuple input: {empty_tuple} (type: {type(empty_tuple)})")
+    print(f"Empty tuple output: {empty_result2} (type: {type(empty_result2)})")
+    print(f"Type preserved: {type(empty_tuple) == type(empty_result2)}")
+
+if __name__ == '__main__':
+    test_pickledfield_scenario()
\ No newline at end of file
diff --git a/test_with_expressions.py b/test_with_expressions.py
new file mode 100644
index 0000000000..1574ba9c46
--- /dev/null
+++ b/test_with_expressions.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Test that expressions (F objects) still work correctly with our fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.sql.query import Query
+from django.db.models import F
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_with_expressions():
+    """Test that expressions work correctly with our fix"""
+    
+    query = Query(TestModel)
+    
+    print("=== Testing with expressions (F objects) ===")
+    
+    # Test with F object (should work as before)
+    f_obj = F('value')
+    result = query.resolve_lookup_value(f_obj, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"F object input: {type(f_obj)}")
+    print(f"F object output: {type(result)}")
+    print(f"Is expression resolved: {hasattr(result, 'resolve_expression')}")
+    
+    # Test with list containing F objects
+    f_list = [F('value'), 42]
+    result2 = query.resolve_lookup_value(f_list, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nList with F objects input: {f_list} (type: {type(f_list)})")
+    print(f"List with F objects output: {result2} (type: {type(result2)})")
+    print(f"Type preserved: {type(f_list) == type(result2)}")
+    
+    # Test with tuple containing F objects
+    f_tuple = (F('value'), 42)
+    result3 = query.resolve_lookup_value(f_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"\nTuple with F objects input: {f_tuple} (type: {type(f_tuple)})")
+    print(f"Tuple with F objects output: {result3} (type: {type(result3)})")
+    print(f"Type preserved: {type(f_tuple) == type(result3)}")
+    
+    print("\nAll expression tests completed successfully!")
+
+if __name__ == '__main__':
+    test_with_expressions()
\ No newline at end of file