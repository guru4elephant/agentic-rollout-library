diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..c6a90a505d
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,42 @@
+from sympy import *
+from sympy.matrices.expressions.blockmatrix import BlockMatrix
+from sympy.matrices.expressions import ZeroMatrix, MatrixSymbol
+
+print("=== FINAL COMPREHENSIVE TEST ===")
+
+# Test the exact scenario from the GitHub issue
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+b = BlockMatrix([[a, z], [z, z]])
+
+print("\n1. Original issue reproduction:")
+print("b =", b)
+
+# Test first multiplication
+result1 = block_collapse(b * b)
+print("\n2. First multiplication (b * b):")
+print("Result:", result1)
+print("Type of zero block:", type(result1.blocks[0, 1]))
+
+# Test second multiplication (this was failing before)
+result2 = block_collapse(b * b * b)
+print("\n3. Second multiplication (b * b * b):")
+print("Result:", result2)
+
+# Test direct _blockmul calls
+result3 = b._blockmul(b)
+print("\n4. Direct _blockmul (b._blockmul(b)):")
+print("Result:", result3)
+
+result4 = b._blockmul(b)._blockmul(b)
+print("\n5. Chained _blockmul (b._blockmul(b)._blockmul(b)):")
+print("Result:", result4)
+
+# Test that all zero blocks are properly preserved as ZeroMatrix
+print("\n6. Zero block types:")
+print("Block [0,1]:", type(result4.blocks[0, 1]))
+print("Block [1,0]:", type(result4.blocks[1, 0]))
+print("Block [1,1]:", type(result4.blocks[1, 1]))
+
+print("\n=== ALL TESTS PASSED! ===")
+print("The issue has been successfully fixed.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..1d854c4f9d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,82 @@
+from sympy import *
+from sympy.matrices.expressions.blockmatrix import BlockMatrix
+from sympy.matrices.expressions import ZeroMatrix, MatrixSymbol
+from sympy.matrices import Matrix
+
+# Check if ZeroMatrix has is_Matrix attribute
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+print("MatrixSymbol is_Matrix:", hasattr(a, 'is_Matrix'))
+print("ZeroMatrix is_Matrix:", hasattr(z, 'is_Matrix'))
+print("ZeroMatrix is_Matrix value:", getattr(z, 'is_Matrix', 'Not found'))
+
+# Try to create BlockMatrix with proper format
+try:
+    b = BlockMatrix([[a, z], [z, z]])
+    print("BlockMatrix created successfully")
+    
+    print("\nDebug: Checking block structure")
+    print("b.blocks:", b.blocks)
+    print("b.blocks[0,0]:", b.blocks[0,0], type(b.blocks[0,0]))
+    print("b.blocks[0,1]:", b.blocks[0,1], type(b.blocks[0,1]))
+    print("b.blocks[1,0]:", b.blocks[1,0], type(b.blocks[1,0]))
+    print("b.blocks[1,1]:", b.blocks[1,1], type(b.blocks[1,1]))
+    
+    print("\nDebug: Checking colblocksizes")
+    try:
+        print("b.colblocksizes:", b.colblocksizes)
+    except Exception as e:
+        print("Error getting colblocksizes:", e)
+        
+    print("\nDebug: Checking matrix multiplication")
+    try:
+        mat_mult = b.blocks * b.blocks
+        print("Matrix multiplication result:", mat_mult)
+        print("Type of result[0,0]:", type(mat_mult[0,0]))
+        print("Type of result[0,1]:", type(mat_mult[0,1]))
+        print("Type of result[1,0]:", type(mat_mult[1,0]))
+        print("Type of result[1,1]:", type(mat_mult[1,1]))
+        
+        # Check if Zero objects have shape information
+        from sympy.core.numbers import Zero
+        if isinstance(mat_mult[0,1], Zero):
+            print("Zero object at [0,1] - checking if we can determine shape")
+            # The Zero at position [0,1] comes from a[0,0] * b.blocks[0,1] + a[0,1] * b.blocks[1,1]
+            # Since a is MatrixSymbol(2,2) and b.blocks are ZeroMatrix(2,2), the result should be ZeroMatrix(2,2)
+            print("Original dimensions:")
+            print("a.rows, a.cols:", a.rows, a.cols)
+            print("b.blocks[0,1].rows, b.blocks[0,1].cols:", b.blocks[0,1].rows, b.blocks[0,1].cols)
+            print("b.blocks[1,1].rows, b.blocks[1,1].cols:", b.blocks[1,1].rows, b.blocks[1,1].cols)
+    except Exception as e:
+        print("Error in matrix multiplication:", e)
+    
+    print("\nFirst multiplication:")
+    try:
+        result1 = b._blockmul(b)
+        print("Success:", result1)
+        print("Type of result:", type(result1))
+        if hasattr(result1, 'blocks'):
+            print("result1.blocks:", result1.blocks)
+            print("result1.blocks[0,0]:", result1.blocks[0,0], type(result1.blocks[0,0]))
+            print("result1.blocks[0,1]:", result1.blocks[0,1], type(result1.blocks[0,1]))
+            print("result1.blocks[1,0]:", result1.blocks[1,0], type(result1.blocks[1,0]))
+            print("result1.blocks[1,1]:", result1.blocks[1,1], type(result1.blocks[1,1]))
+    except Exception as e:
+        print("Error:", e)
+
+    print("\nSecond multiplication:")
+    try:
+        result2 = b._blockmul(b)._blockmul(b)
+        print("Success:", result2)
+    except Exception as e:
+        print("Error:", e)
+
+    print("\nUsing block_collapse:")
+    try:
+        result3 = block_collapse(b * b * b)
+        print("Success:", result3)
+    except Exception as e:
+        print("Error:", e)
+        
+except Exception as e:
+    print("Error creating BlockMatrix:", e)
\ No newline at end of file
diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py
index 95302a05ca..0b96936ca8 100644
--- a/sympy/matrices/expressions/blockmatrix.py
+++ b/sympy/matrices/expressions/blockmatrix.py
@@ -164,7 +164,26 @@ def structurally_equal(self, other):
     def _blockmul(self, other):
         if (isinstance(other, BlockMatrix) and
                 self.colblocksizes == other.rowblocksizes):
-            return BlockMatrix(self.blocks*other.blocks)
+            # Perform matrix multiplication
+            result_blocks = self.blocks * other.blocks
+            
+            # Convert Zero objects back to ZeroMatrix with proper dimensions
+            from sympy.core.numbers import Zero
+            from sympy.matrices.expressions import ZeroMatrix
+            from sympy.matrices import MutableDenseMatrix
+            
+            # Create a mutable copy of the result matrix
+            new_blocks = MutableDenseMatrix(result_blocks)
+            for i in range(new_blocks.rows):
+                for j in range(new_blocks.cols):
+                    if isinstance(new_blocks[i, j], Zero):
+                        # The result at position (i,j) has dimensions:
+                        # (rows of block i in self) Ã— (cols of block j in other)
+                        rows = self.rowblocksizes[i]
+                        cols = other.colblocksizes[j]
+                        new_blocks[i, j] = ZeroMatrix(rows, cols)
+            
+            return BlockMatrix(new_blocks)
 
         return self * other
 
diff --git a/test_blockadd.py b/test_blockadd.py
new file mode 100644
index 0000000000..c1eb4f3d1a
--- /dev/null
+++ b/test_blockadd.py
@@ -0,0 +1,18 @@
+from sympy import *
+from sympy.matrices.expressions.blockmatrix import BlockMatrix
+from sympy.matrices.expressions import ZeroMatrix, MatrixSymbol
+
+# Test _blockadd with ZeroMatrix
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+b1 = BlockMatrix([[a, z], [z, z]])
+b2 = BlockMatrix([[z, z], [z, z]])
+
+print("Testing _blockadd:")
+try:
+    result = b1._blockadd(b2)
+    print("Success:", result)
+    print("Type of block [0,0]:", type(result.blocks[0, 0]))
+    print("Type of block [0,1]:", type(result.blocks[0, 1]))
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..249faaf0c4
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,44 @@
+from sympy import *
+from sympy.matrices.expressions.blockmatrix import BlockMatrix
+from sympy.matrices.expressions import ZeroMatrix, MatrixSymbol
+
+print("Testing edge cases:")
+
+# Test 1: Different block sizes (compatible for multiplication)
+print("\n1. Different block sizes:")
+a = MatrixSymbol("a", 2, 3)
+b = MatrixSymbol("b", 3, 2)
+z1 = ZeroMatrix(2, 2)
+z2 = ZeroMatrix(3, 3)
+z3 = ZeroMatrix(3, 2)
+block_mat = BlockMatrix([[a, z1], [z2, b]])
+result = block_mat._blockmul(block_mat)
+print("Result:", result)
+
+# Test 2: All zero matrix
+print("\n2. All zero matrix:")
+z = ZeroMatrix(2, 2)
+all_zero = BlockMatrix([[z, z], [z, z]])
+result = all_zero._blockmul(all_zero)
+print("Result:", result)
+print("Type of block [0,0]:", type(result.blocks[0, 0]))
+
+# Test 3: Mixed with identity matrix (same dimensions)
+print("\n3. Mixed with identity matrix:")
+from sympy.matrices.expressions import Identity
+i = Identity(2)
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+mixed = BlockMatrix([[a, z], [z, i]])
+result = mixed._blockmul(mixed)
+print("Result:", result)
+
+# Test 4: Multiple multiplications with proper block matrices
+print("\n4. Multiple multiplications:")
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+block_mat = BlockMatrix([[a, z], [z, z]])
+result = block_mat._blockmul(block_mat)._blockmul(block_mat)
+print("Triple multiplication result:", result)
+
+print("\nAll edge case tests passed!")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..c1417baa62
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,30 @@
+from sympy import *
+from sympy.matrices.expressions.blockmatrix import BlockMatrix
+from sympy.matrices.expressions import ZeroMatrix, MatrixSymbol
+
+# Reproduce the exact issue from the GitHub issue
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+b = BlockMatrix([[a, z], [z, z]])
+
+print("Testing the original issue:")
+
+# First multiplication should work
+print("\n1. First multiplication:")
+result1 = block_collapse(b * b)
+print("b * b =", result1)
+print("Type of block [0,1]:", type(result1.blocks[0, 1]))
+
+# Second multiplication should now work too
+print("\n2. Second multiplication:")
+result2 = block_collapse(b * b * b)
+print("b * b * b =", result2)
+
+# Direct _blockmul calls should also work
+print("\n3. Direct _blockmul calls:")
+result3 = b._blockmul(b)
+print("b._blockmul(b) =", result3)
+result4 = b._blockmul(b)._blockmul(b)
+print("b._blockmul(b)._blockmul(b) =", result4)
+
+print("\nAll tests passed! The issue has been fixed.")
\ No newline at end of file