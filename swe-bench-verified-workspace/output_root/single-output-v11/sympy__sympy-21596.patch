diff --git a/debug_base_set.py b/debug_base_set.py
new file mode 100644
index 0000000000..f94595592e
--- /dev/null
+++ b/debug_base_set.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S, Dummy, Eq, FiniteSet
+from sympy.sets import imageset, ConditionSet
+from sympy.solvers.solvers import solve_linear, denoms
+from sympy.core.function import expand_complex
+from sympy.core.mul import Mul
+
+n = symbols('n')
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*S.ImaginaryUnit), S.Integers)
+
+print("Debugging base_set operations...")
+
+# Simulate the intersection logic
+f = S1.lamda.expr
+n_var = S1.lamda.variables[0]
+base_set = S1.base_sets[0]
+
+print(f"Initial base_set = {base_set}")
+
+n_ = Dummy(n_var.name, real=True)
+f_ = f.subs(n_var, n_)
+
+re, im = f_.as_real_imag()
+im = expand_complex(im)
+
+re = re.subs(n_, n_var)
+im = im.subs(n_, n_var)
+ifree = im.free_symbols
+lam = Lambda(n_var, re)
+
+if im.is_zero:
+    print("im.is_zero is True")
+elif im.is_zero is False:
+    print("im.is_zero is False")
+    print("Would return EmptySet")
+elif ifree != {n_var}:
+    print(f"ifree != {{n_var}}: {ifree} != {{n_var}}")
+    print("Would return None")
+else:
+    print("Entering the univariate case...")
+    results = [solve_linear(i, 0) for i in Mul.make_args(im) if n_var in i.free_symbols]
+    print(f"results = {results}")
+    
+    x, xis = zip(*results)
+    print(f"x = {x}")
+    print(f"xis = {xis}")
+    
+    print(f"all(i == n_var for i in x) = {all(i == n_var for i in x)}")
+    
+    if x and all(i == n_var for i in x):
+        print("Doing: base_set -= FiniteSet(xis)")
+        print(f"xis = {xis}")
+        base_set = base_set - FiniteSet(*xis)
+        print(f"base_set after subtraction = {base_set}")
+        
+        # Check denominators
+        for i in denoms(f):
+            if i.has(n_var):
+                print(f"Checking denominator: {i}")
+                sol = list(zip(*[solve_linear(j, 0) for j in Mul.make_args(im) if n_var in j.free_symbols]))
+                print(f"sol = {sol}")
+                if sol != []:
+                    x_denom, xis_denom = sol
+                    print(f"x_denom = {x_denom}")
+                    print(f"xis_denom = {xis_denom}")
+                    if x_denom and all(k == n_var for k in x_denom):
+                        print("Would do: base_set -= FiniteSet(xis_denom)")
+                        base_set = base_set - FiniteSet(*xis_denom)
+                    else:
+                        print("Would do: base_set -= ConditionSet(n_var, Eq(i, 0), S.Integers)")
+                        base_set = base_set - ConditionSet(n_var, Eq(i, 0), S.Integers)
+                else:
+                    print("Would do: base_set -= ConditionSet(n_var, Eq(i, 0), S.Integers)")
+                    base_set = base_set - ConditionSet(n_var, Eq(i, 0), S.Integers)
+        
+        print(f"Final base_set = {base_set}")
+        result_set = imageset(lam, base_set)
+        print(f"Result set = {result_set}")
+        
+        # Test if 2 is in the result
+        print(f"2 in result_set = {2 in result_set}")
+    else:
+        print("Would do: base_set -= ConditionSet(n_var, Eq(im, 0), S.Integers)")
+        base_set = base_set - ConditionSet(n_var, Eq(im, 0), S.Integers)
+        print(f"base_set after subtraction = {base_set}")
\ No newline at end of file
diff --git a/debug_intersection.py b/debug_intersection.py
new file mode 100644
index 0000000000..1b05f6e525
--- /dev/null
+++ b/debug_intersection.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S, Dummy, Eq
+from sympy.sets import imageset, ConditionSet, FiniteSet
+from sympy.solvers.solvers import solve_linear, denoms
+from sympy.core.function import expand_complex
+from sympy.core.mul import Mul
+
+n = symbols('n')
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*S.ImaginaryUnit), S.Integers)
+
+print("Debugging ImageSet.intersect(Reals)...")
+
+# Simulate the intersection logic
+f = S1.lamda.expr
+n_var = S1.lamda.variables[0]
+
+n_ = Dummy(n_var.name, real=True)
+f_ = f.subs(n_var, n_)
+
+re, im = f_.as_real_imag()
+im = expand_complex(im)
+
+re = re.subs(n_, n_var)
+im = im.subs(n_, n_var)
+ifree = im.free_symbols
+lam = Lambda(n_var, re)
+
+print(f"f = {f}")
+print(f"re = {re}")
+print(f"im = {im}")
+print(f"ifree = {ifree}")
+
+if im.is_zero:
+    print("im.is_zero is True")
+elif im.is_zero is False:
+    print("im.is_zero is False")
+    print("Would return EmptySet")
+elif ifree != {n_var}:
+    print(f"ifree != {{n_var}}: {ifree} != {{n_var}}")
+    print("Would return None")
+else:
+    print("Entering the univariate case...")
+    results = [solve_linear(i, 0) for i in Mul.make_args(im) if n_var in i.free_symbols]
+    print(f"results = {results}")
+    
+    x, xis = zip(*results)
+    print(f"x = {x}")
+    print(f"xis = {xis}")
+    
+    print(f"all(i == n_var for i in x) = {all(i == n_var for i in x)}")
+    
+    if x and all(i == n_var for i in x):
+        print("Would do: base_set -= FiniteSet(xis)")
+        print(f"xis = {xis}")
+    else:
+        print("Would do: base_set -= ConditionSet(n_var, Eq(im, 0), S.Integers)")
\ No newline at end of file
diff --git a/debug_solve.py b/debug_solve.py
new file mode 100644
index 0000000000..aa134e76cf
--- /dev/null
+++ b/debug_solve.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, solve_linear, Mul, Eq
+from sympy.solvers.solvers import denoms
+
+n = symbols('n')
+im = (n - 1)*(n + 1)
+
+print(f"im = {im}")
+print(f"Mul.make_args(im) = {Mul.make_args(im)}")
+
+# Try to solve using solve_linear
+for i in Mul.make_args(im):
+    if n in i.free_symbols:
+        print(f"Trying to solve {i} = 0")
+        result = solve_linear(i, 0)
+        print(f"Result: {result}")
+
+# Let's also check what solve_linear actually returns
+print(f"\nsolve_linear(im, 0) = {solve_linear(im, 0)}")
\ No newline at end of file
diff --git a/debug_xis.py b/debug_xis.py
new file mode 100644
index 0000000000..1165edd082
--- /dev/null
+++ b/debug_xis.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, solve_linear, Mul, FiniteSet
+
+n = symbols('n')
+im = (n - 1)*(n + 1)
+
+results = [solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]
+print(f"results = {results}")
+
+x, xis = zip(*results)
+print(f"x = {x}")
+print(f"xis = {xis}")
+
+# Create FiniteSet with xis
+fs = FiniteSet(xis)
+print(f"FiniteSet(xis) = {fs}")
+
+# Create FiniteSet with individual elements
+fs2 = FiniteSet(*xis)
+print(f"FiniteSet(*xis) = {fs2}")
\ No newline at end of file
diff --git a/debug_zip.py b/debug_zip.py
new file mode 100644
index 0000000000..820c137871
--- /dev/null
+++ b/debug_zip.py
@@ -0,0 +1,16 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, solve_linear, Mul
+from sympy.solvers.solvers import denoms
+
+n = symbols('n')
+im = (n - 1)*(n + 1)
+
+results = [solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]
+print(f"results = {results}")
+
+x, xis = zip(*results)
+print(f"x = {x}")
+print(f"xis = {xis}")
+
+print(f"all(i == n for i in x) = {all(i == n for i in x)}")
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..33970e8f37
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S
+from sympy.sets import imageset
+
+n = symbols('n')
+
+# Original issue from GitHub
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*S.ImaginaryUnit), S.Integers)
+print(f"S1 = {S1}")
+
+# Test the specific cases mentioned in the issue
+print(f"2 in S1 = {2 in S1}")
+print(f"2 in S1.intersect(S.Reals) = {2 in S1.intersect(S.Reals)}")
+
+# Test the intersection result
+intersection = S1.intersect(S.Reals)
+print(f"S1.intersect(S.Reals) = {intersection}")
+
+# Test the elements that should be in the intersection
+print(f"-1 in intersection = {-1 in intersection}")
+print(f"1 in intersection = {1 in intersection}")
+print(f"2 in intersection = {2 in intersection}")
+
+# Expected results according to GitHub issue
+print("\nExpected results:")
+print("2 in S1 = False")
+print("2 in S1.intersect(S.Reals) = False")
+print("S1.intersect(S.Reals) = FiniteSet(-1, 1)")
+print("-1 in intersection = True")
+print("1 in intersection = True")
+print("2 in intersection = False")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bb17c2ae98
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S
+from sympy.sets import imageset
+
+n = symbols('n')
+
+# Reproduce the issue described in the GitHub issue
+print("Reproducing the issue...")
+
+# Create the ImageSet
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*S.ImaginaryUnit), S.Integers)
+print(f"S1 = {S1}")
+
+# Test if 2 is in S1
+result1 = 2 in S1
+print(f"2 in S1 = {result1}")
+
+# Test if 2 is in S1.intersect(S.Reals)
+result2 = 2 in S1.intersect(S.Reals)
+print(f"2 in S1.intersect(Reals) = {result2}")
+
+# Expected results according to the issue
+print("\nExpected results:")
+print("2 in S1 = False")
+print("2 in S1.intersect(Reals) = False")
+print(f"S1.intersect(S.Reals) = {S1.intersect(S.Reals)}")
\ No newline at end of file
diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py
index c54dc8f72a..c72a490af7 100644
--- a/sympy/sets/handlers/intersection.py
+++ b/sympy/sets/handlers/intersection.py
@@ -306,9 +306,9 @@ def intersection_sets(self, other): # noqa:F811
             # univarite imaginary part in same variable
             x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])
             if x and all(i == n for i in x):
-                base_set -= FiniteSet(xis)
+                base_set = FiniteSet(*xis)
             else:
-                base_set -= ConditionSet(n, Eq(im, 0), S.Integers)
+                base_set = ConditionSet(n, Eq(im, 0), S.Integers)
         # exclude values that make denominators 0
         for i in denoms(f):
             if i.has(n):
@@ -316,9 +316,9 @@ def intersection_sets(self, other): # noqa:F811
                 if sol != []:
                     x, xis = sol
                     if x and all(i == n for i in x):
-                        base_set -= FiniteSet(xis)
+                        base_set = base_set - FiniteSet(*xis)
                 else:
-                    base_set -= ConditionSet(n, Eq(i, 0), S.Integers)
+                    base_set = base_set - ConditionSet(n, Eq(i, 0), S.Integers)
         return imageset(lam, base_set)
 
     elif isinstance(other, Interval):
diff --git a/test_denominator.py b/test_denominator.py
new file mode 100644
index 0000000000..f88b638a22
--- /dev/null
+++ b/test_denominator.py
@@ -0,0 +1,16 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S
+from sympy.sets import imageset
+
+n = symbols('n')
+
+# Test case with denominator that could cause issues
+S1 = imageset(Lambda(n, n + S.ImaginaryUnit/(n - 2)), S.Integers)  # {n + I/(n-2)}
+result = S1.intersect(S.Reals)
+print(f"S1 = {S1}")
+print(f"S1.intersect(Reals) = {result}")
+
+# The imaginary part is I/(n-2), which is zero only when denominator is infinite
+# So the intersection should be empty
+print(f"Empty? {result == S.EmptySet}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..7b8b706063
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S
+from sympy.sets import imageset
+
+n = symbols('n')
+
+# Test case 1: Simple linear imaginary part
+S1 = imageset(Lambda(n, n + n*S.ImaginaryUnit), S.Integers)  # {n + n*I}
+result1 = S1.intersect(S.Reals)
+print(f"S1 = {S1}")
+print(f"S1.intersect(Reals) = {result1}")
+print(f"0 in result1 = {0 in result1}")
+print(f"1 in result1 = {1 in result1}")
+
+# Test case 2: No imaginary part (should return original set)
+S2 = imageset(Lambda(n, n), S.Integers)  # {n}
+result2 = S2.intersect(S.Reals)
+print(f"\nS2 = {S2}")
+print(f"S2.intersect(Reals) = {result2}")
+print(f"2 in result2 = {2 in result2}")
+
+# Test case 3: Always imaginary (should return EmptySet)
+S3 = imageset(Lambda(n, n + S.ImaginaryUnit), S.Integers)  # {n + I}
+result3 = S3.intersect(S.Reals)
+print(f"\nS3 = {S3}")
+print(f"S3.intersect(Reals) = {result3}")
+print(f"2 in result3 = {2 in result3}")
+
+# Test case 4: Complex case with denominator
+S4 = imageset(Lambda(n, n + S.ImaginaryUnit/(n - 1)), S.Integers)  # {n + I/(n-1)}
+result4 = S4.intersect(S.Reals)
+print(f"\nS4 = {S4}")
+print(f"S4.intersect(Reals) = {result4}")
\ No newline at end of file
diff --git a/test_intersection_result.py b/test_intersection_result.py
new file mode 100644
index 0000000000..4abf7bd7b5
--- /dev/null
+++ b/test_intersection_result.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Lambda, S
+from sympy.sets import imageset
+
+n = symbols('n')
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*S.ImaginaryUnit), S.Integers)
+
+result = S1.intersect(S.Reals)
+print(f"S1.intersect(S.Reals) = {result}")
+
+# Check what elements are in the result
+print(f"Elements in result: {list(result)}")
+
+# Test individual elements
+print(f"-1 in result = {-1 in result}")
+print(f"1 in result = {1 in result}")
+print(f"2 in result = {2 in result}")
\ No newline at end of file