diff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py
index 3903e4c98c..69eccd168b 100644
--- a/django/contrib/admin/views/autocomplete.py
+++ b/django/contrib/admin/views/autocomplete.py
@@ -26,12 +26,15 @@ class AutocompleteJsonView(BaseListView):
         context = self.get_context_data()
         return JsonResponse({
             'results': [
-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}
-                for obj in context['object_list']
+                self.serialize_result(obj, to_field_name) for obj in context['object_list']
             ],
             'pagination': {'more': context['page_obj'].has_next()},
         })
 
+    def serialize_result(self, obj, to_field_name):
+        """Return a dictionary representation of an object for autocomplete results."""
+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}
+
     def get_paginator(self, *args, **kwargs):
         """Use the ModelAdmin's paginator."""
         return self.model_admin.get_paginator(self.request, *args, **kwargs)
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..f9a6bd04c9
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+"""
+Final verification that our implementation solves the GitHub issue exactly as described.
+"""
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes'],
+        SECRET_KEY='test',
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+def test_github_issue_example():
+    """Test the exact example from the GitHub issue"""
+    print("Testing GitHub issue example...")
+    
+    # This is the exact pattern from the GitHub issue
+    class CustomAutocompleteJsonView(AutocompleteJsonView):
+        def serialize_result(self, obj, to_field_name):
+            # This is the exact implementation suggested in the issue
+            base_result = super().serialize_result(obj, to_field_name)
+            base_result['notes'] = obj.notes  # Adding custom field
+            return base_result
+    
+    # Create a mock object with notes (simulating a real model)
+    class MockObject:
+        def __init__(self, pk, name, notes):
+            self.pk = pk
+            self.name = name
+            self.notes = notes
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(123, "Test Object", "These are some notes")
+    
+    # Test the custom view
+    custom_view = CustomAutocompleteJsonView()
+    result = custom_view.serialize_result(mock_obj, 'pk')
+    
+    expected = {
+        'id': '123',
+        'text': 'Test Object',
+        'notes': 'These are some notes'
+    }
+    
+    assert result == expected, f"Expected {expected}, got {result}"
+    print("✓ GitHub issue example works perfectly!")
+    
+    # Verify it's much simpler than the old approach
+    print("\nComparison with old approach:")
+    print("Old approach: Override entire get() method with complex code")
+    print("New approach: Simple override of serialize_result() method")
+    print("✓ Maintenance overhead significantly reduced!")
+
+def test_backward_compatibility():
+    """Ensure the base class still works exactly as before"""
+    print("\nTesting backward compatibility...")
+    
+    view = AutocompleteJsonView()
+    
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(456, "Backward Compatible")
+    result = view.serialize_result(mock_obj, 'pk')
+    
+    expected = {'id': '456', 'text': 'Backward Compatible'}
+    assert result == expected, f"Expected {expected}, got {result}"
+    print("✓ Backward compatibility maintained!")
+
+if __name__ == "__main__":
+    test_github_issue_example()
+    test_backward_compatibility()
+    print("\n🎉 Implementation successfully solves the GitHub issue!")
+    print("   - Adds serialize_result() method for easy customization")
+    print("   - Maintains full backward compatibility")
+    print("   - Reduces maintenance overhead significantly")
+    print("   - Follows Django's extension patterns")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dcf263f957
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the autocomplete functionality and demonstrate the new customization capability.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+from django.http import HttpRequest
+from django.test import RequestFactory
+
+# Create a custom AutocompleteJsonView that overrides serialize_result
+class CustomAutocompleteJsonView(AutocompleteJsonView):
+    def serialize_result(self, obj, to_field_name):
+        """Override to add custom fields to autocomplete results"""
+        base_result = super().serialize_result(obj, to_field_name)
+        # Add a custom field - in a real scenario, this would be obj.notes or similar
+        base_result['custom_field'] = f'custom_value_for_{obj.pk}'
+        return base_result
+
+def test_serialize_result_method():
+    """Test that the new serialize_result method works correctly"""
+    print("Testing new serialize_result method...")
+    
+    view = AutocompleteJsonView()
+    
+    # Create a mock object for testing
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(123, "Test Object")
+    
+    # Test the serialize_result method
+    result = view.serialize_result(mock_obj, 'pk')
+    print("Serialized result:", result)
+    
+    expected = {'id': '123', 'text': 'Test Object'}
+    assert result == expected, f"Expected {expected}, got {result}"
+    print("✓ Basic serialize_result test passed")
+
+def test_custom_autocomplete_view():
+    """Test that custom AutocompleteJsonView can override serialize_result"""
+    print("\nTesting custom AutocompleteJsonView...")
+    
+    custom_view = CustomAutocompleteJsonView()
+    
+    # Create a mock object for testing
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(456, "Custom Test Object")
+    
+    # Test the custom serialize_result method
+    result = custom_view.serialize_result(mock_obj, 'pk')
+    print("Custom serialized result:", result)
+    
+    expected_base = {'id': '456', 'text': 'Custom Test Object'}
+    expected_custom = expected_base.copy()
+    expected_custom['custom_field'] = 'custom_value_for_456'
+    assert result == expected_custom, f"Expected {expected_custom}, got {result}"
+    print("✓ Custom serialize_result test passed")
+
+def test_method_override_example():
+    """Demonstrate the example from the GitHub issue"""
+    print("\nTesting the GitHub issue example pattern...")
+    
+    # This mimics the example from the GitHub issue
+    class ExampleAutocompleteJsonView(AutocompleteJsonView):
+        def serialize_result(self, obj, to_field_name):
+            base_result = super().serialize_result(obj, to_field_name)
+            base_result['notes'] = 'example_notes'
+            return base_result
+    
+    example_view = ExampleAutocompleteJsonView()
+    
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+            self.notes = 'example_notes'  # Simulating obj.notes
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(789, "Example Object")
+    
+    result = example_view.serialize_result(mock_obj, 'pk')
+    print("Example serialized result:", result)
+    
+    expected = {'id': '789', 'text': 'Example Object', 'notes': 'example_notes'}
+    assert result == expected, f"Expected {expected}, got {result}"
+    print("✓ GitHub issue example test passed")
+
+if __name__ == "__main__":
+    test_serialize_result_method()
+    test_custom_autocomplete_view()
+    test_method_override_example()
+    print("\n🎉 All tests passed! The refactoring is working correctly.")
\ No newline at end of file
diff --git a/run_single_test.py b/run_single_test.py
new file mode 100644
index 0000000000..bde4ef8208
--- /dev/null
+++ b/run_single_test.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+"""
+Simple script to run a basic autocomplete test to verify our changes don't break existing functionality.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+from django.test import RequestFactory
+from django.contrib.auth.models import User, Group
+from django.contrib import admin
+
+# Create a simple test based on the existing test structure
+def test_basic_autocomplete():
+    """Test that basic autocomplete functionality still works"""
+    print("Testing basic autocomplete functionality...")
+    
+    # Create a test admin site
+    test_site = admin.AdminSite(name='test_admin')
+    
+    # Create a simple model admin with search fields for Group
+    class GroupAdmin(admin.ModelAdmin):
+        search_fields = ['name']
+    
+    test_site.register(Group, GroupAdmin)
+    
+    # Create view instance
+    view = AutocompleteJsonView()
+    view.admin_site = test_site
+    view.request = request  # Set the request attribute
+    
+    # Create a mock request with a foreign key field (User.groups)
+    factory = RequestFactory()
+    request = factory.get('/autocomplete/?app_label=auth&model_name=user&field_name=groups')
+    
+    # Add a mock user to the request for permission checking
+    class MockUser:
+        def has_perm(self, perm):
+            return True
+    
+    request.user = MockUser()
+    
+    try:
+        # This should work for basic functionality test
+        response = view.get(request)
+        print("✓ Basic autocomplete test completed successfully")
+        return True
+    except Exception as e:
+        import traceback
+        print(f"✗ Basic autocomplete test failed: {e}")
+        print("Full traceback:")
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    success = test_basic_autocomplete()
+    if success:
+        print("\n🎉 Basic autocomplete functionality is working correctly!")
+    else:
+        print("\n❌ Basic autocomplete functionality is broken!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_autocomplete_simple.py b/test_autocomplete_simple.py
new file mode 100644
index 0000000000..ea9c66e5c9
--- /dev/null
+++ b/test_autocomplete_simple.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Simple script to test that our autocomplete changes don't break existing functionality.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+from django.test import RequestFactory
+from django.contrib.auth.models import Group
+from django.contrib import admin
+
+def test_serialize_result_method():
+    """Test that the new serialize_result method works correctly"""
+    print("Testing serialize_result method...")
+    
+    view = AutocompleteJsonView()
+    
+    # Create a mock object for testing
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(123, "Test Object")
+    
+    # Test the serialize_result method
+    result = view.serialize_result(mock_obj, 'pk')
+    print("Serialized result:", result)
+    
+    expected = {'id': '123', 'text': 'Test Object'}
+    assert result == expected, f"Expected {expected}, got {result}"
+    print("✓ serialize_result test passed")
+
+def test_custom_serialize_result():
+    """Test that custom AutocompleteJsonView can override serialize_result"""
+    print("\nTesting custom serialize_result override...")
+    
+    class CustomAutocompleteJsonView(AutocompleteJsonView):
+        def serialize_result(self, obj, to_field_name):
+            base_result = super().serialize_result(obj, to_field_name)
+            base_result['custom_field'] = f'custom_value_for_{obj.pk}'
+            return base_result
+    
+    custom_view = CustomAutocompleteJsonView()
+    
+    # Create a mock object for testing
+    class MockObject:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        
+        def __str__(self):
+            return self.name
+    
+    mock_obj = MockObject(456, "Custom Test Object")
+    
+    # Test the custom serialize_result method
+    result = custom_view.serialize_result(mock_obj, 'pk')
+    print("Custom serialized result:", result)
+    
+    expected_base = {'id': '456', 'text': 'Custom Test Object'}
+    expected_custom = expected_base.copy()
+    expected_custom['custom_field'] = 'custom_value_for_456'
+    assert result == expected_custom, f"Expected {expected_custom}, got {result}"
+    print("✓ Custom serialize_result test passed")
+
+if __name__ == "__main__":
+    test_serialize_result_method()
+    test_custom_serialize_result()
+    print("\n🎉 All tests passed! The refactoring is working correctly.")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..1005eb9c3c
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the serialize_result method.
+"""
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes'],
+        SECRET_KEY='test',
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+def test_edge_cases():
+    """Test edge cases for serialize_result"""
+    print("Testing edge cases...")
+    
+    view = AutocompleteJsonView()
+    
+    # Test with non-string ID values
+    class MockObj:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        def __str__(self):
+            return self.name
+    
+    # Test integer ID
+    obj_int = MockObj(123, "Integer ID")
+    result_int = view.serialize_result(obj_int, 'pk')
+    expected_int = {'id': '123', 'text': 'Integer ID'}
+    assert result_int == expected_int, f"Expected {expected_int}, got {result_int}"
+    print("✓ Integer ID conversion works")
+    
+    # Test None value (should be converted to string)
+    obj_none = MockObj(None, "None ID")
+    result_none = view.serialize_result(obj_none, 'pk')
+    expected_none = {'id': 'None', 'text': 'None ID'}
+    assert result_none == expected_none, f"Expected {expected_none}, got {result_none}"
+    print("✓ None ID conversion works")
+    
+    # Test empty string
+    obj_empty = MockObj("", "Empty ID")
+    result_empty = view.serialize_result(obj_empty, 'pk')
+    expected_empty = {'id': '', 'text': 'Empty ID'}
+    assert result_empty == expected_empty, f"Expected {expected_empty}, got {result_empty}"
+    print("✓ Empty string ID works")
+    
+    # Test with different field names
+    class MockObjCustom:
+        def __init__(self, custom_id, name):
+            self.custom_id = custom_id
+            self.name = name
+        def __str__(self):
+            return self.name
+    
+    obj_custom = MockObjCustom(999, "Custom Field")
+    result_custom = view.serialize_result(obj_custom, 'custom_id')
+    expected_custom = {'id': '999', 'text': 'Custom Field'}
+    assert result_custom == expected_custom, f"Expected {expected_custom}, got {result_custom}"
+    print("✓ Custom field name works")
+
+if __name__ == "__main__":
+    test_edge_cases()
+    print("\n🎉 All edge case tests passed!")
\ No newline at end of file
diff --git a/verify_output_format.py b/verify_output_format.py
new file mode 100644
index 0000000000..a73f73fc5b
--- /dev/null
+++ b/verify_output_format.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+"""
+Verify that the output format of the get() method remains unchanged after our refactoring.
+"""
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes'],
+        SECRET_KEY='test',
+    )
+
+django.setup()
+
+from django.contrib.admin.views.autocomplete import AutocompleteJsonView
+
+def test_output_format_consistency():
+    """Verify that the output format remains consistent"""
+    print("Testing output format consistency...")
+    
+    # Create a mock context similar to what get() would receive
+    class MockPage:
+        def has_next(self):
+            return True
+    
+    class MockContext:
+        def __init__(self):
+            self.object_list = []
+            self.page_obj = MockPage()
+    
+    # Create test objects
+    class MockObj:
+        def __init__(self, pk, name):
+            self.pk = pk
+            self.name = name
+        def __str__(self):
+            return self.name
+    
+    obj1 = MockObj(1, "Object One")
+    obj2 = MockObj(2, "Object Two")
+    
+    context = MockContext()
+    context.object_list = [obj1, obj2]
+    
+    # Simulate what the original get() method would produce
+    to_field_name = 'pk'
+    
+    # Original format (before refactoring)
+    original_results = [
+        {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}
+        for obj in context.object_list
+    ]
+    original_output = {
+        'results': original_results,
+        'pagination': {'more': context.page_obj.has_next()},
+    }
+    
+    # New format (after refactoring)
+    view = AutocompleteJsonView()
+    new_results = [
+        view.serialize_result(obj, to_field_name) for obj in context.object_list
+    ]
+    new_output = {
+        'results': new_results,
+        'pagination': {'more': context.page_obj.has_next()},
+    }
+    
+    print("Original output:", original_output)
+    print("New output:", new_output)
+    
+    # Verify they are identical
+    assert original_output == new_output, "Output format changed after refactoring!"
+    print("✓ Output format remains consistent")
+    
+    # Test individual serialize_result calls
+    result1 = view.serialize_result(obj1, to_field_name)
+    expected1 = {'id': '1', 'text': 'Object One'}
+    assert result1 == expected1, f"Expected {expected1}, got {result1}"
+    
+    result2 = view.serialize_result(obj2, to_field_name)
+    expected2 = {'id': '2', 'text': 'Object Two'}
+    assert result2 == expected2, f"Expected {expected2}, got {result2}"
+    
+    print("✓ Individual serialize_result calls work correctly")
+
+if __name__ == "__main__":
+    test_output_format_consistency()
+    print("\n🎉 Output format verification passed!")
\ No newline at end of file