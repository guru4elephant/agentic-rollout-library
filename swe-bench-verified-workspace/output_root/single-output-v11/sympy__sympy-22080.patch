diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..93fe0e29eb
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+"""Script to reproduce the Mod function lambdify bug"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+def test_mod_lambdify_bug():
+    print("Testing Mod function lambdify bug...")
+    
+    x, y = symbols('x y')
+    expr = -Mod(x, y)
+    
+    # Test without modules parameter (should use math/numpy mod)
+    print("\n1. Testing without modules parameter:")
+    f = lambdify([x, y], expr)
+    result1 = f(3, 7)
+    print(f"Result: {result1}")
+    print("Source code:")
+    try:
+        print(inspect.getsource(f))
+    except:
+        print("Could not get source (might be compiled)")
+    
+    # Test with modules=[] (should use Python's built-in % operator)
+    print("\n2. Testing with modules=[]:")
+    g = lambdify([x, y], expr, modules=[])
+    result2 = g(3, 7)
+    print(f"Result: {result2}")
+    print("Source code:")
+    try:
+        print(inspect.getsource(g))
+    except:
+        print("Could not get source (might be compiled)")
+    
+    # Expected behavior: both should return the same result
+    print(f"\nResults should be the same: {result1 == result2}")
+    print(f"Expected result (using direct computation): -Mod(3, 7) = {-3 % 7} = {(-3 % 7)}")
+    
+    return result1, result2
+
+if __name__ == "__main__":
+    test_mod_lambdify_bug()
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..bda9acc094
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""Test script to reproduce the exact GitHub issue behavior"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+def test_exact_github_issue():
+    print("Testing the exact GitHub issue example...")
+    
+    x, y = symbols('x y')
+    expr = -Mod(x, y)
+    
+    print(f"Expression: {expr}")
+    
+    # Test without modules parameter
+    print("\n1. Without modules parameter:")
+    f = lambdify([x, y], expr)
+    result1 = f(3, 7)
+    print(f"Result: {result1}")
+    try:
+        source1 = inspect.getsource(f)
+        print("Source code:")
+        print(source1)
+    except:
+        print("Could not get source code")
+    
+    # Test with modules=[]
+    print("\n2. With modules=[]:")
+    g = lambdify([x, y], expr, modules=[])
+    result2 = g(3, 7)
+    print(f"Result: {result2}")
+    try:
+        source2 = inspect.getsource(g)
+        print("Source code:")
+        print(source2)
+    except:
+        print("Could not get source code")
+    
+    # Check if the results are different (as mentioned in the issue)
+    print(f"\nResults are different: {result1 != result2}")
+    print(f"Expected behavior: Both should return the same result")
+    print(f"Python's -3 % 7: {-3 % 7}")
+
+def test_what_should_happen():
+    print("\n" + "="*60)
+    print("Testing what should happen according to the issue...")
+    
+    # The issue says that with modules=[], the multiplier should be moved into Mod
+    # Let me test if this behavior exists in any form
+    
+    x, y = symbols('x y')
+    
+    # Test various expressions that might trigger the bug
+    expressions = [
+        (-Mod(x, y), "Negative Mod"),
+        (2 * Mod(x, y), "Positive multiplier"),
+        (-2 * Mod(x, y), "Negative multiplier"),
+        (x * Mod(x, y), "Variable multiplier"),
+        (-x * Mod(x, y), "Negative variable multiplier"),
+    ]
+    
+    for expr, desc in expressions:
+        print(f"\nTesting {desc}: {expr}")
+        
+        # Test both module configurations
+        f_normal = lambdify([x, y], expr)
+        f_empty = lambdify([x, y], expr, modules=[])
+        
+        # Get results
+        result_normal = f_normal(3, 7)
+        result_empty = f_empty(3, 7)
+        
+        # Get source code
+        try:
+            source_normal = inspect.getsource(f_normal)
+            source_empty = inspect.getsource(f_empty)
+            
+            print(f"  Normal: {result_normal} -> {source_normal.strip()}")
+            print(f"  Empty:  {result_empty} -> {source_empty.strip()}")
+            
+            # Check if the source codes are different in the way described in the issue
+            if "Mod(" in source_empty and "*" in source_empty:
+                print("  *** POTENTIAL BUG: Multiplier moved into Mod ***")
+            elif source_normal != source_empty:
+                print("  *** SOURCES ARE DIFFERENT ***")
+                
+        except Exception as e:
+            print(f"  Error getting source: {e}")
+
+if __name__ == "__main__":
+    test_exact_github_issue()
+    test_what_should_happen()
\ No newline at end of file
diff --git a/test_mod_issue.py b/test_mod_issue.py
new file mode 100644
index 0000000000..e707bf356c
--- /dev/null
+++ b/test_mod_issue.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+"""Test script to reproduce the specific Mod issue"""
+
+from sympy import Mod, lambdify, symbols
+from sympy.printing.pycode import PythonCodePrinter
+import inspect
+
+def test_mod_printing():
+    print("Testing Mod printing behavior...")
+    
+    x, y = symbols('x y')
+    
+    # Test simple Mod
+    printer = PythonCodePrinter()
+    mod_expr = Mod(x, y)
+    print(f"Mod(x, y): {printer._print_Mod(mod_expr)}")
+    
+    # Test negative Mod
+    neg_mod_expr = -Mod(x, y)
+    print(f"-Mod(x, y): {printer.doprint(neg_mod_expr)}")
+    
+    # Test multiplication with Mod
+    mult_mod_expr = 2 * Mod(x, y)
+    print(f"2 * Mod(x, y): {printer.doprint(mult_mod_expr)}")
+    
+    # Test complex expression with Mod
+    complex_expr = -2 * Mod(x, y)
+    print(f"-2 * Mod(x, y): {printer.doprint(complex_expr)}")
+
+def test_lambdify_behavior():
+    print("\nTesting lambdify behavior...")
+    
+    x, y = symbols('x y')
+    
+    # Test different expressions
+    expressions = [
+        Mod(x, y),
+        -Mod(x, y),
+        2 * Mod(x, y),
+        -2 * Mod(x, y),
+        x * Mod(x, y),
+        -x * Mod(x, y)
+    ]
+    
+    for i, expr in enumerate(expressions):
+        print(f"\nExpression {i+1}: {expr}")
+        
+        # Without modules
+        f = lambdify([x, y], expr)
+        try:
+            source = inspect.getsource(f)
+            print(f"  Without modules: {source.strip()}")
+        except:
+            print("  Without modules: Could not get source")
+        
+        # With modules=[]
+        g = lambdify([x, y], expr, modules=[])
+        try:
+            source = inspect.getsource(g)
+            print(f"  With modules=[]: {source.strip()}")
+        except:
+            print("  With modules=[]: Could not get source")
+
+if __name__ == "__main__":
+    test_mod_printing()
+    test_lambdify_behavior()
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..b6e172fa7b
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+"""Test script to reproduce the exact original issue"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+def test_original_issue():
+    print("Testing the exact original issue from GitHub...")
+    
+    x, y = symbols('x y')
+    expr = -Mod(x, y)
+    
+    print(f"Expression: {expr}")
+    
+    # Test without modules parameter (should use default modules)
+    print("\n1. Without modules parameter:")
+    f = lambdify([x, y], expr)
+    result1 = f(3, 7)
+    print(f"Result: {result1}")
+    try:
+        source1 = inspect.getsource(f)
+        print("Source code:")
+        print(source1)
+    except:
+        print("Could not get source code")
+    
+    # Test with modules=[] (should use Python built-in %)
+    print("\n2. With modules=[]:")
+    g = lambdify([x, y], expr, modules=[])
+    result2 = g(3, 7)
+    print(f"Result: {result2}")
+    try:
+        source2 = inspect.getsource(g)
+        print("Source code:")
+        print(source2)
+    except:
+        print("Could not get source code")
+    
+    print(f"\nResults are the same: {result1 == result2}")
+    print(f"Expected: {-3 % 7} (Python's -3 % 7)")
+    print(f"Direct computation: {-Mod(3, 7)} = {-3 % 7}")
+
+def test_different_behavior():
+    print("\n" + "="*50)
+    print("Testing if there's different behavior in different SymPy versions...")
+    
+    x, y = symbols('x y')
+    
+    # Test various expressions that might trigger the bug
+    test_cases = [
+        (-Mod(x, y), "Negative Mod"),
+        (2 * Mod(x, y), "Positive multiplier"),
+        (-2 * Mod(x, y), "Negative multiplier"),
+        (x * Mod(x, y), "Variable multiplier"),
+        (-x * Mod(x, y), "Negative variable multiplier"),
+    ]
+    
+    for expr, desc in test_cases:
+        print(f"\nTesting {desc}: {expr}")
+        
+        f_normal = lambdify([x, y], expr)
+        f_empty = lambdify([x, y], expr, modules=[])
+        
+        result_normal = f_normal(3, 7)
+        result_empty = f_empty(3, 7)
+        
+        print(f"  Normal: {result_normal}")
+        print(f"  Empty:  {result_empty}")
+        print(f"  Same:   {result_normal == result_empty}")
+
+if __name__ == "__main__":
+    test_original_issue()
+    test_different_behavior()
\ No newline at end of file
diff --git a/test_precedence_issue.py b/test_precedence_issue.py
new file mode 100644
index 0000000000..df55eb33c7
--- /dev/null
+++ b/test_precedence_issue.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""Test script to check precedence handling in Mod printing"""
+
+from sympy import Mod, symbols
+from sympy.printing.pycode import PythonCodePrinter
+from sympy.printing.precedence import precedence
+
+def test_precedence_handling():
+    print("Testing precedence handling in Mod printing...")
+    
+    x, y = symbols('x y')
+    printer = PythonCodePrinter()
+    
+    # Test different Mod expressions
+    expressions = [
+        Mod(x, y),
+        -Mod(x, y),
+        2 * Mod(x, y),
+        -2 * Mod(x, y),
+        x * Mod(x, y),
+        -x * Mod(x, y),
+    ]
+    
+    for expr in expressions:
+        print(f"\nExpression: {expr}")
+        print(f"Precedence: {precedence(expr)}")
+        
+        # Check what _print_Mod does internally
+        if hasattr(expr, 'func') and hasattr(expr.func, '__name__') and expr.func.__name__ == 'Mod':
+            mod_prec = precedence(expr)
+            print(f"Mod precedence: {mod_prec}")
+            
+            # Check how parenthesize works
+            args_parenthesized = []
+            for arg in expr.args:
+                arg_str = printer.parenthesize(arg, mod_prec)
+                args_parenthesized.append(arg_str)
+                print(f"  Arg: {arg}, Parenthesized: {arg_str}")
+            
+            # Simulate what _print_Mod does
+            simulated_result = '{} % {}'.format(*args_parenthesized)
+            print(f"Simulated result: {simulated_result}")
+        
+        # Get actual printed result
+        actual_result = printer.doprint(expr)
+        print(f"Actual result: {actual_result}")
+
+def test_mod_precedence_values():
+    print("\n" + "="*60)
+    print("Testing Mod precedence values...")
+    
+    x, y = symbols('x y')
+    
+    # Test precedence of different Mod expressions
+    mod_expr = Mod(x, y)
+    neg_mod_expr = -Mod(x, y)
+    mult_mod_expr = 2 * Mod(x, y)
+    
+    print(f"Mod(x, y): {precedence(mod_expr)}")
+    print(f"-Mod(x, y): {precedence(neg_mod_expr)}")
+    print(f"2 * Mod(x, y): {precedence(mult_mod_expr)}")
+    
+    # Check if the issue is in the precedence calculation
+    print(f"Type of Mod(x, y): {type(mod_expr)}")
+    print(f"Type of -Mod(x, y): {type(neg_mod_expr)}")
+    print(f"Type of 2 * Mod(x, y): {type(mult_mod_expr)}")
+
+if __name__ == "__main__":
+    test_precedence_handling()
+    test_mod_precedence_values()
\ No newline at end of file
diff --git a/test_printer_behavior.py b/test_printer_behavior.py
new file mode 100644
index 0000000000..6a3c3f9bb7
--- /dev/null
+++ b/test_printer_behavior.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+"""Test script to check printer behavior with different module configurations"""
+
+from sympy import Mod, symbols
+from sympy.utilities.lambdify import lambdify
+from sympy.printing.pycode import PythonCodePrinter
+import inspect
+
+def test_printer_with_different_modules():
+    print("Testing printer behavior with different module configurations...")
+    
+    x, y = symbols('x y')
+    
+    # Test different expressions that might trigger the bug
+    expressions = [
+        -Mod(x, y),
+        2 * Mod(x, y),
+        -2 * Mod(x, y),
+        x * Mod(x, y),
+        -x * Mod(x, y),
+        (x + 1) * Mod(x, y),
+        -(x + 1) * Mod(x, y),
+    ]
+    
+    for expr in expressions:
+        print(f"\nExpression: {expr}")
+        
+        # Test with normal modules
+        f_normal = lambdify([x, y], expr)
+        source_normal = inspect.getsource(f_normal)
+        print(f"Normal: {source_normal.strip()}")
+        
+        # Test with empty modules
+        f_empty = lambdify([x, y], expr, modules=[])
+        source_empty = inspect.getsource(f_empty)
+        print(f"Empty:  {source_empty.strip()}")
+        
+        # Check if they're different
+        if source_normal != source_empty:
+            print("*** DIFFERENCE DETECTED! ***")
+            
+            # Find the difference
+            normal_lines = source_normal.split('\n')
+            empty_lines = source_empty.split('\n')
+            
+            for i, (n_line, e_line) in enumerate(zip(normal_lines, empty_lines)):
+                if n_line != e_line:
+                    print(f"Line {i}:")
+                    print(f"  Normal: {n_line}")
+                    print(f"  Empty:  {e_line}")
+                    break
+
+def test_direct_printing():
+    print("\n" + "="*60)
+    print("Testing direct printing behavior...")
+    
+    x, y = symbols('x y')
+    
+    # Create printers with different namespace configurations
+    printer_normal = PythonCodePrinter()
+    printer_empty = PythonCodePrinter()
+    
+    # Test different expressions
+    expressions = [
+        -Mod(x, y),
+        2 * Mod(x, y),
+        -2 * Mod(x, y),
+        x * Mod(x, y),
+        -x * Mod(x, y),
+        (x + 1) * Mod(x, y),
+        -(x + 1) * Mod(x, y),
+    ]
+    
+    for expr in expressions:
+        print(f"\nExpression: {expr}")
+        
+        normal_print = printer_normal.doprint(expr)
+        empty_print = printer_empty.doprint(expr)
+        
+        print(f"Normal printer: {normal_print}")
+        print(f"Empty printer:  {empty_print}")
+        
+        if normal_print != empty_print:
+            print("*** DIFFERENCE IN DIRECT PRINTING! ***")
+
+if __name__ == "__main__":
+    test_printer_with_different_modules()
+    test_direct_printing()
\ No newline at end of file
diff --git a/test_specific_issue.py b/test_specific_issue.py
new file mode 100644
index 0000000000..1286aef992
--- /dev/null
+++ b/test_specific_issue.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python3
+"""Test script to check for the specific issue with multiplier movement"""
+
+from sympy import Mod, lambdify, symbols
+from sympy.printing.pycode import PythonCodePrinter
+import inspect
+
+def test_multiplier_movement():
+    print("Testing if multipliers are incorrectly moved into Mod arguments...")
+    
+    x, y = symbols('x y')
+    printer = PythonCodePrinter()
+    
+    # Test cases that might trigger the bug
+    test_cases = [
+        (-Mod(x, y), "Negative Mod"),
+        (2 * Mod(x, y), "Positive constant multiplier"),
+        (-2 * Mod(x, y), "Negative constant multiplier"),
+        (x * Mod(x, y), "Variable multiplier"),
+        (-x * Mod(x, y), "Negative variable multiplier"),
+        ((x + 1) * Mod(x, y), "Expression multiplier"),
+        (-(x + 1) * Mod(x, y), "Negative expression multiplier"),
+    ]
+    
+    for expr, desc in test_cases:
+        print(f"\n{desc}: {expr}")
+        
+        # Get the printed representation
+        printed = printer.doprint(expr)
+        print(f"  Printed: {printed}")
+        
+        # Check if the multiplier is incorrectly moved into Mod
+        if printed.count('%') > 1:
+            print("  WARNING: Multiple % operators detected - might indicate the bug!")
+        
+        # Check if the structure looks wrong
+        if printed.startswith('Mod(') and '*' in printed:
+            print("  WARNING: Mod with multiplication detected - might indicate the bug!")
+        
+        # Test lambdify behavior
+        try:
+            f_normal = lambdify([x, y], expr)
+            f_empty = lambdify([x, y], expr, modules=[])
+            
+            # Get source code
+            source_normal = inspect.getsource(f_normal)
+            source_empty = inspect.getsource(f_empty)
+            
+            print(f"  Normal modules source: {source_normal.strip()}")
+            print(f"  Empty modules source:  {source_empty.strip()}")
+            
+            # Check if sources are different
+            if source_normal != source_empty:
+                print("  DIFFERENCE DETECTED! Sources are not identical")
+                
+        except Exception as e:
+            print(f"  Error getting source: {e}")
+
+def test_direct_evaluation():
+    print("\n" + "="*60)
+    print("Testing direct evaluation of expressions...")
+    
+    x, y = symbols('x y')
+    
+    # Test the exact case from the GitHub issue
+    expr = -Mod(x, y)
+    print(f"Expression: {expr}")
+    
+    # Evaluate symbolically
+    result_symbolic = expr.subs({x: 3, y: 7})
+    print(f"Symbolic evaluation: {result_symbolic}")
+    
+    # Test with different approaches
+    approaches = [
+        (lambda: lambdify([x, y], expr)(3, 7), "Normal lambdify"),
+        (lambda: lambdify([x, y], expr, modules=[])(3, 7), "Empty modules lambdify"),
+        (lambda: (-3) % 7, "Python direct"),
+    ]
+    
+    for approach, desc in approaches:
+        try:
+            result = approach()
+            print(f"{desc}: {result}")
+        except Exception as e:
+            print(f"{desc}: Error - {e}")
+
+if __name__ == "__main__":
+    test_multiplier_movement()
+    test_direct_evaluation()
\ No newline at end of file