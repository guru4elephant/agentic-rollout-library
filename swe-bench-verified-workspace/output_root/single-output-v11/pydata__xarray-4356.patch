diff --git a/debug_path_test.py b/debug_path_test.py
new file mode 100644
index 00000000..511bc15c
--- /dev/null
+++ b/debug_path_test.py
@@ -0,0 +1,35 @@
+import xarray as xr
+import numpy as np
+
+# Let's add some debug prints to see which path is taken
+from xarray.core.nanops import _replace_nan, _maybe_null_out
+from xarray.core.duck_array_ops import _dask_or_eager_func
+
+# Monkey patch for debugging
+original_maybe_null_out = _maybe_null_out
+
+def debug_maybe_null_out(result, axis, mask, min_count=1):
+    print(f"DEBUG: result.ndim = {getattr(result, 'ndim', 'no ndim')}")
+    print(f"DEBUG: axis = {axis}")
+    print(f"DEBUG: result.shape = {getattr(result, 'shape', 'no shape')}")
+    
+    if axis is not None and getattr(result, "ndim", 0) > 0:
+        print("DEBUG: Taking array path")
+    elif getattr(result, "dtype", None) not in xr.core.dtypes.NAT_TYPES:
+        print("DEBUG: Taking scalar path")
+    else:
+        print("DEBUG: Taking other path")
+    
+    return original_maybe_null_out(result, axis, mask, min_count)
+
+# Temporarily replace the function
+import xarray.core.nanops
+xarray.core.nanops._maybe_null_out = debug_maybe_null_out
+
+# Test the case
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+result = da_nan.sum(["dim_0", "dim_1"], min_count=5)
+print("Final result:", result.values)
+
+# Restore original function
+xarray.core.nanops._maybe_null_out = original_maybe_null_out
\ No newline at end of file
diff --git a/debug_result_type.py b/debug_result_type.py
new file mode 100644
index 00000000..8ff32003
--- /dev/null
+++ b/debug_result_type.py
@@ -0,0 +1,29 @@
+import xarray as xr
+import numpy as np
+
+# Let's debug what the result object actually is
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+result = da_nan.sum(["dim_0", "dim_1"], min_count=5)
+
+print("Result:", result)
+print("Result values:", result.values)
+print("Result type:", type(result.values))
+print("Result ndim:", result.values.ndim)
+print("Result shape:", result.values.shape)
+
+# Let's also check what the mask looks like after summing
+from xarray.core.nanops import _replace_nan
+from xarray.core.duck_array_ops import _dask_or_eager_func
+
+a, mask = _replace_nan(da_nan.values, 0)
+mask_sum = mask.sum(axis=(0, 1))
+print("Mask sum:", mask_sum)
+print("Mask sum type:", type(mask_sum))
+print("Mask sum ndim:", mask_sum.ndim if hasattr(mask_sum, 'ndim') else 'No ndim')
+
+# Let's manually check the logic
+total_elements = np.take(mask.shape, [0, 1]).prod()
+print("Total elements:", total_elements)
+null_mask = (total_elements - mask_sum - 5) < 0
+print("Null mask:", null_mask)
+print("Null mask type:", type(null_mask))
\ No newline at end of file
diff --git a/debug_shape_test.py b/debug_shape_test.py
new file mode 100644
index 00000000..344b1f99
--- /dev/null
+++ b/debug_shape_test.py
@@ -0,0 +1,43 @@
+import xarray as xr
+import numpy as np
+
+# Let's debug what happens inside _maybe_null_out
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+print("Original array shape:", da_nan.shape)
+
+# Let's manually trace through what happens
+from xarray.core.nanops import _replace_nan, _maybe_null_out
+from xarray.core.duck_array_ops import _dask_or_eager_func
+
+# Step 1: Replace NaN with 0 and get mask
+a, mask = _replace_nan(da_nan.values, 0)
+print("After replace_nan:")
+print("a shape:", a.shape, "a:", a)
+print("mask shape:", mask.shape, "mask:", mask)
+
+# Step 2: Sum along all axes
+axis = [0, 1]  # equivalent to ["dim_0", "dim_1"]
+result = _dask_or_eager_func("sum")(a, axis=tuple(axis))
+print("After sum:")
+print("result shape:", result.shape, "result:", result)
+print("result.ndim:", result.ndim)
+
+# Step 3: Check what happens in _maybe_null_out
+# Let's trace the logic
+if axis is not None and getattr(result, "ndim", False):
+    print("Taking array path...")
+    if hasattr(axis, "__len__"):
+        total_elements = np.take(mask.shape, axis).prod()
+    else:
+        total_elements = mask.shape[axis]
+    
+    print("total_elements:", total_elements)
+    
+    mask_sum = mask.sum(axis=tuple(axis))
+    print("mask.sum(axis) shape:", mask_sum.shape, "value:", mask_sum)
+    
+    null_mask = (total_elements - mask_sum - 5) < 0
+    print("null_mask:", null_mask)
+    
+else:
+    print("Taking scalar path...")
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 00000000..f5ae037a
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,22 @@
+import xarray as xr
+import numpy as np
+
+# Test the specific case where min_count should cause NaN result
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+print("Array with NaN values:")
+print(da_nan)
+
+# Count non-NaN elements
+non_nan_count = da_nan.count()
+print(f"Non-NaN elements: {non_nan_count.values}")
+
+# Test with min_count higher than valid elements
+print("\nTesting min_count=5 (should result in NaN):")
+result = da_nan.sum(["dim_0", "dim_1"], min_count=5)
+print(f"Result: {result.values}")
+print(f"Result type: {type(result.values)}")
+
+# Let's also check what happens with single dimension
+print("\nTesting single dimension with high min_count:")
+result_single = da_nan.sum("dim_0", min_count=5)  # Should have NaN in some positions
+print(f"Single dim result: {result_single.values}")
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 00000000..baa31407
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,44 @@
+import xarray as xr
+import numpy as np
+
+print("Final comprehensive test...")
+
+# Test 1: Original issue from GitHub
+print("\n1. Original GitHub issue:")
+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+result = da.sum(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values} (expected: 21.0)")
+
+# Test 2: Single dimension (should still work)
+print("\n2. Single dimension:")
+result = da.sum("dim_0", min_count=1)
+print(f"   Result: {result.values} (expected: [5. 7. 9.])")
+
+# Test 3: Array with NaN values
+print("\n3. Array with NaN values:")
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+result = da_nan.sum(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values} (expected: 13.0)")
+
+# Test 4: min_count higher than valid elements
+print("\n4. min_count higher than valid elements:")
+result = da_nan.sum(["dim_0", "dim_1"], min_count=5)
+print(f"   Result: {result.values} (expected: nan)")
+
+# Test 5: 3D array
+print("\n5. 3D array:")
+da_3d = xr.DataArray(np.ones((2, 3, 4)))
+result = da_3d.sum(["dim_0", "dim_1", "dim_2"], min_count=1)
+print(f"   Result: {result.values} (expected: 24.0)")
+
+# Test 6: nanprod with multiple dimensions
+print("\n6. nanprod with multiple dimensions:")
+result = da.prod(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values} (expected: 720.0)")
+
+# Test 7: nanprod with NaN values and high min_count
+print("\n7. nanprod with NaN values and high min_count:")
+result = da_nan.prod(["dim_0", "dim_1"], min_count=5)
+print(f"   Result: {result.values} (expected: nan)")
+
+print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..8d1a8966
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,14 @@
+import xarray as xr
+
+# Reproduce the issue described in the GitHub issue
+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+print("DataArray:")
+print(da)
+
+try:
+    result = da.sum(["dim_0", "dim_1"], min_count=1)
+    print("Success! Result:")
+    print(result)
+except Exception as e:
+    print(f"Error: {e}")
+    print(f"Error type: {type(e)}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..231dfaa6
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,34 @@
+import xarray as xr
+import numpy as np
+
+print("Testing edge cases for sum with min_count and multiple dimensions...")
+
+# Test 1: Original case - should work now
+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+print("\n1. Original case:")
+result = da.sum(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values}")
+
+# Test 2: Single dimension - should still work
+print("\n2. Single dimension:")
+result = da.sum("dim_0", min_count=1)
+print(f"   Result: {result.values}")
+
+# Test 3: Array with NaN values
+print("\n3. Array with NaN values:")
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+result = da_nan.sum(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values}")
+
+# Test 4: min_count higher than valid elements
+print("\n4. min_count higher than valid elements:")
+result = da_nan.sum(["dim_0", "dim_1"], min_count=5)  # Only 4 non-NaN elements
+print(f"   Result: {result.values}")
+
+# Test 5: 3D array
+print("\n5. 3D array:")
+da_3d = xr.DataArray(np.ones((2, 3, 4)))
+result = da_3d.sum(["dim_0", "dim_1", "dim_2"], min_count=1)
+print(f"   Result: {result.values}")
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 00000000..6a70d3a1
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,44 @@
+"""
+Test script to verify the GitHub issue is fixed.
+This reproduces the exact example from the GitHub issue.
+"""
+
+import xarray as xr
+
+def test_github_issue():
+    """Test the exact example from the GitHub issue."""
+    print("Testing the exact GitHub issue example...")
+    
+    # This is the exact code from the GitHub issue
+    da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+    result = da.sum(["dim_0", "dim_1"], min_count=1)
+    
+    print(f"DataArray: {da}")
+    print(f"Result: {result}")
+    print(f"Result value: {result.values}")
+    
+    # Verify the result is correct
+    expected = 21.0  # Sum of all elements: 1+2+3+4+5+6 = 21
+    assert result.values == expected, f"Expected {expected}, got {result.values}"
+    
+    print("âœ“ GitHub issue test passed!")
+
+def test_with_nan_values():
+    """Test with NaN values to ensure min_count works correctly."""
+    print("\nTesting with NaN values...")
+    
+    da = xr.DataArray([[1., 2, 3], [4, 5, float('nan')]])
+    result = da.sum(["dim_0", "dim_1"], min_count=6)  # Only 5 non-NaN elements
+    
+    print(f"DataArray: {da}")
+    print(f"Result with min_count=6: {result}")
+    
+    # Should return nan since there are only 5 valid elements but min_count=6
+    assert result.values != result.values, "Expected nan result"  # nan != nan
+    
+    print("âœ“ NaN values test passed!")
+
+if __name__ == "__main__":
+    test_github_issue()
+    test_with_nan_values()
+    print("\nðŸŽ‰ All tests passed! The GitHub issue has been fixed.")
\ No newline at end of file
diff --git a/test_nanprod.py b/test_nanprod.py
new file mode 100644
index 00000000..579150f8
--- /dev/null
+++ b/test_nanprod.py
@@ -0,0 +1,23 @@
+import xarray as xr
+import numpy as np
+
+print("Testing nanprod with min_count and multiple dimensions...")
+
+# Test nanprod with multiple dimensions
+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])
+print("1. Original case:")
+result = da.prod(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values}")
+
+# Test with NaN values
+da_nan = xr.DataArray([[1., np.nan, 3], [4, 5, np.nan]])
+print("\n2. Array with NaN values:")
+result = da_nan.prod(["dim_0", "dim_1"], min_count=1)
+print(f"   Result: {result.values}")
+
+# Test with min_count higher than valid elements
+print("\n3. min_count higher than valid elements:")
+result = da_nan.prod(["dim_0", "dim_1"], min_count=5)
+print(f"   Result: {result.values}")
+
+print("\nAll nanprod tests completed!")
\ No newline at end of file
diff --git a/xarray/core/nanops.py b/xarray/core/nanops.py
index 41c8d258..05e89415 100644
--- a/xarray/core/nanops.py
+++ b/xarray/core/nanops.py
@@ -26,13 +26,29 @@ def _maybe_null_out(result, axis, mask, min_count=1):
     """
     xarray version of pandas.core.nanops._maybe_null_out
     """
-    if hasattr(axis, "__len__"):  # if tuple or list
-        raise ValueError(
-            "min_count is not available for reduction with more than one dimensions."
-        )
-
-    if axis is not None and getattr(result, "ndim", False):
-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0
+    # Handle the case where we have axis information but result is 0-dimensional
+    # (this happens when summing over all dimensions)
+    if axis is not None and getattr(result, "ndim", 0) == 0:
+        if hasattr(axis, "__len__"):  # if tuple or list
+            # For multiple dimensions, calculate total elements across all specified axes
+            total_elements = np.take(mask.shape, axis).prod()
+        else:
+            # For single dimension, use the shape directly
+            total_elements = mask.shape[axis]
+        
+        valid_elements = total_elements - mask.sum(axis=tuple(axis) if hasattr(axis, "__len__") else axis)
+        if valid_elements < min_count:
+            result = np.nan
+    
+    elif axis is not None and getattr(result, "ndim", 0) > 0:
+        if hasattr(axis, "__len__"):  # if tuple or list
+            # For multiple dimensions, calculate total elements across all specified axes
+            total_elements = np.take(mask.shape,axis).prod()
+        else:
+            # For single dimension, use the shape directly
+            total_elements = mask.shape[axis]
+        
+        null_mask = (total_elements - mask.sum(axis) - min_count) < 0
         if null_mask.any():
             dtype, fill_value = dtypes.maybe_promote(result.dtype)
             result = result.astype(dtype)