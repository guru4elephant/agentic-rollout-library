diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..95f558a37
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the symlink directory collection issue.
+This script creates a test directory structure with symlinks and
+tests whether pytest collects tests from symlinked directories.
+"""
+
+import os
+import tempfile
+import shutil
+import subprocess
+import sys
+from pathlib import Path
+
+def create_test_structure():
+    """Create a test directory structure with symlinks"""
+    # Create a temporary directory
+    test_dir = Path(tempfile.mkdtemp(prefix="pytest_symlink_test_"))
+    print(f"Creating test structure in: {test_dir}")
+    
+    # Create main test directory
+    main_test_dir = test_dir / "main_tests"
+    main_test_dir.mkdir()
+    
+    # Create a test file in main directory
+    (main_test_dir / "test_main.py").write_text("def test_main(): assert True\n")
+    
+    # Create a subdirectory with tests
+    sub_dir = test_dir / "sub_tests"
+    sub_dir.mkdir()
+    (sub_dir / "test_sub.py").write_text("def test_sub(): assert True\n")
+    
+    # Create symlink to subdirectory in main test directory
+    symlink_path = main_test_dir / "symlinked_sub"
+    try:
+        symlink_path.symlink_to(sub_dir, target_is_directory=True)
+        print(f"Created symlink: {symlink_path} -> {sub_dir}")
+    except OSError as e:
+        print(f"Failed to create symlink: {e}")
+        # Clean up and exit
+        shutil.rmtree(test_dir)
+        return None
+    
+    return test_dir
+
+def run_pytest_collection(test_dir):
+    """Run pytest collection on the test directory"""
+    main_test_dir = test_dir / "main_tests"
+    
+    print(f"\nRunning pytest collection on: {main_test_dir}")
+    
+    # Run pytest with collection only
+    result = subprocess.run([
+        sys.executable, "-m", "pytest", 
+        str(main_test_dir), 
+        "--collect-only", "-q"
+    ], capture_output=True, text=True, cwd="/testbed")
+    
+    print("STDOUT:")
+    print(result.stdout)
+    print("STDERR:")
+    print(result.stderr)
+    print(f"Return code: {result.returncode}")
+    
+    return result
+
+def main():
+    """Main test function"""
+    test_dir = create_test_structure()
+    if test_dir is None:
+        return
+    
+    try:
+        result = run_pytest_collection(test_dir)
+        
+        # Check if symlinked tests were collected
+        collected_tests = result.stdout.strip().split('\n')
+        symlinked_tests_collected = any("symlinked_sub" in test for test in collected_tests)
+        
+        print(f"\nSymlinked tests collected: {symlinked_tests_collected}")
+        
+        if not symlinked_tests_collected:
+            print("ISSUE CONFIRMED: Symlinked directory tests were not collected!")
+            print("This matches the reported issue.")
+        else:
+            print("Symlinked directory tests were collected - issue may be fixed.")
+            
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py
index f0bdb1481..b96cba069 100644
--- a/src/_pytest/pathlib.py
+++ b/src/_pytest/pathlib.py
@@ -558,7 +558,7 @@ def visit(
     entries = sorted(os.scandir(path), key=lambda entry: entry.name)
     yield from entries
     for entry in entries:
-        if entry.is_dir(follow_symlinks=False) and recurse(entry):
+        if entry.is_dir() and recurse(entry):
             yield from visit(entry.path, recurse)
 
 
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..2df602fe1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,145 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for symlink directory collection fix.
+This tests various scenarios to ensure the fix is robust.
+"""
+
+import os
+import tempfile
+import shutil
+import subprocess
+import sys
+from pathlib import Path
+
+def create_complex_test_structure():
+    """Create a complex test directory structure with multiple symlinks"""
+    test_dir = Path(tempfile.mkdtemp(prefix="pytest_symlink_complex_test_"))
+    print(f"Creating complex test structure in: {test_dir}")
+    
+    # Create main test directory
+    main_test_dir = test_dir / "main_tests"
+    main_test_dir.mkdir()
+    
+    # Create test files in main directory
+    (main_test_dir / "test_main.py").write_text("def test_main(): assert True\n")
+    
+    # Create multiple subdirectories with tests
+    sub_dir1 = test_dir / "sub_tests_1"
+    sub_dir1.mkdir()
+    (sub_dir1 / "test_sub1.py").write_text("def test_sub1(): assert True\n")
+    
+    sub_dir2 = test_dir / "sub_tests_2"
+    sub_dir2.mkdir()
+    (sub_dir2 / "test_sub2.py").write_text("def test_sub2(): assert True\n")
+    
+    # Create nested directory structure
+    nested_dir = test_dir / "nested_tests"
+    nested_dir.mkdir()
+    (nested_dir / "test_nested.py").write_text("def test_nested(): assert True\n")
+    
+    deep_nested = nested_dir / "deep"
+    deep_nested.mkdir()
+    (deep_nested / "test_deep.py").write_text("def test_deep(): assert True\n")
+    
+    # Create multiple symlinks
+    try:
+        # Symlink to subdirectory 1
+        symlink1 = main_test_dir / "symlinked_sub1"
+        symlink1.symlink_to(sub_dir1, target_is_directory=True)
+        print(f"Created symlink: {symlink1} -> {sub_dir1}")
+        
+        # Symlink to subdirectory 2
+        symlink2 = main_test_dir / "symlinked_sub2"
+        symlink2.symlink_to(sub_dir2, target_is_directory=True)
+        print(f"Created symlink: {symlink2} -> {sub_dir2}")
+        
+        # Symlink to nested directory
+        symlink3 = main_test_dir / "symlinked_nested"
+        symlink3.symlink_to(nested_dir, target_is_directory=True)
+        print(f"Created symlink: {symlink3} -> {nested_dir}")
+        
+        # Symlink to a file (should not be collected as directory)
+        symlink4 = main_test_dir / "symlink_to_file"
+        symlink4.symlink_to(sub_dir1 / "test_sub1.py")
+        print(f"Created file symlink: {symlink4} -> {sub_dir1 / 'test_sub1.py'}")
+        
+    except OSError as e:
+        print(f"Failed to create symlinks: {e}")
+        shutil.rmtree(test_dir)
+        return None
+    
+    return test_dir
+
+def run_pytest_collection(test_dir):
+    """Run pytest collection on the test directory"""
+    main_test_dir = test_dir / "main_tests"
+    
+    print(f"\nRunning pytest collection on: {main_test_dir}")
+    
+    # Run pytest with collection only
+    result = subprocess.run([
+        sys.executable, "-m", "pytest", 
+        str(main_test_dir), 
+        "--collect-only", "-q"
+    ], capture_output=True, text=True, cwd="/testbed")
+    
+    print("STDOUT:")
+    print(result.stdout)
+    print("STDERR:")
+    print(result.stderr)
+    print(f"Return code: {result.returncode}")
+    
+    return result
+
+def analyze_results(result, expected_tests):
+    """Analyze the pytest collection results"""
+    collected_tests = result.stdout.strip().split('\n')
+    collected_tests = [test for test in collected_tests if test]  # Remove empty lines
+    
+    print(f"\nCollected {len(collected_tests)} tests:")
+    for test in collected_tests:
+        print(f"  {test}")
+    
+    # Check if all expected tests were collected
+    missing_tests = []
+    for expected_test in expected_tests:
+        if not any(expected_test in test for test in collected_tests):
+            missing_tests.append(expected_test)
+    
+    if missing_tests:
+        print(f"\nMISSING TESTS: {missing_tests}")
+        return False
+    
+    print("\nAll expected tests were collected!")
+    return True
+
+def main():
+    """Main test function"""
+    test_dir = create_complex_test_structure()
+    if test_dir is None:
+        return
+    
+    try:
+        # Expected tests that should be collected
+        expected_tests = [
+            "test_main.py::test_main",
+            "symlinked_sub1/test_sub1.py::test_sub1",
+            "symlinked_sub2/test_sub2.py::test_sub2", 
+            "symlinked_nested/test_nested.py::test_nested",
+            "symlinked_nested/deep/test_deep.py::test_deep"
+        ]
+        
+        result = run_pytest_collection(test_dir)
+        success = analyze_results(result, expected_tests)
+        
+        if success:
+            print("SUCCESS: All symlinked directory tests were properly collected!")
+        else:
+            print("FAILURE: Some symlinked directory tests were not collected!")
+            
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/test_regular_directories.py b/test_regular_directories.py
new file mode 100644
index 000000000..5f2d80d2e
--- /dev/null
+++ b/test_regular_directories.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+"""
+Test that regular directory traversal still works correctly after our fix.
+"""
+
+import os
+import tempfile
+import shutil
+import subprocess
+import sys
+from pathlib import Path
+
+def create_regular_test_structure():
+    """Create a regular test directory structure (no symlinks)"""
+    test_dir = Path(tempfile.mkdtemp(prefix="pytest_regular_test_"))
+    print(f"Creating regular test structure in: {test_dir}")
+    
+    # Create main test directory
+    main_test_dir = test_dir / "main_tests"
+    main_test_dir.mkdir()
+    
+    # Create test files in main directory
+    (main_test_dir / "test_main.py").write_text("def test_main(): assert True\n")
+    
+    # Create regular subdirectories with tests
+    sub_dir1 = main_test_dir / "sub_tests_1"
+    sub_dir1.mkdir()
+    (sub_dir1 / "test_sub1.py").write_text("def test_sub1(): assert True\n")
+    
+    sub_dir2 = main_test_dir / "sub_tests_2"
+    sub_dir2.mkdir()
+    (sub_dir2 / "test_sub2.py").write_text("def test_sub2(): assert True\n")
+    
+    # Create nested directory structure
+    nested_dir = main_test_dir / "nested_tests"
+    nested_dir.mkdir()
+    (nested_dir / "test_nested.py").write_text("def test_nested(): assert True\n")
+    
+    deep_nested = nested_dir / "deep"
+    deep_nested.mkdir()
+    (deep_nested / "test_deep.py").write_text("def test_deep(): assert True\n")
+    
+    return test_dir
+
+def run_pytest_collection(test_dir):
+    """Run pytest collection on the test directory"""
+    main_test_dir = test_dir / "main_tests"
+    
+    print(f"\nRunning pytest collection on: {main_test_dir}")
+    
+    # Run pytest with collection only
+    result = subprocess.run([
+        sys.executable, "-m", "pytest", 
+        str(main_test_dir), 
+        "--collect-only", "-q"
+    ], capture_output=True, text=True, cwd="/testbed")
+    
+    print("STDOUT:")
+    print(result.stdout)
+    print("STDERR:")
+    print(result.stderr)
+    print(f"Return code: {result.returncode}")
+    
+    return result
+
+def analyze_results(result, expected_tests):
+    """Analyze the pytest collection results"""
+    collected_tests = result.stdout.strip().split('\n')
+    collected_tests = [test for test in collected_tests if test]  # Remove empty lines
+    
+    print(f"\nCollected {len(collected_tests)} tests:")
+    for test in collected_tests:
+        print(f"  {test}")
+    
+    # Check if all expected tests were collected
+    missing_tests = []
+    for expected_test in expected_tests:
+        if not any(expected_test in test for test in collected_tests):
+            missing_tests.append(expected_test)
+    
+    if missing_tests:
+        print(f"\nMISSING TESTS: {missing_tests}")
+        return False
+    
+    print("\nAll expected tests were collected!")
+    return True
+
+def main():
+    """Main test function"""
+    test_dir = create_regular_test_structure()
+    if test_dir is None:
+        return
+    
+    try:
+        # Expected tests that should be collected
+        expected_tests = [
+            "test_main.py::test_main",
+            "sub_tests_1/test_sub1.py::test_sub1",
+            "sub_tests_2/test_sub2.py::test_sub2", 
+            "nested_tests/test_nested.py::test_nested",
+            "nested_tests/deep/test_deep.py::test_deep"
+        ]
+        
+        result = run_pytest_collection(test_dir)
+        success = analyze_results(result, expected_tests)
+        
+        if success:
+            print("SUCCESS: Regular directory traversal is working correctly!")
+        else:
+            print("FAILURE: Regular directory traversal is broken!")
+            
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file