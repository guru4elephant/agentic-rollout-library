diff --git a/check_html_structure.py b/check_html_structure.py
new file mode 100644
index 000000000..86802f503
--- /dev/null
+++ b/check_html_structure.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+
+import os
+import shutil
+import subprocess
+import tempfile
+
+def check_html_structure():
+    # Create a temporary directory for testing
+    with tempfile.TemporaryDirectory() as tmpdir:
+        os.chdir(tmpdir)
+        
+        # Create the test module
+        with open('type_hint_test.py', 'w') as f:
+            f.write("""def f1() -> None: return None
+def f2() -> int: return 42
+""")
+        
+        # Create docs directory
+        os.makedirs('docs', exist_ok=True)
+        
+        # Create conf.py with signature mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'signature'
+""")
+        
+        # Create index.rst
+        with open('docs/index.rst', 'w') as f:
+            f.write(""".. automodule:: type_hint_test
+.. autofunction:: f1
+.. autofunction:: f2
+""")
+        
+        # Create html directory
+        os.makedirs('html_sig', exist_ok=True)
+        
+        # Run sphinx
+        subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html_sig'
+        ], capture_output=True)
+        
+        # Check HTML structure for signature mode
+        if os.path.exists('html_sig/index.html'):
+            with open('html_sig/index.html', 'r') as f:
+                content = f.read()
+                print("=== SIGNATURE MODE ===")
+                # Look for f1 and f2 function documentation and return types
+                lines = content.split('\n')
+                for i, line in enumerate(lines):
+                    if 'f1' in line or 'f2' in line or 'return' in line or 'rtype' in line:
+                        print(f"Line {i}: {line.strip()}")
+        
+        # Now test with description mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'description'
+""")
+        
+        # Create html directory
+        os.makedirs('html_desc', exist_ok=True)
+        
+        # Run sphinx again
+        subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html_desc'
+        ], capture_output=True)
+        
+        # Check HTML structure for description mode
+        if os.path.exists('html_desc/index.html'):
+            with open('html_desc/index.html', 'r') as f:
+                content = f.read()
+                print("\n=== DESCRIPTION MODE ===")
+                # Look for f1 and f2 function documentation and return types
+                lines = content.split('\n')
+                for i, line in enumerate(lines):
+                    if 'f1' in line or 'f2' in line or 'return' in line or 'rtype' in line:
+                        print(f"Line {i}: {line.strip()}")
+
+if __name__ == '__main__':
+    check_html_structure()
\ No newline at end of file
diff --git a/examine_html.py b/examine_html.py
new file mode 100644
index 000000000..71563ba39
--- /dev/null
+++ b/examine_html.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+
+import os
+import shutil
+import subprocess
+import tempfile
+
+def examine_html():
+    # Create a temporary directory for testing
+    with tempfile.TemporaryDirectory() as tmpdir:
+        os.chdir(tmpdir)
+        
+        # Create the test module
+        with open('type_hint_test.py', 'w') as f:
+            f.write("""def f1() -> None: return None
+def f2() -> int: return 42
+""")
+        
+        # Create docs directory
+        os.makedirs('docs', exist_ok=True)
+        
+        # Create conf.py with signature mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'signature'
+""")
+        
+        # Create index.rst
+        with open('docs/index.rst', 'w') as f:
+            f.write(""".. automodule:: type_hint_test
+.. autofunction:: f1
+.. autofunction:: f2
+""")
+        
+        # Create html directory
+        os.makedirs('html_sig', exist_ok=True)
+        
+        # Run sphinx
+        result = subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html_sig'
+        ], capture_output=True, text=True)
+        
+        print("Sphinx build output (signature mode):")
+        print(result.stdout)
+        if result.stderr:
+            print("Sphinx build errors (signature mode):")
+            print(result.stderr)
+        
+        # Now test with description mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'description'
+""")
+        
+        # Create html directory
+        os.makedirs('html_desc', exist_ok=True)
+        
+        # Run sphinx again
+        result = subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html_desc'
+        ], capture_output=True, text=True)
+        
+        print("\nSphinx build output (description mode):")
+        print(result.stdout)
+        if result.stderr:
+            print("Sphinx build errors (description mode):")
+            print(result.stderr)
+        
+        # Save the HTML files for examination
+        print("\nHTML files saved:")
+        print("  Signature mode: html_sig/index.html")
+        print("  Description mode: html_desc/index.html")
+
+if __name__ == '__main__':
+    examine_html()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..96cafe9d0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python3
+
+import os
+import shutil
+import subprocess
+import tempfile
+
+def reproduce_issue():
+    # Create a temporary directory for testing
+    with tempfile.TemporaryDirectory() as tmpdir:
+        os.chdir(tmpdir)
+        
+        # Create the test module
+        with open('type_hint_test.py', 'w') as f:
+            f.write("""def f1() -> None: return None
+def f2() -> int: return 42
+""")
+        
+        # Create docs directory
+        os.makedirs('docs', exist_ok=True)
+        
+        # Create conf.py with signature mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'signature'
+nitpicky = True
+""")
+        
+        # Create index.rst
+        with open('docs/index.rst', 'w') as f:
+            f.write(""".. automodule:: type_hint_test
+.. autofunction:: f1
+.. autofunction:: f2
+""")
+        
+        # Create html directory
+        os.makedirs('html', exist_ok=True)
+        
+        # Run sphinx
+        result = subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html'
+        ], capture_output=True, text=True)
+        
+        print("Sphinx build output:")
+        print(result.stdout)
+        if result.stderr:
+            print("Sphinx build errors:")
+            print(result.stderr)
+        
+        # Check for HTML content
+        print("\nHTML content in signature mode:")
+        if os.path.exists('html/index.html'):
+            with open('html/index.html', 'r') as f:
+                content = f.read()
+                print("Content around f1 and f2 functions:")
+                # Look for f1 and f2 function documentation
+                lines = content.split('\n')
+                for i, line in enumerate(lines):
+                    if 'f1' in line or 'f2' in line:
+                        print(f"Line {i}: {line.strip()}")
+                        # Show some context
+                        for j in range(max(0, i-2), min(len(lines), i+3)):
+                            if j != i:
+                                print(f"  Line {j}: {lines[j].strip()}")
+        
+        # Now test with description mode
+        with open('docs/conf.py', 'w') as f:
+            f.write("""extensions = ["sphinx.ext.autodoc", "sphinx.ext.intersphinx"]
+intersphinx_mapping = {"python": ("https://docs.python.org/3", None)}
+autodoc_typehints = 'description'
+nitpicky = True
+""")
+        
+        # Clean html directory
+        shutil.rmtree('html')
+        os.makedirs('html', exist_ok=True)
+        
+        # Run sphinx again
+        result = subprocess.run([
+            'python', '-m', 'sphinx', '-nW', '-b', 'html', '--keep-going', 'docs', 'html'
+        ], capture_output=True, text=True)
+        
+        print("\nSphinx build output (description mode):")
+        print(result.stdout)
+        if result.stderr:
+            print("Sphinx build errors (description mode):")
+            print(result.stderr)
+        
+        # Check for HTML content
+        print("\nHTML content in description mode:")
+        if os.path.exists('html/index.html'):
+            with open('html/index.html', 'r') as f:
+                content = f.read()
+                print("Content around f1 and f2 functions:")
+                # Look for f1 and f2 function documentation
+                lines = content.split('\n')
+                for i, line in enumerate(lines):
+                    if 'f1' in line or 'f2' in line:
+                        print(f"Line {i}: {line.strip()}")
+                        # Show some context
+                        for j in range(max(0, i-2), min(len(lines), i+3)):
+                            if j != i:
+                                print(f"  Line {j}: {lines[j].strip()}")
+
+if __name__ == '__main__':
+    reproduce_issue()
\ No newline at end of file
diff --git a/setup.py b/setup.py
index a427d5493..978e3d8e0 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py
index eb38d232c..23f1833a5 100644
--- a/sphinx/util/typing.py
+++ b/sphinx/util/typing.py
@@ -48,7 +48,7 @@ def stringify(annotation: Any) -> str:
     elif not annotation:
         return repr(annotation)
     elif annotation is NoneType:  # type: ignore
-        return 'None'
+        return ':class:`None`'
     elif (getattr(annotation, '__module__', None) == 'builtins' and
           hasattr(annotation, '__qualname__')):
         return annotation.__qualname__
diff --git a/test_complete_process.py b/test_complete_process.py
new file mode 100644
index 000000000..7fb6b5feb
--- /dev/null
+++ b/test_complete_process.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.domains.python import PythonDomain, _parse_annotation
+from sphinx.addnodes import desc_signature
+from docutils import nodes
+
+# Create a mock signature node
+signode = desc_signature('', '')
+
+# Test the complete process for return annotation
+retann = "None"
+print(f"Processing return annotation: {retann}")
+
+# This is what happens in handle_signature
+children = _parse_annotation(retann)
+print(f"Parsed annotation children: {children}")
+
+# This creates the desc_returns node
+returns_node = nodes.paragraph('', '', *children)
+print(f"Returns node: {returns_node}")
+print(f"Returns node children: {list(returns_node.children)}")
+
+# Test with int as well
+retann2 = "int"
+print(f"\nProcessing return annotation: {retann2}")
+children2 = _parse_annotation(retann2)
+print(f"Parsed annotation children: {children2}")
+
+returns_node2 = nodes.paragraph('', '', *children2)
+print(f"Returns node: {returns_node2}")
+print(f"Returns node children: {list(returns_node2.children)}")
\ No newline at end of file
diff --git a/test_parse_annotation.py b/test_parse_annotation.py
new file mode 100644
index 000000000..47a3ad04c
--- /dev/null
+++ b/test_parse_annotation.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.domains.python import _parse_annotation
+from docutils import nodes
+
+# Test what _parse_annotation does with "None"
+result = _parse_annotation("None")
+print("Result of _parse_annotation('None'):")
+for i, node in enumerate(result):
+    print(f"  {i}: {node} ({type(node)})")
+
+# Test what _parse_annotation does with "int"  
+result2 = _parse_annotation("int")
+print("\nResult of _parse_annotation('int'):")
+for i, node in enumerate(result2):
+    print(f"  {i}: {node} ({type(node)})")
\ No newline at end of file
diff --git a/test_parse_annotation_none.py b/test_parse_annotation_none.py
new file mode 100644
index 000000000..f163b285a
--- /dev/null
+++ b/test_parse_annotation_none.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.domains.python import _parse_annotation
+from docutils import nodes
+
+# Test what _parse_annotation does with "None"
+result = _parse_annotation("None")
+print("Result of _parse_annotation('None'):")
+for i, node in enumerate(result):
+    print(f"  {i}: {node} ({type(node)})")
+    print(f"    refdomain: {node.get('refdomain')}")
+    print(f"    reftype: {node.get('reftype')}")  
+    print(f"    reftarget: {node.get('reftarget')}")
+
+# Test what _parse_annotation does with "int"
+result2 = _parse_annotation("int")
+print("\nResult of _parse_annotation('int'):")
+for i, node in enumerate(result2):
+    print(f"  {i}: {node} ({type(node)})")
+    print(f"    refdomain: {node.get('refdomain')}")
+    print(f"    reftype: {node.get('reftype')}")
+    print(f"    reftarget: {node.get('reftarget')}")
\ No newline at end of file
diff --git a/test_python_domain.py b/test_python_domain.py
new file mode 100644
index 000000000..0c916dca6
--- /dev/null
+++ b/test_python_domain.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.domains.python import PythonDomain
+from sphinx.addnodes import desc_signature
+import re
+
+# Test the regex pattern used by Python domain
+py_sig_re = re.compile(
+    r'''^ ([\w.]*\.)?            # class name(s)
+          (\w+)  \s*             # thing name
+          (?: \(\s*(.*)\s*\)     # optional: arguments
+           (?:\s* -> \s* (.*))?  #           return annotation
+          )? $                   # and nothing more
+          ''', re.VERBOSE)
+
+# Test signatures that would be generated
+test_signatures = [
+    "f1() -> None",
+    "f2() -> int", 
+    "func(arg: int) -> str",
+]
+
+for sig in test_signatures:
+    m = py_sig_re.match(sig)
+    if m:
+        print(f"Signature: {sig}")
+        print(f"  Groups: {m.groups()}")
+        print(f"  Return annotation: {m.group(4)}")
+        print()
+    else:
+        print(f"Signature: {sig} - NO MATCH")
+        print()
\ No newline at end of file
diff --git a/test_signature.py b/test_signature.py
new file mode 100644
index 000000000..dedb4c8b1
--- /dev/null
+++ b/test_signature.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.util.inspect import stringify_signature
+from inspect import signature
+
+def f1() -> None: return None
+def f2() -> int: return 42
+
+# Test what stringify_signature returns
+sig1 = signature(f1)
+sig2 = signature(f2)
+
+print("Signature for f1:", stringify_signature(sig1))
+print("Signature for f2:", stringify_signature(sig2))
+
+# Test the regex parsing
+import re
+py_sig_re = re.compile(
+    r'''^ ([\w.]*\.)?            # class name(s)
+          (\w+)  \s*             # thing name
+          (?: \(\s*(.*)\s*\)     # optional: arguments
+           (?:\s* -> \s* (.*))?  #           return annotation
+          )? $                   # and nothing more
+          ''', re.VERBOSE)
+
+# Test what the regex matches for the complete signature
+test_sig1 = "f1() -> None"
+test_sig2 = "f2() -> int"
+
+m1 = py_sig_re.match(test_sig1)
+m2 = py_sig_re.match(test_sig2)
+
+print("\nRegex match for f1:", m1.groups() if m1 else "No match")
+print("Regex match for f2:", m2.groups() if m2 else "No match")
\ No newline at end of file
diff --git a/test_signature_processing.py b/test_signature_processing.py
new file mode 100644
index 000000000..324a50e79
--- /dev/null
+++ b/test_signature_processing.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.domains.python import PythonDomain
+from sphinx.addnodes import desc_signature
+from docutils import nodes
+
+# Create a mock Python domain instance
+domain = PythonDomain(None, 'py')
+
+# Create a mock signature node
+signode = desc_signature('', '')
+
+# Test the handle_signature method with different signatures
+test_signatures = [
+    "f1() -> None",
+    "f2() -> int",
+]
+
+for sig in test_signatures:
+    print(f"\nProcessing signature: {sig}")
+    try:
+        fullname, prefix = domain.handle_signature(sig, signode)
+        print(f"  Fullname: {fullname}")
+        print(f"  Prefix: {prefix}")
+        print(f"  Signode children: {len(signode.children)}")
+        for i, child in enumerate(signode.children):
+            print(f"    {i}: {child} ({type(child)})")
+    except Exception as e:
+        print(f"  Error: {e}")
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index d9f040544..bf39854b6 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3