diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..b470db0e78
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the Choices enum fix works correctly.
+"""
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.db import models
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils.translation import gettext_lazy as _
+from django.core.exceptions import ValidationError
+
+class MyTextChoice(models.TextChoices):
+    FIRST_CHOICE = "first", _("The first choice")
+    SECOND_CHOICE = "second", _("The second choice")
+
+class MyIntegerChoice(models.IntegerChoices):
+    FIRST_CHOICE = 1, _("The first choice")
+    SECOND_CHOICE = 2, _("The second choice")
+
+class TestModel(models.Model):
+    text_field = models.CharField(max_length=10, choices=MyTextChoice.choices)
+    int_field = models.IntegerField(choices=MyIntegerChoice.choices)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_field_to_python():
+    print("Testing field to_python methods...")
+    
+    # Test CharField
+    char_field = models.CharField(max_length=10, choices=MyTextChoice.choices)
+    result = char_field.to_python(MyTextChoice.FIRST_CHOICE)
+    assert result == "first", f"Expected 'first', got {result}"
+    assert isinstance(result, str), f"Expected str, got {type(result)}"
+    print("✓ CharField.to_python works correctly")
+    
+    # Test IntegerField
+    int_field = models.IntegerField(choices=MyIntegerChoice.choices)
+    result = int_field.to_python(MyIntegerChoice.FIRST_CHOICE)
+    assert result == 1, f"Expected 1, got {result}"
+    assert isinstance(result, int), f"Expected int, got {type(result)}"
+    print("✓ IntegerField.to_python works correctly")
+    
+    # Test that normal values still work
+    result = char_field.to_python("test")
+    assert result == "test", f"Expected 'test', got {result}"
+    assert isinstance(result, str), f"Expected str, got {type(result)}"
+    
+    result = int_field.to_python(42)
+    assert result == 42, f"Expected 42, got {result}"
+    assert isinstance(result, int), f"Expected int, got {type(result)}"
+    print("✓ Normal values still work correctly")
+
+def test_model_validation():
+    print("Testing model validation...")
+    
+    # Create model instance with enum values
+    obj = TestModel(
+        text_field=MyTextChoice.FIRST_CHOICE,
+        int_field=MyIntegerChoice.FIRST_CHOICE
+    )
+    
+    # Call clean_fields to trigger validation and conversion
+    obj.clean_fields()
+    
+    # Check that values were converted
+    assert obj.text_field == "first", f"Expected 'first', got {obj.text_field}"
+    assert isinstance(obj.text_field, str), f"Expected str, got {type(obj.text_field)}"
+    
+    assert obj.int_field == 1, f"Expected 1, got {obj.int_field}"
+    assert isinstance(obj.int_field, int), f"Expected int, got {type(obj.int_field)}"
+    print("✓ Model validation converts enum values correctly")
+
+def test_string_representation():
+    print("Testing string representation...")
+    
+    obj = TestModel(
+        text_field=MyTextChoice.FIRST_CHOICE,
+        int_field=MyIntegerChoice.FIRST_CHOICE
+    )
+    
+    # Call clean_fields to trigger conversion
+    obj.clean_fields()
+    
+    # Test string representation
+    assert str(obj.text_field) == "first", f"Expected 'first', got {str(obj.text_field)}"
+    assert str(obj.int_field) == "1", f"Expected '1', got {str(obj.int_field)}"
+    print("✓ String representation works correctly")
+
+if __name__ == "__main__":
+    test_field_to_python()
+    test_model_validation()
+    test_string_representation()
+    print("\n✅ All tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index d610dc86f0..00594fb2f4 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -14,6 +14,7 @@ from django.conf import settings
 from django.core import checks, exceptions, validators
 from django.db import connection, connections, router
 from django.db.models.constants import LOOKUP_SEP
+from django.db.models.enums import Choices, IntegerChoices, TextChoices
 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
 from django.utils import timezone
 from django.utils.datastructures import DictWrapper
@@ -578,6 +579,9 @@ class Field(RegisterLookupMixin):
         django.core.exceptions.ValidationError if the data can't be converted.
         Return the converted value. Subclasses should override this.
         """
+        # Handle Choices enums by returning their value property
+        if isinstance(value, (Choices, IntegerChoices, TextChoices)):
+            return value.value
         return value
 
     @cached_property
@@ -1008,6 +1012,9 @@ class CharField(Field):
         return "CharField"
 
     def to_python(self, value):
+        # Handle Choices enums by returning their value property
+        if isinstance(value, (Choices, IntegerChoices, TextChoices)):
+            return value.value
         if isinstance(value, str) or value is None:
             return value
         return str(value)
@@ -1767,6 +1774,9 @@ class IntegerField(Field):
         return "IntegerField"
 
     def to_python(self, value):
+        # Handle Choices enums by returning their value property
+        if isinstance(value, (Choices, IntegerChoices, TextChoices)):
+            return value.value
         if value is None:
             return value
         try:
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..14e6e23bba
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the TextChoices/IntegerChoices field type issue.
+"""
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.db import models
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils.translation import gettext_lazy as _
+
+class MyChoice(models.TextChoices):
+    FIRST_CHOICE = "first", _("The first choice, it is")
+    SECOND_CHOICE = "second", _("The second choice, it is")
+
+class MyObject(models.Model):
+    my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)
+
+    class Meta:
+        app_label = 'test'
+
+def test_issue():
+    print("Testing TextChoices field type issue...")
+    
+    # Create a model instance without saving to database
+    obj = MyObject(my_str_value=MyChoice.FIRST_CHOICE)
+    print(f"Created object: {obj}")
+    print(f"Object my_str_value: {obj.my_str_value}")
+    print(f"Type of my_str_value: {type(obj.my_str_value)}")
+    print(f"String representation: {str(obj.my_str_value)}")
+    print(f"Expected string: 'first'")
+    
+    # Check if it's a string
+    print(f"Is instance of str: {isinstance(obj.my_str_value, str)}")
+    
+    # Test the enum value itself
+    print(f"\nEnum value: {MyChoice.FIRST_CHOICE}")
+    print(f"Enum value type: {type(MyChoice.FIRST_CHOICE)}")
+    print(f"Enum string representation: {str(MyChoice.FIRST_CHOICE)}")
+    print(f"Enum value property: {MyChoice.FIRST_CHOICE.value}")
+    print(f"Enum value property type: {type(MyChoice.FIRST_CHOICE.value)}")
+    
+    # Test what happens when we call clean_fields
+    print(f"\nAfter calling clean_fields():")
+    try:
+        obj.clean_fields()
+        print(f"Object my_str_value: {obj.my_str_value}")
+        print(f"Type of my_str_value: {type(obj.my_str_value)}")
+        print(f"String representation: {str(obj.my_str_value)}")
+    except Exception as e:
+        print(f"Error during clean_fields: {e}")
+
+if __name__ == "__main__":
+    test_issue()
\ No newline at end of file
diff --git a/test_integer_choices.py b/test_integer_choices.py
new file mode 100644
index 0000000000..3b09466149
--- /dev/null
+++ b/test_integer_choices.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""
+Test to verify that IntegerField handles IntegerChoices correctly.
+"""
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.db import models
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils.translation import gettext_lazy as _
+
+class MyIntegerChoice(models.IntegerChoices):
+    FIRST_CHOICE = 1, _("The first choice")
+    SECOND_CHOICE = 2, _("The second choice")
+
+# Create a field and test to_python directly
+field = models.IntegerField(choices=MyIntegerChoice.choices)
+
+def test_to_python():
+    print("Testing IntegerField to_python method with IntegerChoices...")
+    
+    # Test with enum value
+    result = field.to_python(MyIntegerChoice.FIRST_CHOICE)
+    print(f"to_python(MyIntegerChoice.FIRST_CHOICE) = {result}")
+    print(f"Type: {type(result)}")
+    
+    # Test with integer value
+    result = field.to_python(1)
+    print(f"to_python(1) = {result}")
+    print(f"Type: {type(result)}")
+    
+    # Test with string value
+    result = field.to_python("1")
+    print(f"to_python('1') = {result}")
+    print(f"Type: {type(result)}")
+
+if __name__ == "__main__":
+    test_to_python()
\ No newline at end of file
diff --git a/test_to_python.py b/test_to_python.py
new file mode 100644
index 0000000000..83284db6ed
--- /dev/null
+++ b/test_to_python.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""
+Test to verify that to_python method is called correctly.
+"""
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+# Set up Django environment
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')
+
+import django
+from django.conf import settings
+from django.db import models
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.utils.translation import gettext_lazy as _
+
+class MyChoice(models.TextChoices):
+    FIRST_CHOICE = "first", _("The first choice, it is")
+    SECOND_CHOICE = "second", _("The second choice, it is")
+
+# Create a field and test to_python directly
+field = models.CharField(max_length=10, choices=MyChoice.choices)
+
+def test_to_python():
+    print("Testing to_python method directly...")
+    
+    # Test with enum value
+    result = field.to_python(MyChoice.FIRST_CHOICE)
+    print(f"to_python(MyChoice.FIRST_CHOICE) = {result}")
+    print(f"Type: {type(result)}")
+    
+    # Test with string value
+    result = field.to_python("first")
+    print(f"to_python('first') = {result}")
+    print(f"Type: {type(result)}")
+    
+    # Test with other value
+    result = field.to_python(123)
+    print(f"to_python(123) = {result}")
+    print(f"Type: {type(result)}")
+
+if __name__ == "__main__":
+    test_to_python()
\ No newline at end of file