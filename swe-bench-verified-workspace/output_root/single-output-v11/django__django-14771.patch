diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..f545e1bc02
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test script to verify that -X options are handled correctly
+"""
+
+import sys
+import os
+from pathlib import Path
+
+def simulate_get_child_arguments():
+    """
+    Simulate the get_child_arguments function from Django's autoreload.py
+    """
+    import __main__
+    py_script = Path(sys.argv[0])
+
+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    # Add -X options if any are present
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        args += ['-X%s' % key for key in sys._xoptions]
+    
+    # __spec__ is set when the server was started with the `-m` option,
+    # see https://docs.python.org/3/reference/import.html#main-spec
+    # __spec__ may not exist, e.g. when running in a Conda env.
+    if getattr(__main__, '__spec__', None) is not None:
+        spec = __main__.__spec__
+        if (spec.name == '__main__' or spec.name.endswith('.__main__')) and spec.parent:
+            name = spec.parent
+        else:
+            name = spec.name
+        args += ['-m', name]
+        args += sys.argv[1:]
+    elif not py_script.exists():
+        # sys.argv[0] may not exist for several reasons on Windows.
+        # It may exist with a .exe extension or have a -script.py suffix.
+        exe_entrypoint = py_script.with_suffix('.exe')
+        if exe_entrypoint.exists():
+            # Should be executed directly, ignoring sys.executable.
+            return [exe_entrypoint, *sys.argv[1:]]
+        script_entrypoint = py_script.with_name('%s-script.py' % py_script.name)
+        if script_entrypoint.exists():
+            # Should be executed as usual.
+            return [*args, script_entrypoint, *sys.argv[1:]]
+        raise RuntimeError('Script %s does not exist.' % py_script)
+    else:
+        args += sys.argv
+    return args
+
+def test_with_xoptions():
+    """Test with -X options present"""
+    print("Testing with -X options...")
+    print(f"sys._xoptions: {sys._xoptions}")
+    
+    args = simulate_get_child_arguments()
+    print(f"Command args: {args}")
+    
+    # Check if -X options are preserved
+    x_options_count = sum(1 for arg in args if arg.startswith('-X'))
+    expected_count = len(sys._xoptions) if hasattr(sys, '_xoptions') and sys._xoptions else 0
+    
+    print(f"Expected -X options: {expected_count}, Found: {x_options_count}")
+    
+    return x_options_count == expected_count and expected_count > 0
+
+def test_without_xoptions():
+    """Test without -X options present"""
+    print("Testing without -X options...")
+    print(f"sys._xoptions: {sys._xoptions}")
+    
+    args = simulate_get_child_arguments()
+    print(f"Command args: {args}")
+    
+    # Check that no -X options are added when none exist
+    x_options_count = sum(1 for arg in args if arg.startswith('-X'))
+    expected_count = 0
+    
+    print(f"Expected -X options: {expected_count}, Found: {x_options_count}")
+    
+    return x_options_count == expected_count
+
+if __name__ == "__main__":
+    # Test with -X options (if any were provided)
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        success1 = test_with_xoptions()
+    else:
+        success1 = True  # No -X options to test, this is fine
+    
+    # Test that the function doesn't break when no -X options exist
+    success2 = test_without_xoptions()
+    
+    if success1 and success2:
+        print("SUCCESS: All tests passed!")
+        sys.exit(0)
+    else:
+        print("FAILURE: Some tests failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py
index cc65c043ab..082e55581c 100644
--- a/django/utils/autoreload.py
+++ b/django/utils/autoreload.py
@@ -220,6 +220,9 @@ def get_child_arguments():
     py_script = Path(sys.argv[0])
 
     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    # Add -X options if any are present
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        args += ['-X%s' % key for key in sys._xoptions]
     # __spec__ is set when the server was started with the `-m` option,
     # see https://docs.python.org/3/reference/import.html#main-spec
     # __spec__ may not exist, e.g. when running in a Conda env.
diff --git a/final_reproduction_test.py b/final_reproduction_test.py
new file mode 100644
index 0000000000..4aadcfb24b
--- /dev/null
+++ b/final_reproduction_test.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+"""
+Final test to reproduce the exact issue from the GitHub issue:
+Auto-reloader should pass -X options (for cpython implementation)
+"""
+
+import sys
+import subprocess
+import os
+from pathlib import Path
+
+# Add the current directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.utils import autoreload
+
+def test_original_issue_reproduction():
+    """
+    Reproduce the original issue scenario:
+    - Start with -X utf8 option
+    - The auto-reloader should preserve this option when restarting
+    """
+    print("Reproducing the original GitHub issue...")
+    print(f"Current sys._xoptions: {sys._xoptions}")
+    
+    # Simulate the get_child_arguments call that happens during auto-reload
+    args = autoreload.get_child_arguments()
+    
+    print(f"Auto-reloader would execute: {args}")
+    
+    # Check if -X options are preserved
+    x_options_preserved = any(arg.startswith('-X') for arg in args)
+    x_options_count = sum(1 for arg in args if arg.startswith('-X'))
+    
+    print(f"-X options preserved: {x_options_preserved}")
+    print(f"Number of -X options: {x_options_count}")
+    
+    # For the specific case mentioned in the issue (-X utf8)
+    if 'utf8' in sys._xoptions:
+        utf8_preserved = any(arg == '-Xutf8' for arg in args)
+        print(f"-X utf8 preserved: {utf8_preserved}")
+        
+        if utf8_preserved:
+            print("✅ SUCCESS: -X utf8 option is preserved by the auto-reloader!")
+            return True
+        else:
+            print("❌ FAILURE: -X utf8 option is NOT preserved by the auto-reloader!")
+            return False
+    else:
+        print("ℹ️  No -X utf8 option to test (run with -X utf8 to test this specific case)")
+        return x_options_preserved
+
+def test_encoding_behavior():
+    """
+    Test that the encoding behavior works as expected with -X utf8
+    This simulates the open() call behavior mentioned in the issue
+    """
+    print("\nTesting encoding behavior with -X utf8...")
+    
+    # This should show the effect of -X utf8 on open() encoding
+    with open("test_file.txt", "w") as f:
+        f.write("test")
+    
+    with open("test_file.txt", "r") as f:
+        encoding = f.encoding
+        print(f"File encoding: {encoding}")
+    
+    # Clean up
+    if os.path.exists("test_file.txt"):
+        os.remove("test_file.txt")
+    
+    return True
+
+if __name__ == "__main__":
+    print("=" * 60)
+    print("FINAL TEST: Auto-reloader -X options preservation")
+    print("=" * 60)
+    
+    success1 = test_original_issue_reproduction()
+    success2 = test_encoding_behavior()
+    
+    if success1 and success2:
+        print("\n🎉 ALL TESTS PASSED! The issue has been resolved.")
+        print("The auto-reloader now correctly preserves -X options when restarting.")
+        sys.exit(0)
+    else:
+        print("\n❌ SOME TESTS FAILED! The issue may not be fully resolved.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..478bbbfa0e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with -X options not being passed in auto-reloader
+"""
+
+import sys
+import subprocess
+import os
+
+def test_xoptions_preservation():
+    """Test if -X options are preserved in subprocess calls"""
+    print("Testing -X options preservation...")
+    print(f"Current sys._xoptions: {sys._xoptions}")
+    
+    # Simulate what get_child_arguments does
+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    
+    # Add the current script and some test arguments
+    args += [__file__, '--test']
+    
+    print(f"Command args: {args}")
+    
+    # Run the subprocess and capture output
+    result = subprocess.run(args, capture_output=True, text=True)
+    print(f"Subprocess stdout: {result.stdout}")
+    print(f"Subprocess stderr: {result.stderr}")
+    print(f"Subprocess return code: {result.returncode}")
+
+if __name__ == "__main__":
+    if len(sys.argv) > 1 and sys.argv[1] == '--test':
+        # This is the subprocess execution
+        print(f"In subprocess - sys._xoptions: {sys._xoptions}")
+        print(f"In subprocess - sys.argv: {sys.argv}")
+    else:
+        test_xoptions_preservation()
\ No newline at end of file
diff --git a/test_autoreload_fix.py b/test_autoreload_fix.py
new file mode 100644
index 0000000000..8cdd043d16
--- /dev/null
+++ b/test_autoreload_fix.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+"""Test script to verify the autoreload fix doesn't break existing functionality"""
+
+import sys
+import os
+from unittest import mock
+from pathlib import Path
+
+# Add the current directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.utils import autoreload
+
+def test_basic_functionality():
+    """Test basic functionality without -X options"""
+    print("Testing basic functionality...")
+    
+    with mock.patch('sys.argv', [__file__, 'runserver']), mock.patch('sys.warnoptions', []):
+        result = autoreload.get_child_arguments()
+        expected = [sys.executable, __file__, 'runserver']
+        print(f"Result: {result}")
+        print(f"Expected: {expected}")
+        assert result == expected, f"Expected {expected}, got {result}"
+        print("✓ Basic functionality test passed")
+
+def test_warnoptions():
+    """Test with warnoptions"""
+    print("Testing warnoptions...")
+    
+    with mock.patch('sys.argv', [__file__, 'runserver']), mock.patch('sys.warnoptions', ['error']):
+        result = autoreload.get_child_arguments()
+        expected = [sys.executable, '-Werror', __file__, 'runserver']
+        print(f"Result: {result}")
+        print(f"Expected: {expected}")
+        assert result == expected, f"Expected {expected}, got {result}"
+        print("✓ Warnoptions test passed")
+
+def test_xoptions():
+    """Test with -X options"""
+    print("Testing -X options...")
+    
+    with mock.patch('sys.argv', [__file__, 'runserver']), mock.patch('sys.warnoptions', []):
+        # Mock sys._xoptions
+        original_xoptions = getattr(sys, '_xoptions', {})
+        sys._xoptions = {'utf8': True}
+        
+        result = autoreload.get_child_arguments()
+        expected = [sys.executable, '-Xutf8', __file__, 'runserver']
+        print(f"Result: {result}")
+        print(f"Expected: {expected}")
+        assert result == expected, f"Expected {expected}, got {result}"
+        print("✓ Xoptions test passed")
+        
+        # Restore original _xoptions
+        if hasattr(sys, '_xoptions'):
+            sys._xoptions = original_xoptions
+
+def test_multiple_xoptions():
+    """Test with multiple -X options"""
+    print("Testing multiple -X options...")
+    
+    with mock.patch('sys.argv', [__file__, 'runserver']), mock.patch('sys.warnoptions', []):
+        # Mock sys._xoptions
+        original_xoptions = getattr(sys, '_xoptions', {})
+        sys._xoptions = {'utf8': True, 'dev': True}
+        
+        result = autoreload.get_child_arguments()
+        expected = [sys.executable, '-Xutf8', '-Xdev', __file__, 'runserver']
+        print(f"Result: {result}")
+        print(f"Expected: {expected}")
+        assert result == expected, f"Expected {expected}, got {result}"
+        print("✓ Multiple Xoptions test passed")
+        
+        # Restore original _xoptions
+        if hasattr(sys, '_xoptions'):
+            sys._xoptions = original_xoptions
+
+def test_no_xoptions():
+    """Test that no -X options are added when none exist"""
+    print("Testing no -X options...")
+    
+    with mock.patch('sys.argv', [__file__, 'runserver']), mock.patch('sys.warnoptions', []):
+        # Ensure _xoptions is empty
+        original_xoptions = getattr(sys, '_xoptions', {})
+        if hasattr(sys, '_xoptions'):
+            sys._xoptions = {}
+        
+        result = autoreload.get_child_arguments()
+        expected = [sys.executable, __file__, 'runserver']
+        print(f"Result: {result}")
+        print(f"Expected: {expected}")
+        assert result == expected, f"Expected {expected}, got {result}"
+        print("✓ No Xoptions test passed")
+        
+        # Restore original _xoptions
+        if hasattr(sys, '_xoptions'):
+            sys._xoptions = original_xoptions
+
+if __name__ == "__main__":
+    try:
+        test_basic_functionality()
+        test_warnoptions()
+        test_xoptions()
+        test_multiple_xoptions()
+        test_no_xoptions()
+        print("\n🎉 All tests passed! The fix is working correctly.")
+    except Exception as e:
+        print(f"\n❌ Test failed: {e}")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..9ef309b046
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that -X options are preserved in the auto-reloader
+"""
+
+import sys
+import os
+from pathlib import Path
+
+def simulate_get_child_arguments():
+    """
+    Simulate the get_child_arguments function from Django's autoreload.py
+    """
+    import __main__
+    py_script = Path(sys.argv[0])
+
+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    # Add -X options if any are present
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        args += ['-X%s' % key for key in sys._xoptions]
+    
+    # __spec__ is set when the server was started with the `-m` option,
+    # see https://docs.python.org/3/reference/import.html#main-spec
+    # __spec__ may not exist, e.g. when running in a Conda env.
+    if getattr(__main__, '__spec__', None) is not None:
+        spec = __main__.__spec__
+        if (spec.name == '__main__' or spec.name.endswith('.__main__')) and spec.parent:
+            name = spec.parent
+        else:
+            name = spec.name
+        args += ['-m', name]
+        args += sys.argv[1:]
+    elif not py_script.exists():
+        # sys.argv[0] may not exist for several reasons on Windows.
+        # It may exist with a .exe extension or have a -script.py suffix.
+        exe_entrypoint = py_script.with_suffix('.exe')
+        if exe_entrypoint.exists():
+            # Should be executed directly, ignoring sys.executable.
+            return [exe_entrypoint, *sys.argv[1:]]
+        script_entrypoint = py_script.with_name('%s-script.py' % py_script.name)
+        if script_entrypoint.exists():
+            # Should be executed as usual.
+            return [*args, script_entrypoint, *sys.argv[1:]]
+        raise RuntimeError('Script %s does not exist.' % py_script)
+    else:
+        args += sys.argv
+    return args
+
+def test_xoptions_preservation():
+    """Test if -X options are preserved"""
+    print("Testing -X options preservation in auto-reloader simulation...")
+    print(f"Original sys._xoptions: {sys._xoptions}")
+    
+    # Simulate what get_child_arguments does
+    args = simulate_get_child_arguments()
+    
+    print(f"Command args: {args}")
+    
+    # Check if -X options are preserved
+    x_options_preserved = any(arg.startswith('-X') for arg in args)
+    print(f"-X options preserved: {x_options_preserved}")
+    
+    return x_options_preserved
+
+if __name__ == "__main__":
+    success = test_xoptions_preservation()
+    if success:
+        print("SUCCESS: -X options are being preserved!")
+        sys.exit(0)
+    else:
+        print("FAILURE: -X options are not being preserved!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_no_xoptions_attribute.py b/test_no_xoptions_attribute.py
new file mode 100644
index 0000000000..822ae31229
--- /dev/null
+++ b/test_no_xoptions_attribute.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Test that the fix works when sys._xoptions doesn't exist"""
+
+import sys
+from pathlib import Path
+
+# Add the current directory to Python path
+sys.path.insert(0, '/testbed')
+
+from django.utils import autoreload
+
+def test_no_xoptions_attribute():
+    """Test that the code works when sys._xoptions doesn't exist"""
+    print("Testing with no sys._xoptions attribute...")
+    
+    # Save original _xoptions if it exists
+    original_xoptions = None
+    if hasattr(sys, '_xoptions'):
+        original_xoptions = sys._xoptions
+        del sys._xoptions
+    
+    try:
+        # This should not raise an AttributeError
+        result = autoreload.get_child_arguments()
+        print(f"Success: {result}")
+        print("✓ No AttributeError when sys._xoptions doesn't exist")
+        return True
+    except AttributeError as e:
+        print(f"❌ AttributeError: {e}")
+        return False
+    finally:
+        # Restore original _xoptions if it existed
+        if original_xoptions is not None:
+            sys._xoptions = original_xoptions
+
+if __name__ == "__main__":
+    success = test_no_xoptions_attribute()
+    if success:
+        print("\n🎉 Test passed! The fix handles missing sys._xoptions correctly.")
+        sys.exit(0)
+    else:
+        print("\n❌ Test failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_with_xoptions.py b/test_with_xoptions.py
new file mode 100644
index 0000000000..cc50f5d0a0
--- /dev/null
+++ b/test_with_xoptions.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Test script to verify -X options are preserved when they exist"""
+
+import sys
+from pathlib import Path
+
+def simulate_get_child_arguments():
+    """Simulate the get_child_arguments function"""
+    import __main__
+    py_script = Path(sys.argv[0])
+
+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    # Add -X options if any are present
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        args += ['-X%s' % key for key in sys._xoptions]
+    
+    # Simplified for testing
+    args += sys.argv
+    return args
+
+def main():
+    print("Testing with -X options...")
+    print(f"sys._xoptions: {sys._xoptions}")
+    
+    args = simulate_get_child_arguments()
+    print(f"Command args: {args}")
+    
+    # Check if -X options are preserved
+    x_options_count = sum(1 for arg in args if arg.startswith('-X'))
+    expected_count = len(sys._xoptions) if hasattr(sys, '_xoptions') and sys._xoptions else 0
+    
+    print(f"Expected -X options: {expected_count}, Found: {x_options_count}")
+    
+    if x_options_count == expected_count and expected_count > 0:
+        print("SUCCESS: -X options are being preserved!")
+        return True
+    else:
+        print("FAILURE: -X options are not being preserved correctly!")
+        return False
+
+if __name__ == "__main__":
+    success = main()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_without_xoptions.py b/test_without_xoptions.py
new file mode 100644
index 0000000000..5fa648e325
--- /dev/null
+++ b/test_without_xoptions.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Test script to verify no -X options are added when none exist"""
+
+import sys
+from pathlib import Path
+
+def simulate_get_child_arguments():
+    """Simulate the get_child_arguments function"""
+    import __main__
+    py_script = Path(sys.argv[0])
+
+    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]
+    # Add -X options if any are present
+    if hasattr(sys, '_xoptions') and sys._xoptions:
+        args += ['-X%s' % key for key in sys._xoptions]
+    
+    # Simplified for testing
+    args += sys.argv
+    return args
+
+def main():
+    print("Testing without -X options...")
+    print(f"sys._xoptions: {sys._xoptions}")
+    
+    args = simulate_get_child_arguments()
+    print(f"Command args: {args}")
+    
+    # Check that no -X options are added when none exist
+    x_options_count = sum(1 for arg in args if arg.startswith('-X'))
+    expected_count = 0
+    
+    print(f"Expected -X options: {expected_count}, Found: {x_options_count}")
+    
+    if x_options_count == expected_count:
+        print("SUCCESS: No extra -X options are being added!")
+        return True
+    else:
+        print("FAILURE: Extra -X options are being added!")
+        return False
+
+if __name__ == "__main__":
+    success = main()
+    sys.exit(0 if success else 1)
\ No newline at end of file