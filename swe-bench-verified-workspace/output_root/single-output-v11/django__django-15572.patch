diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..6e0c48b3f3
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix handles all edge cases.
+"""
+from pathlib import Path
+from django.utils._os import to_path
+
+def test_edge_cases():
+    """Test various edge cases for empty string filtering"""
+    print("Testing edge cases for empty string filtering...")
+    
+    cwd = Path.cwd()
+    
+    # Test case 1: Only empty strings
+    test1 = ['', '', '']
+    result1 = {cwd / to_path(dir) for dir in test1 if dir}
+    print(f"Only empty strings: {test1} -> {result1}")
+    assert len(result1) == 0, "Should filter out all empty strings"
+    
+    # Test case 2: Mixed valid and empty strings
+    test2 = ['/valid', '', '/another/valid', '']
+    result2 = {cwd / to_path(dir) for dir in test2 if dir}
+    print(f"Mixed valid and empty: {test2} -> {result2}")
+    assert len(result2) == 2, "Should keep only valid paths"
+    assert Path('/valid') in result2
+    assert Path('/another/valid') in result2
+    
+    # Test case 3: No empty strings
+    test3 = ['/path1', '/path2', '/path3']
+    result3 = {cwd / to_path(dir) for dir in test3 if dir}
+    print(f"No empty strings: {test3} -> {result3}")
+    assert len(result3) == 3, "Should keep all valid paths"
+    
+    # Test case 4: Empty list
+    test4 = []
+    result4 = {cwd / to_path(dir) for dir in test4 if dir}
+    print(f"Empty list: {test4} -> {result4}")
+    assert len(result4) == 0, "Should handle empty list"
+    
+    # Test case 5: Whitespace-only strings (should be treated as non-empty)
+    test5 = ['   ', '/valid']
+    result5 = {cwd / to_path(dir) for dir in test5 if dir}
+    print(f"Whitespace strings: {test5} -> {result5}")
+    assert len(result5) == 2, "Should keep whitespace strings (they're not empty)"
+    
+    print("All edge cases passed!")
+
+def test_path_behavior():
+    """Test the specific path behavior that was causing the issue"""
+    print("\nTesting path behavior...")
+    
+    # This was the problematic behavior
+    empty_path = to_path('')
+    cwd = Path.cwd()
+    result = cwd / empty_path
+    
+    print(f"to_path('') = {empty_path}")
+    print(f"Path.cwd() = {cwd}")
+    print(f"Path.cwd() / to_path('') = {result}")
+    print(f"Result equals cwd? {result == cwd}")
+    
+    # This demonstrates why the filtering is necessary
+    if result == cwd:
+        print("This confirms the issue: empty string becomes current directory")
+    else:
+        print("Unexpected behavior")
+
+if __name__ == "__main__":
+    test_edge_cases()
+    test_path_behavior()
+    print("\nAll tests passed! The fix is working correctly.")
\ No newline at end of file
diff --git a/django/template/autoreload.py b/django/template/autoreload.py
index 84c8554165..f3fd704031 100644
--- a/django/template/autoreload.py
+++ b/django/template/autoreload.py
@@ -17,7 +17,7 @@ def get_template_directories():
         if not isinstance(backend, DjangoTemplates):
             continue
 
-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)
+        items.update(cwd / to_path(dir) for dir in backend.engine.dirs if dir)
 
         for loader in backend.engine.template_loaders:
             if not hasattr(loader, "get_dirs"):
@@ -25,7 +25,7 @@ def get_template_directories():
             items.update(
                 cwd / to_path(directory)
                 for directory in loader.get_dirs()
-                if not is_django_path(directory)
+                if directory and not is_django_path(directory)
             )
     return items
 
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..bec8350a57
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the autoreload fix works correctly.
+"""
+from pathlib import Path
+from django.utils._os import to_path
+
+def test_filtering_logic():
+    """Test the exact filtering logic used in the fix"""
+    print("Testing the exact filtering logic from autoreload.py...")
+    
+    # Simulate the exact code from the fixed autoreload.py
+    cwd = Path.cwd()
+    
+    # Test case 1: backend.engine.dirs with empty strings
+    backend_dirs = ['/valid/path', '', '/another/valid/path', '']
+    result1 = [cwd / to_path(dir) for dir in backend_dirs if dir]
+    
+    print(f"Backend dirs input: {backend_dirs}")
+    print(f"Backend dirs output: {result1}")
+    
+    # Test case 2: loader.get_dirs() with empty strings  
+    loader_dirs = ['', '/loader/path', '', '/another/loader/path']
+    result2 = [cwd / to_path(dir) for dir in loader_dirs if dir]
+    
+    print(f"Loader dirs input: {loader_dirs}")
+    print(f"Loader dirs output: {result2}")
+    
+    # Verify results
+    success = True
+    
+    # Check that empty strings are filtered out
+    if len(result1) != 2 or any(str(p) == str(cwd) for p in result1):
+        print("FAIL: Backend dirs filtering not working")
+        success = False
+        
+    if len(result2) != 2 or any(str(p) == str(cwd) for p in result2):
+        print("FAIL: Loader dirs filtering not working")
+        success = False
+    
+    if success:
+        print("SUCCESS: Filtering logic works correctly!")
+        
+    return success
+
+if __name__ == "__main__":
+    result = test_filtering_logic()
+    if result:
+        print("\nFix is working correctly!")
+    else:
+        print("\nFix needs more work!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2f856344ef
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the Django autoreload issue with empty strings in TEMPLATES DIRS.
+"""
+import os
+import tempfile
+from pathlib import Path
+from django.template.autoreload import get_template_directories
+from django.template.backends.django import DjangoTemplates
+from django.conf import settings
+from django.template import engines
+
+# Configure minimal Django settings
+settings.configure(
+    TEMPLATES=[
+        {
+            'BACKEND': 'django.template.backends.django.DjangoTemplates',
+            'DIRS': [''],  # This is the problematic case - empty string
+        },
+    ],
+    USE_TZ=True,
+    INSTALLED_APPS=[],
+)
+
+def test_empty_string_in_dirs():
+    """Test that empty strings in DIRS cause issues with autoreload"""
+    print("Testing empty string in TEMPLATES DIRS...")
+    
+    # Get template directories
+    directories = get_template_directories()
+    print(f"Template directories found: {list(directories)}")
+    
+    # Check if any directory is the current working directory (which would be wrong)
+    cwd = Path.cwd()
+    print(f"Current working directory: {cwd}")
+    
+    for dir_path in directories:
+        print(f"Checking directory: {dir_path}")
+        if dir_path == cwd:
+            print("ERROR: Empty string was converted to current working directory!")
+            print("This will cause template_changed() to always return True")
+            return True
+    
+    print("No issues found")
+    return False
+
+if __name__ == "__main__":
+    result = test_empty_string_in_dirs()
+    if result:
+        print("\nIssue reproduced successfully!")
+    else:
+        print("\nIssue not reproduced - may need different setup")
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..f95bb66ec7
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the Django autoreload issue with empty strings.
+"""
+import os
+from pathlib import Path
+from django.utils._os import to_path
+
+def test_to_path_behavior():
+    """Test how to_path handles empty strings"""
+    print("Testing to_path behavior with empty strings...")
+    
+    # Test what happens when we pass an empty string to to_path
+    empty_path = to_path('')
+    cwd = Path.cwd()
+    
+    print(f"to_path('') = {empty_path}")
+    print(f"Path.cwd() = {cwd}")
+    print(f"Are they equal? {empty_path == cwd}")
+    
+    # Test the specific operation from autoreload.py
+    result = Path.cwd() / to_path('')
+    print(f"Path.cwd() / to_path('') = {result}")
+    print(f"Is this the current directory? {result == cwd}")
+    
+    return result == cwd
+
+if __name__ == "__main__":
+    result = test_to_path_behavior()
+    if result:
+        print("\nIssue confirmed! Empty string gets converted to current directory.")
+    else:
+        print("\nNo issue found.")
\ No newline at end of file
diff --git a/test_autoreload_fix.py b/test_autoreload_fix.py
new file mode 100644
index 0000000000..5c384ee57a
--- /dev/null
+++ b/test_autoreload_fix.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the autoreload fix works with Django template engines.
+"""
+import os
+from pathlib import Path
+from django.conf import settings
+from django.template import engines
+from django.template.backends.django import DjangoTemplates
+from django.template.autoreload import get_template_directories
+
+# Configure Django settings
+settings.configure(
+    TEMPLATES=[
+        {
+            'BACKEND': 'django.template.backends.django.DjangoTemplates',
+            'DIRS': ['/valid/template/dir', '', '/another/valid/dir'],  # Empty string in the middle
+        },
+    ],
+    USE_TZ=True,
+    INSTALLED_APPS=[],
+)
+
+def test_get_template_directories():
+    """Test that get_template_directories() filters out empty strings"""
+    print("Testing get_template_directories() with empty strings...")
+    
+    # Manually create a mock backend to test the function
+    class MockEngine:
+        def __init__(self, dirs):
+            self.dirs = dirs
+            self.template_loaders = []
+    
+    class MockBackend:
+        def __init__(self, dirs):
+            self.engine = MockEngine(dirs)
+    
+    # Mock the engines.all() method
+    original_all = engines.all
+    def mock_all():
+        return [MockBackend(['/valid/template/dir', '', '/another/valid/dir'])]
+    
+    engines.all = mock_all
+    
+    try:
+        directories = get_template_directories()
+        print(f"Template directories found: {list(directories)}")
+        
+        # Check that no empty string directories are included
+        cwd = Path.cwd()
+        has_empty_dirs = any(str(dir_path) == str(cwd) for dir_path in directories)
+        
+        if not has_empty_dirs and len(directories) == 2:
+            print("SUCCESS: Empty strings were filtered out from template directories!")
+            return True
+        else:
+            print(f"FAILED: Found {len(directories)} directories, expected 2. Has empty dirs: {has_empty_dirs}")
+            return False
+            
+    finally:
+        # Restore original method
+        engines.all = original_all
+
+if __name__ == "__main__":
+    result = test_get_template_directories()
+    if result:
+        print("\nAutoreload fix verified successfully!")
+    else:
+        print("\nAutoreload fix verification failed!")
\ No newline at end of file
diff --git a/test_empty_string_fix.py b/test_empty_string_fix.py
new file mode 100644
index 0000000000..41e8b41a0a
--- /dev/null
+++ b/test_empty_string_fix.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+"""
+Test to verify that empty strings in TEMPLATES DIRS are properly handled.
+"""
+import os
+from pathlib import Path
+from django.conf import settings
+from django.template import autoreload
+from django.test import SimpleTestCase, override_settings
+
+# Configure minimal Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    USE_TZ=True,
+    INSTALLED_APPS=[],
+)
+
+class EmptyStringTemplateTests(SimpleTestCase):
+    
+    @override_settings(
+        TEMPLATES=[
+            {
+                'BACKEND': 'django.template.backends.django.DjangoTemplates',
+                'DIRS': ['/valid/path', '', '/another/valid/path'],  # Empty string in the middle
+            },
+        ]
+    )
+    def test_empty_string_in_dirs(self):
+        """Test that empty strings in DIRS are filtered out"""
+        directories = autoreload.get_template_directories()
+        
+        # Should only contain the valid paths, not the empty string
+        expected_dirs = {
+            Path('/valid/path'),
+            Path('/another/valid/path'),
+        }
+        
+        self.assertEqual(directories, expected_dirs)
+        self.assertEqual(len(directories), 2)
+        
+        # Ensure no current working directory is included (which would happen with empty strings)
+        cwd = Path.cwd()
+        self.assertNotIn(cwd, directories)
+
+if __name__ == "__main__":
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..82d35ef85c
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for empty strings in TEMPLATES DIRS.
+"""
+import os
+from pathlib import Path
+from django.utils._os import to_path
+
+def test_empty_string_filtering():
+    """Test that empty strings are properly filtered out"""
+    print("Testing empty string filtering...")
+    
+    # Test the filtering logic
+    test_dirs = ['/valid/path', '', '/another/valid/path', '']
+    
+    # Simulate the fixed logic
+    cwd = Path.cwd()
+    filtered_items = [cwd / to_path(dir) for dir in test_dirs if dir]
+    
+    print(f"Original directories: {test_dirs}")
+    print(f"Filtered directories: {filtered_items}")
+    
+    # Check that empty strings are filtered out
+    has_empty_strings = any(str(item).endswith('/.') or str(item).endswith('/') for item in filtered_items)
+    
+    if not has_empty_strings and len(filtered_items) == 2:
+        print("SUCCESS: Empty strings were properly filtered out!")
+        return True
+    else:
+        print("FAILED: Empty strings were not properly filtered out!")
+        return False
+
+if __name__ == "__main__":
+    result = test_empty_string_filtering()
+    if result:
+        print("\nFix verified successfully!")
+    else:
+        print("\nFix verification failed!")
\ No newline at end of file
diff --git a/unit_test_fix.py b/unit_test_fix.py
new file mode 100644
index 0000000000..1c31176a04
--- /dev/null
+++ b/unit_test_fix.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+"""
+Unit test to verify the filtering logic in autoreload.py works correctly.
+"""
+from pathlib import Path
+from django.utils._os import to_path
+
+def test_empty_string_filtering():
+    """Test that empty strings are properly filtered out"""
+    print("Testing empty string filtering logic...")
+    
+    # Simulate the exact code from the fixed autoreload.py
+    cwd = Path.cwd()
+    
+    # Test case 1: backend.engine.dirs with empty strings
+    backend_dirs = ['/valid/path', '', '/another/valid/path', '']
+    result1 = {cwd / to_path(dir) for dir in backend_dirs if dir}
+    
+    print(f"Backend dirs input: {backend_dirs}")
+    print(f"Backend dirs output: {result1}")
+    
+    # Test case 2: loader.get_dirs() with empty strings  
+    loader_dirs = ['', '/loader/path', '', '/another/loader/path']
+    result2 = {cwd / to_path(dir) for dir in loader_dirs if dir}
+    
+    print(f"Loader dirs input: {loader_dirs}")
+    print(f"Loader dirs output: {result2}")
+    
+    # Verify results
+    success = True
+    
+    # Check that empty strings are filtered out
+    expected1 = {Path('/valid/path'), Path('/another/valid/path')}
+    if result1 != expected1:
+        print(f"FAIL: Expected {expected1}, got {result1}")
+        success = False
+        
+    expected2 = {Path('/loader/path'), Path('/another/loader/path')}
+    if result2 != expected2:
+        print(f"FAIL: Expected {expected2}, got {result2}")
+        success = False
+    
+    # Check that current working directory is NOT included (which would happen with empty strings)
+    if any(p == cwd for p in result1) or any(p == cwd for p in result2):
+        print("FAIL: Current working directory should not be included")
+        success = False
+    
+    if success:
+        print("SUCCESS: Empty strings are properly filtered out!")
+        
+    return success
+
+if __name__ == "__main__":
+    result = test_empty_string_filtering()
+    if result:
+        print("\nFix is working correctly!")
+    else:
+        print("\nFix needs more work!")
\ No newline at end of file