diff --git a/direct_test.py b/direct_test.py
new file mode 100644
index 0000000000..f927d13eba
--- /dev/null
+++ b/direct_test.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+"""
+Direct test of the fixture_dirs property with Path instances.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_fixture_dirs_property():
+    """Test the fixture_dirs property directly."""
+    
+    # Create a temporary directory
+    with tempfile.TemporaryDirectory() as temp_dir:
+        test_dir = os.path.join(temp_dir, 'fixtures')
+        os.makedirs(test_dir)
+        
+        print("Testing fixture_dirs property with Path instances...")
+        
+        # Create a command instance
+        cmd = Command()
+        
+        # Test with string duplicates
+        try:
+            # Monkey patch settings.FIXTURE_DIRS to test the property
+            import django.conf
+            original_fixture_dirs = django.conf.settings.FIXTURE_DIRS
+            django.conf.settings.FIXTURE_DIRS = [test_dir, test_dir]
+            
+            # Access the property to trigger duplicate check
+            _ = cmd.fixture_dirs
+            print("ERROR: Should have raised ImproperlyConfigured for string duplicates")
+            return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected string duplicates: {e}")
+        finally:
+            # Restore original settings
+            django.conf.settings.FIXTURE_DIRS = original_fixture_dirs
+        
+        # Test with Path duplicates
+        try:
+            # Monkey patch settings.FIXTURE_DIRS with Path instances
+            import django.conf
+            original_fixture_dirs = django.conf.settings.FIXTURE_DIRS
+            django.conf.settings.FIXTURE_DIRS = [Path(test_dir), Path(test_dir)]
+            
+            # Access the property to trigger duplicate check
+            _ = cmd.fixture_dirs
+            print("ERROR: Should have raised ImproperlyConfigured for Path duplicates")
+            return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected Path duplicates: {e}")
+            return True
+        finally:
+            # Restore original settings
+            django.conf.settings.FIXTURE_DIRS = original_fixture_dirs
+        
+        return True
+
+if __name__ == '__main__':
+    success = test_fixture_dirs_property()
+    if success:
+        print("\n✓ All tests passed!")
+    else:
+        print("\n✗ Tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9c7c45e847
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the FIXTURE_DIRS duplicate detection issue with Path instances.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+from django.test.utils import override_settings
+
+# Set up minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_duplicate_detection():
+    """Test that duplicate detection works with both strings and Path instances."""
+    
+    # Create temporary directories for testing
+    with tempfile.TemporaryDirectory() as temp_dir:
+        dir1 = os.path.join(temp_dir, 'fixtures1')
+        dir2 = os.path.join(temp_dir, 'fixtures2')
+        os.makedirs(dir1)
+        os.makedirs(dir2)
+        
+        print("Testing duplicate detection with strings...")
+        
+        # Test with string duplicates - should raise ImproperlyConfigured
+        try:
+            cmd = Command()
+            # Access the property to trigger duplicate check
+            _ = cmd.fixture_dirs
+            print("ERROR: Should have raised ImproperlyConfigured for string duplicates")
+            return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected string duplicates: {e}")
+        
+        print("\nTesting duplicate detection with Path instances...")
+        
+        # Test with Path instances - this should also raise ImproperlyConfigured but currently doesn't
+        try:
+            cmd = Command()
+            cmd.fixture_dirs = [Path(dir1), Path(dir1)]  # Duplicate Path instances
+            print("ERROR: Should have raised ImproperlyConfigured for Path duplicates")
+            return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected Path duplicates: {e}")
+            return True
+        
+        return True
+
+if __name__ == '__main__':
+    success = test_duplicate_detection()
+    if success:
+        print("\n✓ All tests passed!")
+    else:
+        print("\n✗ Tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/reproduce_path_issue.py b/reproduce_path_issue.py
new file mode 100644
index 0000000000..8fb3be4066
--- /dev/null
+++ b/reproduce_path_issue.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the FIXTURE_DIRS duplicate detection issue with Path instances.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+
+# Set up minimal Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+import django
+from django.conf import settings, Settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+django.setup()
+
+def test_duplicate_detection():
+    """Test that duplicate detection works with both strings and Path instances."""
+    
+    # Create temporary directories for testing
+    with tempfile.TemporaryDirectory() as temp_dir:
+        dir1 = os.path.join(temp_dir, 'fixtures1')
+        dir2 = os.path.join(temp_dir, 'fixtures2')
+        os.makedirs(dir1)
+        os.makedirs(dir2)
+        
+        print("Testing duplicate detection with strings...")
+        
+        # Test with string duplicates - should raise ImproperlyConfigured
+        try:
+            # Create a custom settings object with duplicate string paths
+            custom_settings = Settings('test')
+            custom_settings.configure(
+                FIXTURE_DIRS=[dir1, dir1],
+                INSTALLED_APPS=settings.INSTALLED_APPS,
+                DATABASES=settings.DATABASES
+            )
+            
+            with django.conf.override_settings(custom_settings):
+                cmd = Command()
+                # Access the property to trigger duplicate check
+                _ = cmd.fixture_dirs
+                print("ERROR: Should have raised ImproperlyConfigured for string duplicates")
+                return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected string duplicates: {e}")
+        
+        print("\nTesting duplicate detection with Path instances...")
+        
+        # Test with Path instances - this should also raise ImproperlyConfigured but currently doesn't
+        try:
+            # Create a custom settings object with duplicate Path instances
+            custom_settings = Settings('test')
+            custom_settings.configure(
+                FIXTURE_DIRS=[Path(dir1), Path(dir1)],
+                INSTALLED_APPS=settings.INSTALLED_APPS,
+                DATABASES=settings.DATABASES
+            )
+            
+            with django.conf.override_settings(custom_settings):
+                cmd = Command()
+                # Access the property to trigger duplicate check
+                _ = cmd.fixture_dirs
+                print("ERROR: Should have raised ImproperlyConfigured for Path duplicates")
+                return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected Path duplicates: {e}")
+            return True
+        
+        return True
+
+if __name__ == '__main__':
+    success = test_duplicate_detection()
+    if success:
+        print("\n✓ All tests passed!")
+    else:
+        print("\n✗ Tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..213b06b466
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the FIXTURE_DIRS duplicate detection issue with Path instances.
+"""
+
+from pathlib import Path
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+# Test the duplicate detection logic directly
+def test_duplicate_logic():
+    print("Testing duplicate detection logic...")
+    
+    # Create some test paths
+    test_path = "/some/test/path"
+    
+    # Test with strings
+    string_dirs = [test_path, test_path]
+    print(f"String dirs: {string_dirs}")
+    print(f"String set: {set(string_dirs)}")
+    print(f"String duplicates detected: {len(string_dirs) != len(set(string_dirs))}")
+    
+    # Test with Path instances
+    path_dirs = [Path(test_path), Path(test_path)]
+    print(f"Path dirs: {path_dirs}")
+    print(f"Path set: {set(path_dirs)}")
+    print(f"Path duplicates detected: {len(path_dirs) != len(set(path_dirs))}")
+    
+    # This demonstrates the issue: Path instances with same path but different objects
+    # are not considered equal in a set, so duplicates are not detected
+
+if __name__ == '__main__':
+    test_duplicate_logic()
\ No newline at end of file
diff --git a/test_edge_case.py b/test_edge_case.py
new file mode 100644
index 0000000000..e1496868ba
--- /dev/null
+++ b/test_edge_case.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+"""
+Test edge cases that might cause Path duplicate detection issues.
+"""
+
+from pathlib import Path
+import os
+
+def test_path_edge_cases():
+    """Test edge cases that might cause Path duplicate detection issues."""
+    
+    # Test with relative paths that resolve to the same absolute path
+    os.chdir("/tmp")  # Change to a known directory
+    
+    path1 = Path("relative/path")
+    path2 = Path("./relative/path")  # Different representation
+    path3 = Path("relative/./path")  # Another representation
+    
+    print("Testing relative path edge cases:")
+    print(f"Path 1: {path1}")
+    print(f"Path 2: {path2}")
+    print(f"Path 3: {path3}")
+    
+    print(f"\nAbsolute paths:")
+    print(f"path1.resolve(): {path1.resolve()}")
+    print(f"path2.resolve(): {path2.resolve()}")
+    print(f"path3.resolve(): {path3.resolve()}")
+    
+    print(f"\nEquality comparisons:")
+    print(f"path1 == path2: {path1 == path2}")
+    print(f"path1 == path3: {path1 == path3}")
+    print(f"path2 == path3: {path2 == path3}")
+    
+    print(f"\nSet behavior:")
+    path_set = {path1, path2, path3}
+    print(f"Set contents: {path_set}")
+    print(f"Set length: {len(path_set)}")
+    
+    # Test if they all resolve to the same absolute path
+    all_same_absolute = (
+        path1.resolve() == path2.resolve() == path3.resolve()
+    )
+    print(f"All resolve to same absolute path: {all_same_absolute}")
+    
+    # Test with paths containing trailing slashes
+    path4 = Path("/same/path")
+    path5 = Path("/same/path/")  # Trailing slash
+    
+    print(f"\nTesting trailing slash:")
+    print(f"Path 4: {path4}")
+    print(f"Path 5: {path5}")
+    print(f"path4 == path5: {path4 == path5}")
+    print(f"Set with trailing slash: { {path4, path5} }")
+    
+    return len(path_set) == 1 and path4 == path5
+
+if __name__ == '__main__':
+    edge_cases_work = test_path_edge_cases()
+    if edge_cases_work:
+        print("\n✓ Path edge cases work correctly!")
+    else:
+        print("\n✗ Path edge cases have issues!")
\ No newline at end of file
diff --git a/test_loaddata_path_issue.py b/test_loaddata_path_issue.py
new file mode 100644
index 0000000000..d56d3e3c6d
--- /dev/null
+++ b/test_loaddata_path_issue.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the Path duplicate detection issue in loaddata command.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management import execute_from_command_line
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_loaddata_path_duplicates():
+    """Test that demonstrates the Path duplicate detection issue in loaddata."""
+    
+    # Create a temporary directory with a fixture file
+    with tempfile.TemporaryDirectory() as temp_dir:
+        fixture_dir = os.path.join(temp_dir, 'fixtures')
+        os.makedirs(fixture_dir)
+        
+        # Create a simple fixture file
+        fixture_file = os.path.join(fixture_dir, 'test.json')
+        with open(fixture_file, 'w') as f:
+            f.write('[]')  # Empty fixture
+        
+        print("Testing loaddata with Path duplicates in FIXTURE_DIRS...")
+        
+        # Test with string duplicates - should raise ImproperlyConfigured
+        try:
+            with settings.override(FIXTURE_DIRS=[fixture_dir, fixture_dir]):
+                execute_from_command_line(['loaddata', 'test.json', '--verbosity=0'])
+                print("ERROR: Should have raised ImproperlyConfigured for string duplicates")
+                return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected string duplicates: {e}")
+        
+        # Test with Path duplicates - this should also raise ImproperlyConfigured
+        try:
+            with settings.override(FIXTURE_DIRS=[Path(fixture_dir), Path(fixture_dir)]):
+                execute_from_command_line(['loaddata', 'test.json', '--verbosity=0'])
+                print("ERROR: Should have raised ImproperlyConfigured for Path duplicates")
+                return False
+        except ImproperlyConfigured as e:
+            print(f"✓ Correctly detected Path duplicates: {e}")
+            return True
+        
+        return True
+
+if __name__ == '__main__':
+    success = test_loaddata_path_duplicates()
+    if success:
+        print("\n✓ All tests passed!")
+    else:
+        print("\n✗ Tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/test_path_creation_issue.py b/test_path_creation_issue.py
new file mode 100644
index 0000000000..64d43d012b
--- /dev/null
+++ b/test_path_creation_issue.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate Path creation issues that might cause duplicate detection problems.
+"""
+
+from pathlib import Path
+import os
+
+def test_different_path_creation():
+    """Test different ways of creating Path objects that might cause issues."""
+    
+    # Different ways to create Path objects for the same path
+    path1 = Path("/same/path")
+    path2 = Path("/same") / "path"  # Different creation method
+    path3 = Path(os.path.join("/same", "path"))  # Another method
+    
+    print("Testing different Path creation methods:")
+    print(f"Path 1: {path1} (direct)")
+    print(f"Path 2: {path2} (division)")
+    print(f"Path 3: {path3} (os.path.join)")
+    
+    print(f"\nEquality comparisons:")
+    print(f"path1 == path2: {path1 == path2}")
+    print(f"path1 == path3: {path1 == path3}")
+    print(f"path2 == path3: {path2 == path3}")
+    
+    print(f"\nHash comparisons:")
+    print(f"hash(path1) == hash(path2): {hash(path1) == hash(path2)}")
+    print(f"hash(path1) == hash(path3): {hash(path1) == hash(path3)}")
+    print(f"hash(path2) == hash(path3): {hash(path2) == hash(path3)}")
+    
+    print(f"\nSet behavior:")
+    path_set = {path1, path2, path3}
+    print(f"Set contents: {path_set}")
+    print(f"Set length: {len(path_set)}")
+    
+    # Test if they all resolve to the same absolute path
+    print(f"\nAbsolute path comparisons:")
+    print(f"path1.resolve(): {path1.resolve()}")
+    print(f"path2.resolve(): {path2.resolve()}")
+    print(f"path3.resolve(): {path3.resolve()}")
+    print(f"All resolve to same: {path1.resolve() == path2.resolve() == path3.resolve()}")
+    
+    return len(path_set) == 1  # Should be 1 if all are considered duplicates
+
+if __name__ == '__main__':
+    duplicates_detected = test_different_path_creation()
+    if duplicates_detected:
+        print("\n✓ All Path duplicates are detected correctly!")
+    else:
+        print("\n✗ Path duplicates are NOT detected!")
\ No newline at end of file
diff --git a/test_path_duplicates.py b/test_path_duplicates.py
new file mode 100644
index 0000000000..d064f2baa3
--- /dev/null
+++ b/test_path_duplicates.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the Path duplicate detection issue.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_path_duplicate_issue():
+    """Test that demonstrates the Path duplicate detection issue."""
+    
+    # Create a temporary directory
+    with tempfile.TemporaryDirectory() as temp_dir:
+        test_dir = os.path.join(temp_dir, 'fixtures')
+        os.makedirs(test_dir)
+        
+        print("Testing Path duplicate detection...")
+        
+        # Create Path objects pointing to the same directory
+        path1 = Path(test_dir)
+        path2 = Path(test_dir)
+        
+        print(f"Path 1: {path1}")
+        print(f"Path 2: {path2}")
+        print(f"Are they equal? {path1 == path2}")
+        print(f"Are they the same object? {path1 is path2}")
+        
+        # Test the current duplicate detection logic
+        fixture_dirs = [path1, path2]
+        print(f"Fixture dirs: {fixture_dirs}")
+        print(f"Set of fixture dirs: {set(fixture_dirs)}")
+        print(f"Length of fixture_dirs: {len(fixture_dirs)}")
+        print(f"Length of set: {len(set(fixture_dirs))}")
+        print(f"Duplicates detected: {len(fixture_dirs) != len(set(fixture_dirs))}")
+        
+        # The issue: even though path1 and path2 point to the same directory,
+        # they are different objects, so set() doesn't consider them duplicates
+        
+        # Let's test what happens when we convert to strings first
+        string_dirs = [str(path1), str(path2)]
+        print(f"String dirs: {string_dirs}")
+        print(f"Set of string dirs: {set(string_dirs)}")
+        print(f"Length of string_dirs: {len(string_dirs)}")
+        print(f"Length of string set: {len(set(string_dirs))}")
+        print(f"String duplicates detected: {len(string_dirs) != len(set(string_dirs))}")
+        
+        return len(fixture_dirs) != len(set(fixture_dirs))
+
+if __name__ == '__main__':
+    has_issue = test_path_duplicate_issue()
+    if has_issue:
+        print("\n✓ Issue confirmed: Path duplicates are not detected!")
+    else:
+        print("\n✗ No issue found: Path duplicates are detected!")
\ No newline at end of file
diff --git a/test_path_hash_issue.py b/test_path_hash_issue.py
new file mode 100644
index 0000000000..561b742a95
--- /dev/null
+++ b/test_path_hash_issue.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the Path hashing issue in duplicate detection.
+"""
+
+from pathlib import Path
+
+def test_path_hashing():
+    """Test Path object hashing behavior."""
+    
+    # Create two Path objects pointing to the same directory
+    path1 = Path("/same/path")
+    path2 = Path("/same/path")
+    
+    print(f"Path 1: {path1}")
+    print(f"Path 2: {path2}")
+    print(f"Are they equal? {path1 == path2}")
+    print(f"Are they the same object? {path1 is path2}")
+    print(f"Hash of path1: {hash(path1)}")
+    print(f"Hash of path2: {hash(path2)}")
+    print(f"Are hashes equal? {hash(path1) == hash(path2)}")
+    
+    # Test set behavior
+    path_set = {path1, path2}
+    print(f"Set contents: {path_set}")
+    print(f"Set length: {len(path_set)}")
+    
+    # The issue: even though they represent the same path, they might have different hashes
+    # if they were created differently or if there's a hashing issue
+    
+    return len(path_set) == 1  # Should be 1 if duplicates are detected
+
+if __name__ == '__main__':
+    duplicates_detected = test_path_hashing()
+    if duplicates_detected:
+        print("\n✓ Path duplicates are detected correctly!")
+    else:
+        print("\n✗ Path duplicates are NOT detected!")
\ No newline at end of file
diff --git a/test_real_issue.py b/test_real_issue.py
new file mode 100644
index 0000000000..5214a1d6d7
--- /dev/null
+++ b/test_real_issue.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the real Path duplicate detection issue.
+The issue might be more subtle - perhaps with different Path instances
+that represent the same path but are created differently.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_real_path_issue():
+    """Test that demonstrates the real Path duplicate detection issue."""
+    
+    # Create a temporary directory
+    with tempfile.TemporaryDirectory() as temp_dir:
+        test_dir = os.path.join(temp_dir, 'fixtures')
+        os.makedirs(test_dir)
+        
+        print("Testing real Path duplicate detection issue...")
+        
+        # Create Path objects in different ways that might cause the issue
+        path1 = Path(test_dir)
+        path2 = Path(temp_dir) / 'fixtures'  # Different way to create the same path
+        
+        print(f"Path 1: {path1}")
+        print(f"Path 2: {path2}")
+        print(f"Are they equal? {path1 == path2}")
+        print(f"Are they the same object? {path1 is path2}")
+        print(f"String representation equal? {str(path1) == str(path2)}")
+        
+        # Test the current duplicate detection logic
+        fixture_dirs = [path1, path2]
+        print(f"Fixture dirs: {fixture_dirs}")
+        print(f"Set of fixture dirs: {set(fixture_dirs)}")
+        print(f"Length of fixture_dirs: {len(fixture_dirs)}")
+        print(f"Length of set: {len(set(fixture_dirs))}")
+        print(f"Duplicates detected: {len(fixture_dirs) != len(set(fixture_dirs))}")
+        
+        # Test what happens when we convert to strings first
+        string_dirs = [str(path1), str(path2)]
+        print(f"String dirs: {string_dirs}")
+        print(f"Set of string dirs: {set(string_dirs)}")
+        print(f"Length of string_dirs: {len(string_dirs)}")
+        print(f"Length of string set: {len(set(string_dirs))}")
+        print(f"String duplicates detected: {len(string_dirs) != len(set(string_dirs))}")
+        
+        return len(fixture_dirs) != len(set(fixture_dirs))
+
+if __name__ == '__main__':
+    has_issue = test_real_path_issue()
+    if has_issue:
+        print("\n✓ Issue confirmed: Path duplicates are not detected!")
+    else:
+        print("\n✗ No issue found: Path duplicates are detected!")
\ No newline at end of file
diff --git a/test_real_issue_demo.py b/test_real_issue_demo.py
new file mode 100644
index 0000000000..e01c63e3bf
--- /dev/null
+++ b/test_real_issue_demo.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the actual issue with Path duplicate detection.
+The issue is that duplicate check happens before path normalization.
+"""
+
+import os
+import tempfile
+from pathlib import Path
+from django.conf import settings
+from django.core.exceptions import ImproperlyConfigured
+from django.core.management.commands.loaddata import Command
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+def test_duplicate_check_issue():
+    """Test that demonstrates the actual duplicate check issue."""
+    
+    # Create a temporary directory
+    with tempfile.TemporaryDirectory() as temp_dir:
+        test_dir = os.path.join(temp_dir, 'fixtures')
+        os.makedirs(test_dir)
+        
+        print("Testing the actual duplicate check issue...")
+        
+        # Create Path objects that represent the same directory but different objects
+        path1 = Path(test_dir)
+        path2 = Path(temp_dir) / 'fixtures'  # Different way to create same path
+        
+        print(f"Path 1: {path1}")
+        print(f"Path 2: {path2}")
+        print(f"Are they equal? {path1 == path2}")
+        print(f"String representations: {str(path1)} vs {str(path2)}")
+        print(f"Real paths: {os.path.realpath(path1)} vs {os.path.realpath(path2)}")
+        
+        # Test the current duplicate check logic (before normalization)
+        fixture_dirs = [path1, path2]
+        print(f"\nDuplicate check on original paths:")
+        print(f"Fixture dirs: {fixture_dirs}")
+        print(f"Set of fixture dirs: {set(fixture_dirs)}")
+        print(f"Duplicates detected: {len(fixture_dirs) != len(set(fixture_dirs))}")
+        
+        # Test what happens after normalization (like the final result does)
+        normalized_dirs = [os.path.realpath(d) for d in fixture_dirs]
+        print(f"\nAfter normalization (like final result):")
+        print(f"Normalized dirs: {normalized_dirs}")
+        print(f"Set of normalized dirs: {set(normalized_dirs)}")
+        print(f"Duplicates detected after normalization: {len(normalized_dirs) != len(set(normalized_dirs))}")
+        
+        # The issue: duplicate check happens before normalization, but final result normalizes
+        # So duplicates might not be detected in the check but would be duplicates in the result
+        
+        return len(fixture_dirs) != len(set(fixture_dirs))
+
+if __name__ == '__main__':
+    has_issue = test_duplicate_check_issue()
+    if has_issue:
+        print("\n✓ Issue confirmed: Duplicate check happens before normalization!")
+    else:
+        print("\n✗ No issue found")
\ No newline at end of file