diff --git a/check_test_data.py b/check_test_data.py
new file mode 100644
index 0000000000..16a56b2448
--- /dev/null
+++ b/check_test_data.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Check what test data is in the comprehensive test
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def check_test_data():
+    """Check what test data is actually in the database"""
+    # Create the same test data as comprehensive_test.py
+    test_data = [
+        {'foo': 'bar'},                      # String key
+        {'1111': 'bar1'},                    # Numeric string key
+        {'1112': 'bar2'},                    # Another numeric string key
+        {'0': 'zero1'},                      # Zero string key
+        {'1': 'zero2'},                      # Another numeric string key
+        {'negative': -1},                    # Negative number as value
+        {'nested': {'key': 'value'}},       # Nested object
+        {'array': [1, 2, 3]},               # Array value
+        {'special.chars': 'test'},           # Key with special characters
+        {'with spaces': 'test'},             # Key with spaces
+    ]
+    
+    # Insert test data
+    for i, data in enumerate(test_data):
+        test = JsonFieldHasKeyTest(data=data)
+        test.save()
+    
+    # Print all data
+    print("All data in database:")
+    for obj in JsonFieldHasKeyTest.objects.all():
+        print(f"ID {obj.id}: {obj.data}")
+    
+    # Check if any object has both 'foo' and '1111' keys
+    print("\nObjects with both 'foo' and '1111' keys:")
+    for obj in JsonFieldHasKeyTest.objects.all():
+        if 'foo' in obj.data and '1111' in obj.data:
+            print(f"ID {obj.id}: {obj.data}")
+
+if __name__ == '__main__':
+    check_test_data()
\ No newline at end of file
diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..a05c63328e
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for JSONField has_key lookup with various key types
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def test_comprehensive_json_field_has_key():
+    """Test the has_key lookup with various key types"""
+    # Create test data with different key types
+    test_data = [
+        {'foo': 'bar', '1111': 'bar1'},      # Both keys in same object
+        {'foo': 'bar2'},                     # Only foo key
+        {'1111': 'bar3'},                    # Only 1111 key
+        {'0': 'zero1'},                      # Zero string key
+        {'1': 'zero2'},                      # Another numeric string key
+        {'negative': -1},                    # Negative number as value
+        {'nested': {'key': 'value'}},       # Nested object
+        {'array': [1, 2, 3]},               # Array value
+        {'special.chars': 'test'},           # Key with special characters
+        {'with spaces': 'test'},             # Key with spaces
+    ]
+    
+    # Insert test data
+    for i, data in enumerate(test_data):
+        test = JsonFieldHasKeyTest(data=data)
+        test.save()
+    
+    # Test has_key lookup for each key type
+    test_cases = [
+        ('foo', 2),             # Appears in 2 objects
+        ('1111', 2),            # Appears in 2 objects  
+        ('1112', 0),            # Does not appear
+        ('0', 1),               # Appears in 1 object
+        ('1', 1),               # Appears in 1 object
+        ('negative', 1),        # Appears in 1 object
+        ('nested', 1),          # Appears in 1 object
+        ('array', 1),           # Appears in 1 object
+        ('special.chars', 1),   # Appears in 1 object
+        ('with spaces', 1),     # Appears in 1 object
+        ('nonexistent', 0),     # Should not exist
+        ('missing', 0),         # Should not exist
+    ]
+    
+    all_passed = True
+    
+    for key, expected in test_cases:
+        count = JsonFieldHasKeyTest.objects.filter(data__has_key=key).count()
+        status = "PASS" if count == expected else "FAIL"
+        
+        if count != expected:
+            all_passed = False
+            
+        print(f"{status}: key={key!r}, expected={expected}, got={count}")
+    
+    # Test has_keys lookup
+    has_keys_result = JsonFieldHasKeyTest.objects.filter(data__has_keys=['foo', '1111']).count()
+    print(f"has_keys(['foo', '1111']): {has_keys_result} (expected: 1)")
+    if has_keys_result != 1:
+        all_passed = False
+    
+    # Test has_any_keys lookup
+    has_any_result = JsonFieldHasKeyTest.objects.filter(data__has_any_keys=['foo', 'nonexistent']).count()
+    print(f"has_any_keys(['foo', 'nonexistent']): {has_any_result} (expected: 2)")
+    if has_any_result != 2:
+        all_passed = False
+    
+    if all_passed:
+        print("\nSUCCESS: All tests passed!")
+        return True
+    else:
+        print("\nFAILURE: Some tests failed!")
+        return False
+
+if __name__ == '__main__':
+    success = test_comprehensive_json_field_has_key()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/debug_has_keys.py b/debug_has_keys.py
new file mode 100644
index 0000000000..96fc9afad5
--- /dev/null
+++ b/debug_has_keys.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+"""
+Debug has_keys lookup
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def debug_has_keys():
+    """Debug has_keys lookup"""
+    # Create test data
+    test_data = [
+        {'foo': 'bar', '1111': 'bar1'},  # Both keys in same object
+        {'foo': 'bar2'},                  # Only foo key
+        {'1111': 'bar3'},                 # Only 1111 key
+    ]
+    
+    # Insert test data
+    for i, data in enumerate(test_data):
+        test = JsonFieldHasKeyTest(data=data)
+        test.save()
+    
+    # Retrieve and print the actual JSON data stored
+    for obj in JsonFieldHasKeyTest.objects.all():
+        print(f"ID {obj.id}: {obj.data}")
+    
+    # Test individual has_key lookups
+    print("\nIndividual has_key tests:")
+    for key in ['foo', '1111']:
+        count = JsonFieldHasKeyTest.objects.filter(data__has_key=key).count()
+        print(f"has_key({key!r}): {count}")
+    
+    # Test has_keys lookup
+    print("\nhas_keys(['foo', '1111']) test:")
+    result = JsonFieldHasKeyTest.objects.filter(data__has_keys=['foo', '1111'])
+    print(f"Count: {result.count()}")
+    for obj in result:
+        print(f"  ID {obj.id}: {obj.data}")
+
+if __name__ == '__main__':
+    debug_has_keys()
\ No newline at end of file
diff --git a/debug_sql.py b/debug_sql.py
new file mode 100644
index 0000000000..bfc046b0b1
--- /dev/null
+++ b/debug_sql.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+"""
+Debug the SQL generated by has_keys lookup
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def debug_sql():
+    """Debug the SQL generated by has_keys lookup"""
+    # Create test data
+    test_data = [
+        {'foo': 'bar', '1111': 'bar1'},  # Both keys in same object
+    ]
+    
+    # Insert test data
+    for i, data in enumerate(test_data):
+        test = JsonFieldHasKeyTest(data=data)
+        test.save()
+    
+    # Test has_keys lookup and print SQL
+    queryset = JsonFieldHasKeyTest.objects.filter(data__has_keys=['foo', '1111'])
+    print("SQL Query:")
+    print(queryset.query)
+    
+    # Execute and print results
+    print("\nResults:")
+    result = queryset.count()
+    print(f"Count: {result}")
+    for obj in queryset:
+        print(f"  ID {obj.id}: {obj.data}")
+
+if __name__ == '__main__':
+    debug_sql()
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..cee2d81d25
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Debug test to see what JSON data is stored in the database
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def debug_json_data():
+    """Debug what JSON data is actually stored"""
+    # Create test data with different key types
+    test_data = [
+        {'foo': 'bar'},                      # String key
+        {'1111': 'bar'},                     # Numeric string key
+        {1111: 'bar'},                       # Integer key
+    ]
+    
+    # Insert test data
+    for i, data in enumerate(test_data):
+        test = JsonFieldHasKeyTest(data=data)
+        test.save()
+    
+    # Retrieve and print the actual JSON data stored
+    for obj in JsonFieldHasKeyTest.objects.all():
+        print(f"ID {obj.id}: {obj.data} (type: {type(obj.data)})")
+    
+    # Test what the current compile_json_path function generates
+    from django.db.models.fields.json import compile_json_path
+    
+    test_keys = ['foo', '1111', 1111]
+    for key in test_keys:
+        path = compile_json_path([key])
+        print(f"Key {key!r} -> Path: {path}")
+
+if __name__ == '__main__':
+    debug_json_data()
\ No newline at end of file
diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fdca700c9d..d454908314 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -227,9 +227,50 @@ class HasKeyLookup(PostgresOperatorLookup):
         return super().as_postgresql(compiler, connection)
 
     def as_sqlite(self, compiler, connection):
-        return self.as_sql(
-            compiler, connection, template="JSON_TYPE(%s, %%s) IS NOT NULL"
-        )
+        # For SQLite, we need to use a custom approach because JSON_TYPE()
+        # doesn't work with array notation for numeric keys
+        # Process JSON path from the left-hand side.
+        if isinstance(self.lhs, KeyTransform):
+            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(
+                compiler, connection
+            )
+            lhs_json_path = compile_json_path(lhs_key_transforms)
+        else:
+            lhs, lhs_params = self.process_lhs(compiler, connection)
+            lhs_json_path = "$"
+        sql = "JSON_TYPE(%s, %%s) IS NOT NULL" % lhs
+        # Process JSON path from the right-hand side.
+        rhs = self.rhs
+        rhs_params = []
+        if not isinstance(rhs, (list, tuple)):
+            rhs = [rhs]
+        for key in rhs:
+            if isinstance(key, KeyTransform):
+                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
+            else:
+                rhs_key_transforms = [key]
+            # For SQLite, we need to use object notation for numeric keys
+            # instead of array notation
+            sqlite_path = self._compile_sqlite_json_path(rhs_key_transforms)
+            rhs_params.append("%s%s" % (lhs_json_path, sqlite_path))
+        # Add condition for each key.
+        if self.logical_operator:
+            sql = "(%s)" % self.logical_operator.join([sql] * len(rhs_params))
+        return sql, tuple(lhs_params) + tuple(rhs_params)
+
+    def _compile_sqlite_json_path(self, key_transforms):
+        """Compile JSON path for SQLite with object notation for numeric keys"""
+        path = []
+        for key_transform in key_transforms:
+            try:
+                num = int(key_transform)
+                # Use object notation for numeric keys to be compatible with SQLite's JSON_TYPE()
+                path.append(".")
+                path.append(json.dumps(str(key_transform)))
+            except ValueError:  # non-integer
+                path.append(".")
+                path.append(json.dumps(key_transform))
+        return "".join(path)
 
 
 class HasKey(HasKeyLookup):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..67259e8495
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the JSONField has_key issue with numeric keys on SQLite
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a test model
+class JsonFieldHasKeyTest(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table manually
+from django.db import connection
+with connection.cursor() as cursor:
+    cursor.execute('''
+        CREATE TABLE test_jsonfieldhaskeytest (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            data TEXT NOT NULL
+        )
+    ''')
+
+def test_json_field_has_key():
+    """Test the has_key lookup with both string and numeric keys"""
+    # Create test data
+    test1 = JsonFieldHasKeyTest(data={'foo': 'bar'})
+    test2 = JsonFieldHasKeyTest(data={'1111': 'bar'})
+    test1.save()
+    test2.save()
+    
+    # Test with string key
+    c1 = JsonFieldHasKeyTest.objects.filter(data__has_key='foo').count()
+    print(f"Count with key 'foo': {c1}")
+    
+    # Test with numeric key
+    c2 = JsonFieldHasKeyTest.objects.filter(data__has_key='1111').count()
+    print(f"Count with key '1111': {c2}")
+    
+    # Test with integer key (as string)
+    c3 = JsonFieldHasKeyTest.objects.filter(data__has_key=1111).count()
+    print(f"Count with key 1111: {c3}")
+    
+    # Expected results
+    print(f"Expected: 1, 1, 1")
+    print(f"Actual: {c1}, {c2}, {c3}")
+    
+    if c1 == 1 and c2 == 1 and c3 == 1:
+        print("SUCCESS: All tests passed!")
+        return True
+    else:
+        print("FAILURE: Tests failed!")
+        return False
+
+if __name__ == '__main__':
+    success = test_json_field_has_key()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_sqlite_json.py b/test_sqlite_json.py
new file mode 100644
index 0000000000..f99a5c5f5e
--- /dev/null
+++ b/test_sqlite_json.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+"""
+Test SQLite JSON_TYPE function behavior with numeric keys
+"""
+
+import sqlite3
+import json
+
+# Create an in-memory SQLite database
+conn = sqlite3.connect(':memory:')
+conn.enable_load_extension(True)
+
+# Create a test table with JSON data
+conn.execute('CREATE TABLE test_table (id INTEGER PRIMARY KEY, data TEXT)')
+
+# Insert test data with both string and numeric keys
+test_data1 = {'foo': 'bar'}
+test_data2 = {'1111': 'bar'}
+test_data3 = {1111: 'bar'}  # Integer key
+
+conn.execute('INSERT INTO test_table (data) VALUES (?)', (json.dumps(test_data1),))
+conn.execute('INSERT INTO test_table (data) VALUES (?)', (json.dumps(test_data2),))
+conn.execute('INSERT INTO test_table (data) VALUES (?)', (json.dumps(test_data3),))
+
+# Test JSON_TYPE function with different path formats
+queries = [
+    "SELECT JSON_TYPE(data, '$.foo') FROM test_table WHERE id = 1",
+    "SELECT JSON_TYPE(data, '$.\"1111\"') FROM test_table WHERE id = 2",
+    "SELECT JSON_TYPE(data, '$[1111]') FROM test_table WHERE id = 2",
+    "SELECT JSON_TYPE(data, '$.1111') FROM test_table WHERE id = 2",
+    "SELECT JSON_TYPE(data, '$.\"1111\"') FROM test_table WHERE id = 3",
+    "SELECT JSON_TYPE(data, '$[1111]') FROM test_table WHERE id = 3",
+    "SELECT JSON_TYPE(data, '$.1111') FROM test_table WHERE id = 3",
+]
+
+for query in queries:
+    result = conn.execute(query).fetchone()
+    print(f"{query} -> {result[0]}")
+
+conn.close()
\ No newline at end of file