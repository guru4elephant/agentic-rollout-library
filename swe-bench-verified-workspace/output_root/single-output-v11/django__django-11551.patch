diff --git a/accurate_test.py b/accurate_test.py
new file mode 100644
index 0000000000..8671aa156a
--- /dev/null
+++ b/accurate_test.py
@@ -0,0 +1,144 @@
+#!/usr/bin/env python3
+"""
+Accurate test that simulates the real PositionField behavior from django-positions.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Simulate the exact behavior described in the issue
+# PositionField is NOT a Django model field, but a descriptor added to the model
+class PositionDescriptor:
+    """Descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This is the key issue: when accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    
+    # This simulates how django-positions adds the PositionField
+    # It's not a model field, but a descriptor on the class
+    order = PositionDescriptor()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_check():
+    """Test the admin checks with the problematic descriptor"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    
+    # Run the checks
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+        if error.id == 'admin.E108':
+            print("    *** This is the bug we're trying to fix ***")
+    
+    return errors
+
+def test_descriptor_behavior():
+    """Test how our descriptor behaves"""
+    print("Testing descriptor behavior:")
+    
+    # Test accessing on class level
+    print("1. Accessing order on class level:")
+    try:
+        value = Thing.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test accessing on instance level
+    print("2. Accessing order on instance level:")
+    try:
+        instance = Thing()
+        value = instance.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test hasattr on class level
+    print("3. hasattr(Thing, 'order'):")
+    try:
+        result = hasattr(Thing, 'order')
+        print(f"   Result: {result}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+    
+    # Test getattr on class level
+    print("4. getattr(Thing, 'order'):")
+    try:
+        result = getattr(Thing, 'order')
+        print(f"   Result: {type(result).__name__}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+
+def test_field_lookup():
+    """Test field lookup behavior"""
+    print("\nTesting field lookup behavior:")
+    
+    # Test _meta.get_field
+    print("1. Thing._meta.get_field('order'):")
+    try:
+        field = Thing._meta.get_field('order')
+        print(f"   Result: {field}")
+        print(f"   Field type: {type(field).__name__}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+    except Exception as e:
+        print(f"   Other Exception: {e}")
+
+if __name__ == '__main__':
+    test_descriptor_behavior()
+    test_field_lookup()
+    print("\n" + "="*50)
+    errors = test_check()
+    
+    if any(error.id == 'admin.E108' for error in errors):
+        print("\n❌ BUG REPRODUCED: admin.E108 error found when it shouldn't be!")
+        sys.exit(1)
+    else:
+        print("\n✅ No admin.E108 error - the fix is working!")
+        sys.exit(0)
\ No newline at end of file
diff --git a/debug_fix.py b/debug_fix.py
new file mode 100644
index 0000000000..dbbd6dd4a8
--- /dev/null
+++ b/debug_fix.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Debug the fix to see what's happening step by step.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Simulate the exact behavior described in the issue
+class PositionDescriptor:
+    """Descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This is the key issue: when accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionDescriptor()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def debug_check_list_display_item():
+    """Debug the _check_list_display_item function step by step"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    item = 'order'
+    label = 'list_display[1]'
+    
+    print("Debugging _check_list_display_item:")
+    print(f"  item: {item}")
+    print(f"  label: {label}")
+    print(f"  obj: {admin_obj}")
+    print(f"  obj.model: {admin_obj.model}")
+    
+    # Step 1: Check if callable
+    print("\n1. Checking if callable:")
+    callable_result = callable(item)
+    print(f"   callable('{item}'): {callable_result}")
+    
+    # Step 2: Check if hasattr(obj, item)
+    print("\n2. Checking hasattr(obj, item):")
+    hasattr_obj_result = hasattr(admin_obj, item)
+    print(f"   hasattr({admin_obj}, '{item}'): {hasattr_obj_result}")
+    
+    # Step 3: Try _meta.get_field
+    print("\n3. Trying obj.model._meta.get_field(item):")
+    try:
+        field = admin_obj.model._meta.get_field(item)
+        print(f"   SUCCESS: {field}")
+        print(f"   Field type: {type(field).__name__}")
+        print(f"   isinstance(field, models.ManyToManyField): {isinstance(field, models.ManyToManyField)}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+        
+        # Step 4: Try getattr(obj.model, item)
+        print("\n4. Trying getattr(obj.model, item):")
+        try:
+            field = getattr(admin_obj.model, item)
+            print(f"   SUCCESS: {field}")
+            print(f"   Field type: {type(field).__name__}")
+            print(f"   isinstance(field, models.ManyToManyField): {isinstance(field, models.ManyToManyField)}")
+            
+            # This should return [] (no error)
+            print("\n5. Result: [] (no error)")
+            
+        except AttributeError as e:
+            print(f"   AttributeError: {e}")
+            print("\n5. Result: admin.E108 error")
+    
+    print("\nFinal result should be: [] (no error)")
+
+if __name__ == '__main__':
+    debug_check_list_display_item()
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..557358b8b0
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the behavior of our PositionField mock.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create a mock PositionField-like descriptor that raises AttributeError when accessed on class
+class PositionField:
+    """Mock descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This simulates the behavior that causes the issue
+            # When accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+def test_descriptor_behavior():
+    """Test how our descriptor behaves"""
+    print("Testing descriptor behavior:")
+    
+    # Test accessing on class level
+    print("1. Accessing order on class level:")
+    try:
+        value = Thing.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test accessing on instance level
+    print("2. Accessing order on instance level:")
+    try:
+        instance = Thing()
+        value = instance.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test hasattr on class level
+    print("3. hasattr(Thing, 'order'):")
+    try:
+        result = hasattr(Thing, 'order')
+        print(f"   Result: {result}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+    
+    # Test getattr on class level
+    print("4. getattr(Thing, 'order'):")
+    try:
+        result = getattr(Thing, 'order')
+        print(f"   Result: {type(result).__name__}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+
+def test_field_lookup():
+    """Test field lookup behavior"""
+    print("\nTesting field lookup behavior:")
+    
+    # Test _meta.get_field
+    print("1. Thing._meta.get_field('order'):")
+    try:
+        field = Thing._meta.get_field('order')
+        print(f"   Result: {field}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+    except Exception as e:
+        print(f"   Other Exception: {e}")
+
+if __name__ == '__main__':
+    test_descriptor_behavior()
+    test_field_lookup()
\ No newline at end of file
diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py
index f82c20c2f1..9fd77b5d41 100644
--- a/django/contrib/admin/checks.py
+++ b/django/contrib/admin/checks.py
@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):
             return []
         elif hasattr(obj, item):
             return []
-        elif hasattr(obj.model, item):
+        else:
             try:
                 field = obj.model._meta.get_field(item)
             except FieldDoesNotExist:
-                return []
-            else:
-                if isinstance(field, models.ManyToManyField):
+                try:
+                    field = getattr(obj.model, item)
+                except AttributeError:
                     return [
                         checks.Error(
-                            "The value of '%s' must not be a ManyToManyField." % label,
+                            "The value of '%s' refers to '%s', which is not a callable, "
+                            "an attribute of '%s', or an attribute or method on '%s.%s'." % (
+                                label, item, obj.__class__.__name__,
+                                obj.model._meta.app_label, obj.model._meta.object_name,
+                            ),
                             obj=obj.__class__,
-                            id='admin.E109',
+                            id='admin.E108',
                         )
                     ]
-                return []
-        else:
-            return [
-                checks.Error(
-                    "The value of '%s' refers to '%s', which is not a callable, "
-                    "an attribute of '%s', or an attribute or method on '%s.%s'." % (
-                        label, item, obj.__class__.__name__,
-                        obj.model._meta.app_label, obj.model._meta.object_name,
-                    ),
-                    obj=obj.__class__,
-                    id='admin.E108',
-                )
-            ]
+            if isinstance(field, models.ManyToManyField):
+                return [
+                    checks.Error(
+                        "The value of '%s' must not be a ManyToManyField." % label,
+                        obj=obj.__class__,
+                        id='admin.E109',
+                    )
+                ]
+            return []
 
     def _check_list_display_links(self, obj):
         """ Check that list_display_links is a unique subset of list_display.
diff --git a/final_comprehensive_test.py b/final_comprehensive_test.py
new file mode 100644
index 0000000000..766598a3a1
--- /dev/null
+++ b/final_comprehensive_test.py
@@ -0,0 +1,178 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test to verify the GitHub issue is fixed.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Simulate the exact scenario from the GitHub issue
+# PositionField that raises AttributeError when accessed on class level
+class PositionFieldDescriptor:
+    """Descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This is the key behavior that causes the issue
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a custom field that uses the problematic descriptor
+class PositionField(models.IntegerField):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.descriptor = PositionFieldDescriptor()
+    
+    def contribute_to_class(self, cls, name, **kwargs):
+        super().contribute_to_class(cls, name, **kwargs)
+        # Replace the default descriptor with our problematic one
+        setattr(cls, name, self.descriptor)
+
+# Create the exact model from the GitHub issue
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create the exact ModelAdmin from the GitHub issue
+@admin.register(Thing)
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_github_issue_scenario():
+    """Test the exact scenario described in the GitHub issue"""
+    print("Testing GitHub issue scenario:")
+    print("=" * 50)
+    print("Model: Thing with number (IntegerField) and order (PositionField)")
+    print("ModelAdmin: list_display = ['number', 'order']")
+    print()
+    
+    # Test the behavior that causes the issue
+    print("1. Testing hasattr(Thing, 'order'):")
+    hasattr_result = hasattr(Thing, 'order')
+    print(f"   Result: {hasattr_result}")
+    print("   ❌ This returns False because accessing order raises AttributeError")
+    
+    print("\n2. Testing Thing._meta.get_field('order'):")
+    try:
+        field = Thing._meta.get_field('order')
+        print(f"   ✅ SUCCESS: {field}")
+        print(f"   Field type: {type(field).__name__}")
+    except FieldDoesNotExist as e:
+        print(f"   ❌ FieldDoesNotExist: {e}")
+        return False
+    
+    print("\n3. Testing getattr(Thing, 'order'):")
+    try:
+        value = getattr(Thing, 'order')
+        print(f"   ❌ UNEXPECTED SUCCESS: {value}")
+    except AttributeError as e:
+        print(f"   ✅ EXPECTED AttributeError: {e}")
+    
+    # Run the actual admin checks
+    print("\n4. Running admin checks:")
+    admin_obj = ThingAdmin(Thing, admin.site)
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    has_e108 = any(error.id == 'admin.E108' for error in errors)
+    
+    print(f"\n5. Result: {'❌ admin.E108 error found (BUG)' if has_e108 else '✅ No admin.E108 error (FIXED)'}")
+    
+    return not has_e108
+
+def test_original_reproduction():
+    """Test the original reproduction case"""
+    print("\n" + "=" * 50)
+    print("Testing original reproduction case:")
+    print("=" * 50)
+    
+    # This is the original reproduction case from the issue
+    class PositionDescriptor:
+        def __get__(self, instance, owner):
+            if instance is None:
+                raise AttributeError("PositionField can only be accessed via instance")
+            return 1
+        
+        def __set__(self, instance, value):
+            pass
+
+    class Thing2(models.Model):
+        number = models.IntegerField(default=0)
+        order = PositionDescriptor()
+        
+        class Meta:
+            app_label = 'testapp2'
+
+    class ThingAdmin2(admin.ModelAdmin):
+        list_display = ['number', 'order']
+    
+    admin_obj = ThingAdmin2(Thing2, admin.site)
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    has_e108 = any(error.id == 'admin.E108' for error in errors)
+    print(f"Result: {'✅ E108 error (expected for non-field)' if has_e108 else '❌ No E108 error (unexpected)'}")
+    
+    return has_e108  # This should return E108 since it's not a field
+
+if __name__ == '__main__':
+    # Test the GitHub issue scenario (should NOT have E108)
+    scenario_1_result = test_github_issue_scenario()
+    
+    # Test the original reproduction (should have E108 since it's not a field)
+    scenario_2_result = test_original_reproduction()
+    
+    print("\n" + "=" * 50)
+    print("FINAL RESULTS:")
+    print("=" * 50)
+    print(f"GitHub issue scenario: {'PASS' if scenario_1_result else 'FAIL'}")
+    print(f"Original reproduction: {'PASS' if scenario_2_result else 'FAIL'}")
+    
+    if scenario_1_result and scenario_2_result:
+        print("\n🎉 SUCCESS! The GitHub issue has been fixed.")
+        print("   - PositionField in _meta but with problematic descriptor: ✅ No E108")
+        print("   - Non-field descriptor: ✅ Correctly raises E108")
+        sys.exit(0)
+    else:
+        print("\n❌ FAILURE! The fix needs more work.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..b79c749f6d
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,141 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix handles both scenarios correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Test Case 1: Field exists in _meta but descriptor raises exception (should work)
+class PositionFieldDescriptor:
+    """Descriptor that raises AttributeError when accessed on class level"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1
+    
+    def __set__(self, instance, value):
+        pass
+
+class PositionField(models.IntegerField):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.descriptor = PositionFieldDescriptor()
+    
+    def contribute_to_class(self, cls, name, **kwargs):
+        super().contribute_to_class(cls, name, **kwargs)
+        setattr(cls, name, self.descriptor)
+
+class ThingWithField(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp1'
+
+class ThingAdminWithField(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+# Test Case 2: Non-field descriptor (should raise E108)
+class NonFieldDescriptor:
+    """Descriptor that's not a field"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            raise AttributeError("NonField can only be accessed via instance")
+        return 1
+    
+    def __set__(self, instance, value):
+        pass
+
+class ThingWithoutField(models.Model):
+    number = models.IntegerField(default=0)
+    order = NonFieldDescriptor()
+    
+    class Meta:
+        app_label = 'testapp2'
+
+class ThingAdminWithoutField(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_case_1():
+    """Test case 1: Field exists in _meta but descriptor raises exception"""
+    print("=" * 60)
+    print("TEST CASE 1: Field exists in _meta but descriptor raises exception")
+    print("=" * 60)
+    
+    admin_obj = ThingAdminWithField(ThingWithField, admin.site)
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    has_e108 = any(error.id == 'admin.E108' for error in errors)
+    print(f"\nResult: {'❌ E108 error (UNEXPECTED)' if has_e108 else '✅ No E108 error (EXPECTED)'}")
+    
+    return not has_e108
+
+def test_case_2():
+    """Test case 2: Non-field descriptor (should raise E108)"""
+    print("\n" + "=" * 60)
+    print("TEST CASE 2: Non-field descriptor")
+    print("=" * 60)
+    
+    admin_obj = ThingAdminWithoutField(ThingWithoutField, admin.site)
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    has_e108 = any(error.id == 'admin.E108' for error in errors)
+    print(f"\nResult: {'✅ E108 error (EXPECTED)' if has_e108 else '❌ No E108 error (UNEXPECTED)'}")
+    
+    return has_e108
+
+if __name__ == '__main__':
+    case1_result = test_case_1()
+    case2_result = test_case_2()
+    
+    print("\n" + "=" * 60)
+    print("FINAL RESULTS:")
+    print("=" * 60)
+    print(f"Case 1 (Field in _meta): {'PASS' if case1_result else 'FAIL'}")
+    print(f"Case 2 (Non-field): {'PASS' if case2_result else 'FAIL'}")
+    
+    if case1_result and case2_result:
+        print("\n🎉 ALL TESTS PASSED! The fix is working correctly.")
+        sys.exit(0)
+    else:
+        print("\n❌ SOME TESTS FAILED! The fix needs more work.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/realistic_test.py b/realistic_test.py
new file mode 100644
index 0000000000..71181d5250
--- /dev/null
+++ b/realistic_test.py
@@ -0,0 +1,152 @@
+#!/usr/bin/env python3
+"""
+More realistic test using a proper Django field-like descriptor.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create a more realistic descriptor that behaves like a field
+class PositionField(models.Field):
+    """A field-like descriptor that raises AttributeError when accessed on class"""
+    
+    def __init__(self, *args, **kwargs):
+        kwargs['null'] = True
+        super().__init__(*args, **kwargs)
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This simulates the behavior that causes the issue
+            # When accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+    
+    def get_internal_type(self):
+        return "IntegerField"
+    
+    def formfield(self, **kwargs):
+        from django.forms import IntegerField
+        return IntegerField(**kwargs)
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_check():
+    """Test the admin checks with the problematic field"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    
+    # Run the checks
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+        if error.id == 'admin.E108':
+            print("    *** This is the bug we're trying to fix ***")
+    
+    return errors
+
+def test_descriptor_behavior():
+    """Test how our descriptor behaves"""
+    print("Testing descriptor behavior:")
+    
+    # Test accessing on class level
+    print("1. Accessing order on class level:")
+    try:
+        value = Thing.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test accessing on instance level
+    print("2. Accessing order on instance level:")
+    try:
+        instance = Thing()
+        value = instance.order
+        print(f"   Result: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Test hasattr on class level
+    print("3. hasattr(Thing, 'order'):")
+    try:
+        result = hasattr(Thing, 'order')
+        print(f"   Result: {result}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+    
+    # Test getattr on class level
+    print("4. getattr(Thing, 'order'):")
+    try:
+        result = getattr(Thing, 'order')
+        print(f"   Result: {type(result).__name__}")
+    except Exception as e:
+        print(f"   Exception: {e}")
+
+def test_field_lookup():
+    """Test field lookup behavior"""
+    print("\nTesting field lookup behavior:")
+    
+    # Test _meta.get_field
+    print("1. Thing._meta.get_field('order'):")
+    try:
+        field = Thing._meta.get_field('order')
+        print(f"   Result: {field}")
+        print(f"   Field type: {type(field).__name__}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+    except Exception as e:
+        print(f"   Other Exception: {e}")
+
+if __name__ == '__main__':
+    test_descriptor_behavior()
+    test_field_lookup()
+    print("\n" + "="*50)
+    errors = test_check()
+    
+    if any(error.id == 'admin.E108' for error in errors):
+        print("\n❌ BUG REPRODUCED: admin.E108 error found when it shouldn't be!")
+        sys.exit(1)
+    else:
+        print("\n✅ No admin.E108 error - the fix is working!")
+        sys.exit(0)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..887aa56e1d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the admin.E108 issue with PositionField-like descriptors.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create a mock PositionField-like descriptor that raises AttributeError when accessed on class
+class PositionField:
+    """Mock descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This simulates the behavior that causes the issue
+            # When accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_check():
+    """Test the admin checks with the problematic field"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    
+    # Run the checks
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+        if error.id == 'admin.E108':
+            print("    *** This is the bug we're trying to fix ***")
+    
+    return errors
+
+if __name__ == '__main__':
+    print("Testing admin.E108 issue reproduction...")
+    errors = test_check()
+    
+    if any(error.id == 'admin.E108' for error in errors):
+        print("\n❌ BUG REPRODUCED: admin.E108 error found when it shouldn't be!")
+        sys.exit(1)
+    else:
+        print("\n✅ No admin.E108 error - the fix is working!")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..1eae3de50e
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,160 @@
+#!/usr/bin/env python3
+"""
+Test to ensure our changes don't break existing functionality.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create test models
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key = models.ForeignKey('self', on_delete=models.CASCADE, null=True)
+    many_to_many = models.ManyToManyField('self')
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Test various scenarios
+def test_normal_field():
+    """Test normal field access"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = ['name']
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Normal field test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    return len(errors) == 0
+
+def test_foreign_key():
+    """Test foreign key field"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = ['foreign_key']
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Foreign key test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    return len(errors) == 0
+
+def test_many_to_many():
+    """Test many-to-many field (should raise E109)"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = ['many_to_many']
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Many-to-many test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    has_e109 = any(e.id == 'admin.E109' for e in errors)
+    return has_e109
+
+def test_nonexistent_field():
+    """Test non-existent field (should raise E108)"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = ['nonexistent']
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Non-existent field test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    has_e108 = any(e.id == 'admin.E108' for e in errors)
+    return has_e108
+
+def test_callable():
+    """Test callable in list_display"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = [lambda obj: obj.name]
+        
+        def test_method(self, obj):
+            return obj.name
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Callable test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    return len(errors) == 0
+
+def test_admin_method():
+    """Test admin method in list_display"""
+    class TestAdmin(admin.ModelAdmin):
+        list_display = ['test_method']
+        
+        def test_method(self, obj):
+            return obj.name
+    
+    admin_obj = TestAdmin(TestModel, admin.site)
+    errors = admin_obj.check()
+    
+    print("Admin method test:")
+    print(f"Errors: {[e.id for e in errors]}")
+    return len(errors) == 0
+
+if __name__ == '__main__':
+    print("Testing existing functionality...")
+    print("=" * 50)
+    
+    results = []
+    results.append(test_normal_field())
+    results.append(test_foreign_key())
+    results.append(test_many_to_many())
+    results.append(test_nonexistent_field())
+    results.append(test_callable())
+    results.append(test_admin_method())
+    
+    print("\n" + "=" * 50)
+    print("RESULTS:")
+    print("=" * 50)
+    
+    test_names = [
+        "Normal field", "Foreign key", "Many-to-many", 
+        "Non-existent field", "Callable", "Admin method"
+    ]
+    
+    all_passed = True
+    for i, (name, result) in enumerate(zip(test_names, results)):
+        status = "PASS" if result else "FAIL"
+        print(f"{i+1}. {name}: {status}")
+        if not result:
+            all_passed = False
+    
+    if all_passed:
+        print("\n🎉 ALL TESTS PASSED! Existing functionality is preserved.")
+        sys.exit(0)
+    else:
+        print("\n❌ SOME TESTS FAILED! The fix may have broken existing functionality.")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_field_in_meta.py b/test_field_in_meta.py
new file mode 100644
index 0000000000..a629ae5bd8
--- /dev/null
+++ b/test_field_in_meta.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Test with a field that exists in _meta but raises exception when accessed.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create a custom field that raises AttributeError when accessed on class
+class PositionField(models.IntegerField):
+    """A field that raises AttributeError when accessed on class level"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # Raise AttributeError when accessed on class level
+            raise AttributeError("PositionField can only be accessed via instance")
+        return super().__get__(instance, owner)
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_behavior():
+    """Test the behavior with a field that's in _meta but raises exception"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    item = 'order'
+    label = 'list_display[1]'
+    
+    print("Testing behavior:")
+    print(f"  item: {item}")
+    print(f"  label: {label}")
+    
+    # Test hasattr(obj.model, item)
+    print(f"\n1. hasattr(obj.model, '{item}'):")
+    hasattr_result = hasattr(admin_obj.model, item)
+    print(f"   Result: {hasattr_result}")
+    
+    # Test _meta.get_field
+    print(f"\n2. obj.model._meta.get_field('{item}'):")
+    try:
+        field = admin_obj.model._meta.get_field(item)
+        print(f"   SUCCESS: {field}")
+        print(f"   Field type: {type(field).__name__}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+    
+    # Test getattr
+    print(f"\n3. getattr(obj.model, '{item}'):")
+    try:
+        value = getattr(admin_obj.model, item)
+        print(f"   SUCCESS: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Run the actual checks
+    print(f"\n4. Running admin checks:")
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    return errors
+
+if __name__ == '__main__':
+    errors = test_behavior()
+    
+    print("\n" + "="*50)
+    if any(error.id == 'admin.E108' for error in errors):
+        print("❌ admin.E108 error found")
+        sys.exit(1)
+    else:
+        print("✅ No admin.E108 error")
+        sys.exit(0)
\ No newline at end of file
diff --git a/test_original_behavior.py b/test_original_behavior.py
new file mode 100644
index 0000000000..7db55dbea3
--- /dev/null
+++ b/test_original_behavior.py
@@ -0,0 +1,155 @@
+#!/usr/bin/env python3
+"""
+Test to understand the original behavior before the fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Simulate the original problematic behavior
+def original_check_list_display_item(obj, item, label):
+    """Original implementation with the bug"""
+    if callable(item):
+        return []
+    elif hasattr(obj, item):
+        return []
+    elif hasattr(obj.model, item):  # This is the problematic line
+        try:
+            field = obj.model._meta.get_field(item)
+        except FieldDoesNotExist:
+            return []
+        else:
+            if isinstance(field, models.ManyToManyField):
+                return [
+                    checks.Error(
+                        "The value of '%s' must not be a ManyToManyField." % label,
+                        obj=obj.__class__,
+                        id='admin.E109',
+                    )
+                ]
+            return []
+    else:
+        return [
+            checks.Error(
+                "The value of '%s' refers to '%s', which is not a callable, "
+                "an attribute of '%s', or an attribute or method on '%s.%s'." % (
+                    label, item, obj.__class__.__name__,
+                    obj.model._meta.app_label, obj.model._meta.object_name,
+                ),
+                obj=obj.__class__,
+                id='admin.E108',
+            )
+        ]
+
+# Simulate the exact behavior described in the issue
+class PositionDescriptor:
+    """Descriptor that behaves like django-positions PositionField"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            # This is the key issue: when accessed on the class, it raises AttributeError
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1  # Return some value for instances
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionDescriptor()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_original_behavior():
+    """Test the original behavior with the bug"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    item = 'order'
+    label = 'list_display[1]'
+    
+    print("Testing original behavior:")
+    print(f"  item: {item}")
+    print(f"  label: {label}")
+    
+    # Test hasattr(obj.model, item) - this is the problematic check
+    print(f"\n1. hasattr(obj.model, '{item}'):")
+    hasattr_result = hasattr(admin_obj.model, item)
+    print(f"   Result: {hasattr_result}")
+    
+    if not hasattr_result:
+        print("   ❌ This returns False, so the original code would skip _meta.get_field")
+        print("   ❌ and go straight to the else clause, returning E108")
+    else:
+        print("   ✅ This returns True, so the original code would try _meta.get_field")
+    
+    # Test the original function
+    print("\n2. Running original_check_list_display_item:")
+    errors = original_check_list_display_item(admin_obj, item, label)
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    return errors
+
+def test_fixed_behavior():
+    """Test the fixed behavior"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    
+    # Run the actual checks (with our fix)
+    errors = admin_obj.check()
+    
+    print("\nTesting fixed behavior:")
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    return errors
+
+if __name__ == '__main__':
+    original_errors = test_original_behavior()
+    fixed_errors = test_fixed_behavior()
+    
+    print("\n" + "="*50)
+    if any(error.id == 'admin.E108' for error in original_errors):
+        print("❌ ORIGINAL: admin.E108 error found (this is the bug)")
+    else:
+        print("✅ ORIGINAL: No admin.E108 error")
+    
+    if any(error.id == 'admin.E108' for error in fixed_errors):
+        print("❌ FIXED: admin.E108 error found (fix didn't work)")
+    else:
+        print("✅ FIXED: No admin.E108 error (fix worked)")
\ No newline at end of file
diff --git a/test_real_scenario.py b/test_real_scenario.py
new file mode 100644
index 0000000000..0fcf891b93
--- /dev/null
+++ b/test_real_scenario.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python3
+"""
+Test the real scenario: field exists in _meta but hasattr returns False.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.core import checks
+from django.core.exceptions import FieldDoesNotExist
+
+# Create a field descriptor that raises AttributeError when accessed on class
+class PositionFieldDescriptor:
+    """Descriptor that raises AttributeError when accessed on class level"""
+    
+    def __get__(self, instance, owner):
+        if instance is None:
+            raise AttributeError("PositionField can only be accessed via instance")
+        return 1
+    
+    def __set__(self, instance, value):
+        pass
+
+# Create a custom field that uses our problematic descriptor
+class PositionField(models.IntegerField):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        # Replace the default descriptor with our problematic one
+        self.descriptor = PositionFieldDescriptor()
+    
+    def contribute_to_class(self, cls, name, **kwargs):
+        super().contribute_to_class(cls, name, **kwargs)
+        # Replace the descriptor after contribution
+        setattr(cls, name, self.descriptor)
+
+# Create a test model
+class Thing(models.Model):
+    number = models.IntegerField(default=0)
+    order = PositionField()
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create a ModelAdmin
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ['number', 'order']
+
+def test_behavior():
+    """Test the real scenario"""
+    admin_obj = ThingAdmin(Thing, admin.site)
+    item = 'order'
+    label = 'list_display[1]'
+    
+    print("Testing real scenario:")
+    print(f"  item: {item}")
+    print(f"  label: {label}")
+    
+    # Test hasattr(obj.model, item) - this should return False
+    print(f"\n1. hasattr(obj.model, '{item}'):")
+    hasattr_result = hasattr(admin_obj.model, item)
+    print(f"   Result: {hasattr_result}")
+    
+    # Test _meta.get_field - this should succeed
+    print(f"\n2. obj.model._meta.get_field('{item}'):")
+    try:
+        field = admin_obj.model._meta.get_field(item)
+        print(f"   SUCCESS: {field}")
+        print(f"   Field type: {type(field).__name__}")
+    except FieldDoesNotExist as e:
+        print(f"   FieldDoesNotExist: {e}")
+    
+    # Test getattr - this should fail with AttributeError
+    print(f"\n3. getattr(obj.model, '{item}'):")
+    try:
+        value = getattr(admin_obj.model, item)
+        print(f"   SUCCESS: {value}")
+    except AttributeError as e:
+        print(f"   AttributeError: {e}")
+    
+    # Run the actual checks
+    print(f"\n4. Running admin checks:")
+    errors = admin_obj.check()
+    
+    print("Errors found:")
+    for error in errors:
+        print(f"  - {error.id}: {error.msg}")
+    
+    return errors
+
+if __name__ == '__main__':
+    errors = test_behavior()
+    
+    print("\n" + "="*50)
+    if any(error.id == 'admin.E108' for error in errors):
+        print("❌ admin.E108 error found")
+        sys.exit(1)
+    else:
+        print("✅ No admin.E108 error")
+        sys.exit(0)
\ No newline at end of file