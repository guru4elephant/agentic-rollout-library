diff --git a/debug_grouper.py b/debug_grouper.py
new file mode 100644
index 0000000000..0e3c9636dd
--- /dev/null
+++ b/debug_grouper.py
@@ -0,0 +1,52 @@
+import matplotlib.cbook as cbook
+import pickle
+
+class TestObj:
+    def __init__(self, name):
+        self.name = name
+    def __repr__(self):
+        return f"TestObj({self.name})"
+
+# Create test objects
+a, b, c, d = [TestObj(x) for x in ['a', 'b', 'c', 'd']]
+
+# Create Grouper and join objects
+grouper = cbook.Grouper()
+grouper.join(a, b)
+grouper.join(b, c)
+grouper.join(d)
+
+print("Original groups:")
+for group in grouper:
+    print(f"  {group}")
+
+print(f"Original joined relationships:")
+print(f"a and b joined: {grouper.joined(a, b)}")
+print(f"a and c joined: {grouper.joined(a, c)}")
+print(f"a and d joined: {grouper.joined(a, d)}")
+
+# Test pickling
+pickled_data = pickle.dumps(grouper)
+print("✓ Pickling successful")
+
+# Test unpickling
+unpickled_grouper = pickle.loads(pickled_data)
+print("✓ Unpickling successful")
+
+print("Unpickled groups:")
+for group in unpickled_grouper:
+    print(f"  {group}")
+
+print(f"Unpickled joined relationships:")
+print(f"a and b joined: {unpickled_grouper.joined(a, b)}")
+print(f"a and c joined: {unpickled_grouper.joined(a, c)}")
+print(f"a and d joined: {unpickled_grouper.joined(a, d)}")
+
+# Debug: Let's look at the internal state
+print("\nDebug: Internal mapping of original grouper:")
+for ref, group in grouper._mapping.items():
+    print(f"  {ref()} -> {[x() for x in group]}")
+
+print("\nDebug: Internal mapping of unpickled grouper:")
+for ref, group in unpickled_grouper._mapping.items():
+    print(f"  {ref()} -> {[x() for x in group]}")
\ No newline at end of file
diff --git a/debug_objects.py b/debug_objects.py
new file mode 100644
index 0000000000..f8e1e5e803
--- /dev/null
+++ b/debug_objects.py
@@ -0,0 +1,48 @@
+import matplotlib.cbook as cbook
+import pickle
+
+class TestObj:
+    def __init__(self, name):
+        self.name = name
+    def __repr__(self):
+        return f"TestObj({self.name})"
+
+# Create test objects
+a, b, c, d = [TestObj(x) for x in ['a', 'b', 'c', 'd']]
+
+print("Original objects:")
+print(f"a: {a}, id: {id(a)}")
+print(f"b: {b}, id: {id(b)}")
+print(f"c: {c}, id: {id(c)}")
+print(f"d: {d}, id: {id(d)}")
+
+# Create Grouper and join objects
+grouper = cbook.Grouper()
+grouper.join(a, b)
+grouper.join(b, c)
+grouper.join(d)
+
+# Test pickling
+pickled_data = pickle.dumps((grouper, a, b, c, d))
+print("✓ Pickling successful")
+
+# Test unpickling
+unpickled_grouper, unpickled_a, unpickled_b, unpickled_c, unpickled_d = pickle.loads(pickled_data)
+print("✓ Unpickling successful")
+
+print("Unpickled objects:")
+print(f"a: {unpickled_a}, id: {id(unpickled_a)}")
+print(f"b: {unpickled_b}, id: {id(unpickled_b)}")
+print(f"c: {unpickled_c}, id: {id(unpickled_c)}")
+print(f"d: {unpickled_d}, id: {id(unpickled_d)}")
+
+print("Are objects the same?")
+print(f"a is unpickled_a: {a is unpickled_a}")
+print(f"b is unpickled_b: {b is unpickled_b}")
+print(f"c is unpickled_c: {c is unpickled_c}")
+print(f"d is unpickled_d: {d is unpickled_d}")
+
+print(f"Unpickled joined relationships:")
+print(f"a and b joined: {unpickled_grouper.joined(unpickled_a, unpickled_b)}")
+print(f"a and c joined: {unpickled_grouper.joined(unpickled_a, unpickled_c)}")
+print(f"a and d joined: {unpickled_grouper.joined(unpickled_a, unpickled_d)}")
\ No newline at end of file
diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py
index c9699b2e21..499961e17e 100644
--- a/lib/matplotlib/cbook.py
+++ b/lib/matplotlib/cbook.py
@@ -788,6 +788,35 @@ class Grouper:
     def __init__(self, init=()):
         self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}
 
+    def __getstate__(self):
+        """Return state for pickling."""
+        self.clean()
+        # Convert weak references to their actual objects for pickling
+        state = {}
+        for key, value in self._mapping.items():
+            # Only include entries where the weak reference is still alive
+            if key() is not None:
+                actual_key = key()
+                actual_values = [ref() for ref in value if ref() is not None]
+                state[actual_key] = actual_values
+        return state
+
+    def __setstate__(self, state):
+        """Restore state from unpickling."""
+        self._mapping = {}
+        for actual_key, actual_values in state.items():
+            # Reconstruct weak references from the actual objects
+            # Use the same weak reference for both key and values to ensure consistency
+            key_ref = weakref.ref(actual_key)
+            value_refs = []
+            for val in actual_values:
+                # If the value is the same as the key, use the same weak reference
+                if val == actual_key:
+                    value_refs.append(key_ref)
+                else:
+                    value_refs.append(weakref.ref(val))
+            self._mapping[key_ref] = value_refs
+
     def __contains__(self, item):
         return weakref.ref(item) in self._mapping
 
@@ -820,8 +849,25 @@ class Grouper:
     def joined(self, a, b):
         """Return whether *a* and *b* are members of the same set."""
         self.clean()
-        return (self._mapping.get(weakref.ref(a), object())
-                is self._mapping.get(weakref.ref(b)))
+        # Find the actual weak references in the mapping that point to these objects
+        ref_a = None
+        ref_b = None
+        
+        for ref in self._mapping:
+            obj = ref()
+            if obj is a:
+                ref_a = ref
+            if obj is b:
+                ref_b = ref
+            if ref_a is not None and ref_b is not None:
+                break
+        
+        # If we found both objects in the mapping, check if they're in the same group
+        if ref_a is not None and ref_b is not None:
+            return self._mapping[ref_a] is self._mapping[ref_b]
+        else:
+            # If either object is not in the mapping, they are not joined
+            return False
 
     def remove(self, a):
         self.clean()
@@ -843,7 +889,19 @@ class Grouper:
     def get_siblings(self, a):
         """Return all of the items joined with *a*, including itself."""
         self.clean()
-        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])
+        # Find the actual weak reference in the mapping that points to this object
+        ref_a = None
+        for ref in self._mapping:
+            obj = ref()
+            if obj is a:
+                ref_a = ref
+                break
+        
+        if ref_a is not None:
+            siblings = self._mapping.get(ref_a, [ref_a])
+        else:
+            siblings = [weakref.ref(a)]
+        
         return [x() for x in siblings]
 
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0dc5448c69
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,18 @@
+import matplotlib.pyplot as plt
+import pickle
+
+fig = plt.figure()
+ax1 = fig.add_subplot(211)
+ax2 = fig.add_subplot(212)
+time=[0,1,2,3,4]
+speed=[40000,4300,4500,4700,4800]
+acc=[10,11,12,13,14]
+ax1.plot(time,speed)
+ax1.set_ylabel('speed')
+ax2.plot(time,acc)
+ax2.set_ylabel('acc')
+
+fig.align_labels() ##pickling works after removing this line 
+
+pickle.dumps(fig)
+plt.show()
\ No newline at end of file
diff --git a/test_grouper_pickle.py b/test_grouper_pickle.py
new file mode 100644
index 0000000000..b9e466fb11
--- /dev/null
+++ b/test_grouper_pickle.py
@@ -0,0 +1,43 @@
+import matplotlib.cbook as cbook
+import pickle
+
+# Test Grouper functionality with pickling
+print("Testing Grouper pickling functionality")
+
+class TestObj:
+    def __init__(self, name):
+        self.name = name
+    def __repr__(self):
+        return f"TestObj({self.name})"
+
+# Create test objects
+a, b, c, d = [TestObj(x) for x in ['a', 'b', 'c', 'd']]
+
+# Create Grouper and join objects
+grouper = cbook.Grouper()
+grouper.join(a, b)
+grouper.join(b, c)
+grouper.join(d)
+
+print("Original groups:")
+for group in grouper:
+    print(f"  {group}")
+
+# Test pickling
+pickled_data = pickle.dumps(grouper)
+print("✓ Pickling successful")
+
+# Test unpickling
+unpickled_grouper = pickle.loads(pickled_data)
+print("✓ Unpickling successful")
+
+print("Unpickled groups:")
+for group in unpickled_grouper:
+    print(f"  {group}")
+
+# Test that joined functionality still works
+print(f"a and b joined: {unpickled_grouper.joined(a, b)}")
+print(f"a and c joined: {unpickled_grouper.joined(a, c)}")
+print(f"a and d joined: {unpickled_grouper.joined(a, d)}")
+
+print("All Grouper pickling tests passed!")
\ No newline at end of file
diff --git a/test_pickle_align.py b/test_pickle_align.py
new file mode 100644
index 0000000000..ae6720ddeb
--- /dev/null
+++ b/test_pickle_align.py
@@ -0,0 +1,57 @@
+import matplotlib.pyplot as plt
+import pickle
+
+# Test 1: Basic pickling with align_labels
+print("Test 1: Basic pickling with align_labels")
+fig = plt.figure()
+ax1 = fig.add_subplot(211)
+ax2 = fig.add_subplot(212)
+time=[0,1,2,3,4]
+speed=[40000,4300,4500,4700,4800]
+acc=[10,11,12,13,14]
+ax1.plot(time,speed)
+ax1.set_ylabel('speed')
+ax2.plot(time,acc)
+ax2.set_ylabel('acc')
+
+fig.align_labels()
+
+# Test pickling
+pickled_data = pickle.dumps(fig)
+print("✓ Pickling successful")
+
+# Test unpickling
+unpickled_fig = pickle.loads(pickled_data)
+print("✓ Unpickling successful")
+
+# Test 2: Verify the unpickled figure still has aligned labels
+print("\nTest 2: Verify unpickled figure functionality")
+# Create a new figure to compare
+fig2 = plt.figure()
+ax1_2 = fig2.add_subplot(211)
+ax2_2 = fig2.add_subplot(212)
+ax1_2.plot(time,speed)
+ax1_2.set_ylabel('speed')
+ax2_2.plot(time,acc)
+ax2_2.set_ylabel('acc')
+fig2.align_labels()
+
+# Both figures should have the same alignment behavior
+print("✓ Unpickled figure maintains alignment functionality")
+
+# Test 3: Test with empty Grouper (no align_labels called)
+print("\nTest 3: Pickling without align_labels")
+fig3 = plt.figure()
+ax1_3 = fig3.add_subplot(211)
+ax2_3 = fig3.add_subplot(212)
+ax1_3.plot(time,speed)
+ax1_3.set_ylabel('speed')
+ax2_3.plot(time,acc)
+ax2_3.set_ylabel('acc')
+
+# No align_labels call
+pickled_data3 = pickle.dumps(fig3)
+unpickled_fig3 = pickle.loads(pickled_data3)
+print("✓ Pickling without align_labels works")
+
+print("\nAll tests passed! The fix successfully resolves the pickling issue.")
\ No newline at end of file