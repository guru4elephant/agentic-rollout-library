diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..930c355d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,15 @@
+import xarray as xr
+
+good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])
+
+class HasValues(object):
+    values = 5
+    
+good_indexed.loc[{'dim_0': 0}] = set()
+bad_indexed.loc[{'dim_0': 0}] = HasValues()
+
+print("good_indexed.values:", good_indexed.values)
+print("bad_indexed.values:", bad_indexed.values)
+
+# Expected: bad_indexed.values should be array([<__main__.HasValues instance>], dtype=object)
+# Actual: bad_indexed.values => array([array(5)], dtype=object)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..8a46e5d1
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,66 @@
+import xarray as xr
+import pandas as pd
+import numpy as np
+
+# Test 1: Objects with values property should not be coerced
+class HasValues(object):
+    values = 42
+    
+class HasValuesComplex(object):
+    def __init__(self, val):
+        self.values = val
+
+# Test 2: Pandas objects should still have their values extracted
+series = pd.Series([1, 2, 3])
+df = pd.DataFrame({'a': [4, 5, 6]})
+
+# Test 3: Xarray objects should still have their values extracted
+da = xr.DataArray([7, 8, 9])
+ds = xr.Dataset({'b': ('x', [10, 11, 12])})
+
+# Test assignments
+results = {}
+
+# Test object with values property
+arr1 = xr.DataArray([None])
+arr1.loc[{'dim_0': 0}] = HasValues()
+results['HasValues'] = arr1.values[0]
+
+# Test object with complex values property
+arr2 = xr.DataArray([None])
+arr2.loc[{'dim_0': 0}] = HasValuesComplex("test")
+results['HasValuesComplex'] = arr2.values[0]
+
+# Test pandas Series (single value)
+arr3 = xr.DataArray([None])
+arr3.loc[{'dim_0': 0}] = series.iloc[0]
+results['Series'] = arr3.values[0]
+
+# Test pandas DataFrame (single value)
+arr4 = xr.DataArray([None])
+arr4.loc[{'dim_0': 0}] = df.iloc[0, 0]
+results['DataFrame'] = arr4.values[0]
+
+# Test xarray DataArray (single value)
+arr5 = xr.DataArray([None])
+arr5.loc[{'dim_0': 0}] = da.values[0]
+results['DataArray'] = arr5.values[0]
+
+# Test xarray Dataset (single value)
+arr6 = xr.DataArray([None])
+arr6.loc[{'dim_0': 0}] = ds['b'].values[0]
+results['Dataset'] = arr6.values[0]
+
+# Print results
+for key, value in results.items():
+    print(f"{key}: {value} (type: {type(value)})")
+
+# Verify the fix
+assert isinstance(results['HasValues'], HasValues), "HasValues object should be preserved"
+assert isinstance(results['HasValuesComplex'], HasValuesComplex), "HasValuesComplex object should be preserved"
+assert results['Series'] == 1, "Pandas Series value should be extracted"
+assert results['DataFrame'] == 4, "Pandas DataFrame value should be extracted"
+assert results['DataArray'] == 7, "Xarray DataArray value should be extracted"
+assert results['Dataset'] == 10, "Xarray Dataset value should be extracted"
+
+print("All tests passed!")
\ No newline at end of file
diff --git a/test_pandas_detection.py b/test_pandas_detection.py
new file mode 100644
index 00000000..740d70f1
--- /dev/null
+++ b/test_pandas_detection.py
@@ -0,0 +1,18 @@
+import pandas as pd
+import xarray as xr
+
+# Test if pandas objects have _typ attribute
+series = pd.Series([1, 2, 3])
+df = pd.DataFrame({'a': [1, 2, 3]})
+
+print("Series _typ:", getattr(series, '_typ', 'No _typ'))
+print("DataFrame _typ:", getattr(df, '_typ', 'No _typ'))
+print("Series module:", series.__class__.__module__)
+print("DataFrame module:", df.__class__.__module__)
+
+# Test xarray objects
+da = xr.DataArray([1, 2, 3])
+ds = xr.Dataset({'a': ('x', [1, 2, 3])})
+
+print("DataArray module:", da.__class__.__module__)
+print("Dataset module:", ds.__class__.__module__)
\ No newline at end of file
diff --git a/test_pandas_xarray.py b/test_pandas_xarray.py
new file mode 100644
index 00000000..7cce620b
--- /dev/null
+++ b/test_pandas_xarray.py
@@ -0,0 +1,32 @@
+import xarray as xr
+import pandas as pd
+import numpy as np
+
+# Test that pandas objects still work correctly
+da = xr.DataArray([1, 2, 3])
+series = pd.Series([4, 5, 6])
+df = pd.DataFrame({'a': [7, 8, 9]})
+
+# Test assignment with pandas Series (single value)
+da2 = xr.DataArray([None])
+da2.loc[{'dim_0': 0}] = series.iloc[0]
+print("Series single value assignment:", da2.values)
+
+# Test assignment with pandas DataFrame (single value)
+da3 = xr.DataArray([None])
+da3.loc[{'dim_0': 0}] = df.iloc[0, 0]
+print("DataFrame single value assignment:", da3.values)
+
+# Test assignment with xarray DataArray (single value)
+da4 = xr.DataArray([None])
+da5 = xr.DataArray([10])
+da4.loc[{'dim_0': 0}] = da5.values[0]
+print("DataArray single value assignment:", da4.values)
+
+# Test that regular objects with values property still work
+class HasValues(object):
+    values = 42
+    
+da5 = xr.DataArray([None])
+da5.loc[{'dim_0': 0}] = HasValues()
+print("HasValues assignment:", da5.values)
\ No newline at end of file
diff --git a/xarray/core/variable.py b/xarray/core/variable.py
index 45553eb9..29a63faf 100644
--- a/xarray/core/variable.py
+++ b/xarray/core/variable.py
@@ -218,7 +218,20 @@ def as_compatible_data(data, fastpath=False):
         data = np.timedelta64(getattr(data, "value", data), "ns")
 
     # we don't want nested self-described arrays
-    data = getattr(data, "values", data)
+    # Only extract .values for pandas or xarray objects, not arbitrary objects
+    if hasattr(data, "values"):
+        # Check if it's a pandas Series or DataFrame
+        if hasattr(data, '_typ') and data._typ in ['series', 'dataframe']:
+            data = data.values
+        # Check if it's an xarray DataArray or Dataset
+        elif hasattr(data, '__class__') and hasattr(data.__class__, '__module__'):
+            module_name = data.__class__.__module__
+            if module_name and ('xarray' in module_name or 'pandas' in module_name):
+                data = data.values
+        # For other objects with .values property, don't extract it automatically
+        # to avoid coercing types on objects that happen to have a values property
+        else:
+            pass
 
     if isinstance(data, np.ma.MaskedArray):
         mask = np.ma.getmaskarray(data)