diff --git a/demonstrate_fix.py b/demonstrate_fix.py
new file mode 100644
index 000000000..fdcc89f49
--- /dev/null
+++ b/demonstrate_fix.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+"""
+Script to demonstrate that the dict(str,str) parameter issue is fixed
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+def demonstrate_fix():
+    """Demonstrate that the fix works for the reported issue"""
+    print("Demonstrating the fix for :param dict(str,str) rendering issue")
+    print("=" * 60)
+    
+    # Import the fixed parsing logic
+    from sphinx.ext.autodoc.typehints import modify_field_list
+    from docutils import nodes
+    
+    # Create the exact problematic field from the issue
+    field_list = nodes.field_list()
+    
+    # This field would be generated from:
+    # :param dict(str, str) opc_meta: (optional)
+    field = nodes.field()
+    field += nodes.field_name('', 'param dict(str, str) opc_meta')
+    field += nodes.field_body('', nodes.paragraph('', '(optional)'))
+    field_list += field
+    
+    # Test the parsing logic
+    field_name = 'param dict(str, str) opc_meta'
+    import re
+    parts = re.split(' +', field_name)
+    
+    print(f"Original field name: '{field_name}'")
+    print(f"Parts after splitting: {parts}")
+    
+    # Show the old vs new logic
+    if parts[0] == 'param' and len(parts) > 2:
+        old_name = ' '.join(parts[2:])
+        new_name = parts[-1]
+        
+        print(f"\nOLD logic (broken): ' '.join(parts[2:]) = '{old_name}'")
+        print(f"NEW logic (fixed): parts[-1] = '{new_name}'")
+        
+        print(f"\nExpected parameter name: 'opc_meta'")
+        print(f"Old logic result: '{old_name}' ‚ùå (INCORRECT)")
+        print(f"New logic result: '{new_name}' ‚úÖ (CORRECT)")
+        
+        if new_name == 'opc_meta':
+            print("\nüéâ SUCCESS: The fix correctly extracts the parameter name!")
+        else:
+            print("\n‚ùå FAILURE: The fix does not work correctly")
+    
+    # Test with modify_field_list to ensure no errors
+    annotations = {'opc_meta': 'Dict[str, str]'}
+    try:
+        modify_field_list(field_list, annotations)
+        print("\n‚úÖ modify_field_list completed without errors")
+    except Exception as e:
+        print(f"\n‚ùå modify_field_list failed: {e}")
+
+if __name__ == "__main__":
+    demonstrate_fix()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..5d0f60e6e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the docstring rendering issue with :param dict(str,str)
+"""
+
+import tempfile
+import os
+import sys
+from pathlib import Path
+import re
+
+# Add the sphinx package to the path
+sys.path.insert(0, '/testbed')
+
+def test_field_parsing():
+    """Test how field parsing works with complex parameter types"""
+    
+    # Import the docstring parsing utilities
+    from sphinx.util.docstrings import separate_metadata
+    from docutils.parsers.rst.states import Body
+    
+    # Test docstring with the problematic parameter
+    docstring = '''
+Some function description.
+
+:param dict(str, str) opc_meta: (optional) A dictionary mapping strings to strings
+:return: None
+'''
+    
+    print("Original docstring:")
+    print(docstring)
+    print("\n" + "="*50 + "\n")
+    
+    # Test the field marker regex directly
+    field_list_item_re = re.compile(Body.patterns['field_marker'])
+    
+    lines = docstring.splitlines()
+    for line in lines:
+        if line.strip():
+            matched = field_list_item_re.match(line)
+            if matched:
+                field_name = matched.group()[1:].split(':', 1)[0]
+                print(f"Line: '{line}'")
+                print(f"Matched: '{matched.group()}'")
+                print(f"Field name: '{field_name}'")
+                print(f"Rest of line: '{line[matched.end():].strip()}'")
+                print("---")
+    
+    # Try to extract metadata
+    try:
+        content, metadata = separate_metadata(docstring)
+        print("Separated content:")
+        print(content)
+        print("\nSeparated metadata:")
+        print(metadata)
+        
+    except Exception as e:
+        print(f"Error during parsing: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    test_field_parsing()
\ No newline at end of file
diff --git a/setup.py b/setup.py
index 2538952e3..94e1d8b32 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.14,<0.18',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py
index af4b47bb0..940545765 100644
--- a/sphinx/ext/autodoc/typehints.py
+++ b/sphinx/ext/autodoc/typehints.py
@@ -93,7 +93,8 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No
                 arg['param'] = True
             elif len(parts) > 2:
                 # :param xxx yyy:
-                name = ' '.join(parts[2:])
+                # The parameter name is always the last part
+                name = parts[-1]
                 arg = arguments.setdefault(name, {})
                 arg['param'] = True
                 arg['type'] = True
@@ -143,7 +144,8 @@ def augment_descriptions_with_types(
                 has_description.add(parts[1])
             elif len(parts) > 2:
                 # :param xxx yyy:
-                name = ' '.join(parts[2:])
+                # The parameter name is always the last part
+                name = parts[-1]
                 has_description.add(name)
                 has_type.add(name)
         elif parts[0] == 'type':
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 000000000..427758efe
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for parameter parsing
+"""
+
+import re
+
+def test_various_cases():
+    """Test various parameter parsing cases"""
+    
+    test_cases = [
+        "param dict(str, str) opc_meta",
+        "param int count",
+        "param str name", 
+        "param List[str] items",
+        "param Dict[str, int] mapping",
+        "param tuple(int, str) pair",
+        "param CustomClass obj",
+        "param Union[str, int] value",
+    ]
+    
+    for field_name in test_cases:
+        print(f"\nField name: '{field_name}'")
+        
+        # Current approach (broken)
+        parts = re.split(' +', field_name)
+        print(f"Parts after split: {parts}")
+        
+        if parts[0] == 'param' and len(parts) > 2:
+            name_current = ' '.join(parts[2:])
+            print(f"Extracted name (current): '{name_current}'")
+            
+            # Simple fix: take the last part
+            name_simple = parts[-1]
+            print(f"Extracted name (simple fix): '{name_simple}'")
+            
+            # More robust approach: everything after the type
+            # The pattern is always: param <type> <name>
+            # So we need to find where the type ends and name begins
+            if len(parts) >= 3:
+                # The name is always the last token
+                name_robust = parts[-1]
+                print(f"Extracted name (robust): '{name_robust}'")
+
+if __name__ == "__main__":
+    test_various_cases()
\ No newline at end of file
diff --git a/test_comprehensive_fix.py b/test_comprehensive_fix.py
new file mode 100644
index 000000000..aaa192ee3
--- /dev/null
+++ b/test_comprehensive_fix.py
@@ -0,0 +1,135 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix handles all edge cases
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc.typehints import modify_field_list, augment_descriptions_with_types
+from docutils import nodes
+
+def create_field_node(field_name, field_body):
+    """Create a field node for testing"""
+    field = nodes.field()
+    field += nodes.field_name('', field_name)
+    field += nodes.field_body('', nodes.paragraph('', field_body))
+    return field
+
+def test_all_parameter_types():
+    """Test various parameter types to ensure the fix works for all cases"""
+    print("Testing various parameter types...")
+    
+    test_cases = [
+        # (field_name, expected_parameter_name)
+        ('param dict(str, str) opc_meta', 'opc_meta'),
+        ('param int count', 'count'),
+        ('param str name', 'name'),
+        ('param List[str] items', 'items'),
+        ('param Dict[str, int] mapping', 'mapping'),
+        ('param tuple(int, str) pair', 'pair'),
+        ('param CustomClass obj', 'obj'),
+        ('param Union[str, int] value', 'value'),
+        ('param Optional[str] maybe_str', 'maybe_str'),
+        ('param Callable[[], None] callback', 'callback'),
+    ]
+    
+    all_passed = True
+    
+    for field_name, expected_name in test_cases:
+        print(f"\nTesting: '{field_name}'")
+        
+        # Test the parsing logic
+        import re
+        parts = re.split(' +', field_name)
+        
+        if parts[0] == 'param':
+            if len(parts) == 2:
+                extracted_name = parts[1]
+                print(f"  Simple param: '{extracted_name}'")
+            elif len(parts) > 2:
+                # New logic (fixed)
+                extracted_name = parts[-1]
+                print(f"  Extracted name: '{extracted_name}'")
+                
+                if extracted_name == expected_name:
+                    print(f"  ‚úì PASS: Expected '{expected_name}', got '{extracted_name}'")
+                else:
+                    print(f"  ‚úó FAIL: Expected '{expected_name}', got '{extracted_name}'")
+                    all_passed = False
+    
+    return all_passed
+
+def test_modify_field_list_comprehensive():
+    """Test modify_field_list with various parameter types"""
+    print("\n" + "="*50)
+    print("Testing modify_field_list comprehensively...")
+    
+    field_list = nodes.field_list()
+    
+    # Add various parameter types
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) Dictionary')
+    field_list += create_field_node('param int count', 'Integer count')
+    field_list += create_field_node('param List[str] items', 'List of strings')
+    field_list += create_field_node('param Dict[str, int] mapping', 'Mapping')
+    
+    annotations = {
+        'opc_meta': 'Dict[str, str]',
+        'count': 'int',
+        'items': 'List[str]',
+        'mapping': 'Dict[str, int]'
+    }
+    
+    print("Before modify_field_list:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    modify_field_list(field_list, annotations)
+    
+    print("\nAfter modify_field_list:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Check that no errors occurred
+    print("‚úì modify_field_list completed without errors")
+
+def test_augment_descriptions_with_types_comprehensive():
+    """Test augment_descriptions_with_types with various parameter types"""
+    print("\n" + "="*50)
+    print("Testing augment_descriptions_with_types comprehensively...")
+    
+    field_list = nodes.field_list()
+    
+    # Add various parameter types
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) Dictionary')
+    field_list += create_field_node('param int count', 'Integer count')
+    field_list += create_field_node('param List[str] items', 'List of strings')
+    
+    annotations = {
+        'opc_meta': 'Dict[str, str]',
+        'count': 'int',
+        'items': 'List[str]'
+    }
+    
+    print("Before augment_descriptions_with_types:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    augment_descriptions_with_types(field_list, annotations)
+    
+    print("\nAfter augment_descriptions_with_types:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Check that no errors occurred
+    print("‚úì augment_descriptions_with_types completed without errors")
+
+if __name__ == "__main__":
+    success = test_all_parameter_types()
+    test_modify_field_list_comprehensive()
+    test_augment_descriptions_with_types_comprehensive()
+    
+    if success:
+        print("\nüéâ ALL TESTS PASSED! The fix is working correctly.")
+    else:
+        print("\n‚ùå SOME TESTS FAILED! The fix needs more work.")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..27fb2d0d1
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""
+Test to verify the fix works correctly
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc.typehints import modify_field_list, augment_descriptions_with_types
+from docutils import nodes
+
+def create_field_node(field_name, field_body):
+    """Create a field node for testing"""
+    field = nodes.field()
+    field += nodes.field_name('', field_name)
+    field += nodes.field_body('', nodes.paragraph('', field_body))
+    return field
+
+def test_modify_field_list():
+    """Test the modify_field_list function"""
+    print("Testing modify_field_list...")
+    
+    # Create a field list with the problematic parameter
+    field_list = nodes.field_list()
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) A dictionary')
+    field_list += create_field_node('param int count', 'An integer count')
+    
+    annotations = {'opc_meta': 'Dict[str, str]', 'count': 'int'}
+    
+    print("Before modification:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Apply the modification
+    modify_field_list(field_list, annotations)
+    
+    print("\nAfter modification:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+
+def test_augment_descriptions_with_types():
+    """Test the augment_descriptions_with_types function"""
+    print("\nTesting augment_descriptions_with_types...")
+    
+    # Create a field list with the problematic parameter
+    field_list = nodes.field_list()
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) A dictionary')
+    field_list += create_field_node('param int count', 'An integer count')
+    
+    annotations = {'opc_meta': 'Dict[str, str]', 'count': 'int'}
+    
+    print("Before augmentation:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Apply the augmentation
+    augment_descriptions_with_types(field_list, annotations)
+    
+    print("\nAfter augmentation:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+
+if __name__ == "__main__":
+    test_modify_field_list()
+    test_augment_descriptions_with_types()
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 000000000..0a5d61d37
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix works correctly
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc.typehints import modify_field_list, augment_descriptions_with_types
+from docutils import nodes
+
+def create_field_node(field_name, field_body):
+    """Create a field node for testing"""
+    field = nodes.field()
+    field += nodes.field_name('', field_name)
+    field += nodes.field_body('', nodes.paragraph('', field_body))
+    return field
+
+def test_modify_field_list_scenario():
+    """Test modify_field_list with a scenario that triggers modification"""
+    print("Testing modify_field_list scenario...")
+    
+    # Create a field list with only parameter descriptions (no type fields)
+    field_list = nodes.field_list()
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) A dictionary')
+    field_list += create_field_node('param int count', 'An integer count')
+    
+    annotations = {'opc_meta': 'Dict[str, str]', 'count': 'int'}
+    
+    print("Before modification:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Apply the modification - this should add type fields
+    modify_field_list(field_list, annotations)
+    
+    print("\nAfter modification:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+
+def test_augment_descriptions_with_types_scenario():
+    """Test augment_descriptions_with_types with a scenario that triggers augmentation"""
+    print("\nTesting augment_descriptions_with_types scenario...")
+    
+    # Create a field list with parameter descriptions but no explicit type fields
+    field_list = nodes.field_list()
+    field_list += create_field_node('param dict(str, str) opc_meta', '(optional) A dictionary')
+    field_list += create_field_node('param int count', 'An integer count')
+    
+    annotations = {'opc_meta': 'Dict[str, str]', 'count': 'int'}
+    
+    print("Before augmentation:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # Apply the augmentation - this should add type fields
+    augment_descriptions_with_types(field_list, annotations)
+    
+    print("\nAfter augmentation:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+
+if __name__ == "__main__":
+    test_modify_field_list_scenario()
+    test_augment_descriptions_with_types_scenario()
\ No newline at end of file
diff --git a/test_parsing_issue.py b/test_parsing_issue.py
new file mode 100644
index 000000000..ce140d459
--- /dev/null
+++ b/test_parsing_issue.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""
+Test to confirm the exact parsing issue
+"""
+
+import re
+
+def test_current_parsing():
+    """Test the current parsing logic"""
+    
+    # Simulate the current parsing logic
+    field_name = "param dict(str, str) opc_meta"
+    
+    # Current approach (broken)
+    parts = re.split(' +', field_name)
+    print(f"Field name: '{field_name}'")
+    print(f"Parts after split: {parts}")
+    
+    if parts[0] == 'param' and len(parts) > 2:
+        name = ' '.join(parts[2:])
+        print(f"Extracted name (current): '{name}'")
+    
+    # Proposed approach (fixed)
+    # The pattern should be: param <type> <name>
+    # We need to extract the name part correctly
+    if parts[0] == 'param' and len(parts) > 2:
+        # Find where the type ends and name begins
+        # The name should be the last part after the type
+        name = parts[-1]
+        print(f"Extracted name (fixed): '{name}'")
+
+if __name__ == "__main__":
+    test_current_parsing()
\ No newline at end of file
diff --git a/test_real_scenario.py b/test_real_scenario.py
new file mode 100644
index 000000000..1bf7f309d
--- /dev/null
+++ b/test_real_scenario.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+"""
+Test to simulate the actual Sphinx documentation generation scenario
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc.typehints import modify_field_list, augment_descriptions_with_types
+from docutils import nodes
+
+def create_test_field_list():
+    """Create a field list that simulates what Sphinx would generate"""
+    field_list = nodes.field_list()
+    
+    # Simulate the problematic field that would be generated
+    field = nodes.field()
+    field += nodes.field_name('', 'param dict(str, str) opc_meta')
+    field += nodes.field_body('', nodes.paragraph('', '(optional) A dictionary mapping strings to strings'))
+    field_list += field
+    
+    # Add a simple parameter for comparison
+    field = nodes.field()
+    field += nodes.field_name('', 'param int count')
+    field += nodes.field_body('', nodes.paragraph('', 'An integer count'))
+    field_list += field
+    
+    return field_list
+
+def test_parsing_logic():
+    """Test the parsing logic that's used in typehints.py"""
+    print("Testing the parsing logic...")
+    
+    # Simulate the field parsing that happens in typehints.py
+    field_names_to_test = [
+        'param dict(str, str) opc_meta',
+        'param int count',
+        'param List[str] items',
+        'param Dict[str, int] mapping'
+    ]
+    
+    for field_name in field_names_to_test:
+        print(f"\nField name: '{field_name}'")
+        
+        # This is the current parsing logic in typehints.py
+        import re
+        parts = re.split(' +', field_name)
+        print(f"Parts: {parts}")
+        
+        if parts[0] == 'param':
+            if len(parts) == 2:
+                print(f"Simple param: {parts[1]}")
+            elif len(parts) > 2:
+                # OLD LOGIC (broken):
+                old_name = ' '.join(parts[2:])
+                print(f"OLD logic name: '{old_name}'")
+                
+                # NEW LOGIC (fixed):
+                new_name = parts[-1]
+                print(f"NEW logic name: '{new_name}'")
+
+def test_with_annotations():
+    """Test with annotations to see if fields get added"""
+    print("\n" + "="*50)
+    print("Testing with annotations...")
+    
+    field_list = create_test_field_list()
+    annotations = {
+        'opc_meta': 'Dict[str, str]',
+        'count': 'int'
+    }
+    
+    print("Before modify_field_list:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+    
+    # This should add type fields if needed
+    modify_field_list(field_list, annotations)
+    
+    print("\nAfter modify_field_list:")
+    for field in field_list:
+        print(f"  {field[0].astext()}: {field[1].astext()}")
+
+if __name__ == "__main__":
+    test_parsing_logic()
+    test_with_annotations()
\ No newline at end of file
diff --git a/test_specific_fix.py b/test_specific_fix.py
new file mode 100644
index 000000000..0ff0a5fcc
--- /dev/null
+++ b/test_specific_fix.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+"""
+Test to specifically verify the fix for the dict(str,str) parameter issue
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc.typehints import modify_field_list, augment_descriptions_with_types
+from docutils import nodes
+
+def test_dict_str_str_parameter():
+    """Test the specific case reported in the issue"""
+    print("Testing dict(str, str) parameter parsing...")
+    
+    # Create a field list with the exact problematic parameter from the issue
+    field_list = nodes.field_list()
+    
+    # This is the exact field that would be generated from:
+    # :param dict(str, str) opc_meta: (optional)
+    field = nodes.field()
+    field += nodes.field_name('', 'param dict(str, str) opc_meta')
+    field += nodes.field_body('', nodes.paragraph('', '(optional)'))
+    field_list += field
+    
+    # Test the parsing logic directly
+    field_name = 'param dict(str, str) opc_meta'
+    import re
+    parts = re.split(' +', field_name)
+    
+    print(f"Field name: '{field_name}'")
+    print(f"Parts: {parts}")
+    
+    # Test the old logic (should be broken)
+    if parts[0] == 'param' and len(parts) > 2:
+        old_name = ' '.join(parts[2:])
+        print(f"OLD logic would extract: '{old_name}'")
+        
+        # Test the new logic (should be correct)
+        new_name = parts[-1]
+        print(f"NEW logic extracts: '{new_name}'")
+        
+        if new_name == 'opc_meta':
+            print("‚úì SUCCESS: New logic correctly extracts 'opc_meta'")
+        else:
+            print("‚úó FAILURE: New logic does not extract 'opc_meta'")
+            
+        if old_name == 'str) opc_meta':
+            print("‚úì CONFIRMED: Old logic is broken as expected")
+        else:
+            print("? UNEXPECTED: Old logic behavior changed")
+    
+    # Test with modify_field_list
+    annotations = {'opc_meta': 'Dict[str, str]'}
+    print("\nTesting modify_field_list...")
+    modify_field_list(field_list, annotations)
+    
+    # Check if any new fields were added
+    field_names = [field[0].astext() for field in field_list]
+    print(f"Field names after modify_field_list: {field_names}")
+    
+    # Test with augment_descriptions_with_types
+    print("\nTesting augment_descriptions_with_types...")
+    augment_descriptions_with_types(field_list, annotations)
+    
+    field_names = [field[0].astext() for field in field_list]
+    print(f"Field names after augment_descriptions_with_types: {field_names}")
+
+if __name__ == "__main__":
+    test_dict_str_str_parameter()
\ No newline at end of file
diff --git a/test_sphinx_project.py b/test_sphinx_project.py
new file mode 100644
index 000000000..1b26a80b3
--- /dev/null
+++ b/test_sphinx_project.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+"""
+Test with a minimal Sphinx project to verify the fix
+"""
+
+import tempfile
+import os
+import sys
+from pathlib import Path
+
+# Add the sphinx package to the path
+sys.path.insert(0, '/testbed')
+
+def create_test_module():
+    """Create a test module with the problematic docstring"""
+    test_module_content = '''
+def test_function(opc_meta=None):
+    """
+    Test function with problematic parameter.
+    
+    :param dict(str, str) opc_meta: (optional) A dictionary mapping strings to strings
+    :return: None
+    """
+    return None
+'''
+    
+    test_dir = Path(tempfile.mkdtemp())
+    module_path = test_dir / "test_module.py"
+    with open(module_path, 'w') as f:
+        f.write(test_module_content)
+    
+    return test_dir, module_path
+
+def test_autodoc_generation():
+    """Test autodoc generation with the problematic parameter"""
+    
+    test_dir, module_path = create_test_module()
+    
+    # Create a minimal Sphinx configuration
+    conf_py_content = '''
+extensions = ['sphinx.ext.autodoc']
+'''
+    
+    index_rst_content = '''
+Test Documentation
+==================
+
+.. autofunction:: test_module.test_function
+'''
+    
+    with open(test_dir / "conf.py", 'w') as f:
+        f.write(conf_py_content)
+    
+    with open(test_dir / "index.rst", 'w') as f:
+        f.write(index_rst_content)
+    
+    # Try to build the documentation
+    os.chdir(test_dir)
+    
+    try:
+        from sphinx.application import Sphinx
+        from sphinx.util.docutils import docutils_namespace
+        
+        with docutils_namespace():
+            app = Sphinx(
+                srcdir=str(test_dir),
+                confdir=str(test_dir), 
+                outdir=str(test_dir / "_build"),
+                doctreedir=str(test_dir / "_doctrees"),
+                buildername='html'
+            )
+            
+            # Build the documentation
+            app.build()
+            
+            # Check the output
+            html_file = test_dir / "_build" / "index.html"
+            if html_file.exists():
+                with open(html_file, 'r') as f:
+                    content = f.read()
+                    print("Generated HTML content:")
+                    print(content)
+                    
+                    # Check if the parameter is rendered correctly
+                    if 'opc_meta' in content and 'dict(str, str)' in content:
+                        print("SUCCESS: Parameter appears to be rendered correctly")
+                    else:
+                        print("WARNING: Parameter rendering may still be broken")
+            
+    except Exception as e:
+        print(f"Error during Sphinx build: {e}")
+        import traceback
+        traceback.print_exc()
+    
+    finally:
+        # Clean up
+        os.chdir('/testbed')
+
+if __name__ == "__main__":
+    test_autodoc_generation()
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index a363e187f..3b8bc12d0 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3