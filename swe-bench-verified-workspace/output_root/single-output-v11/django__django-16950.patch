diff --git a/admin_reproduce.py b/admin_reproduce.py
new file mode 100644
index 0000000000..679c8bf391
--- /dev/null
+++ b/admin_reproduce.py
@@ -0,0 +1,129 @@
+#!/usr/bin/env python3
+"""
+Admin reproduction script for UUIDField default value issue with inline formsets.
+This matches the exact scenario described in the GitHub issue.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference from the simple test
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+# Create the admin classes as described in the issue
+class SubThingInline(admin.StackedInline):
+    model = SubThing
+
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ('name',)
+    ordering = ('pkid',)
+    inlines = (SubThingInline,)
+
+# Register the admin
+admin_site = AdminSite()
+admin_site.register(Thing, ThingAdmin)
+
+def test_admin_uuid_inline_issue():
+    print("Testing Admin UUID inline issue with to_field='id'...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a Thing instance
+    thing = Thing.objects.create(name="Test Thing")
+    print(f"Created Thing with UUID: {thing.id}")
+    
+    # Create inline formset factory that matches admin behavior
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    # Create formset data that simulates the admin scenario
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Create the formset
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if formset.is_valid():
+        try:
+            instances = formset.save()
+            print("Formset saved successfully!")
+            print(f"Created SubThing instances: {instances}")
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:", formset.errors)
+
+if __name__ == '__main__':
+    test_admin_uuid_inline_issue()
\ No newline at end of file
diff --git a/confirm_issue.py b/confirm_issue.py
new file mode 100644
index 0000000000..cf84a1e831
--- /dev/null
+++ b/confirm_issue.py
@@ -0,0 +1,113 @@
+#!/usr/bin/env python3
+"""
+Confirm the exact issue in BaseInlineFormSet._construct_form.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def confirm_issue():
+    print("Confirming the exact issue in _construct_form...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"Thing instance created - PK: {thing.pkid}, UUID: {thing.id}")
+    
+    # Test the exact logic from _construct_form
+    fk_field = SubThing._meta.get_field('thing')
+    print(f"FK field: {fk_field.name}")
+    print(f"FK remote_field.field_name: {fk_field.remote_field.field_name}")
+    print(f"FK remote_field.model._meta.pk.name: {fk_field.remote_field.model._meta.pk.name}")
+    
+    # Simulate the exact logic from _construct_form
+    fk_value = thing.pk  # This will be None for new objects
+    print(f"Step 1 - fk_value = thing.pk: {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        print("Step 2 - Entering if block (field_name != pk.name)")
+        fk_value = getattr(thing, fk_field.remote_field.field_name)
+        print(f"Step 3 - fk_value = getattr(thing, '{fk_field.remote_field.field_name}'): {fk_value}")
+        
+        # This is the problematic line
+        fk_value = getattr(fk_value, "pk", fk_value)
+        print(f"Step 4 - fk_value = getattr(fk_value, 'pk', fk_value): {fk_value}")
+    
+    print(f"Final fk_value: {fk_value}")
+    
+    # The issue is that fk_value might be None if the UUID field's default value
+    # hasn't been generated yet (because the object hasn't been saved)
+    
+    # Let's test what happens when we try to access the UUID field value
+    # before the object is saved
+    uuid_value = getattr(thing, 'id', 'NOT_SET')
+    print(f"Thing.id value before save: {uuid_value}")
+    
+    # Save the object and check again
+    thing.save()
+    print(f"Thing.id value after save: {thing.id}")
+
+if __name__ == '__main__':
+    confirm_issue()
\ No newline at end of file
diff --git a/debug_construct_form.py b/debug_construct_form.py
new file mode 100644
index 0000000000..5f3ddc6ad9
--- /dev/null
+++ b/debug_construct_form.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python3
+"""
+Debug the _construct_form method to understand how it's modifying the instance.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def debug_construct_form():
+    print("Debugging _construct_form method...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"3. After formset creation - Thing.id: {thing.id}")
+    
+    # Monkey patch _construct_form to trace what's happening
+    original_construct_form = formset._construct_form
+    
+    def traced_construct_form(self, i, **kwargs):
+        print(f"4. _construct_form called - self.instance.id: {self.instance.id if self.instance else 'None'}")
+        result = original_construct_form(self, i, **kwargs)
+        print(f"5. After _construct_form - self.instance.id: {self.instance.id if self.instance else 'None'}")
+        return result
+    
+    formset._construct_form = traced_construct_form
+    
+    # Now access the forms to trigger _construct_form
+    print("6. Accessing forms to trigger _construct_form...")
+    forms = formset.forms
+    print(f"7. After accessing forms - Thing.id: {thing.id}")
+    
+    # Check individual form values
+    for i, form in enumerate(forms):
+        print(f"8. Form {i} - thing_id: {getattr(form.instance, 'thing_id', 'NOT_SET')}")
+        print(f"9. Form {i} - Thing.id: {thing.id}")
+
+if __name__ == '__main__':
+    debug_construct_form()
\ No newline at end of file
diff --git a/debug_reproduce.py b/debug_reproduce.py
new file mode 100644
index 0000000000..1d4aaed344
--- /dev/null
+++ b/debug_reproduce.py
@@ -0,0 +1,129 @@
+#!/usr/bin/env python3
+"""
+Debug reproduction script to understand exactly what's happening in _construct_form.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def debug_construct_form():
+    print("Debugging _construct_form method...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"New Thing - PK: {thing.pkid}, UUID: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    # Debug the _construct_form logic step by step
+    fk_field = SubThing._meta.get_field('thing')
+    print(f"FK field: {fk_field}")
+    print(f"FK remote_field.field_name: {fk_field.remote_field.field_name}")
+    print(f"FK remote_field.model._meta.pk.name: {fk_field.remote_field.model._meta.pk.name}")
+    
+    # Simulate the exact logic from _construct_form
+    fk_value = thing.pk  # This will be None for new objects
+    print(f"Step 1 - fk_value = thing.pk: {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        print("Step 2 - Entering if block (field_name != pk.name)")
+        fk_value = getattr(thing, fk_field.remote_field.field_name)
+        print(f"Step 3 - fk_value = getattr(thing, '{fk_field.remote_field.field_name}'): {fk_value}")
+        
+        fk_value = getattr(fk_value, "pk", fk_value)
+        print(f"Step 4 - fk_value = getattr(fk_value, 'pk', fk_value): {fk_value}")
+    
+    print(f"Final fk_value: {fk_value}")
+    print(f"FK get_attname(): {fk_field.get_attname()}")
+    
+    # Check what value is actually set on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT SET')
+    print(f"Form instance thing_id value: {form_thing_id}")
+    
+    # Let's also check if the Thing instance has the UUID value
+    print(f"Thing.id value: {thing.id}")
+
+if __name__ == '__main__':
+    debug_construct_form()
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 0000000000..a087f948e7
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,135 @@
+#!/usr/bin/env python3
+"""
+Detailed debug script to track the UUID value throughout the process.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def detailed_debug():
+    print("Detailed debugging of UUID value...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"3. After formset creation - Thing.id: {thing.id}")
+    
+    # Check what value is actually set on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT SET')
+    print(f"4. Form instance thing_id value: {form_thing_id}")
+    
+    # Let's also check if the Thing instance has the UUID value
+    print(f"5. Thing.id value: {thing.id}")
+    
+    # Let's check the form instance's thing attribute
+    form_thing = getattr(form.instance, 'thing', 'NOT SET')
+    print(f"6. Form instance thing value: {form_thing}")
+    
+    if form_thing != 'NOT SET':
+        print(f"7. Form instance thing.id value: {form_thing.id}")
+    
+    # Let's check if the formset instance has the correct UUID value
+    print(f"8. Formset instance Thing.id: {formset.instance.id if formset.instance else 'None'}")
+    
+    # Let's manually check the _construct_form logic
+    fk_field = SubThing._meta.get_field('thing')
+    fk_value = thing.pk
+    print(f"9. thing.pk: {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        fk_value = getattr(thing, fk_field.remote_field.field_name)
+        print(f"10. getattr(thing, 'id'): {fk_value}")
+        
+        fk_value = getattr(fk_value, "pk", fk_value)
+        print(f"11. getattr(fk_value, 'pk', fk_value): {fk_value}")
+    
+    print(f"12. Final fk_value: {fk_value}")
+
+if __name__ == '__main__':
+    detailed_debug()
\ No newline at end of file
diff --git a/django/forms/models.py b/django/forms/models.py
index 3fa04b821f..1b56f5b78d 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -1134,7 +1134,9 @@ class BaseInlineFormSet(BaseModelFormSet):
         fk_value = self.instance.pk
         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
             fk_value = getattr(self.instance, self.fk.remote_field.field_name)
-            fk_value = getattr(fk_value, "pk", fk_value)
+            # Only try to get pk attribute if fk_value is not None and has a pk attribute
+            if fk_value is not None:
+                fk_value = getattr(fk_value, "pk", fk_value)
         setattr(form.instance, self.fk.get_attname(), fk_value)
         return form
 
diff --git a/exact_moment_test.py b/exact_moment_test.py
new file mode 100644
index 0000000000..2b9f795b8a
--- /dev/null
+++ b/exact_moment_test.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python3
+"""
+Test to find the exact moment when the UUID value is lost.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def exact_moment_test():
+    print("Finding the exact moment when UUID value is lost...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Let's trace the exact moment by creating the formset step by step
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Create the formset manually to trace the exact moment
+    print("3. Creating formset manually...")
+    
+    # Step 1: Create the formset instance
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"4. After formset instance creation - Thing.id: {thing.id}")
+    
+    # Step 2: Access the forms to trigger _construct_form
+    print("5. Accessing forms to trigger _construct_form...")
+    forms = formset.forms
+    print(f"6. After accessing forms - Thing.id: {thing.id}")
+    
+    # Step 3: Check individual form values
+    for i, form in enumerate(forms):
+        print(f"7. Form {i} - thing_id: {getattr(form.instance, 'thing_id', 'NOT_SET')}")
+        print(f"8. Form {i} - Thing.id: {thing.id}")
+    
+    # The issue might be that the formset is somehow modifying the instance
+    # Let's check if the instance is the same object
+    print(f"9. Formset instance is same as original thing: {formset.instance is thing}")
+    
+    # Let's check if the formset instance has the UUID value
+    print(f"10. Formset instance.id: {formset.instance.id if formset.instance else 'None'}")
+
+if __name__ == '__main__':
+    exact_moment_test()
\ No newline at end of file
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..55bf25a28a
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,126 @@
+#!/usr/bin/env python3
+"""
+Final test to understand and fix the UUID issue.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def final_test():
+    print("Final test to understand the UUID issue...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"3. After formset creation - Thing.id: {thing.id}")
+    
+    # The issue is that the UUID value is being lost during form processing
+    # Let's examine the form instance directly
+    form = formset.forms[0]
+    print(f"4. Form instance: {form.instance}")
+    print(f"5. Form instance thing_id: {getattr(form.instance, 'thing_id', 'NOT_SET')}")
+    print(f"6. Form instance thing: {getattr(form.instance, 'thing', 'NOT_SET')}")
+    
+    # Let's check if the form has the correct data
+    print(f"7. Form data: {form.data}")
+    
+    # Let's check if the formset instance has the correct UUID value
+    print(f"8. Formset instance.id: {formset.instance.id if formset.instance else 'None'}")
+    
+    # The issue might be that the form is not properly bound to the instance
+    # Let's check if the form is bound
+    print(f"9. Form is bound: {form.is_bound}")
+    
+    # Let's check if the form has errors
+    print(f"10. Form errors: {form.errors}")
+    
+    # Let's check if the formset is valid
+    print(f"11. Formset is valid: {formset.is_valid()}")
+
+if __name__ == '__main__':
+    final_test()
\ No newline at end of file
diff --git a/focused_trace.py b/focused_trace.py
new file mode 100644
index 0000000000..ecd2eee2b6
--- /dev/null
+++ b/focused_trace.py
@@ -0,0 +1,153 @@
+#!/usr/bin/env python3
+"""
+Focused trace to find exactly where the UUID value is lost.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def focused_trace():
+    print("Focused trace of UUID value loss...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Let's trace step by step through the BaseInlineFormSet.__init__ method
+    # First, let's see what happens when we just create the formset class
+    print(f"3. After inlineformset_factory - Thing.id: {thing.id}")
+    
+    # Now let's see what happens during the actual formset creation
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Let's manually step through the BaseInlineFormSet.__init__ logic
+    print("4. Starting BaseInlineFormSet.__init__ simulation...")
+    
+    # Simulate the __init__ method
+    instance = thing
+    save_as_new = False
+    prefix = None
+    queryset = None
+    
+    # Line 1092-1095: Set the instance
+    if instance is None:
+        formset_instance = SubThing._meta.get_field('thing').remote_field.model()
+    else:
+        formset_instance = instance
+    
+    print(f"5. After setting formset_instance - Thing.id: {thing.id}, formset_instance.id: {formset_instance.id}")
+    
+    # Line 1096: Set save_as_new
+    formset_save_as_new = save_as_new
+    
+    # Line 1097-1098: Set queryset
+    if queryset is None:
+        formset_queryset = SubThing._default_manager
+    
+    # Line 1099-1102: Filter queryset based on instance.pk
+    if formset_instance.pk is not None:
+        qs = formset_queryset.filter(**{SubThing._meta.get_field('thing').name: formset_instance})
+    else:
+        qs = formset_queryset.none()
+    
+    print(f"6. After queryset setup - Thing.id: {thing.id}")
+    
+    # Line 1103: Set unique_fields
+    unique_fields = {SubThing._meta.get_field('thing').name}
+    
+    print(f"7. Before calling super().__init__ - Thing.id: {thing.id}")
+    
+    # Now let's actually create the formset to see what happens
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"8. After formset creation - Thing.id: {thing.id}")
+    
+    # Check what value is actually set on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT SET')
+    print(f"9. Form instance thing_id value: {form_thing_id}")
+    
+    # Let's also check if the Thing instance has the UUID value
+    print(f"10. Thing.id value: {thing.id}")
+
+if __name__ == '__main__':
+    focused_trace()
\ No newline at end of file
diff --git a/new_object_reproduce.py b/new_object_reproduce.py
new file mode 100644
index 0000000000..07f1b6be0a
--- /dev/null
+++ b/new_object_reproduce.py
@@ -0,0 +1,144 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for UUIDField default value issue when creating new objects with inlines.
+This tests the scenario where the parent object doesn't have a PK yet.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def test_new_object_uuid_issue():
+    print("Testing UUID issue with new object creation...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"New Thing - PK: {thing.pkid}, UUID: {thing.id}")
+    
+    # Test the scenario where instance doesn't have PK yet
+    # This simulates what happens in admin when creating a new object
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    # Test the BaseInlineFormSet._construct_form logic
+    fk_field = SubThing._meta.get_field('thing')
+    print(f"FK field name: {fk_field.name}")
+    print(f"FK remote field name: {fk_field.remote_field.field_name}")
+    print(f"FK remote field model PK: {fk_field.remote_field.model._meta.pk.name}")
+    
+    # Simulate the _construct_form logic
+    fk_value = thing.pk  # This will be None for new objects
+    print(f"Initial fk_value (thing.pk): {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        fk_value = getattr(thing, fk_field.remote_field.field_name, None)
+        fk_value = getattr(fk_value, "pk", fk_value) if fk_value is not None else None
+        print(f"Corrected fk_value (thing.id): {fk_value}")
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    # Check what value is being set on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT SET')
+    print(f"Form instance thing_id value: {form_thing_id}")
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if formset.is_valid():
+        try:
+            # First save the parent object
+            thing.save()
+            print(f"Saved Thing - PK: {thing.pkid}, UUID: {thing.id}")
+            
+            # Now save the formset
+            instances = formset.save()
+            print("Formset saved successfully!")
+            for instance in instances:
+                print(f"SubThing thing_id: {instance.thing_id}")
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:", formset.errors)
+
+if __name__ == '__main__':
+    test_new_object_uuid_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a0824cd688
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for Django Admin with Inlines not using UUIDField default value issue.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        'Thing',
+        to_field='id',
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+
+# Create the admin classes
+class SubThingInline(admin.StackedInline):
+    model = SubThing
+
+class ThingAdmin(admin.ModelAdmin):
+    list_display = ('name',)
+    ordering = ('pkid',)
+    inlines = (SubThingInline,)
+
+# Register the admin
+admin_site = AdminSite()
+admin_site.register(Thing, ThingAdmin)
+
+# Create test data and simulate the issue
+from django.test import RequestFactory
+from django.contrib.auth.models import User
+
+def test_uuid_inline_issue():
+    print("Testing UUID inline issue...")
+    
+    # Create a superuser for admin access
+    user = User.objects.create_superuser('admin', 'admin@example.com', 'password')
+    
+    # Create a request factory
+    factory = RequestFactory()
+    
+    # Create a Thing instance
+    thing = Thing.objects.create(name="Test Thing")
+    print(f"Created Thing with UUID: {thing.id}")
+    
+    # Simulate admin POST data that would cause the issue
+    post_data = {
+        'name': 'Test Thing',
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+        '_save': 'Save',
+    }
+    
+    # Create a request
+    request = factory.post('/admin/bugapp/thing/add/', post_data)
+    request.user = user
+    
+    # Try to process the form
+    try:
+        model_admin = ThingAdmin(Thing, admin_site)
+        response = model_admin.add_view(request)
+        print("Form processed successfully!")
+    except Exception as e:
+        print(f"Error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    # Create database tables
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(['manage.py', 'migrate', '--run-syncdb'])
+    
+    test_uuid_inline_issue()
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..1f6fe1300e
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Simple reproduction script for UUIDField default value issue with inline formsets.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.forms.models import inlineformset_factory
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'test'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'test'
+
+def test_uuid_inline_issue():
+    print("Testing UUID inline issue...")
+    
+    # Create a Thing instance
+    thing = Thing.objects.create(name="Test Thing")
+    print(f"Created Thing with UUID: {thing.id}")
+    
+    # Create inline formset factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    # Create formset data that simulates the admin scenario
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Create the formset
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if formset.is_valid():
+        try:
+            formset.save()
+            print("Formset saved successfully!")
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:", formset.errors)
+
+if __name__ == '__main__':
+    # Create database tables
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(['manage.py', 'migrate', '--run-syncdb'])
+    
+    # Create tables for our test models
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(UUIDModel)
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    test_uuid_inline_issue()
\ No newline at end of file
diff --git a/targeted_reproduce.py b/targeted_reproduce.py
new file mode 100644
index 0000000000..ded2881c97
--- /dev/null
+++ b/targeted_reproduce.py
@@ -0,0 +1,138 @@
+#!/usr/bin/env python3
+"""
+Targeted reproduction script for UUIDField default value issue with inline formsets.
+This specifically tests the scenario where to_field='id' is used.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def test_uuid_to_field_issue():
+    print("Testing UUID to_field='id' issue...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a Thing instance
+    thing = Thing.objects.create(name="Test Thing")
+    print(f"Created Thing with UUID: {thing.id}, PK: {thing.pkid}")
+    
+    # Test the ForeignKey field behavior
+    fk_field = SubThing._meta.get_field('thing')
+    print(f"FK field name: {fk_field.name}")
+    print(f"FK remote field name: {fk_field.remote_field.field_name}")
+    print(f"FK get_attname(): {fk_field.get_attname()}")
+    print(f"FK remote field model PK: {fk_field.remote_field.model._meta.pk.name}")
+    
+    # Test the scenario from BaseInlineFormSet._construct_form
+    fk_value = thing.pk  # This is what the current code does
+    print(f"Current fk_value (thing.pk): {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        fk_value = getattr(thing, fk_field.remote_field.field_name)
+        fk_value = getattr(fk_value, "pk", fk_value)
+        print(f"Corrected fk_value (thing.id): {fk_value}")
+    
+    # Create inline formset to test the actual behavior
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    # Create formset data
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    # Create the formset
+    formset = SubThingFormSet(formset_data, instance=thing)
+    
+    # Check what value is being set on the form instance
+    form = formset.forms[0]
+    print(f"Form instance thing_id value: {getattr(form.instance, 'thing_id', 'NOT SET')}")
+    
+    print(f"Formset is valid: {formset.is_valid()}")
+    
+    if formset.is_valid():
+        try:
+            instances = formset.save()
+            print("Formset saved successfully!")
+            print(f"Created SubThing instances: {instances}")
+            for instance in instances:
+                print(f"SubThing thing_id: {instance.thing_id}")
+        except Exception as e:
+            print(f"Error saving formset: {e}")
+            import traceback
+            traceback.print_exc()
+    else:
+        print("Formset errors:", formset.errors)
+
+if __name__ == '__main__':
+    test_uuid_to_field_issue()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..365cee76b4
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,136 @@
+#!/usr/bin/env python3
+"""
+Test to understand and fix the UUID issue.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def test_fix():
+    print("Testing the fix for UUID issue...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"3. After formset creation - Thing.id: {thing.id}")
+    
+    # The issue is that the UUID value is being lost during _construct_form
+    # Let's examine what happens in _construct_form
+    
+    fk_field = SubThing._meta.get_field('thing')
+    print(f"4. FK field: {fk_field.name}")
+    print(f"5. FK remote_field.field_name: {fk_field.remote_field.field_name}")
+    print(f"6. FK remote_field.model._meta.pk.name: {fk_field.remote_field.model._meta.pk.name}")
+    
+    # Simulate the _construct_form logic
+    fk_value = thing.pk  # This will be None for new objects
+    print(f"7. fk_value = thing.pk: {fk_value}")
+    
+    if fk_field.remote_field.field_name != fk_field.remote_field.model._meta.pk.name:
+        print("8. Entering if block (field_name != pk.name)")
+        fk_value = getattr(thing, fk_field.remote_field.field_name)
+        print(f"9. fk_value = getattr(thing, '{fk_field.remote_field.field_name}'): {fk_value}")
+        
+        # This is the problematic line - UUID objects don't have a 'pk' attribute
+        fk_value = getattr(fk_value, "pk", fk_value)
+        print(f"10. fk_value = getattr(fk_value, 'pk', fk_value): {fk_value}")
+    
+    print(f"11. Final fk_value: {fk_value}")
+    
+    # The issue might be that fk_value becomes None somehow
+    # Let's check if the UUID value is available at this point
+    uuid_value = getattr(thing, 'id', 'NOT_SET')
+    print(f"12. Thing.id value: {uuid_value}")
+    
+    # Let's see what happens when we try to set the value on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT_SET')
+    print(f"13. Form instance thing_id value: {form_thing_id}")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/trace_formset.py b/trace_formset.py
new file mode 100644
index 0000000000..6105b83a50
--- /dev/null
+++ b/trace_formset.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python3
+"""
+Trace what happens during formset initialization.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'bugapp'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'bugapp'
+
+class SubThing(models.Model):
+    name = models.CharField(max_length=191)
+    thing = models.ForeignKey(
+        Thing,
+        to_field='id',  # This is the key difference
+        on_delete=models.CASCADE,
+        related_name='subthings',
+    )
+    
+    class Meta:
+        app_label = 'bugapp'
+
+def trace_formset():
+    print("Tracing formset initialization...")
+    
+    # Create database tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+        schema_editor.create_model(SubThing)
+    
+    # Create a new Thing instance (not saved to database yet)
+    thing = Thing(name="New Test Thing")
+    print(f"1. After instantiation - Thing.id: {thing.id}")
+    
+    # Create inline formset
+    from django.forms.models import inlineformset_factory
+    SubThingFormSet = inlineformset_factory(
+        Thing, 
+        SubThing, 
+        fields=['name'],
+        fk_name='thing'
+    )
+    
+    print(f"2. Before formset creation - Thing.id: {thing.id}")
+    
+    # Monkey patch to trace what happens during formset init
+    original_init = SubThingFormSet.__init__
+    
+    def traced_init(self, data=None, files=None, instance=None, save_as_new=False, prefix=None, queryset=None, **kwargs):
+        print(f"3. FormSet.__init__ called - instance.id: {instance.id if instance else 'None'}")
+        result = original_init(self, data, files, instance, save_as_new, prefix, queryset, **kwargs)
+        print(f"4. After FormSet.__init__ - instance.id: {instance.id if instance else 'None'}")
+        return result
+    
+    SubThingFormSet.__init__ = traced_init
+    
+    # Create formset with unsaved instance
+    formset_data = {
+        'subthings-TOTAL_FORMS': '1',
+        'subthings-INITIAL_FORMS': '0',
+        'subthings-MIN_NUM_FORMS': '0',
+        'subthings-MAX_NUM_FORMS': '1000',
+        'subthings-0-name': 'Test SubThing',
+    }
+    
+    formset = SubThingFormSet(formset_data, instance=thing)
+    print(f"5. After formset creation - Thing.id: {thing.id}")
+    
+    # Check what value is actually set on the form instance
+    form = formset.forms[0]
+    form_thing_id = getattr(form.instance, 'thing_id', 'NOT SET')
+    print(f"6. Form instance thing_id value: {form_thing_id}")
+    
+    # Let's also check if the Thing instance has the UUID value
+    print(f"7. Thing.id value: {thing.id}")
+
+if __name__ == '__main__':
+    trace_formset()
\ No newline at end of file
diff --git a/uuid_timing_test.py b/uuid_timing_test.py
new file mode 100644
index 0000000000..c8324466dc
--- /dev/null
+++ b/uuid_timing_test.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Test to understand when UUIDField default values are generated.
+"""
+
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+class UUIDModel(models.Model):
+    pkid = models.BigAutoField(primary_key=True, editable=False)
+    id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
+    
+    class Meta:
+        abstract = True
+        app_label = 'test'
+
+class Thing(UUIDModel):
+    name = models.CharField(max_length=191)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_uuid_timing():
+    print("Testing UUID field timing...")
+    
+    # Create a new Thing instance
+    thing = Thing(name="Test Thing")
+    
+    print(f"After instantiation - Thing.id: {thing.id}")
+    print(f"After instantiation - Thing.id type: {type(thing.id)}")
+    
+    # Check if the id field has been accessed
+    print(f"Thing._state.adding: {thing._state.adding}")
+    
+    # Access the field descriptor to see the default value
+    id_field = Thing._meta.get_field('id')
+    print(f"ID field default: {id_field.default}")
+    print(f"ID field default type: {type(id_field.default)}")
+    
+    # Test calling the default function
+    if callable(id_field.default):
+        default_value = id_field.default()
+        print(f"Default function result: {default_value}")
+        print(f"Default function result type: {type(default_value)}")
+    
+    # Test getting the field value through the descriptor
+    print(f"Getting id through descriptor: {thing.id}")
+    
+    # Test what happens when we save the object
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Thing)
+    
+    thing.save()
+    print(f"After save - Thing.id: {thing.id}")
+    print(f"After save - Thing.id type: {type(thing.id)}")
+
+if __name__ == '__main__':
+    test_uuid_timing()
\ No newline at end of file