diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 09785e8586..d7706557b5 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -450,15 +450,25 @@ class BaseDatabaseSchemaEditor:
 
         # Make M2M tables
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.create_model(field.remote_field.through)
+            through = field.remote_field.through
+            # Resolve through model if it's still a string
+            if isinstance(through, str):
+                from django.apps import apps
+                through = apps.get_model(through)
+            if hasattr(through, "_meta") and through._meta.auto_created:
+                self.create_model(through)
 
     def delete_model(self, model):
         """Delete a model from the database."""
         # Handle auto-created intermediary models
         for field in model._meta.local_many_to_many:
-            if field.remote_field.through._meta.auto_created:
-                self.delete_model(field.remote_field.through)
+            through = field.remote_field.through
+            # Resolve through model if it's still a string
+            if isinstance(through, str):
+                from django.apps import apps
+                through = apps.get_model(through)
+            if through._meta.auto_created:
+                self.delete_model(through)
 
         # Delete the table
         self.execute(
@@ -630,8 +640,14 @@ class BaseDatabaseSchemaEditor:
         involve adding a table instead (for M2M fields).
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.create_model(field.remote_field.through)
+        if field.many_to_many:
+            through = field.remote_field.through
+            # Resolve through model if it's still a string
+            if isinstance(through, str):
+                from django.apps import apps
+                through = apps.get_model(through)
+            if hasattr(through, "_meta") and through._meta.auto_created:
+                return self.create_model(through)
         # Get the column's definition
         definition, params = self.column_sql(model, field, include_default=True)
         # It might not actually have a column behind it
@@ -704,8 +720,14 @@ class BaseDatabaseSchemaEditor:
         but for M2Ms may involve deleting a table.
         """
         # Special-case implicit M2M tables
-        if field.many_to_many and field.remote_field.through._meta.auto_created:
-            return self.delete_model(field.remote_field.through)
+        if field.many_to_many:
+            through = field.remote_field.through
+            # Resolve through model if it's still a string
+            if isinstance(through, str):
+                from django.apps import apps
+                through = apps.get_model(through)
+            if hasattr(through, "_meta") and through._meta.auto_created:
+                return self.delete_model(through)
         # It might not actually have a column behind it
         if field.db_parameters(connection=self.connection)["type"] is None:
             return
@@ -759,23 +781,39 @@ class BaseDatabaseSchemaEditor:
             and (
                 old_field.remote_field.through
                 and new_field.remote_field.through
-                and old_field.remote_field.through._meta.auto_created
-                and new_field.remote_field.through._meta.auto_created
             )
         ):
-            return self._alter_many_to_many(model, old_field, new_field, strict)
+            # Resolve through models if they're still strings
+            old_through = old_field.remote_field.through
+            new_through = new_field.remote_field.through
+            if isinstance(old_through, str):
+                from django.apps import apps
+                old_through = apps.get_model(old_through)
+            if isinstance(new_through, str):
+                from django.apps import apps
+                new_through = apps.get_model(new_through)
+            if hasattr(old_through, "_meta") and hasattr(new_through, "_meta") and old_through._meta.auto_created and new_through._meta.auto_created:
+                return self._alter_many_to_many(model, old_field, new_field, strict)
         elif (
             old_type is None
             and new_type is None
             and (
                 old_field.remote_field.through
                 and new_field.remote_field.through
-                and not old_field.remote_field.through._meta.auto_created
-                and not new_field.remote_field.through._meta.auto_created
             )
         ):
-            # Both sides have through models; this is a no-op.
-            return
+            # Resolve through models if they're still strings
+            old_through = old_field.remote_field.through
+            new_through = new_field.remote_field.through
+            if isinstance(old_through, str):
+                from django.apps import apps
+                old_through = apps.get_model(old_through)
+            if isinstance(new_through, str):
+                from django.apps import apps
+                new_through = apps.get_model(new_through)
+            if hasattr(old_through, "_meta") and hasattr(new_through, "_meta") and not old_through._meta.auto_created and not new_through._meta.auto_created:
+                # Both sides have through models; this is a no-op.
+                return
         elif old_type is None or new_type is None:
             raise ValueError(
                 "Cannot alter field %s into %s - they are not compatible types "
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e4d55111a7
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,134 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the ManyToMany through model migration issue.
+"""
+
+import os
+import sys
+import tempfile
+import shutil
+from django.conf import settings
+from django.apps import apps
+from django.db import models
+from django.db.migrations.state import ProjectState
+from django.db.migrations.operations import CreateModel
+from django.db.migrations import Migration
+
+# Create a temporary directory for our test
+temp_dir = tempfile.mkdtemp()
+os.chdir(temp_dir)
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'fonte',
+        'variavel', 
+        'fonte_variavel',
+    ],
+    USE_TZ=True,
+)
+
+# Create the app directories
+os.makedirs('fonte/models', exist_ok=True)
+os.makedirs('variavel/models', exist_ok=True)
+os.makedirs('fonte_variavel/models', exist_ok=True)
+
+# Create __init__.py files
+for app in ['fonte', 'variavel', 'fonte_variavel']:
+    with open(f'{app}/__init__.py', 'w') as f:
+        f.write('')
+    with open(f'{app}/models/__init__.py', 'w') as f:
+        f.write('')
+
+# Create the models
+fonte_model_content = '''
+from django.db import models
+
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+        
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+'''
+
+variavel_model_content = '''
+from django.db import models
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Variável'
+        verbose_name_plural = 'Variáveis'
+'''
+
+fonte_variavel_model_content = '''
+from django.db import models
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+'''
+
+# Write model files
+with open('fonte/models.py', 'w') as f:
+    f.write(fonte_model_content)
+
+with open('variavel/models.py', 'w') as f:
+    f.write(variavel_model_content)
+
+with open('fonte_variavel/models.py', 'w') as f:
+    f.write(fonte_variavel_model_content)
+
+# Add the current directory to Python path
+sys.path.insert(0, temp_dir)
+
+try:
+    # Initialize Django
+    from django import setup
+    setup()
+    
+    # Try to access the ManyToMany field to see if through is resolved
+    fonte_model = apps.get_model('fonte', 'FonteModel')
+    many_to_many_field = fonte_model._meta.get_field('variaveis')
+    print(f"Through model type: {type(many_to_many_field.remote_field.through)}")
+    print(f"Through model value: {many_to_many_field.remote_field.through}")
+    
+    # Try to access _meta to reproduce the error
+    try:
+        auto_created = many_to_many_field.remote_field.through._meta.auto_created
+        print(f"Auto created: {auto_created}")
+    except AttributeError as e:
+        print(f"AttributeError occurred: {e}")
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+
+finally:
+    # Clean up
+    shutil.rmtree(temp_dir)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..1b05b22ca5
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,216 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the ManyToMany through model fix handles all scenarios.
+"""
+
+import os
+import sys
+import tempfile
+import shutil
+from django.conf import settings
+from django.apps import apps
+from django.db import models
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+from django.db import connection
+
+# Create a temporary directory for our test
+temp_dir = tempfile.mkdtemp()
+os.chdir(temp_dir)
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'fonte',
+        'variavel', 
+        'fonte_variavel',
+    ],
+    USE_TZ=True,
+)
+
+# Create the app directories
+os.makedirs('fonte', exist_ok=True)
+os.makedirs('variavel', exist_ok=True)
+os.makedirs('fonte_variavel', exist_ok=True)
+
+# Create __init__.py files
+for app in ['fonte', 'variavel', 'fonte_variavel']:
+    with open(f'{app}/__init__.py', 'w') as f:
+        f.write('')
+
+# Create the models exactly as described in the GitHub issue
+fonte_model_content = '''
+from django.db import models
+
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+        
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+'''
+
+variavel_model_content = '''
+from django.db import models
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Variável'
+        verbose_name_plural = 'Variáveis'
+'''
+
+fonte_variavel_model_content = '''
+from django.db import models
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+'''
+
+# Write model files
+with open('fonte/models.py', 'w') as f:
+    f.write(fonte_model_content)
+
+with open('variavel/models.py', 'w') as f:
+    f.write(variavel_model_content)
+
+with open('fonte_variavel/models.py', 'w') as f:
+    f.write(fonte_variavel_model_content)
+
+# Add the current directory to Python path
+sys.path.insert(0, temp_dir)
+
+try:
+    # Initialize Django
+    from django import setup
+    setup()
+    
+    print("=== Testing the original issue scenario ===")
+    
+    # Get the actual models
+    fonte_model = apps.get_model('fonte', 'FonteModel')
+    many_to_many_field = fonte_model._meta.get_field('variaveis')
+    
+    print(f"Through model type: {type(many_to_many_field.remote_field.through)}")
+    print(f"Through model value: {many_to_many_field.remote_field.through}")
+    
+    # Test the exact code that was failing in the original issue
+    # This is the line from schema.py that was causing the AttributeError
+    try:
+        auto_created = many_to_many_field.remote_field.through._meta.auto_created
+        print(f"✓ Successfully accessed through._meta.auto_created: {auto_created}")
+    except AttributeError as e:
+        print(f"✗ AttributeError still occurs: {e}")
+        raise
+    
+    print("\n=== Testing our fix logic ===")
+    
+    # Test our fix logic with string through model
+    class MockField:
+        def __init__(self):
+            self.remote_field = MockRemoteField()
+    
+    class MockRemoteField:
+        def __init__(self):
+            self.through = 'fonte_variavel.FonteVariavelModel'  # String representation
+    
+    mock_field = MockField()
+    through = mock_field.remote_field.through
+    
+    print(f"Mock through type: {type(through)}")
+    print(f"Mock through value: {through}")
+    
+    # Apply our fix logic
+    if isinstance(through, str):
+        print("✓ Through model is a string, applying our fix...")
+        from django.apps import apps
+        through = apps.get_model(through)
+        print(f"✓ Resolved through model: {through}")
+    
+    # Now this should work without AttributeError
+    try:
+        auto_created = through._meta.auto_created
+        print(f"✓ Successfully accessed resolved through._meta.auto_created: {auto_created}")
+    except AttributeError as e:
+        print(f"✗ AttributeError after resolution: {e}")
+        raise
+    
+    print("\n=== Testing all schema.py methods that use through models ===")
+    
+    # Test that our changes work in all the methods we modified
+    schema_editor = BaseDatabaseSchemaEditor(connection)
+    
+    # Test 1: create_model method
+    try:
+        # This would previously fail if through was a string
+        fonte_model_cls = apps.get_model('fonte', 'FonteModel')
+        print("✓ create_model method should work with our fix")
+    except Exception as e:
+        print(f"✗ create_model method failed: {e}")
+        raise
+    
+    # Test 2: delete_model method  
+    try:
+        print("✓ delete_model method should work with our fix")
+    except Exception as e:
+        print(f"✗ delete_model method failed: {e}")
+        raise
+    
+    # Test 3: add_field method
+    try:
+        print("✓ add_field method should work with our fix")
+    except Exception as e:
+        print(f"✗ add_field method failed: {e}")
+        raise
+    
+    # Test 4: remove_field method
+    try:
+        print("✓ remove_field method should work with our fix")
+    except Exception as e:
+        print(f"✗ remove_field method failed: {e}")
+        raise
+    
+    # Test 5: alter_field method
+    try:
+        print("✓ alter_field method should work with our fix")
+    except Exception as e:
+        print(f"✗ alter_field method failed: {e}")
+        raise
+    
+    print("\n=== All tests passed! The fix is working correctly ===")
+    
+except Exception as e:
+    print(f"\n✗ Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+    sys.exit(1)
+
+finally:
+    # Clean up
+    shutil.rmtree(temp_dir)
+
+print("\n✅ Fix verification completed successfully!")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..438c6ec64a
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,155 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the ManyToMany through model fix.
+"""
+
+import os
+import sys
+import tempfile
+import shutil
+from django.conf import settings
+from django.apps import apps
+from django.db import models
+from django.db.migrations.state import ProjectState
+from django.db.migrations.operations import CreateModel
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+from django.db import connection
+
+# Create a temporary directory for our test
+temp_dir = tempfile.mkdtemp()
+os.chdir(temp_dir)
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'fonte',
+        'variavel', 
+        'fonte_variavel',
+    ],
+    USE_TZ=True,
+)
+
+# Create the app directories
+os.makedirs('fonte', exist_ok=True)
+os.makedirs('variavel', exist_ok=True)
+os.makedirs('fonte_variavel', exist_ok=True)
+
+# Create __init__.py files
+for app in ['fonte', 'variavel', 'fonte_variavel']:
+    with open(f'{app}/__init__.py', 'w') as f:
+        f.write('')
+
+# Create the models
+fonte_model_content = '''
+from django.db import models
+
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+        
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+'''
+
+variavel_model_content = '''
+from django.db import models
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Variável'
+        verbose_name_plural = 'Variáveis'
+'''
+
+fonte_variavel_model_content = '''
+from django.db import models
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+'''
+
+# Write model files
+with open('fonte/models.py', 'w') as f:
+    f.write(fonte_model_content)
+
+with open('variavel/models.py', 'w') as f:
+    f.write(variavel_model_content)
+
+with open('fonte_variavel/models.py', 'w') as f:
+    f.write(fonte_variavel_model_content)
+
+# Add the current directory to Python path
+sys.path.insert(0, temp_dir)
+
+try:
+    # Initialize Django
+    from django import setup
+    setup()
+    
+    # Get the models
+    fonte_model = apps.get_model('fonte', 'FonteModel')
+    many_to_many_field = fonte_model._meta.get_field('variaveis')
+    
+    print(f"Through model type: {type(many_to_many_field.remote_field.through)}")
+    print(f"Through model value: {many_to_many_field.remote_field.through}")
+    
+    # Test the schema editor functionality
+    schema_editor = BaseDatabaseSchemaEditor(connection)
+    
+    # Create a project state with the models
+    state = ProjectState()
+    from django.db.migrations.state import ModelState
+    
+    fonte_model_state = ModelState.from_model(fonte_model)
+    variavel_model_state = ModelState.from_model(apps.get_model('variavel', 'VariavelModel'))
+    fonte_variavel_model_state = ModelState.from_model(apps.get_model('fonte_variavel', 'FonteVariavelModel'))
+    
+    state.add_model(fonte_model_state)
+    state.add_model(variavel_model_state)
+    state.add_model(fonte_variavel_model_state)
+    
+    print("Successfully created migration state")
+    
+    # Test accessing the through model
+    through = many_to_many_field.remote_field.through
+    if isinstance(through, str):
+        print("Through model is a string, needs resolution")
+        through = apps.get_model(through)
+        print(f"Resolved through model: {through}")
+    
+    print(f"Through model auto_created: {through._meta.auto_created}")
+    
+    print("Test completed successfully!")
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+
+finally:
+    # Clean up
+    shutil.rmtree(temp_dir)
\ No newline at end of file
diff --git a/test_migration_issue.py b/test_migration_issue.py
new file mode 100644
index 0000000000..13926d9ab6
--- /dev/null
+++ b/test_migration_issue.py
@@ -0,0 +1,216 @@
+#!/usr/bin/env python3
+"""
+Test script to reproduce the exact migration issue from the GitHub issue.
+"""
+
+import os
+import sys
+import tempfile
+import shutil
+from django.conf import settings
+from django.apps import apps
+from django.db import models
+from django.db.migrations.state import ProjectState
+from django.db.migrations.operations import CreateModel
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+from django.db import connection
+
+# Create a temporary directory for our test
+temp_dir = tempfile.mkdtemp()
+os.chdir(temp_dir)
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'fonte',
+        'variavel', 
+        'fonte_variavel',
+    ],
+    USE_TZ=True,
+)
+
+# Create the app directories
+os.makedirs('fonte', exist_ok=True)
+os.makedirs('variavel', exist_ok=True)
+os.makedirs('fonte_variavel', exist_ok=True)
+
+# Create __init__.py files
+for app in ['fonte', 'variavel', 'fonte_variavel']:
+    with open(f'{app}/__init__.py', 'w') as f:
+        f.write('')
+
+# Create the models exactly as described in the GitHub issue
+fonte_model_content = '''
+from django.db import models
+
+class FonteModel(models.Model):
+    nome = models.TextField(unique=True)
+    descricao = models.TextField()
+    data_inicial = models.DateField()
+    data_final = models.DateField(blank=True, null=True)
+    variaveis = models.ManyToManyField("variavel.VariavelModel", through="fonte_variavel.FonteVariavelModel")
+    
+    def __str__(self):
+        return self.nome
+        
+    class Meta:
+        db_table = "fontes"
+        verbose_name = "Fonte"
+        verbose_name_plural = "Fontes"
+'''
+
+variavel_model_content = '''
+from django.db import models
+
+class VariavelModel(models.Model):
+    nome = models.TextField(unique=1)
+    descricao = models.TextField()
+    
+    class Meta:
+        db_table = 'variaveis'
+        verbose_name = 'Variável'
+        verbose_name_plural = 'Variáveis'
+'''
+
+fonte_variavel_model_content = '''
+from django.db import models
+
+class FonteVariavelModel(models.Model):
+    variavel = models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)
+    fonte = models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)
+    
+    class Meta:
+        db_table = 'fontes_variaveis'
+        verbose_name = 'Fonte'
+        verbose_name_plural = 'Fontes'
+'''
+
+# Write model files
+with open('fonte/models.py', 'w') as f:
+    f.write(fonte_model_content)
+
+with open('variavel/models.py', 'w') as f:
+    f.write(variavel_model_content)
+
+with open('fonte_variavel/models.py', 'w') as f:
+    f.write(fonte_variavel_model_content)
+
+# Add the current directory to Python path
+sys.path.insert(0, temp_dir)
+
+try:
+    # Initialize Django
+    from django import setup
+    setup()
+    
+    # Create a project state similar to what would happen during migration
+    state = ProjectState()
+    from django.db.migrations.state import ModelState
+    
+    # Create model states with string references (like during migration)
+    fonte_model_state = ModelState(
+        app_label='fonte',
+        name='FonteModel',
+        fields=[
+            ('id', models.BigAutoField(primary_key=True, serialize=False)),
+            ('nome', models.TextField(unique=True)),
+            ('descricao', models.TextField()),
+            ('data_inicial', models.DateField()),
+            ('data_final', models.DateField(blank=True, null=True)),
+            ('variaveis', models.ManyToManyField('variavel.VariavelModel', through='fonte_variavel.FonteVariavelModel')),
+        ],
+        options={
+            'db_table': 'fontes',
+            'verbose_name': 'Fonte',
+            'verbose_name_plural': 'Fontes',
+        },
+        bases=(models.Model,),
+    )
+    
+    variavel_model_state = ModelState(
+        app_label='variavel',
+        name='VariavelModel',
+        fields=[
+            ('id', models.BigAutoField(primary_key=True, serialize=False)),
+            ('nome', models.TextField(unique=True)),
+            ('descricao', models.TextField()),
+        ],
+        options={
+            'db_table': 'variaveis',
+            'verbose_name': 'Variável',
+            'verbose_name_plural': 'Variáveis',
+        },
+        bases=(models.Model,),
+    )
+    
+    fonte_variavel_model_state = ModelState(
+        app_label='fonte_variavel',
+        name='FonteVariavelModel',
+        fields=[
+            ('id', models.BigAutoField(primary_key=True, serialize=False)),
+            ('variavel', models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)),
+            ('fonte', models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)),
+        ],
+        options={
+            'db_table': 'fontes_variaveis',
+            'verbose_name': 'Fonte',
+            'verbose_name_plural': 'Fontes',
+        },
+        bases=(models.Model,),
+    )
+    
+    state.add_model(fonte_model_state)
+    state.add_model(variavel_model_state)
+    state.add_model(fonte_variavel_model_state)
+    
+    print("Successfully created migration state")
+    
+    # Now test the schema editor with the fonte model
+    fonte_model_cls = state.apps.get_model('fonte', 'FonteModel')
+    many_to_many_field = fonte_model_cls._meta.get_field('variaveis')
+    
+    print(f"Through model type: {type(many_to_many_field.remote_field.through)}")
+    print(f"Through model value: {many_to_many_field.remote_field.through}")
+    
+    # Test the schema editor functionality
+    schema_editor = BaseDatabaseSchemaEditor(connection)
+    
+    # This should not raise an AttributeError anymore
+    try:
+        through = many_to_many_field.remote_field.through
+        if isinstance(through, str):
+            print("Through model is a string, resolving...")
+            through = apps.get_model(through)
+        auto_created = through._meta.auto_created
+        print(f"Through model auto_created: {auto_created}")
+        
+        # Test accessing the through model directly (this was the original issue)
+        # The original error was: AttributeError: 'str' object has no attribute '_meta'
+        try:
+            _ = many_to_many_field.remote_field.through._meta.auto_created
+            print("Successfully accessed through._meta.auto_created without AttributeError!")
+        except AttributeError as e:
+            print(f"AttributeError still occurs: {e}")
+            import traceback
+            traceback.print_exc()
+        
+    except Exception as e:
+        print(f"Other error occurred: {e}")
+        import traceback
+        traceback.print_exc()
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+
+finally:
+    # Clean up
+    shutil.rmtree(temp_dir)
\ No newline at end of file