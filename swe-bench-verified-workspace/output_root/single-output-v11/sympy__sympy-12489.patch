diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..cbe9e5822c
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+class MyPermutation(Permutation):
+    """A custom permutation subclass for testing"""
+    pass
+
+# Test the specific issue mentioned in the GitHub issue
+print("Testing the specific GitHub issue scenario...")
+
+# Test 1: Direct subclass instantiation
+my_perm = MyPermutation([1, 0, 2])
+print(f"✓ Direct instantiation: {type(my_perm)}")
+
+# Test 2: _af_new method called on subclass
+my_perm2 = MyPermutation._af_new([1, 0, 2])
+print(f"✓ _af_new on subclass: {type(my_perm2)}")
+print(f"  Is instance of MyPermutation: {isinstance(my_perm2, MyPermutation)}")
+
+# Test 3: _af_new method called on base class (should still work)
+base_perm = Permutation._af_new([1, 0, 2])
+print(f"✓ _af_new on base class: {type(base_perm)}")
+print(f"  Is instance of Permutation: {isinstance(base_perm, Permutation)}")
+print(f"  Is instance of MyPermutation: {isinstance(base_perm, MyPermutation)}")
+
+print("\nAll tests passed! The subclassing issue has been fixed.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8969425823
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+class MyPermutation(Permutation):
+    """A custom permutation subclass for testing"""
+    def custom_method(self):
+        return "This is a custom method"
+
+# Test subclassing
+try:
+    my_perm = MyPermutation([1, 0, 2])
+    print("Subclass instance created successfully!")
+    print("Type:", type(my_perm))
+    print("Is instance of MyPermutation?", isinstance(my_perm, MyPermutation))
+    print("Is instance of Permutation?", isinstance(my_perm, Permutation))
+    print("Custom method:", my_perm.custom_method())
+except Exception as e:
+    print("Error creating subclass instance:", e)
+
+# Test if _af_new returns the correct type
+try:
+    my_perm2 = MyPermutation._af_new([1, 0, 2])
+    print("_af_new created successfully!")
+    print("Type:", type(my_perm2))
+    print("Is instance of MyPermutation?", isinstance(my_perm2, MyPermutation))
+    print("Is instance of Permutation?", isinstance(my_perm2, Permutation))
+except Exception as e:
+    print("Error with _af_new:", e)
\ No newline at end of file
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 4ac1c2ef3b..00921fba3f 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -857,9 +857,9 @@ def __new__(cls, *args, **kwargs):
         #g) (Permutation) = adjust size or return copy
         ok = True
         if not args:  # a
-            return _af_new(list(range(size or 0)))
+            return cls._af_new(list(range(size or 0)))
         elif len(args) > 1:  # c
-            return _af_new(Cycle(*args).list(size))
+            return cls._af_new(Cycle(*args).list(size))
         if len(args) == 1:
             a = args[0]
             if isinstance(a, Perm):  # g
@@ -867,9 +867,9 @@ def __new__(cls, *args, **kwargs):
                     return a
                 return Perm(a.array_form, size=size)
             if isinstance(a, Cycle):  # f
-                return _af_new(a.list(size))
+                return cls._af_new(a.list(size))
             if not is_sequence(a):  # b
-                return _af_new(list(range(a + 1)))
+                return cls._af_new(list(range(a + 1)))
             if has_variety(is_sequence(ai) for ai in a):
                 ok = False
         else:
@@ -924,8 +924,8 @@ def __new__(cls, *args, **kwargs):
         obj._size = size
         return obj
 
-    @staticmethod
-    def _af_new(perm):
+    @classmethod
+    def _af_new(cls, perm):
         """A method to produce a Permutation object from a list;
         the list is bound to the _array_form attribute, so it must
         not be modified; this method is meant for internal use only;
@@ -944,7 +944,7 @@ def _af_new(perm):
         Permutation([2, 1, 3, 0])
 
         """
-        p = Basic.__new__(Perm, perm)
+        p = Basic.__new__(cls, perm)
         p._array_form = perm
         p._size = len(perm)
         return p
diff --git a/test_subclassing.py b/test_subclassing.py
new file mode 100644
index 0000000000..d5d07e8c2c
--- /dev/null
+++ b/test_subclassing.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+from sympy.combinatorics.permutations import Permutation
+
+class MyPermutation(Permutation):
+    """A custom permutation subclass for testing"""
+    def __init__(self, *args, **kwargs):
+        # Don't call super().__init__ as it may not be needed for Basic subclasses
+        self.custom_attribute = "custom_value"
+    
+    def custom_method(self):
+        return f"This is a custom method for permutation {self}"
+
+def test_subclassing():
+    print("Testing Permutation subclassing...")
+    
+    # Test 1: Direct instantiation
+    try:
+        my_perm = MyPermutation([1, 0, 2])
+        print("✓ Direct instantiation works")
+        print(f"  Type: {type(my_perm)}")
+        print(f"  Is MyPermutation: {isinstance(my_perm, MyPermutation)}")
+        print(f"  Custom method: {my_perm.custom_method()}")
+        print(f"  Custom attribute: {my_perm.custom_attribute}")
+    except Exception as e:
+        print(f"✗ Direct instantiation failed: {e}")
+        return False
+    
+    # Test 2: _af_new method
+    try:
+        my_perm2 = MyPermutation._af_new([1, 0, 2])
+        print("✓ _af_new method works")
+        print(f"  Type: {type(my_perm2)}")
+        print(f"  Is MyPermutation: {isinstance(my_perm2, MyPermutation)}")
+        
+        # Test that it has the custom attributes/methods
+        my_perm2.custom_attribute = "custom_value_2"
+        print(f"  Custom attribute set: {my_perm2.custom_attribute}")
+    except Exception as e:
+        print(f"✗ _af_new method failed: {e}")
+        return False
+    
+    # Test 3: Ensure normal Permutation._af_new still works
+    try:
+        normal_perm = Permutation._af_new([1, 0, 2])
+        print("✓ Normal Permutation._af_new still works")
+        print(f"  Type: {type(normal_perm)}")
+        print(f"  Is Permutation: {isinstance(normal_perm, Permutation)}")
+        print(f"  Is MyPermutation: {isinstance(normal_perm, MyPermutation)}")
+    except Exception as e:
+        print(f"✗ Normal Permutation._af_new failed: {e}")
+        return False
+    
+    # Test 4: Test that internal methods that use _af_new work correctly
+    try:
+        # Test multiplication which uses _af_new internally
+        p1 = MyPermutation([1, 0, 2])
+        p2 = MyPermutation([0, 2, 1])
+        product = p1 * p2
+        print("✓ Multiplication with subclasses works")
+        print(f"  Product type: {type(product)}")
+        print(f"  Is MyPermutation: {isinstance(product, MyPermutation)}")
+    except Exception as e:
+        print(f"✗ Multiplication failed: {e}")
+        return False
+    
+    print("\nAll tests passed! ✓")
+    return True
+
+if __name__ == "__main__":
+    test_subclassing()
\ No newline at end of file