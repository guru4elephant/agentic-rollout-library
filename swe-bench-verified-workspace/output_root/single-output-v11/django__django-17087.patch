diff --git a/debug_nested.py b/debug_nested.py
new file mode 100644
index 0000000000..165848deee
--- /dev/null
+++ b/debug_nested.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Create a test nested class structure
+class OuterClass:
+    class NestedClass:
+        @classmethod
+        def class_method(cls):
+            return "test"
+
+# Get the class method
+class_method = OuterClass.NestedClass.class_method
+
+# Debug the structure
+print("Class method:", class_method)
+print("Class method __self__:", class_method.__self__)
+print("Class method __self__ type:", type(class_method.__self__))
+print("Class method __self__ __name__:", class_method.__self__.__name__)
+print("Class method __self__ __module__:", class_method.__self__.__module__)
+print("Class method __self__ __qualname__:", class_method.__self__.__qualname__)
+print("Class method __qualname__:", class_method.__qualname__)
+
+# Check if there are any other attributes that might help
+print("\nAll attributes of __self__:")
+for attr in dir(class_method.__self__):
+    if not attr.startswith('_'):
+        print(f"  {attr}: {getattr(class_method.__self__, attr)}")
+
+print("\nAll attributes of class method:")
+for attr in dir(class_method):
+    if not attr.startswith('_'):
+        print(f"  {attr}: {getattr(class_method, attr)}")
\ No newline at end of file
diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index d88cda6e20..2626ca5bad 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -168,7 +168,8 @@ class FunctionTypeSerializer(BaseSerializer):
         ):
             klass = self.value.__self__
             module = klass.__module__
-            return "%s.%s.%s" % (module, klass.__name__, self.value.__name__), {
+            # Use __qualname__ to get the full nesting path for nested classes
+            return "%s.%s.%s" % (module, klass.__qualname__, self.value.__name__), {
                 "import %s" % module
             }
         # Further error checking
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ce366ce8c3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import tempfile
+from pathlib import Path
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+# Create a test nested class structure similar to the issue
+class OuterClass:
+    class NestedClass:
+        @classmethod
+        def class_method(cls):
+            return "test"
+
+# Test the serialization
+def test_serialization():
+    # Get the class method
+    class_method = OuterClass.NestedClass.class_method
+    
+    # Try to serialize it
+    try:
+        result, imports = serializer_factory(class_method).serialize()
+        print("Serialization result:", result)
+        print("Imports:", imports)
+        return result
+    except Exception as e:
+        print("Error during serialization:", e)
+        return None
+
+if __name__ == "__main__":
+    result = test_serialization()
+    print("Test completed. Result:", result)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..751e56925f
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+def test_nested_class_method_serialization():
+    """Test that nested class methods are serialized correctly"""
+    
+    # Test case 1: Simple nested class
+    class OuterClass:
+        class NestedClass:
+            @classmethod
+            def class_method(cls):
+                return "test"
+    
+    result, imports = serializer_factory(OuterClass.NestedClass.class_method).serialize()
+    print("Test 1 - Simple nested class:")
+    print("  Result:", result)
+    print("  Expected pattern: __main__.OuterClass.NestedClass.class_method")
+    print("  Success:", "OuterClass.NestedClass.class_method" in result)
+    print()
+    
+    # Test case 2: Multiple levels of nesting
+    class Level1:
+        class Level2:
+            class Level3:
+                @classmethod
+                def deep_method(cls):
+                    return "deep"
+    
+    result, imports = serializer_factory(Level1.Level2.Level3.deep_method).serialize()
+    print("Test 2 - Multiple level nesting:")
+    print("  Result:", result)
+    print("  Expected pattern: __main__.Level1.Level2.Level3.deep_method")
+    print("  Success:", "Level1.Level2.Level3.deep_method" in result)
+    print()
+    
+    # Test case 3: Regular class method (not nested)
+    class RegularClass:
+        @classmethod
+        def regular_method(cls):
+            return "regular"
+    
+    result, imports = serializer_factory(RegularClass.regular_method).serialize()
+    print("Test 3 - Regular class method:")
+    print("  Result:", result)
+    print("  Expected pattern: __main__.RegularClass.regular_method")
+    print("  Success:", "RegularClass.regular_method" in result)
+    print()
+    
+    # Test case 4: Instance method (should fail as expected)
+    class TestClass:
+        def instance_method(self):
+            return "instance"
+    
+    instance = TestClass()
+    try:
+        result, imports = serializer_factory(instance.instance_method).serialize()
+        print("Test 4 - Instance method:")
+        print("  Result:", result)
+        print("  Expected: Should fail - instance methods cannot be serialized")
+        print("  Success: False (unexpected success)")
+    except ValueError as e:
+        print("Test 4 - Instance method:")
+        print("  Expected: Should fail - instance methods cannot be serialized")
+        print("  Success: True (failed as expected)")
+        print("  Error:", str(e))
+    print()
+
+def test_existing_functionality():
+    """Test that existing functionality still works"""
+    
+    # Test regular function (defined at module level)
+    result, imports = serializer_factory(test_existing_functionality).serialize()
+    print("Test 5 - Module level function:")
+    print("  Result:", result)
+    print("  Expected pattern: __main__.test_existing_functionality")
+    print("  Success:", "test_existing_functionality" in result)
+    print()
+
+if __name__ == "__main__":
+    print("=== Testing Nested Class Method Serialization ===")
+    print()
+    test_nested_class_method_serialization()
+    
+    print("=== Testing Existing Functionality ===")
+    print()
+    test_existing_functionality()
+    
+    print("All tests completed!")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..2a42c0373a
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+def test_edge_cases():
+    """Test edge cases to ensure we haven't broken anything"""
+    
+    # Test 1: Regular class method (not nested)
+    class RegularClass:
+        @classmethod
+        def regular_method(cls):
+            return "regular"
+    
+    result, imports = serializer_factory(RegularClass.regular_method).serialize()
+    print("Test 1 - Regular class method:")
+    print("  Result:", result)
+    print("  Success:", "RegularClass.regular_method" in result)
+    print()
+    
+    # Test 2: Static methods are not bound methods, so they work differently
+    # Let's skip this test as it's not relevant to our fix
+    print("Test 2 - Static method:")
+    print("  Note: Static methods are not bound methods, so they use different serialization path")
+    print("  This is expected behavior and not related to our nested class fix")
+    print()
+    
+    # Test 3: Regular function (use module-level function)
+    result, imports = serializer_factory(test_edge_cases).serialize()
+    print("Test 3 - Module-level function:")
+    print("  Result:", result)
+    print("  Success:", "test_edge_cases" in result)
+    print()
+    
+    # Test 4: Built-in class method (e.g., from Django models)
+    result, imports = serializer_factory(models.Model.delete).serialize()
+    print("Test 4 - Django Model class method:")
+    print("  Result:", result)
+    print("  Success:", "Model.delete" in result)
+    print()
+
+if __name__ == "__main__":
+    print("=== Testing Edge Cases ===")
+    print()
+    test_edge_cases()
+    print("All edge case tests completed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..0dd4dd8572
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+# Reproduce the exact scenario from the GitHub issue
+class Profile(models.Model):
+    class Meta:
+        app_label = 'test_app'  # Needed to avoid Django model registration issues
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+
+# Test the serialization
+def test_serialization():
+    # Get the default value function
+    default_func = Profile.Capability.default
+    
+    # Try to serialize it
+    try:
+        result, imports = serializer_factory(default_func).serialize()
+        print("Serialization result:", result)
+        print("Imports:", imports)
+        
+        # Check if the result is correct - it should contain the full nesting path
+        if "Profile.Capability.default" in result:
+            print("✓ SUCCESS: Serialization contains full nesting path!")
+            print("  Full result:", result)
+            return True
+        else:
+            print("✗ FAILURE: Expected result to contain 'Profile.Capability.default'")
+            print("            Got:     ", result)
+            return False
+            
+    except Exception as e:
+        print("Error during serialization:", e)
+        return False
+
+if __name__ == "__main__":
+    success = test_serialization()
+    print("Test completed. Success:", success)
\ No newline at end of file
diff --git a/test_github_scenario.py b/test_github_scenario.py
new file mode 100644
index 0000000000..ec8d1177cc
--- /dev/null
+++ b/test_github_scenario.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+
+# Add the testbed directory to Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.migrations.serializer import serializer_factory
+
+# Reproduce the exact scenario from the GitHub issue
+class Profile(models.Model):
+    class Meta:
+        app_label = 'test_app'
+    
+    class Capability(models.TextChoices):
+        BASIC = ("BASIC", "Basic")
+        PROFESSIONAL = ("PROFESSIONAL", "Professional")
+        
+        @classmethod
+        def default(cls) -> list[str]:
+            return [cls.BASIC]
+
+def test_github_issue():
+    """Test the exact scenario from the GitHub issue"""
+    
+    # Get the default method from the nested class
+    default_method = Profile.Capability.default
+    
+    # Serialize it
+    result, imports = serializer_factory(default_method).serialize()
+    
+    print("GitHub Issue Test:")
+    print("  Method:", default_method)
+    print("  Serialization result:", result)
+    print("  Imports:", imports)
+    
+    # The key test: the result should contain the full nesting path
+    # Before fix: would be "test_app.models.Capability.default" (WRONG)
+    # After fix: should be "test_app.models.Profile.Capability.default" (CORRECT)
+    
+    if "Profile.Capability.default" in result:
+        print("✓ SUCCESS: Serialization contains full nesting path!")
+        print("  The migration will now correctly reference: Profile.Capability.default")
+        return True
+    else:
+        print("✗ FAILURE: Serialization missing full nesting path!")
+        print("  Expected to contain: 'Profile.Capability.default'")
+        print("  Got:", result)
+        return False
+
+if __name__ == "__main__":
+    success = test_github_issue()
+    print("\nTest completed. Success:", success)
\ No newline at end of file