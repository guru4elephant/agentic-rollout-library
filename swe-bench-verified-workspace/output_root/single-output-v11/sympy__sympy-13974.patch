diff --git a/debug_1x1.py b/debug_1x1.py
new file mode 100644
index 0000000000..17c4be89f5
--- /dev/null
+++ b/debug_1x1.py
@@ -0,0 +1,13 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Let's check what 1x1 actually is
+t = tp(1,1)
+print("tp(1,1) =", t)
+print("type(t) =", type(t))
+print("t.args =", t.args)
+
+# Let's see what happens when we raise it to a power
+t_pow = t**3
+print("tp(1,1)**3 =", t_pow)
+print("type(t_pow) =", type(t_pow))
\ No newline at end of file
diff --git a/debug_expand.py b/debug_expand.py
new file mode 100644
index 0000000000..42b2d34cbb
--- /dev/null
+++ b/debug_expand.py
@@ -0,0 +1,16 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Create a simple test case
+t_pow = tp(1,1)**2
+print("t_pow =", t_pow)
+print("type(t_pow) =", type(t_pow))
+
+# Try to expand with tensorproduct=True
+result = t_pow.expand(tensorproduct=True)
+print("t_pow.expand(tensorproduct=True) =", result)
+print("type(result) =", type(result))
+
+# Let's also check what methods are available
+print("hasattr(t_pow, '_eval_expand_tensorproduct') =", hasattr(t_pow, '_eval_expand_tensorproduct'))
+print("hasattr(t_pow.base, '_eval_expand_tensorproduct') =", hasattr(t_pow.base, '_eval_expand_tensorproduct'))
\ No newline at end of file
diff --git a/debug_expand2.py b/debug_expand2.py
new file mode 100644
index 0000000000..c1641ee3fd
--- /dev/null
+++ b/debug_expand2.py
@@ -0,0 +1,16 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Create a simple test case
+t_pow = tp(1,1)**2
+print("t_pow =", t_pow)
+print("t_pow.base =", t_pow.base)
+
+# Let's see what happens when we expand the base
+base_expanded = t_pow.base.expand(tensorproduct=True)
+print("base_expanded =", base_expanded)
+
+# Now let's see what happens if we manually construct the correct result
+correct_result = tp(1**2, 1**2)
+print("correct_result =", correct_result)
+print("correct_result.expand(tensorproduct=True) =", correct_result.expand(tensorproduct=True))
\ No newline at end of file
diff --git a/debug_mul_power.py b/debug_mul_power.py
new file mode 100644
index 0000000000..51e15ce9af
--- /dev/null
+++ b/debug_mul_power.py
@@ -0,0 +1,20 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Create a Mul object: 6 * 1x1
+t = tp(2,3)  # This becomes 6 * 1x1
+print("tp(2,3) =", t)
+print("type(t) =", type(t))
+
+# Raise it to a power
+t_pow = t**3
+print("(6 * 1x1)**3 =", t_pow)
+print("type(t_pow) =", type(t_pow))
+
+# Let's see what the args are
+print("t_pow.args =", t_pow.args)
+
+# Let's see what the base of the power is
+if hasattr(t_pow, 'base'):
+    print("t_pow.base =", t_pow.base)
+    print("type(t_pow.base) =", type(t_pow.base))
\ No newline at end of file
diff --git a/debug_pow_recognition.py b/debug_pow_recognition.py
new file mode 100644
index 0000000000..b25ae3d1fb
--- /dev/null
+++ b/debug_pow_recognition.py
@@ -0,0 +1,23 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul
+
+# Create the problematic expression
+t = tp(2,3)**3  # This becomes 216 * 1x1**3
+print("tp(2,3)**3 =", t)
+
+# Check if it has TensorProduct
+print("t.has(TensorProduct) =", t.has(tp))
+
+# Let's manually check the args
+c_part, nc_part = t.args_cnc()
+print("c_part =", c_part)
+print("nc_part =", nc_part)
+
+# Check if any nc_part items are Pow with TensorProduct base
+for item in nc_part:
+    print(f"item = {item}, type = {type(item)}")
+    if isinstance(item, Pow):
+        print(f"  item.base = {item.base}, type = {type(item.base)}")
+        print(f"  isinstance(item.base, TensorProduct) = {isinstance(item.base, tp)}")
+        print(f"  item.exp = {item.exp}")
\ No newline at end of file
diff --git a/debug_power.py b/debug_power.py
new file mode 100644
index 0000000000..68e8a02902
--- /dev/null
+++ b/debug_power.py
@@ -0,0 +1,19 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Create a simple test case
+t1 = tp(1,1)*tp(1,1)
+print("t1 =", t1)
+print("type(t1) =", type(t1))
+
+# Let's see what happens when we raise a tensor product to a power
+t_pow = tp(1,1)**2
+print("tp(1,1)**2 =", t_pow)
+print("type(tp(1,1)**2) =", type(t_pow))
+print("t_pow.base =", t_pow.base)
+print("t_pow.exp =", t_pow.exp)
+print("isinstance(t_pow.base, TensorProduct) =", isinstance(t_pow.base, tp))
+
+# Test the current behavior
+print("tps(t_pow) =", tps(t_pow))
\ No newline at end of file
diff --git a/debug_power3.py b/debug_power3.py
new file mode 100644
index 0000000000..12783143dc
--- /dev/null
+++ b/debug_power3.py
@@ -0,0 +1,18 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Let's trace through what happens step by step
+t = tp(2,3)
+print("tp(2,3) =", t)
+
+# Apply power
+t_pow = t**3
+print("tp(2,3)**3 =", t_pow)
+
+# Let's see what the _eval_power method returns
+result = t._eval_power(3)
+print("t._eval_power(3) =", result)
+
+# Let's see what happens when we create the tensor product manually
+manual = tp(8,27)
+print("tp(8,27) =", manual)
\ No newline at end of file
diff --git a/debug_simple_mul.py b/debug_simple_mul.py
new file mode 100644
index 0000000000..b0a0da5c22
--- /dev/null
+++ b/debug_simple_mul.py
@@ -0,0 +1,23 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Create a simple Mul: 216 * 1x1
+t = 216 * tp(1,1)
+print("216 * tp(1,1) =", t)
+print("type(t) =", type(t))
+
+# Apply tensor_product_simp
+result = tps(t)
+print("tps(216 * tp(1,1)) =", result)
+print("type(result) =", type(result))
+
+# Let's see what args_cnc returns
+c_part, nc_part = t.args_cnc()
+print("c_part =", c_part)
+print("nc_part =", nc_part)
+print("nc_part types =", [type(x) for x in nc_part])
+
+# Check what happens in tensor_product_simp_Mul
+print("n_nc =", len(nc_part))
+print("n_nc == 0 or n_nc == 1:", len(nc_part) == 0 or len(nc_part) == 1)
\ No newline at end of file
diff --git a/debug_tp.py b/debug_tp.py
new file mode 100644
index 0000000000..48e657de05
--- /dev/null
+++ b/debug_tp.py
@@ -0,0 +1,15 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# Let's check what tp(2,3) actually is
+t = tp(2,3)
+print("tp(2,3) =", t)
+print("type(t) =", type(t))
+print("t.args =", t.args)
+
+# Let's check what happens when we create a TensorProduct with non-commutative elements
+a = Symbol('a', commutative=False)
+t2 = tp(2, a)
+print("tp(2,a) =", t2)
+print("type(t2) =", type(t2))
+print("t2.args =", t2.args)
\ No newline at end of file
diff --git a/debug_tps.py b/debug_tps.py
new file mode 100644
index 0000000000..4175c7bd0f
--- /dev/null
+++ b/debug_tps.py
@@ -0,0 +1,19 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Create the problematic expression
+t = tp(2,3)**3  # This becomes 216 * 1x1**3
+print("tp(2,3)**3 =", t)
+print("type(t) =", type(t))
+
+# Apply tensor_product_simp
+result = tps(t)
+print("tps(t) =", result)
+print("type(result) =", type(result))
+
+# Let's also check what happens with the individual parts
+part = (tp(1,1)**3)
+print("(tp(1,1)**3) =", part)
+print("type(part) =", type(part))
+print("tps(part) =", tps(part))
\ No newline at end of file
diff --git a/debug_tps_mul.py b/debug_tps_mul.py
new file mode 100644
index 0000000000..493ff5b4aa
--- /dev/null
+++ b/debug_tps_mul.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+
+# Create the problematic expression
+t = tp(2,3)**3  # This becomes 216 * 1x1**3
+print("tp(2,3)**3 =", t)
+print("type(t) =", type(t))
+
+# Let's see what args_cnc returns
+c_part, nc_part = t.args_cnc()
+print("c_part =", c_part)
+print("nc_part =", nc_part)
+print("nc_part types =", [type(x) for x in nc_part])
+
+# Check if any nc_part items are Pow with TensorProduct base
+for i, item in enumerate(nc_part):
+    if isinstance(item, Pow) and isinstance(item.base, tp):
+        print(f"nc_part[{i}] is Pow with TensorProduct base:")
+        print(f"  item = {item}")
+        print(f"  item.base = {item.base}")
+        print(f"  item.exp = {item.exp}")
+        # Try our simplification
+        simplified = item.base._eval_power(item.exp)
+        print(f"  simplified = {simplified}")
+        print(f"  type(simplified) = {type(simplified)}")
\ No newline at end of file
diff --git a/debug_tps_mul_direct.py b/debug_tps_mul_direct.py
new file mode 100644
index 0000000000..2309f5d75d
--- /dev/null
+++ b/debug_tps_mul_direct.py
@@ -0,0 +1,27 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul
+
+# Create the problematic expression
+t = tp(2,3)**3  # This becomes 216 * 1x1**3
+print("tp(2,3)**3 =", t)
+
+# Apply tensor_product_simp_Mul directly
+result = tensor_product_simp_Mul(t)
+print("tensor_product_simp_Mul(t) =", result)
+print("type(result) =", type(result))
+
+# Let's also test the recursive case manually
+# First simplify the Pow object
+pow_obj = t.args[1]  # This is 1x1**3
+print("pow_obj =", pow_obj)
+simplified = pow_obj.base._eval_power(pow_obj.exp)  # This should be 1x1
+print("simplified =", simplified)
+
+# Now reconstruct the Mul
+new_mul = t.args[0] * simplified  # This should be 216 * 1x1
+print("new_mul =", new_mul)
+
+# Apply tensor_product_simp_Mul again
+result2 = tensor_product_simp_Mul(new_mul)
+print("tensor_product_simp_Mul(new_mul) =", result2)
\ No newline at end of file
diff --git a/debug_tps_mul_internals.py b/debug_tps_mul_internals.py
new file mode 100644
index 0000000000..bd8c68ad25
--- /dev/null
+++ b/debug_tps_mul_internals.py
@@ -0,0 +1,66 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum.tensorproduct import tensor_product_simp_Mul, TensorProduct
+
+# Monkey patch the function to add debug output
+def debug_tensor_product_simp_Mul(e):
+    print(f"debug_tensor_product_simp_Mul called with: {e}")
+    if not isinstance(e, Mul):
+        print("  Not a Mul, returning")
+        return e
+    c_part, nc_part = e.args_cnc()
+    print(f"  c_part = {c_part}")
+    print(f"  nc_part = {nc_part}")
+    n_nc = len(nc_part)
+    print(f"  n_nc = {n_nc}")
+    if n_nc == 0 or n_nc == 1:
+        print("  n_nc == 0 or n_nc == 1, returning")
+        return e
+    elif e.has(TensorProduct):
+        print("  e.has(TensorProduct) is True")
+        # Handle the case where we have Pow objects containing TensorProducts
+        # First, simplify any Pow objects that contain TensorProducts
+        new_nc_part = []
+        for item in nc_part:
+            print(f"    Processing item: {item}, type: {type(item)}")
+            if isinstance(item, Pow) and isinstance(item.base, TensorProduct):
+                print(f"      Found Pow with TensorProduct base: {item}")
+                # Simplify the power of TensorProduct
+                simplified = item.base._eval_power(item.exp)
+                print(f"      Simplified to: {simplified}")
+                new_nc_part.append(simplified)
+            else:
+                print(f"      Not a Pow with TensorProduct base, keeping as is")
+                new_nc_part.append(item)
+        
+        nc_part = new_nc_part
+        print(f"  After processing Pow objects, nc_part = {nc_part}")
+        
+        # After simplifying Pow objects, we may need to recursively simplify again
+        # if the simplified parts contain TensorProducts that need further processing
+        if any(isinstance(item, TensorProduct) for item in nc_part):
+            print(f"  Found TensorProducts in nc_part, reconstructing Mul")
+            # Reconstruct the Mul and recursively simplify
+            new_mul = Mul(*c_part) * Mul(*nc_part)
+            print(f"  new_mul = {new_mul}")
+            result = debug_tensor_product_simp_Mul(new_mul)
+            print(f"  Recursive result = {result}")
+            return result
+        
+        current = nc_part[0]
+        if not isinstance(current, TensorProduct):
+            raise TypeError('TensorProduct expected, got: %r' % current)
+        # ... rest of the function would continue here
+        print("  Continuing with normal processing...")
+        return e
+    else:
+        print("  No TensorProduct found, returning")
+        return e
+
+# Create the problematic expression
+t = tp(2,3)**3  # This becomes 216 * 1x1**3
+print("tp(2,3)**3 =", t)
+
+# Apply our debug function
+result = debug_tensor_product_simp_Mul(t)
+print("Final result =", result)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..b6527bd4aa
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+from sympy.physics.paulialgebra import Pauli
+a = Symbol('a', commutative=False)
+
+print("Testing issue with TensorProduct powers:")
+
+# Test case 1: Simple tensor product squared
+print("\n1. Testing tp(1,1)*tp(1,1):")
+t1 = tp(1,1)*tp(1,1)
+print("t1 =", t1)
+print("tps(t1) =", tps(t1))
+print("t1.expand(tensorproduct=True) =", t1.expand(tensorproduct=True))
+
+# Test case 2: Expected result using substitution
+print("\n2. Testing expected result via substitution:")
+print("tps(tp(1,1)*tp(1,a)).subs(a, 1) =", tps(tp(1,1)*tp(1,a)).subs(a, 1))
+
+# Test case 3: Pauli tensor product squared
+print("\n3. Testing tp(1,Pauli(3))*tp(1,Pauli(3)):")
+t2 = tp(1,Pauli(3))*tp(1,Pauli(3))
+print("t2 =", t2)
+print("tps(t2) =", tps(t2))
+print("t2.expand(tensorproduct=True) =", t2.expand(tensorproduct=True))
+
+# Test case 4: Expected result using substitution
+print("\n4. Testing expected result via substitution:")
+print("tps(tp(1,Pauli(3))*tp(1,a)).subs(a, Pauli(3)) =", tps(tp(1,Pauli(3))*tp(1,a)).subs(a, Pauli(3)))
\ No newline at end of file
diff --git a/sympy/physics/quantum/tensorproduct.py b/sympy/physics/quantum/tensorproduct.py
index 9dd10d219e..cd8b98e4d0 100644
--- a/sympy/physics/quantum/tensorproduct.py
+++ b/sympy/physics/quantum/tensorproduct.py
@@ -143,6 +143,12 @@ def flatten(cls, args):
     def _eval_adjoint(self):
         return TensorProduct(*[Dagger(i) for i in self.args])
 
+    def _eval_power(self, exp):
+        """Handle powers of TensorProduct by distributing the power across components."""
+        # Distribute the power across the tensor product components
+        new_args = [arg ** exp for arg in self.args]
+        return TensorProduct(*new_args)
+
     def _eval_rewrite(self, pattern, rule, **hints):
         sargs = self.args
         terms = [t._eval_rewrite(pattern, rule, **hints) for t in sargs]
@@ -316,9 +322,42 @@ def tensor_product_simp_Mul(e):
         return e
     c_part, nc_part = e.args_cnc()
     n_nc = len(nc_part)
+    
+    # Handle the case where we have Pow objects containing TensorProducts
+    # even when n_nc == 1
+    if n_nc == 1 and isinstance(nc_part[0], Pow) and isinstance(nc_part[0].base, TensorProduct):
+        # Simplify the power of TensorProduct
+        simplified = nc_part[0].base._eval_power(nc_part[0].exp)
+        # Reconstruct the Mul and return
+        return Mul(*c_part) * simplified
+    
     if n_nc == 0 or n_nc == 1:
         return e
     elif e.has(TensorProduct):
+        # Handle the case where we have Pow objects containing TensorProducts
+        # First, simplify any Pow objects that contain TensorProducts
+        new_nc_part = []
+        for item in nc_part:
+            if isinstance(item, Pow) and isinstance(item.base, TensorProduct):
+                # Simplify the power of TensorProduct
+                simplified = item.base._eval_power(item.exp)
+                new_nc_part.append(simplified)
+            else:
+                new_nc_part.append(item)
+        
+        nc_part = new_nc_part
+        
+        # After simplifying Pow objects, we may need to recursively simplify again
+        # if the simplified parts contain TensorProducts that need further processing
+        if any(isinstance(item, TensorProduct) for item in nc_part):
+            # Reconstruct the Mul and check if it needs further simplification
+            new_mul = Mul(*c_part) * Mul(*nc_part)
+            # Only recurse if the new expression is different from the original
+            if new_mul != e:
+                return tensor_product_simp_Mul(new_mul)
+            else:
+                return new_mul
+        
         current = nc_part[0]
         if not isinstance(current, TensorProduct):
             raise TypeError('TensorProduct expected, got: %r' % current)
@@ -382,7 +421,13 @@ def tensor_product_simp(e, **hints):
     if isinstance(e, Add):
         return Add(*[tensor_product_simp(arg) for arg in e.args])
     elif isinstance(e, Pow):
-        return tensor_product_simp(e.base) ** e.exp
+        # Handle the case where the base is a TensorProduct
+        if isinstance(e.base, TensorProduct):
+            # Distribute the power across the tensor product components
+            new_args = [arg ** e.exp for arg in e.base.args]
+            return TensorProduct(*new_args)
+        else:
+            return tensor_product_simp(e.base) ** e.exp
     elif isinstance(e, Mul):
         return tensor_product_simp_Mul(e)
     elif isinstance(e, Commutator):
diff --git a/test_commutative.py b/test_commutative.py
new file mode 100644
index 0000000000..5688f0f8be
--- /dev/null
+++ b/test_commutative.py
@@ -0,0 +1,21 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+print("Testing commutative behavior:")
+
+# Test case 1: Simple commutative numbers
+t1 = tp(2, 3)
+print("tp(2, 3) =", t1)
+
+# Test case 2: Mixed commutative and non-commutative
+a = Symbol('a', commutative=False)
+t2 = tp(2, a)
+print("tp(2, a) =", t2)
+
+# Test case 3: Power of commutative numbers
+t3 = tp(2, 3)**3
+print("tp(2, 3)**3 =", t3)
+
+# Test case 4: Check what happens when we create the expected result manually
+t4 = tp(8, 27)
+print("tp(8, 27) =", t4)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..f12eb1f470
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,43 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+from sympy.physics.quantum import tensor_product_simp as tps
+from sympy.physics.paulialgebra import Pauli
+
+print("Testing edge cases for TensorProduct powers:")
+
+# Test case 1: Regular multiplication still works
+print("\n1. Testing regular multiplication:")
+t1 = tp(1,2)*tp(3,4)
+print("tp(1,2)*tp(3,4) =", t1)
+print("tps(t1) =", tps(t1))
+
+# Test case 2: Power of 1
+print("\n2. Testing power of 1:")
+t2 = tp(1,1)**1
+print("tp(1,1)**1 =", t2)
+print("tps(t2) =", tps(t2))
+
+# Test case 3: Power of 0
+print("\n3. Testing power of 0:")
+t3 = tp(1,1)**0
+print("tp(1,1)**0 =", t3)
+print("tps(t3) =", tps(t3))
+
+# Test case 4: Higher powers
+print("\n4. Testing higher powers:")
+t4 = tp(2,3)**3
+print("tp(2,3)**3 =", t4)
+print("tps(t4) =", tps(t4))
+
+# Test case 5: Mixed commutative and non-commutative
+print("\n5. Testing mixed commutative and non-commutative:")
+a = Symbol('a', commutative=False)
+t5 = tp(1,a)**2
+print("tp(1,a)**2 =", t5)
+print("tps(t5) =", tps(t5))
+
+# Test case 6: With Pauli matrices
+print("\n6. Testing with Pauli matrices:")
+t6 = tp(Pauli(1), Pauli(2))**2
+print("tp(Pauli(1), Pauli(2))**2 =", t6)
+print("tps(t6) =", tps(t6))
\ No newline at end of file
diff --git a/verify_result.py b/verify_result.py
new file mode 100644
index 0000000000..7391c28bd3
--- /dev/null
+++ b/verify_result.py
@@ -0,0 +1,30 @@
+from sympy import *
+from sympy.physics.quantum import TensorProduct as tp
+
+# What should tp(2,3)**3 actually be?
+# tp(2,3) becomes 6 * 1x1 because 2 and 3 are commutative
+# (6 * 1x1)**3 becomes 216 * (1x1)**3
+# But (1x1)**3 should be 1x1 because 1**3 = 1
+# So the final result should be 216 * 1x1
+
+print("Expected result calculation:")
+print("tp(2,3) = 6 * 1x1")
+print("(6 * 1x1)**3 = 216 * (1x1)**3")
+print("(1x1)**3 = 1x1 (because 1**3 = 1)")
+print("Final result = 216 * 1x1")
+
+# Let's verify this step by step
+t = tp(2,3)
+print("tp(2,3) =", t)
+
+t_pow = t**3
+print("tp(2,3)**3 =", t_pow)
+
+# The result 216 * 1x1 is actually correct!
+# The issue is that we're expecting 216 * 1x1 but seeing 216 * 1x1**3
+# This suggests that our _eval_power method is not being called
+
+# Let's check if _eval_power is being called
+t_simple = tp(1,1)
+print("tp(1,1) =", t_simple)
+print("tp(1,1)**3 =", t_simple**3)
\ No newline at end of file