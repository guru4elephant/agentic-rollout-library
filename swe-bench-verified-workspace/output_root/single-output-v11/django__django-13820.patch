diff --git a/debug_loader.py b/debug_loader.py
new file mode 100644
index 0000000000..f27d72f5d1
--- /dev/null
+++ b/debug_loader.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+"""
+Debug the migration loader to see what apps are being processed.
+"""
+
+import sys
+import os
+
+# Add current directory and tests directory to Python path
+sys.path.insert(0, os.getcwd())
+sys.path.insert(0, os.path.join(os.getcwd(), 'tests'))
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+def debug_loader():
+    """Debug the migration loader process."""
+    from django.db.migrations.loader import MigrationLoader
+    from django.test.utils import override_settings
+    from django.db import connections
+    from django.apps import apps
+    
+    # Use the test namespace package
+    with override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_namespace_package"}):
+        print("Available apps:", [app.label for app in apps.get_app_configs()])
+        
+        loader = MigrationLoader(connections['default'])
+        print("Before load_disk:")
+        print(f"  unmigrated_apps: {loader.unmigrated_apps}")
+        print(f"  migrated_apps: {loader.migrated_apps}")
+        
+        loader.load_disk()
+        print("After load_disk:")
+        print(f"  unmigrated_apps: {loader.unmigrated_apps}")
+        print(f"  migrated_apps: {loader.migrated_apps}")
+        print(f"  disk_migrations: {loader.disk_migrations}")
+        
+        # Check what happens with the specific app
+        for app_config in apps.get_app_configs():
+            if app_config.label == 'migrations':
+                module_name, explicit = loader.migrations_module(app_config.label)
+                print(f"\nApp 'migrations':")
+                print(f"  module_name: {module_name}")
+                print(f"  explicit: {explicit}")
+                
+                if module_name is None:
+                    print("  Module name is None - skipping")
+                    continue
+                
+                try:
+                    module = __import__(module_name, fromlist=[''])
+                    print(f"  Module imported: {module}")
+                    print(f"  Module __file__: {getattr(module, '__file__', None)}")
+                    print(f"  Module __path__: {getattr(module, '__path__', None)}")
+                    print(f"  Module __path__ type: {type(getattr(module, '__path__', None))}")
+                    print(f"  Module __path__ is list: {isinstance(getattr(module, '__path__', None), list)}")
+                    
+                    # Test our check logic
+                    has_file = getattr(module, '__file__', None) is not None
+                    has_path = hasattr(module, '__path__')
+                    is_list_path = has_path and isinstance(module.__path__, list)
+                    should_skip = not has_file and not is_list_path
+                    
+                    print(f"  Should skip: {should_skip}")
+                    
+                except ImportError as e:
+                    print(f"  Import error: {e}")
+    
+    return True
+
+if __name__ == '__main__':
+    success = debug_loader()
+    if success:
+        print("\n✅ Debug completed!")
+    else:
+        print("\n❌ Debug failed!")
\ No newline at end of file
diff --git a/debug_namespace_package.py b/debug_namespace_package.py
new file mode 100644
index 0000000000..2706638209
--- /dev/null
+++ b/debug_namespace_package.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+"""
+Debug test to understand namespace package behavior.
+"""
+
+import sys
+import os
+
+# Add current directory and tests directory to Python path
+sys.path.insert(0, os.getcwd())
+sys.path.insert(0, os.path.join(os.getcwd(), 'tests'))
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+def debug_namespace_package():
+    """Debug what happens with namespace packages."""
+    from django.db.migrations.loader import MigrationLoader
+    from django.test.utils import override_settings
+    from django.db import connection
+    
+    # Use the test namespace package
+    with override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_namespace_package"}):
+        # Import the module to see its attributes
+        try:
+            module = __import__("migrations.test_migrations_namespace_package", fromlist=[''])
+            print(f"Module imported successfully: {module}")
+            print(f"Module __file__: {getattr(module, '__file__', None)}")
+            print(f"Module __path__: {getattr(module, '__path__', None)}")
+            print(f"Module __path__ type: {type(getattr(module, '__path__', None))}")
+            print(f"Module __path__ is list: {isinstance(getattr(module, '__path__', None), list)}")
+            
+            # Test our check logic
+            has_file = getattr(module, '__file__', None) is not None
+            has_path = hasattr(module, '__path__')
+            is_list_path = has_path and isinstance(module.__path__, list)
+            should_skip = not has_file and not is_list_path
+            
+            print(f"\nCheck logic:")
+            print(f"  - Has __file__: {has_file}")
+            print(f"  - Has __path__: {has_path}")
+            print(f"  - __path__ is list: {is_list_path}")
+            print(f"  - Should skip: {should_skip}")
+            
+        except ImportError as e:
+            print(f"Import error: {e}")
+            return False
+    
+    return True
+
+if __name__ == '__main__':
+    success = debug_namespace_package()
+    if success:
+        print("\n✅ Debug completed!")
+    else:
+        print("\n❌ Debug failed!")
\ No newline at end of file
diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py
index 95a5062ec9..a639797a6e 100644
--- a/django/db/migrations/loader.py
+++ b/django/db/migrations/loader.py
@@ -90,7 +90,8 @@ class MigrationLoader:
             else:
                 # Empty directories are namespaces.
                 # getattr() needed on PY36 and older (replace w/attribute access).
-                if getattr(module, '__file__', None) is None:
+                # Check for namespace packages: no __file__ and non-list __path__
+                if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):
                     self.unmigrated_apps.add(app_config.label)
                     continue
                 # Module is not a package (e.g. migrations.py).
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..5e00ac7235
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3
+"""
+Final verification that our fix addresses the GitHub issue.
+
+The issue: Permit migrations in non-namespace packages that don't have __file__
+"""
+
+import sys
+import os
+from types import ModuleType
+
+# Add current directory to Python path
+sys.path.insert(0, os.getcwd())
+
+def test_github_issue_fix():
+    """
+    Test that our fix addresses the GitHub issue:
+    - Namespace packages (no __file__ + non-list __path__) should be skipped
+    - Regular packages without __file__ (frozen environments) should NOT be skipped
+    - Regular packages with __file__ should NOT be skipped
+    """
+    
+    # Simulate the different types of packages
+    class NamespacePath:
+        """Simulate namespace package __path__ (not a list)"""
+        def __init__(self, paths):
+            self._paths = paths
+        
+        def __iter__(self):
+            return iter(self._paths)
+        
+        def __len__(self):
+            return len(self._paths)
+    
+    # 1. Namespace package (PEP-420) - should be SKIPPED
+    namespace_pkg = ModuleType('namespace_pkg')
+    namespace_pkg.__path__ = NamespacePath(['/ns/path1', '/ns/path2'])
+    # No __file__ - this is characteristic of namespace packages
+    
+    # 2. Regular package in frozen environment - should NOT be skipped
+    frozen_pkg = ModuleType('frozen_pkg')
+    frozen_pkg.__path__ = ['/frozen/path']  # Regular list __path__
+    # No __file__ - this happens in frozen environments (the GitHub issue)
+    
+    # 3. Regular package with __file__ - should NOT be skipped
+    regular_pkg = ModuleType('regular_pkg')
+    regular_pkg.__path__ = ['/regular/path']  # Regular list __path__
+    regular_pkg.__file__ = '/regular/path/__init__.py'  # Has __file__
+    
+    # Test the fixed logic from MigrationLoader
+    def should_skip_package(module):
+        """Replicate the fixed logic from MigrationLoader.load_disk()"""
+        # The fix: check for namespace packages specifically
+        # Old: if getattr(module, '__file__', None) is None:
+        # New: if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):
+        return getattr(module, '__file__', None) is None and not isinstance(module.__path__, list)
+    
+    print("=== Testing GitHub Issue Fix ===")
+    print("Namespace packages (PEP-420) should be skipped:")
+    print(f"  Should skip: {should_skip_package(namespace_pkg)}")
+    
+    print("\nRegular packages without __file__ (frozen env) should NOT be skipped:")
+    print(f"  Should skip: {should_skip_package(frozen_pkg)}")
+    
+    print("\nRegular packages with __file__ should NOT be skipped:")
+    print(f"  Should skip: {should_skip_package(regular_pkg)}")
+    
+    # Verify the fix
+    results = {
+        'namespace_pkg': should_skip_package(namespace_pkg),
+        'frozen_pkg': should_skip_package(frozen_pkg),
+        'regular_pkg': should_skip_package(regular_pkg),
+    }
+    
+    expected = {
+        'namespace_pkg': True,   # Should be skipped
+        'frozen_pkg': False,    # Should NOT be skipped (the fix!)
+        'regular_pkg': False,   # Should NOT be skipped
+    }
+    
+    print(f"\n=== Results ===")
+    all_passed = True
+    for pkg_type, result in results.items():
+        expected_result = expected[pkg_type]
+        status = "✅" if result == expected_result else "❌"
+        print(f"{pkg_type}: {status} (got {result}, expected {expected_result})")
+        if result != expected_result:
+            all_passed = False
+    
+    if all_passed:
+        print("\n🎉 SUCCESS: The GitHub issue has been fixed!")
+        print("   - Namespace packages are correctly skipped")
+        print("   - Regular packages without __file__ (frozen env) are now accepted")
+        print("   - Regular packages with __file__ continue to work")
+        return True
+    else:
+        print("\n❌ FAILURE: The fix is not working correctly")
+        return False
+
+if __name__ == '__main__':
+    success = test_github_issue_fix()
+    if success:
+        print("\n✅ Final verification passed!")
+    else:
+        print("\n❌ Final verification failed!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e6e5bcf71e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the namespace package migration loading issue.
+
+This script creates a test scenario where a module doesn't have __file__
+but is not a namespace package (simulating frozen environments).
+"""
+
+import sys
+import os
+from importlib.util import module_from_spec, spec_from_file_location
+from types import ModuleType
+
+# Add current directory to Python path
+sys.path.insert(0, os.getcwd())
+
+def create_module_without_file():
+    """Create a module that doesn't have __file__ attribute."""
+    # Create a regular module but remove __file__ to simulate frozen environment
+    module = ModuleType('test_migrations')
+    module.__path__ = ['/fake/path']  # Make it a package
+    # Don't set __file__ to simulate frozen environment
+    return module
+
+def test_current_behavior():
+    """Test the current behavior of the migration loader."""
+    from django.db.migrations.loader import MigrationLoader
+    
+    # Create a test module without __file__
+    test_module = create_module_without_file()
+    
+    # Check what the current code would do
+    has_file = getattr(test_module, '__file__', None) is not None
+    is_namespace_package = hasattr(test_module, '__path__') and not isinstance(test_module.__path__, list)
+    
+    print(f"Module has __file__: {has_file}")
+    print(f"Module is namespace package: {is_namespace_package}")
+    print(f"Current code would skip this module: {not has_file}")
+    
+    # The issue: current code skips modules without __file__ even if they're not namespace packages
+    if not has_file:
+        print("❌ Current code incorrectly skips non-namespace packages without __file__")
+        return False
+    else:
+        print("✅ Current code would accept this module")
+        return True
+
+def test_proposed_fix():
+    """Test the proposed fix behavior."""
+    from django.db.migrations.loader import MigrationLoader
+    
+    # Create a test module without __file__
+    test_module = create_module_without_file()
+    
+    # Current check
+    has_file = getattr(test_module, '__file__', None) is not None
+    
+    # Proposed check: also verify it's not a namespace package
+    is_namespace_package = hasattr(test_module, '__path__') and not isinstance(test_module.__path__, list)
+    should_skip = has_file is None and is_namespace_package
+    
+    print(f"Module has __file__: {has_file}")
+    print(f"Module is namespace package: {is_namespace_package}")
+    print(f"Proposed fix would skip this module: {should_skip}")
+    
+    if not should_skip:
+        print("✅ Proposed fix would accept non-namespace packages without __file__")
+        return True
+    else:
+        print("❌ Proposed fix would skip namespace packages (correct)")
+        return False
+
+if __name__ == '__main__':
+    print("=== Testing Current Behavior ===")
+    current_result = test_current_behavior()
+    
+    print("\n=== Testing Proposed Fix ===")
+    fix_result = test_proposed_fix()
+    
+    print(f"\nSummary:")
+    print(f"Current behavior problematic: {not current_result}")
+    print(f"Proposed fix works: {fix_result}")
\ No newline at end of file
diff --git a/test_actual_behavior.py b/test_actual_behavior.py
new file mode 100644
index 0000000000..665482fbf9
--- /dev/null
+++ b/test_actual_behavior.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+"""
+Test the actual behavior with the Django migration loader.
+"""
+
+import sys
+import os
+from types import ModuleType
+
+# Add current directory to Python path
+sys.path.insert(0, os.getcwd())
+
+def test_actual_migration_loader():
+    """Test the actual migration loader behavior."""
+    from django.db.migrations.loader import MigrationLoader
+    
+    # Create test modules
+    class NamespacePath:
+        def __init__(self, paths):
+            self._paths = paths
+        
+        def __iter__(self):
+            return iter(self._paths)
+        
+        def __len__(self):
+            return len(self._paths)
+    
+    # Test module 1: Namespace package (should be skipped)
+    namespace_module = ModuleType('namespace_test')
+    namespace_module.__path__ = NamespacePath(['/fake/path1', '/fake/path2'])
+    
+    # Test module 2: Regular package without __file__ (should NOT be skipped)
+    regular_module = ModuleType('regular_test')
+    regular_module.__path__ = ['/fake/path']
+    
+    # Test the logic from the actual MigrationLoader code
+    def should_skip_module(module):
+        """Replicate the logic from MigrationLoader.load_disk()"""
+        # Empty directories are namespaces.
+        # getattr() needed on PY36 and older (replace w/attribute access).
+        # Check for namespace packages: no __file__ and non-list __path__
+        if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):
+            return True
+        # Module is not a package (e.g. migrations.py).
+        if not hasattr(module, '__path__'):
+            return True
+        return False
+    
+    print("Testing actual MigrationLoader logic:")
+    print(f"Namespace package should be skipped: {should_skip_module(namespace_module)}")
+    print(f"Regular package without __file__ should be skipped: {should_skip_module(regular_module)}")
+    
+    # Verify the results
+    if should_skip_module(namespace_module) and not should_skip_module(regular_module):
+        print("✅ MigrationLoader logic works correctly!")
+        return True
+    else:
+        print("❌ MigrationLoader logic is incorrect!")
+        return False
+
+if __name__ == '__main__':
+    success = test_actual_migration_loader()
+    if success:
+        print("\n✅ Actual behavior test passed!")
+    else:
+        print("\n❌ Actual behavior test failed!")
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..ece3718f09
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the namespace package fix works correctly.
+Tests both namespace packages and non-namespace packages without __file__.
+"""
+
+import sys
+import os
+from types import ModuleType
+
+# Add current directory to Python path
+sys.path.insert(0, os.getcwd())
+
+def create_namespace_package():
+    """Create a namespace package (no __file__, non-list __path__)."""
+    module = ModuleType('namespace_migrations')
+    # Namespace packages have a special __path__ that's not a list
+    class NamespacePath:
+        def __init__(self, paths):
+            self._paths = paths
+        
+        def __iter__(self):
+            return iter(self._paths)
+        
+        def __len__(self):
+            return len(self._paths)
+    
+    module.__path__ = NamespacePath(['/fake/path1', '/fake/path2'])
+    # No __file__ for namespace packages
+    return module
+
+def create_regular_package_without_file():
+    """Create a regular package without __file__ (simulating frozen environment)."""
+    module = ModuleType('regular_migrations')
+    module.__path__ = ['/fake/path']  # Regular list __path__
+    # No __file__ to simulate frozen environment
+    return module
+
+def test_migration_loader_checks():
+    """Test the migration loader's package detection logic."""
+    from django.db.migrations.loader import MigrationLoader
+    
+    print("=== Testing Migration Loader Package Detection ===")
+    
+    # Test 1: Namespace package (should be skipped)
+    namespace_module = create_namespace_package()
+    has_file = getattr(namespace_module, '__file__', None) is not None
+    has_path = hasattr(namespace_module, '__path__')
+    is_list_path = has_path and isinstance(namespace_module.__path__, list)
+    
+    print(f"Namespace package:")
+    print(f"  - Has __file__: {has_file}")
+    print(f"  - Has __path__: {has_path}")
+    print(f"  - __path__ is list: {is_list_path}")
+    
+    # New check: skip if no __file__ AND not a list __path__
+    should_skip = not has_file and not is_list_path
+    print(f"  - Should be skipped: {should_skip}")
+    
+    # Test 2: Regular package without __file__ (should NOT be skipped)
+    regular_module = create_regular_package_without_file()
+    has_file = getattr(regular_module, '__file__', None) is not None
+    has_path = hasattr(regular_module, '__path__')
+    is_list_path = has_path and isinstance(regular_module.__path__, list)
+    
+    print(f"\nRegular package without __file__:")
+    print(f"  - Has __file__: {has_file}")
+    print(f"  - Has __path__: {has_path}")
+    print(f"  - __path__ is list: {is_list_path}")
+    
+    # New check: skip if no __file__ AND not a list __path__
+    should_skip = not has_file and not is_list_path
+    print(f"  - Should be skipped: {should_skip}")
+    
+    # Verify the fix logic
+    print(f"\n=== Verification ===")
+    print(f"Namespace packages correctly skipped: {not has_file and not is_list_path}")
+    print(f"Regular packages without __file__ correctly accepted: {has_file or (not has_file and is_list_path)}")
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_migration_loader_checks()
+    if success:
+        print("\n✅ All tests passed! The fix correctly handles both cases.")
+    else:
+        print("\n❌ Tests failed!")
\ No newline at end of file
diff --git a/test_fix_logic.py b/test_fix_logic.py
new file mode 100644
index 0000000000..132f4c829d
--- /dev/null
+++ b/test_fix_logic.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python3
+"""
+Test the fix logic directly without Django framework.
+"""
+
+import sys
+import os
+from types import ModuleType
+
+# Add current directory and tests directory to Python path
+sys.path.insert(0, os.getcwd())
+sys.path.insert(0, os.path.join(os.getcwd(), 'tests'))
+
+def test_fix_logic():
+    """Test the logic of our fix directly."""
+    
+    # Test 1: Namespace package (should be skipped)
+    class NamespacePath:
+        def __init__(self, paths):
+            self._paths = paths
+        
+        def __iter__(self):
+            return iter(self._paths)
+        
+        def __len__(self):
+            return len(self._paths)
+    
+    namespace_module = ModuleType('namespace_migrations')
+    namespace_module.__path__ = NamespacePath(['/fake/path1', '/fake/path2'])
+    # No __file__ for namespace packages
+    
+    # Test our check logic
+    has_file = getattr(namespace_module, '__file__', None) is not None
+    has_path = hasattr(namespace_module, '__path__')
+    is_list_path = has_path and isinstance(namespace_module.__path__, list)
+    should_skip = not has_file and not is_list_path
+    
+    print("Test 1 - Namespace package:")
+    print(f"  Has __file__: {has_file}")
+    print(f"  Has __path__: {has_path}")
+    print(f"  __path__ is list: {is_list_path}")
+    print(f"  Should skip: {should_skip}")
+    
+    if should_skip:
+        print("  ✅ Correctly identified as namespace package to skip")
+    else:
+        print("  ❌ Incorrectly identified as regular package")
+        return False
+    
+    # Test 2: Regular package without __file__ (should NOT be skipped)
+    regular_module = ModuleType('regular_migrations')
+    regular_module.__path__ = ['/fake/path']  # Regular list __path__
+    # No __file__ to simulate frozen environment
+    
+    # Test our check logic
+    has_file = getattr(regular_module, '__file__', None) is not None
+    has_path = hasattr(regular_module, '__path__')
+    is_list_path = has_path and isinstance(regular_module.__path__, list)
+    should_skip = not has_file and not is_list_path
+    
+    print("\nTest 2 - Regular package without __file__:")
+    print(f"  Has __file__: {has_file}")
+    print(f"  Has __path__: {has_path}")
+    print(f"  __path__ is list: {is_list_path}")
+    print(f"  Should skip: {should_skip}")
+    
+    if not should_skip:
+        print("  ✅ Correctly identified as regular package to keep")
+    else:
+        print("  ❌ Incorrectly identified as namespace package")
+        return False
+    
+    # Test 3: Regular package with __file__ (should NOT be skipped)
+    regular_module_with_file = ModuleType('regular_migrations_with_file')
+    regular_module_with_file.__path__ = ['/fake/path']  # Regular list __path__
+    regular_module_with_file.__file__ = '/fake/path/__init__.py'  # Has __file__
+    
+    # Test our check logic
+    has_file = getattr(regular_module_with_file, '__file__', None) is not None
+    has_path = hasattr(regular_module_with_file, '__path__')
+    is_list_path = has_path and isinstance(regular_module_with_file.__path__, list)
+    should_skip = not has_file and not is_list_path
+    
+    print("\nTest 3 - Regular package with __file__:")
+    print(f"  Has __file__: {has_file}")
+    print(f"  Has __path__: {has_path}")
+    print(f"  __path__ is list: {is_list_path}")
+    print(f"  Should skip: {should_skip}")
+    
+    if not should_skip:
+        print("  ✅ Correctly identified as regular package to keep")
+    else:
+        print("  ❌ Incorrectly identified as namespace package")
+        return False
+    
+    return True
+
+if __name__ == '__main__':
+    success = test_fix_logic()
+    if success:
+        print("\n✅ All logic tests passed! The fix correctly handles all cases.")
+    else:
+        print("\n❌ Logic tests failed!")
\ No newline at end of file
diff --git a/test_namespace_package.py b/test_namespace_package.py
new file mode 100644
index 0000000000..c553c2ce79
--- /dev/null
+++ b/test_namespace_package.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+"""
+Test to verify namespace packages are still correctly skipped after our fix.
+"""
+
+import sys
+import os
+
+# Add current directory to Python path
+sys.path.insert(0, os.getcwd())
+
+# Configure Django settings
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+def test_namespace_package_skipped():
+    """Test that namespace packages are still skipped correctly."""
+    from django.db.migrations.loader import MigrationLoader
+    from django.test.utils import override_settings
+    
+    # Use the test namespace package
+    with override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_namespace_package"}):
+        from django.db import connections
+        loader = MigrationLoader(connections['default'])
+        loader.load_disk()
+        
+        # Check that the namespace package was skipped (no migrations loaded)
+        migrations = [name for app, name in loader.disk_migrations if app == 'migrations']
+        print(f"Migrations loaded from namespace package: {migrations}")
+        
+        # The namespace package should be in unmigrated_apps
+        print(f"Unmigrated apps: {loader.unmigrated_apps}")
+        
+        if 'migrations' in loader.unmigrated_apps and len(migrations) == 0:
+            print("✅ Namespace package correctly skipped")
+            return True
+        else:
+            print("❌ Namespace package was not skipped correctly")
+            return False
+
+if __name__ == '__main__':
+    success = test_namespace_package_skipped()
+    if success:
+        print("\n✅ Namespace package test passed!")
+    else:
+        print("\n❌ Namespace package test failed!")
\ No newline at end of file