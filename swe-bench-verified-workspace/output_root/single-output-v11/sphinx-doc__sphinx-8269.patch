diff --git a/demonstrate_fix.py b/demonstrate_fix.py
new file mode 100644
index 000000000..5c36f9a6f
--- /dev/null
+++ b/demonstrate_fix.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+"""
+Demonstrate that the fix resolves the GitHub issue.
+"""
+
+def demonstrate_fix():
+    """Demonstrate that the fix resolves the issue described in the GitHub issue"""
+    
+    print("Demonstrating the fix for GitHub issue...")
+    print("\nIssue: Linkcheck should report HTTP errors instead of 'Anchor not found'")
+    print("when linkcheck_anchors=True and server returns error status (e.g. 404, 500)")
+    
+    print("\nBefore the fix:")
+    print("1. GET request to URL with anchor (e.g. https://example.com/test.txt#test)")
+    print("2. Server returns 404 status code")
+    print("3. Code proceeds to check anchor without checking HTTP status")
+    print("4. Reports 'Anchor not found' instead of '404 Client Error'")
+    
+    print("\nAfter the fix:")
+    print("1. GET request to URL with anchor (e.g. https://example.com/test.txt#test)")
+    print("2. Server returns 404 status code")
+    print("3. response.raise_for_status() is called before anchor checking")
+    print("4. HTTPError is raised with '404 Client Error' message")
+    print("5. Exception is caught and properly reported as HTTP error")
+    
+    print("\nThe fix adds 'response.raise_for_status()' before 'check_anchor()'")
+    print("This ensures HTTP errors are caught and reported before anchor checking proceeds")
+    
+    # Show the actual code change
+    print("\nCode change in sphinx/builders/linkcheck.py:")
+    print("Before:")
+    print("  response = requests.get(req_url, stream=True, config=self.app.config,")
+    print("                          auth=auth_info, **kwargs)")
+    print("  found = check_anchor(response, unquote(anchor))")
+    
+    print("\nAfter:")
+    print("  response = requests.get(req_url, stream=True, config=self.app.config,")
+    print("                          auth=auth_info, **kwargs)")
+    print("  response.raise_for_status()  # Check HTTP status before checking anchor")
+    print("  found = check_anchor(response, unquote(anchor))")
+    
+    print("\nThis ensures that if the server returns an HTTP error status,")
+    print("it will be properly reported instead of being masked by 'Anchor not found'")
+    
+    return True
+
+if __name__ == '__main__':
+    success = demonstrate_fix()
+    print(f"\nDemonstration: {'COMPLETE' if success else 'FAILED'}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..0372b731e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the linkcheck anchor issue.
+This script simulates the issue described in the GitHub issue.
+"""
+
+import os
+import tempfile
+import shutil
+from sphinx.application import Sphinx
+from sphinx.builders.linkcheck import CheckExternalLinksBuilder
+
+def test_linkcheck_anchor_issue():
+    # Create a temporary directory for our test
+    with tempfile.TemporaryDirectory() as tmpdir:
+        srcdir = os.path.join(tmpdir, 'source')
+        outdir = os.path.join(tmpdir, 'build')
+        doctreedir = os.path.join(tmpdir, 'doctrees')
+        confdir = srcdir
+        
+        # Create source directory
+        os.makedirs(srcdir)
+        
+        # Create conf.py
+        with open(os.path.join(srcdir, 'conf.py'), 'w') as f:
+            f.write("""
+extensions = []
+linkcheck_anchors = True
+linkcheck_workers = 1
+""")
+        
+        # Create index.rst with a broken link that has an anchor
+        with open(os.path.join(srcdir, 'index.rst'), 'w') as f:
+            f.write("""
+Test Document
+=============
+
+This is a test document with a broken link that has an anchor.
+
+`broken link <https://httpbin.org/status/404#test>`_
+""")
+        
+        # Create Sphinx app
+        app = Sphinx(srcdir, confdir, outdir, doctreedir, 'linkcheck')
+        
+        # Build with linkcheck
+        app.build()
+        
+        # Check the output - this should show the HTTP error, not "Anchor not found"
+        output_file = os.path.join(outdir, 'output.txt')
+        if os.path.exists(output_file):
+            with open(output_file, 'r') as f:
+                content = f.read()
+                print("Linkcheck output:")
+                print(content)
+                
+                # Check if it contains the wrong message
+                if "Anchor 'test' not found" in content:
+                    print("\n❌ BUG REPRODUCED: Shows 'Anchor not found' instead of HTTP error")
+                    return False
+                elif "404" in content or "Client Error" in content:
+                    print("\n✅ FIXED: Shows HTTP error correctly")
+                    return True
+                else:
+                    print("\n⚠️  UNEXPECTED: Output doesn't match expected patterns")
+                    return False
+        else:
+            print("No output file found")
+            return False
+
+if __name__ == '__main__':
+    test_linkcheck_anchor_issue()
\ No newline at end of file
diff --git a/setup.py b/setup.py
index a404f1fa5..2c6848797 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..e051242ac
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify the HTTP error handling logic.
+"""
+
+import requests
+from requests.models import Response
+from unittest.mock import Mock, patch
+
+def test_http_error_handling():
+    """Test the core HTTP error handling logic"""
+    
+    print("Testing HTTP error handling logic...")
+    
+    # Create a mock 404 response
+    response_404 = Response()
+    response_404.status_code = 404
+    response_404._content = b"Not Found"
+    response_404.url = "https://example.com/test.txt"
+    
+    # Test that raise_for_status() raises HTTPError for 404
+    try:
+        response_404.raise_for_status()
+        print("❌ FAIL: raise_for_status() should have raised HTTPError for 404")
+        return False
+    except requests.exceptions.HTTPError as err:
+        print(f"✅ SUCCESS: raise_for_status() correctly raised HTTPError: {err}")
+        # Check that the error message contains the status code
+        if '404' in str(err):
+            print("✅ SUCCESS: Error message contains status code 404")
+            return True
+        else:
+            print(f"❌ FAIL: Error message doesn't contain 404: {err}")
+            return False
+
+if __name__ == '__main__':
+    test_http_error_handling()
\ No newline at end of file
diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py
index 9b54afc7c..bdd689c8c 100644
--- a/sphinx/builders/linkcheck.py
+++ b/sphinx/builders/linkcheck.py
@@ -166,6 +166,7 @@ class CheckExternalLinksBuilder(Builder):
                     # Read the whole document and see if #anchor exists
                     response = requests.get(req_url, stream=True, config=self.app.config,
                                             auth=auth_info, **kwargs)
+                    response.raise_for_status()  # Check HTTP status before checking anchor
                     found = check_anchor(response, unquote(anchor))
 
                     if not found:
diff --git a/test_anchor_bug.py b/test_anchor_bug.py
new file mode 100644
index 000000000..9cfc8b988
--- /dev/null
+++ b/test_anchor_bug.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+"""
+Test to demonstrate the anchor bug directly by testing the check_uri function.
+"""
+
+import tempfile
+import os
+from sphinx.builders.linkcheck import check_anchor
+from unittest.mock import Mock, patch
+import requests
+
+def test_anchor_check_with_http_error():
+    """Test that shows the bug: HTTP errors are masked by anchor not found errors"""
+    
+    # Create a mock response that simulates a 404 error
+    mock_response = Mock()
+    mock_response.status_code = 404
+    mock_response.raise_for_status = Mock(side_effect=requests.exceptions.HTTPError("404 Client Error: Not Found"))
+    mock_response.iter_content = Mock(return_value=iter([b"<html><body>Some content</body></html>"]))
+    
+    # Test the check_anchor function directly
+    # This should work fine when the response is valid
+    found = check_anchor(mock_response, "test")
+    print(f"Anchor found: {found}")
+    
+    # Now let's test what happens in the actual flow
+    # The bug is in the check_uri function where HTTP status is not checked before anchor checking
+    
+    print("\nTesting the actual bug scenario:")
+    print("When linkcheck_anchors=True and server returns 404:")
+    print("Current behavior: 'Anchor not found'")
+    print("Expected behavior: '404 Client Error: Not Found'")
+
+if __name__ == '__main__':
+    test_anchor_check_with_http_error()
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..707ee59cd
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+"""
+Test to verify the fix for the anchor bug.
+"""
+
+import tempfile
+import os
+from sphinx.application import Sphinx
+from unittest.mock import Mock, patch
+import requests
+from requests.models import Response
+
+def test_fix():
+    """Test that HTTP errors are properly reported instead of anchor not found errors"""
+    
+    print("Testing the fix...")
+    
+    # Create a mock response that simulates a 404 error
+    def mock_get(*args, **kwargs):
+        mock_response = Response()
+        mock_response.status_code = 404
+        mock_response._content = b"<html><body>Not Found</body></html>"
+        mock_response.url = "https://example.com/test.txt"
+        return mock_response
+    
+    # Patch the requests.get to return our mock response
+    with patch('sphinx.builders.linkcheck.requests.get', side_effect=mock_get):
+        with patch('sphinx.builders.linkcheck.requests.head', side_effect=mock_get):
+            
+            # Create a minimal test
+            with tempfile.TemporaryDirectory() as tmpdir:
+                srcdir = os.path.join(tmpdir, 'source')
+                outdir = os.path.join(tmpdir, 'build')
+                doctreedir = os.path.join(tmpdir, 'doctrees')
+                confdir = srcdir
+                
+                os.makedirs(srcdir)
+                
+                # Create conf.py
+                with open(os.path.join(srcdir, 'conf.py'), 'w') as f:
+                    f.write("""
+extensions = []
+linkcheck_anchors = True
+linkcheck_workers = 1
+linkcheck_timeout = 5
+""")
+                
+                # Create index.rst with a broken link that has an anchor
+                with open(os.path.join(srcdir, 'index.rst'), 'w') as f:
+                    f.write("""
+Test Document
+=============
+
+`broken link <https://example.com/test.txt#test>`_
+""")
+                
+                try:
+                    # Create Sphinx app
+                    app = Sphinx(srcdir, confdir, outdir, doctreedir, 'linkcheck')
+                    
+                    # Build with linkcheck
+                    app.build()
+                    
+                    # Check the output
+                    output_file = os.path.join(outdir, 'output.txt')
+                    if os.path.exists(output_file):
+                        with open(output_file, 'r') as f:
+                            content = f.read()
+                            print("Linkcheck output:")
+                            print(content)
+                            
+                            # The fix should make it report HTTP error instead of anchor error
+                            if "Anchor 'test' not found" in content:
+                                print("\n❌ BUG STILL EXISTS: Shows 'Anchor not found'")
+                                return False
+                            elif "404" in content or "Client Error" in content:
+                                print("\n✅ FIXED: Shows HTTP error correctly")
+                                return True
+                            else:
+                                print("\n⚠️  UNEXPECTED: Output doesn't match expected patterns")
+                                print("Content:", repr(content))
+                                return False
+                    else:
+                        print("No output file found")
+                        return False
+                        
+                except Exception as e:
+                    print(f"Exception during test: {e}")
+                    return False
+
+if __name__ == '__main__':
+    success = test_fix()
+    print(f"\nTest result: {'PASS' if success else 'FAIL'}")
\ No newline at end of file
diff --git a/test_http_status.py b/test_http_status.py
new file mode 100644
index 000000000..0f2dedf7e
--- /dev/null
+++ b/test_http_status.py
@@ -0,0 +1,62 @@
+#!/usr/bin/env python3
+"""
+Test to verify our fix handles HTTP status codes correctly.
+"""
+
+from unittest.mock import Mock, patch
+from sphinx.builders.linkcheck import CheckExternalLinksBuilder
+import requests
+from requests.models import Response
+
+def test_http_status_handling():
+    """Test that HTTP status codes are handled correctly"""
+    
+    print("Testing HTTP status code handling...")
+    
+    # Create a mock response that simulates a 404 error
+    def create_404_response():
+        response = Response()
+        response.status_code = 404
+        response._content = b"<html><body>Not Found</body></html>"
+        response.url = "https://example.com/test.txt"
+        return response
+    
+    # Test that our fix correctly handles HTTP errors
+    with patch('sphinx.builders.linkcheck.requests.get', side_effect=create_404_response):
+        # Create a minimal builder instance to test the check_uri function
+        builder = Mock()
+        builder.app = Mock()
+        builder.app.config = Mock()
+        builder.app.config.linkcheck_anchors = True
+        builder.app.config.linkcheck_timeout = None
+        builder.auth = []
+        builder.anchors_ignore = []
+        
+        # Import and test the check_uri function
+        from sphinx.builders.linkcheck import check_uri
+        
+        # Test with anchor checking enabled and a 404 response
+        status, info, code = check_uri(
+            "https://example.com/test.txt#anchor", 
+            builder.app.config, 
+            builder.auth, 
+            builder.anchors_ignore
+        )
+        
+        print(f"Status: {status}")
+        print(f"Info: {info}")
+        print(f"Code: {code}")
+        
+        # Should report broken with HTTP error, not anchor error
+        if status == 'broken' and '404' in info:
+            print("✅ SUCCESS: HTTP 404 error correctly reported")
+            return True
+        elif 'Anchor' in info:
+            print("❌ FAIL: Anchor error reported instead of HTTP error")
+            return False
+        else:
+            print(f"⚠️  UNEXPECTED: {status} - {info}")
+            return False
+
+if __name__ == '__main__':
+    test_http_status_handling()
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index a61299979..e2baccc07 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
     PYTEST_ADDOPTS = --color yes
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 000000000..49a3ef2f5
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+"""
+Verify that our fix is correctly implemented by examining the code.
+"""
+
+def verify_fix():
+    """Verify that the fix is correctly implemented in the code"""
+    
+    print("Verifying the fix implementation...")
+    
+    # Read the relevant part of the linkcheck.py file
+    with open('sphinx/builders/linkcheck.py', 'r') as f:
+        content = f.read()
+    
+    # Look for the specific section where our fix should be
+    lines = content.split('\n')
+    
+    # Find the anchor checking section
+    anchor_check_section = None
+    for i, line in enumerate(lines):
+        if 'if anchor and self.app.config.linkcheck_anchors:' in line:
+            anchor_check_section = i
+            break
+    
+    if anchor_check_section is None:
+        print("❌ FAIL: Could not find anchor checking section")
+        return False
+    
+    print(f"Found anchor checking section at line {anchor_check_section + 1}")
+    
+    # Check the next few lines to see if our fix is there
+    fix_found = False
+    for i in range(anchor_check_section, anchor_check_section + 10):
+        if i < len(lines) and 'response.raise_for_status()' in lines[i]:
+            print(f"✅ SUCCESS: Found raise_for_status() call at line {i + 1}")
+            fix_found = True
+            break
+    
+    if not fix_found:
+        print("❌ FAIL: raise_for_status() call not found in anchor checking section")
+        # Print the relevant lines for debugging
+        print("Relevant lines:")
+        for i in range(anchor_check_section, min(anchor_check_section + 10, len(lines))):
+            print(f"{i + 1}: {lines[i]}")
+        return False
+    
+    # Verify that the raise_for_status() call is before check_anchor()
+    check_anchor_found = False
+    for i in range(anchor_check_section, anchor_check_section + 10):
+        if i < len(lines) and 'check_anchor(' in lines[i]:
+            check_anchor_found = True
+            check_anchor_line = i
+            break
+    
+    if not check_anchor_found:
+        print("❌ FAIL: Could not find check_anchor() call")
+        return False
+    
+    # The raise_for_status() should be before check_anchor()
+    raise_status_line = None
+    for i in range(anchor_check_section, check_anchor_line):
+        if 'response.raise_for_status()' in lines[i]:
+            raise_status_line = i
+            break
+    
+    if raise_status_line is None:
+        print("❌ FAIL: raise_for_status() should be before check_anchor()")
+        return False
+    
+    print(f"✅ SUCCESS: raise_for_status() at line {raise_status_line + 1} is before check_anchor() at line {check_anchor_line + 1}")
+    
+    # Verify the fix is in the right try-except block
+    try_block_found = False
+    for i in range(anchor_check_section - 5, anchor_check_section):
+        if i >= 0 and 'try:' in lines[i]:
+            try_block_found = True
+            break
+    
+    if not try_block_found:
+        print("❌ FAIL: Could not find try block for error handling")
+        return False
+    
+    print("✅ SUCCESS: Fix is properly placed within error handling try block")
+    return True
+
+if __name__ == '__main__':
+    success = verify_fix()
+    print(f"\nFix verification: {'PASS' if success else 'FAIL'}")
\ No newline at end of file