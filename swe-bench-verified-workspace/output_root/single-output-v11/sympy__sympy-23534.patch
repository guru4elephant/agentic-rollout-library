diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..1bc46fbe65
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,27 @@
+import sympy as smp
+
+# Let's trace what happens in the recursive call
+def debug_symbols_call():
+    print("=== Direct call with string ===")
+    result = smp.symbols('q:2', cls=smp.Function)
+    print("Result type:", type(result[0]))
+    print("Result:", result)
+    
+    print("\n=== Direct call with tuple ===")
+    result = smp.symbols(('q:2',), cls=smp.Function)
+    print("Result type:", type(result[0][0]))
+    print("Result:", result)
+    
+    print("\n=== Manual recursive call simulation ===")
+    # Simulate what happens in the recursive call
+    names = ('q:2', 'u:2')
+    result = []
+    for name in names:
+        print(f"Calling symbols('{name}', cls=smp.Function)")
+        res = smp.symbols(name, cls=smp.Function)
+        print(f"  Result type: {type(res[0])}")
+        print(f"  Result: {res}")
+        result.append(res)
+    print("Final result:", tuple(result))
+
+debug_symbols_call()
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..5772c80bed
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,18 @@
+import sympy as smp
+
+# Test individual calls to see what happens
+print("Testing symbols('q:2', cls=smp.Function):")
+result1 = smp.symbols('q:2', cls=smp.Function)
+print("Type of result1[0]:", type(result1[0]))
+print("Result1:", result1)
+
+print("\nTesting symbols('u:2', cls=smp.Function):")
+result2 = smp.symbols('u:2', cls=smp.Function)
+print("Type of result2[0]:", type(result2[0]))
+print("Result2:", result2)
+
+print("\nTesting symbols(('q:2', 'u:2'), cls=smp.Function):")
+result3 = smp.symbols(('q:2', 'u:2'), cls=smp.Function)
+print("Type of result3[0][0]:", type(result3[0][0]))
+print("Type of result3[1][0]:", type(result3[1][0]))
+print("Result3:", result3)
\ No newline at end of file
diff --git a/debug_recursive.py b/debug_recursive.py
new file mode 100644
index 0000000000..0cd78197ea
--- /dev/null
+++ b/debug_recursive.py
@@ -0,0 +1,29 @@
+import sympy as smp
+
+# Let's monkey patch the symbols function to see what's happening
+original_symbols = smp.symbols
+
+def debug_symbols(names, *, cls=smp.Symbol, **args):
+    print(f"DEBUG: names={names}, cls={cls}, args={args}")
+    if not isinstance(names, str):
+        print(f"DEBUG: Non-string names, making recursive calls")
+        result = []
+        for name in names:
+            print(f"DEBUG: Recursive call with name={name}, args={args}")
+            res = original_symbols(name, **args)
+            print(f"DEBUG: Recursive result type={type(res[0]) if hasattr(res, '__getitem__') and len(res) > 0 else 'N/A'}")
+            result.append(res)
+        return type(names)(result)
+    else:
+        return original_symbols(names, cls=cls, **args)
+
+# Monkey patch
+smp.symbols = debug_symbols
+
+# Test the problematic case
+print("=== Testing with tuple ===")
+result = smp.symbols(('q:2', 'u:2'), cls=smp.Function)
+print("Final result type:", type(result[0][0]))
+
+# Restore original
+smp.symbols = original_symbols
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0c0beb4c51
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,12 @@
+import sympy as smp
+
+# Test case from the issue
+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)
+print("With extra parentheses - Type of q[0]:", type(q[0]))
+print("Expected: <class 'sympy.core.function.UndefinedFunction'>")
+print("Actual:   <class 'sympy.core.symbol.Symbol'>")
+print()
+
+# Let's also test the working case without extra parentheses
+result = smp.symbols('q:2 u:2', cls=smp.Function)
+print("Without extra parentheses - Type of result[0]:", type(result[0]))
\ No newline at end of file
diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py
index f4a555c13f..2aca8bab27 100644
--- a/sympy/core/symbol.py
+++ b/sympy/core/symbol.py
@@ -791,7 +791,7 @@ def literal(s):
         return tuple(result)
     else:
         for name in names:
-            result.append(symbols(name, **args))
+            result.append(symbols(name, cls=cls, **args))
 
         return type(names)(result)
 
diff --git a/test_cls_handling.py b/test_cls_handling.py
new file mode 100644
index 0000000000..bf952c5ab4
--- /dev/null
+++ b/test_cls_handling.py
@@ -0,0 +1,21 @@
+import sympy as smp
+
+# Test what happens when we pass cls as part of **kwargs
+def test_kwargs_handling():
+    kwargs = {'cls': smp.Function}
+    
+    print("=== Testing direct call with kwargs ===")
+    result = smp.symbols('q:2', **kwargs)
+    print("Result type:", type(result[0]))
+    print("Result:", result)
+    
+    print("\n=== Testing recursive call simulation ===")
+    names = ('q:2', 'u:2')
+    result = []
+    for name in names:
+        res = smp.symbols(name, **kwargs)
+        result.append(res)
+    print("Final result:", tuple(result))
+    print("Type of result[0][0]:", type(result[0][0]))
+
+test_kwargs_handling()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..466d047489
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,42 @@
+import sympy as smp
+
+print("=== Testing edge cases ===")
+
+# Test 1: Normal symbols without cls parameter
+print("1. Normal symbols without cls:")
+x, y = smp.symbols(('x', 'y'))
+print(f"  Type of x: {type(x)}")
+print(f"  Type of y: {type(y)}")
+
+# Test 2: Normal symbols with cls=Symbol (explicit)
+print("\n2. Normal symbols with cls=Symbol:")
+a, b = smp.symbols(('a', 'b'), cls=smp.Symbol)
+print(f"  Type of a: {type(a)}")
+print(f"  Type of b: {type(b)}")
+
+# Test 3: Function symbols with tuple
+print("\n3. Function symbols with tuple:")
+f, g = smp.symbols(('f', 'g'), cls=smp.Function)
+print(f"  Type of f: {type(f)}")
+print(f"  Type of g: {type(g)}")
+
+# Test 4: Mixed range and non-range in tuple
+print("\n4. Mixed range and non-range in tuple:")
+result = smp.symbols(('x:2', 'y'), cls=smp.Function)
+print(f"  Type of result[0][0]: {type(result[0][0])}")
+print(f"  Type of result[1]: {type(result[1])}")
+
+# Test 5: List instead of tuple
+print("\n5. List instead of tuple:")
+result = smp.symbols(['p:2', 'q'], cls=smp.Function)
+print(f"  Type of result[0][0]: {type(result[0][0])}")
+print(f"  Type of result[1]: {type(result[1])}")
+
+# Test 6: Nested tuples
+print("\n6. Nested tuples:")
+result = smp.symbols((('a:2',), ('b', 'c')), cls=smp.Function)
+print(f"  Type of result[0][0][0]: {type(result[0][0][0])}")
+print(f"  Type of result[1][0]: {type(result[1][0])}")
+print(f"  Type of result[1][1]: {type(result[1][1])}")
+
+print("\n=== All tests completed ===")
\ No newline at end of file