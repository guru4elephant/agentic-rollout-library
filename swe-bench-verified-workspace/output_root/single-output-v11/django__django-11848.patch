diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..38cf665083
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+"""Comprehensive test to understand the expected behavior"""
+
+import datetime
+from django.utils.http import parse_http_date
+
+def test_comprehensive():
+    """Test various two-digit year scenarios"""
+    current_year = datetime.datetime.now().year
+    print(f"Current year: {current_year}")
+    print(f"Current century: {current_year // 100 * 100}")
+    print(f"Current two-digit: {current_year % 100}")
+    print()
+    
+    # Test all two-digit years
+    test_cases = []
+    for two_digit in range(0, 100):
+        rfc850_date = f"Monday, 01-Jan-{two_digit:02d} 12:00:00 GMT"
+        
+        try:
+            parsed_timestamp = parse_http_date(rfc850_date)
+            parsed_datetime = datetime.datetime.utcfromtimestamp(parsed_timestamp)
+            parsed_year = parsed_datetime.year
+            
+            # Calculate what it would be with current century
+            current_century = current_year // 100 * 100
+            candidate_year = two_digit + current_century
+            
+            # Calculate what it would be with previous century  
+            previous_century = current_century - 100
+            previous_candidate = two_digit + previous_century
+            
+            test_cases.append({
+                'two_digit': two_digit,
+                'parsed_year': parsed_year,
+                'current_century_candidate': candidate_year,
+                'previous_century_candidate': previous_candidate,
+                'years_in_future': candidate_year - current_year if candidate_year > current_year else 0,
+                'rfc850_date': rfc850_date
+            })
+        except Exception as e:
+            print(f"Error parsing {rfc850_date}: {e}")
+    
+    # Print results
+    print("2-digit | Parsed | Current Century | Prev Century | Years Future | RFC850 Date")
+    print("-" * 90)
+    
+    for case in test_cases:
+        future_str = f"{case['years_in_future']:>11}" if case['years_in_future'] > 0 else "          0"
+        print(f"{case['two_digit']:>6} | {case['parsed_year']:>6} | {case['current_century_candidate']:>14} | {case['previous_century_candidate']:>11} | {future_str} | {case['rfc850_date']}")
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/debug_fix.py b/debug_fix.py
new file mode 100644
index 0000000000..55b3fee3ed
--- /dev/null
+++ b/debug_fix.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""Debug the fix implementation"""
+
+import datetime
+from django.utils.http import parse_http_date
+
+def debug_year_logic():
+    """Debug the year calculation logic"""
+    current_year = datetime.datetime.now().year
+    current_century = current_year // 100 * 100
+    
+    print(f"Current year: {current_year}")
+    print(f"Current century: {current_century}")
+    
+    # Test specific cases
+    test_years = [65, 75, 85, 95, 5, 15, 25, 35, 45, 55]
+    
+    for two_digit_year in test_years:
+        # Calculate what year this two-digit value would represent in current century
+        candidate_year = two_digit_year + current_century
+        
+        # If the candidate year is more than 50 years in the future,
+        # use the same two digits from the previous century
+        if candidate_year > current_year + 50:
+            calculated_year = two_digit_year + current_century - 100
+            print(f"{two_digit_year:02d}: {candidate_year} > {current_year + 50} -> {calculated_year}")
+        else:
+            calculated_year = candidate_year
+            print(f"{two_digit_year:02d}: {candidate_year} <= {current_year + 50} -> {calculated_year}")
+
+def test_specific_cases():
+    """Test specific RFC850 date cases"""
+    test_cases = [
+        ("Monday, 01-Jan-65 12:00:00 GMT", 1965),  # Should be 1965, not 2065
+        ("Monday, 01-Jan-75 12:00:00 GMT", 1975),  # Should be 1975, not 2075
+        ("Monday, 01-Jan-85 12:00:00 GMT", 1985),  # Should be 1985
+    ]
+    
+    for rfc850_date, expected_year in test_cases:
+        try:
+            parsed_timestamp = parse_http_date(rfc850_date)
+            parsed_datetime = datetime.datetime.utcfromtimestamp(parsed_timestamp)
+            parsed_year = parsed_datetime.year
+            status = "✓" if parsed_year == expected_year else "✗"
+            print(f"{status} {rfc850_date} -> {parsed_year} (expected {expected_year})")
+        except Exception as e:
+            print(f"Error parsing {rfc850_date}: {e}")
+
+if __name__ == "__main__":
+    debug_year_logic()
+    print("\nTesting specific cases:")
+    test_specific_cases()
\ No newline at end of file
diff --git a/django/utils/http.py b/django/utils/http.py
index 572cfb4347..398f04dd08 100644
--- a/django/utils/http.py
+++ b/django/utils/http.py
@@ -176,10 +176,20 @@ def parse_http_date(date):
     try:
         year = int(m.group('year'))
         if year < 100:
-            if year < 70:
-                year += 2000
+            # RFC 7231: For two-digit years, interpret dates more than 50 years 
+            # in the future as representing the most recent year in the past
+            current_year = datetime.datetime.now().year
+            current_century = current_year // 100 * 100
+            
+            # Calculate what year this two-digit value would represent in current century
+            candidate_year = year + current_century
+            
+            # If the candidate year is more than 50 years in the future,
+            # use the same two digits from the previous century
+            if candidate_year > current_year + 50:
+                year += current_century - 100
             else:
-                year += 1900
+                year = candidate_year
         month = MONTHS.index(m.group('mon').lower()) + 1
         day = int(m.group('day'))
         hour = int(m.group('hour'))
diff --git a/final_validation.py b/final_validation.py
new file mode 100644
index 0000000000..8b1878a2c5
--- /dev/null
+++ b/final_validation.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python3
+"""Final validation that the implementation follows RFC 7231"""
+
+import datetime
+from django.utils.http import parse_http_date
+
+def validate_rfc_compliance():
+    """Validate that the implementation follows RFC 7231"""
+    current_year = datetime.datetime.now().year
+    print(f"Current year: {current_year}")
+    print("RFC 7231 compliance test:")
+    print("=" * 50)
+    
+    # Test cases that should use current century (not more than 50 years in future)
+    current_century_tests = [
+        (current_year, "current year"),
+        (current_year + 1, "1 year in future"),
+        (current_year + 25, "25 years in future"),
+        (current_year + 49, "49 years in future"),
+        (current_year + 50, "50 years in future (exactly)"),
+    ]
+    
+    # Test cases that should use previous century (more than 50 years in future)
+    previous_century_tests = [
+        (current_year + 51, "51 years in future"),
+        (current_year + 60, "60 years in future"),
+        (current_year + 75, "75 years in future"),
+        (current_year + 100, "100 years in future"),
+    ]
+    
+    print("\nShould use CURRENT century (not more than 50 years in future):")
+    for test_year, description in current_century_tests:
+        two_digit = test_year % 100
+        rfc850_date = f"Monday, 01-Jan-{two_digit:02d} 12:00:00 GMT"
+        
+        parsed_timestamp = parse_http_date(rfc850_date)
+        parsed_datetime = datetime.datetime.utcfromtimestamp(parsed_timestamp)
+        parsed_year = parsed_datetime.year
+        
+        status = "✓" if parsed_year == test_year else "✗"
+        print(f"{status} {description}: {rfc850_date} -> {parsed_year}")
+    
+    print("\nShould use PREVIOUS century (more than 50 years in future):")
+    for test_year, description in previous_century_tests:
+        two_digit = test_year % 100
+        rfc850_date = f"Monday, 01-Jan-{two_digit:02d} 12:00:00 GMT"
+        expected_year = test_year - 100  # Use previous century
+        
+        parsed_timestamp = parse_http_date(rfc850_date)
+        parsed_datetime = datetime.datetime.utcfromtimestamp(parsed_timestamp)
+        parsed_year = parsed_datetime.year
+        
+        status = "✓" if parsed_year == expected_year else "✗"
+        print(f"{status} {description}: {rfc850_date} -> {parsed_year} (expected {expected_year})")
+
+if __name__ == "__main__":
+    validate_rfc_compliance()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..66a1bd215b
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""Script to reproduce the two-digit year issue in parse_http_date"""
+
+import datetime
+from django.utils.http import parse_http_date
+
+def test_two_digit_year_handling():
+    """Test the current two-digit year handling"""
+    current_year = datetime.datetime.now().year
+    print(f"Current year: {current_year}")
+    
+    # Test RFC850 format with two-digit years
+    # Format: Weekday, DD-Mon-YY HH:MM:SS GMT
+    test_cases = []
+    
+    # Test cases around the current year
+    for offset in range(-60, 40, 10):  # Test from 60 years ago to 40 years in the future
+        test_year = current_year + offset
+        two_digit_year = test_year % 100
+        rfc850_date = f"Monday, 01-Jan-{two_digit_year:02d} 12:00:00 GMT"
+        
+        try:
+            parsed_timestamp = parse_http_date(rfc850_date)
+            parsed_datetime = datetime.datetime.utcfromtimestamp(parsed_timestamp)
+            parsed_year = parsed_datetime.year
+            
+            test_cases.append({
+                'input_year': test_year,
+                'two_digit_input': two_digit_year,
+                'parsed_year': parsed_year,
+                'correct': parsed_year == test_year,
+                'rfc850_date': rfc850_date
+            })
+        except Exception as e:
+            print(f"Error parsing {rfc850_date}: {e}")
+    
+    # Print results
+    print("\nTwo-digit year handling test results:")
+    print("Input Year | 2-digit | Parsed Year | Correct | RFC850 Date")
+    print("-" * 80)
+    
+    for case in test_cases:
+        status = "✓" if case['correct'] else "✗"
+        print(f"{case['input_year']:>9} | {case['two_digit_input']:>6} | {case['parsed_year']:>11} | {status:>7} | {case['rfc850_date']}")
+
+if __name__ == "__main__":
+    test_two_digit_year_handling()
\ No newline at end of file