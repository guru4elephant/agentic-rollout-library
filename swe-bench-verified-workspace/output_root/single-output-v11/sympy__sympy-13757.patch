diff --git a/debug_domain.py b/debug_domain.py
new file mode 100644
index 0000000000..0b7efe85e2
--- /dev/null
+++ b/debug_domain.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+
+# Test domain conversion
+p = Poly(x)
+print("Poly(x):", p)
+print("Domain:", p.rep.dom)
+
+print("\nTrying to convert x to domain:")
+try:
+    converted = p.rep.dom.convert(x)
+    print("Success:", converted)
+except Exception as e:
+    print("Error:", e)
+
+print("\nTrying to convert S(-2) to domain:")
+try:
+    converted = p.rep.dom.convert(S(-2))
+    print("Success:", converted)
+except Exception as e:
+    print("Error:", e)
+
+print("\nTrying to convert -2 to domain:")
+try:
+    converted = p.rep.dom.convert(-2)
+    print("Success:", converted)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/debug_exceptions.py b/debug_exceptions.py
new file mode 100644
index 0000000000..b8f6ccefb7
--- /dev/null
+++ b/debug_exceptions.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+from sympy.polys.polyerrors import CoercionFailed
+
+# Test what exceptions are actually raised
+p = Poly(x)
+print("Poly(x):", p)
+print("Domain:", p.rep.dom)
+
+print("\nTrying to convert x to domain:")
+try:
+    converted = p.rep.dom.convert(x)
+    print("Success:", converted)
+except Exception as e:
+    print("Exception type:", type(e).__name__)
+    print("Exception message:", e)
+    print("Is CoercionFailed?", isinstance(e, CoercionFailed))
+
+print("\nTrying to convert S(-2) to domain:")
+try:
+    converted = p.rep.dom.convert(S(-2))
+    print("Success:", converted)
+except Exception as e:
+    print("Exception type:", type(e).__name__)
+    print("Exception message:", e)
+    print("Is CoercionFailed?", isinstance(e, CoercionFailed))
\ No newline at end of file
diff --git a/debug_mul.py b/debug_mul.py
new file mode 100644
index 0000000000..d4af195209
--- /dev/null
+++ b/debug_mul.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+
+# Test what happens when we call mul_ground directly
+p = Poly(x)
+print("Poly(x):", p)
+print("p.mul_ground(x):")
+try:
+    result = p.mul_ground(x)
+    print("Success:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\np.mul_ground(S(-2)):")
+try:
+    result = p.mul_ground(S(-2))
+    print("Success:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\np.mul_ground(-2):")
+try:
+    result = p.mul_ground(-2)
+    print("Success:", result)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5807a55425
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+
+print("Testing the multiplication issue with Poly objects:")
+
+print("\n1. Poly(x)*x (works):")
+result1 = Poly(x)*x
+print(f"Result: {result1}")
+
+print("\n2. x*Poly(x) (doesn't work):")
+result2 = x*Poly(x)
+print(f"Result: {result2}")
+
+print("\n3. -2*Poly(x) (works):")
+result3 = -2*Poly(x)
+print(f"Result: {result3}")
+
+print("\n4. S(-2)*Poly(x) (doesn't work):")
+result4 = S(-2)*Poly(x)
+print(f"Result: {result4}")
+
+print("\n5. Poly(x)*S(-2) (works):")
+result5 = Poly(x)*S(-2)
+print(f"Result: {result5}")
+
+print("\nExpected behavior: all should return Poly objects")
\ No newline at end of file
diff --git a/sympy/core/expr.py b/sympy/core/expr.py
index 72728c44ef..ee343823d6 100644
--- a/sympy/core/expr.py
+++ b/sympy/core/expr.py
@@ -137,6 +137,10 @@ def __rsub__(self, other):
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__rmul__')
     def __mul__(self, other):
+        # If the other operand is a Poly, return NotImplemented so that
+        # Python will try the Poly's __rmul__ method
+        if getattr(other, 'is_Poly', False):
+            return NotImplemented
         return Mul(self, other)
 
     @_sympifyit('other', NotImplemented)
diff --git a/test_debug.py b/test_debug.py
new file mode 100644
index 0000000000..abee3108c2
--- /dev/null
+++ b/test_debug.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+
+# Test the __rmul__ method directly
+p = Poly(x)
+print("Testing __rmul__ directly:")
+
+print("\n1. x.__rmul__(p):")
+try:
+    result = x.__rmul__(p)
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\n2. S(-2).__rmul__(p):")
+try:
+    result = S(-2).__rmul__(p)
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\n3. (-2).__rmul__(p):")
+try:
+    result = (-2).__rmul__(p)
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_debug2.py b/test_debug2.py
new file mode 100644
index 0000000000..06998823e4
--- /dev/null
+++ b/test_debug2.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+
+# Test the Poly's __rmul__ method directly
+p = Poly(x)
+print("Testing Poly.__rmul__ directly:")
+
+print("\n1. p.__rmul__(x):")
+try:
+    result = p.__rmul__(x)
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\n2. p.__rmul__(S(-2)):")
+try:
+    result = p.__rmul__(S(-2))
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
+
+print("\n3. p.__rmul__(-2):")
+try:
+    result = p.__rmul__(-2)
+    print("Result:", result)
+except Exception as e:
+    print("Error:", e)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..8d18a95b56
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x, y
+
+print("Testing edge cases for Poly multiplication:")
+
+print("\n1. Multiple variables:")
+p = Poly(x*y, x, y)
+result = x * p
+print(f"x * Poly(x*y, x, y) = {result}")
+
+print("\n2. Constants:")
+p = Poly(x**2 + 1, x)
+result = 5 * p
+print(f"5 * Poly(x**2 + 1, x) = {result}")
+
+print("\n3. Negative constants:")
+p = Poly(x**2 + 1, x)
+result = -3 * p
+print(f"-3 * Poly(x**2 + 1, x) = {result}")
+
+print("\n4. Symbolic constants:")
+p = Poly(x**2 + 1, x)
+result = S(2)/3 * p
+print(f"(2/3) * Poly(x**2 + 1, x) = {result}")
+
+print("\n5. Complex expressions:")
+p = Poly(x**2 + y, x, y)
+result = (x + y) * p
+print(f"(x + y) * Poly(x**2 + y, x, y) = {result}")
+
+print("\n6. Right multiplication still works:")
+p = Poly(x, x)
+result = p * x
+print(f"Poly(x, x) * x = {result}")
+
+print("\n7. Both sides Poly:")
+p1 = Poly(x, x)
+p2 = Poly(y, y)
+result = p1 * p2
+print(f"Poly(x, x) * Poly(y, y) = {result}")
\ No newline at end of file
diff --git a/test_override.py b/test_override.py
new file mode 100644
index 0000000000..945fc6be71
--- /dev/null
+++ b/test_override.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x
+from sympy.core.mul import Mul
+
+# Test if we can override the multiplication behavior
+p = Poly(x)
+
+print("Testing if Symbol.__mul__ returns NotImplemented for Poly:")
+print("x.is_Poly:", x.is_Poly)
+print("p.is_Poly:", p.is_Poly)
+
+# Test if we can detect Poly in Mul
+print("\nTesting Mul with Poly:")
+mul_obj = Mul(x, p)
+print("Mul(x, p):", mul_obj)
+print("Type:", type(mul_obj))
+
+# Check if any args are Poly
+print("\nChecking if any args are Poly:")
+for i, arg in enumerate(mul_obj.args):
+    print(f"arg[{i}]: {arg}, is_Poly: {getattr(arg, 'is_Poly', False)}")
\ No newline at end of file
diff --git a/test_regular_multiplication.py b/test_regular_multiplication.py
new file mode 100644
index 0000000000..a785b838d7
--- /dev/null
+++ b/test_regular_multiplication.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+from sympy import Poly, S
+from sympy.abc import x, y
+
+print("Testing that regular multiplication still works:")
+
+print("\n1. Symbol * Symbol:")
+result = x * y
+print(f"x * y = {result}")
+
+print("\n2. Number * Symbol:")
+result = 2 * x
+print(f"2 * x = {result}")
+
+print("\n3. Symbol * Number:")
+result = x * 3
+print(f"x * 3 = {result}")
+
+print("\n4. Expression * Expression:")
+result = (x + 1) * (y - 1)
+print(f"(x + 1) * (y - 1) = {result}")
+
+print("\n5. Number * Expression:")
+result = 5 * (x + y)
+print(f"5 * (x + y) = {result}")
+
+print("\n6. Expression * Number:")
+result = (x + y) * 5
+print(f"(x + y) * 5 = {result}")
+
+print("\n7. Mixed operations:")
+result = 2 * x * y + 3 * (x + 1)
+print(f"2*x*y + 3*(x+1) = {result}")
\ No newline at end of file