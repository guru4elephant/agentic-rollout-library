diff --git a/debug_joins.py b/debug_joins.py
new file mode 100644
index 0000000000..a3becfbbaf
--- /dev/null
+++ b/debug_joins.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand JOIN behavior with multiple filter calls.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create models similar to the GitHub issue
+class Client(models.Model):
+    name = models.CharField(max_length=256)
+    name2 = models.CharField(max_length=256, blank=True, null=True)
+    contact_person = models.CharField(max_length=256, blank=True, null=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class ClientOffice(models.Model):
+    name = models.CharField(max_length=256)
+    name2 = models.CharField(max_length=256, blank=True, null=True)
+    client = models.ForeignKey(Client, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_join_behavior():
+    """Test how JOINs behave with multiple filter calls"""
+    from django.db.models import Q
+    
+    print("=== TESTING JOIN BEHAVIOR ===")
+    
+    # Create base queryset
+    queryset = Client.objects.all()
+    
+    # Simulate search with related fields
+    search_terms = ["test", "search", "query"]
+    search_fields = ['name', 'name2', 'contact_person', 'clientoffice__name', 'clientoffice__name2']
+    
+    print(f"Search terms: {search_terms}")
+    print(f"Search fields: {search_fields}")
+    
+    # Build ORM lookups (simplified)
+    orm_lookups = [f"{field}__icontains" for field in search_fields]
+    
+    # Apply filters one by one (current implementation)
+    for i, term in enumerate(search_terms):
+        print(f"\nApplying filter {i+1} for term: '{term}'")
+        
+        # Create Q object with OR conditions for all search fields
+        or_queries = Q()
+        for orm_lookup in orm_lookups:
+            or_queries |= Q(**{orm_lookup: term})
+        
+        queryset = queryset.filter(or_queries)
+        
+        # Print the SQL to see JOINs
+        sql = str(queryset.query)
+        join_count = sql.lower().count('join')
+        print(f"SQL JOIN count: {join_count}")
+        print(f"SQL: {sql}")
+    
+    print(f"\nFinal JOIN count: {sql.lower().count('join')}")
+
+if __name__ == '__main__':
+    test_join_behavior()
\ No newline at end of file
diff --git a/debug_search.py b/debug_search.py
new file mode 100644
index 0000000000..04a38d8b40
--- /dev/null
+++ b/debug_search.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python3
+"""
+Debug script to examine the current search implementation.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create a simple test model
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+
+def debug_search_implementation():
+    """Debug the current search implementation"""
+    from django.contrib.admin.options import ModelAdmin
+    from django.utils.text import smart_split
+    
+    # Create a mock model admin
+    model_admin = BookAdmin(Book, admin.site)
+    
+    # Create a mock queryset
+    queryset = Book.objects.all()
+    
+    # Test with multiple search terms
+    search_term = "test search query"
+    
+    print("=== DEBUGGING CURRENT IMPLEMENTATION ===")
+    print(f"Search term: '{search_term}'")
+    print(f"Search fields: {model_admin.search_fields}")
+    
+    # Simulate the current implementation
+    search_fields = model_admin.search_fields
+    if search_fields and search_term:
+        # Construct search lookups (simplified)
+        orm_lookups = [f"{field}__icontains" for field in search_fields]
+        print(f"ORM lookups: {orm_lookups}")
+        
+        # Current implementation: multiple filters
+        for i, bit in enumerate(smart_split(search_term)):
+            print(f"\nProcessing word {i+1}: '{bit}'")
+            or_queries = models.Q(
+                *((orm_lookup, bit) for orm_lookup in orm_lookups),
+                _connector=models.Q.OR,
+            )
+            print(f"OR query for this word: {or_queries}")
+            queryset = queryset.filter(or_queries)
+            print(f"QuerySet after filter {i+1}: {queryset.query}")
+    
+    print("\n=== FINAL QUERY ===")
+    print(queryset.query)
+    
+    # Count the number of conditions in WHERE clause
+    sql = str(queryset.query)
+    where_count = sql.count('AND') + 1  # Each AND separates a condition
+    print(f"\nNumber of conditions in WHERE clause: {where_count}")
+    print(f"Expected: {len(list(smart_split(search_term)))} (one per word)")
+
+if __name__ == '__main__':
+    debug_search_implementation()
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..9acb197358
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the failing test case.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'tests.admin_changelist',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from tests.admin_changelist.models import Group, Musician
+from tests.admin_changelist.admin import GroupAdmin
+from django.test import RequestFactory
+from django.contrib.admin.views.main import SEARCH_VAR
+
+# Set up the test data
+band_duo = Group.objects.create(name='Duo')
+band_hype = Group.objects.create(name='The Hype')
+mary = Musician.objects.create(name='Mary Halvorson')
+jonathan = Musician.objects.create(name='Jonathan Finlayson')
+band_duo.members.set([mary, jonathan])
+
+# Create admin instance
+group_model_admin = GroupAdmin(Group, None)
+group_model_admin.search_fields = ['name', 'concert__name', 'members__name']
+
+# Test the search
+search_string = 'Mary Jonathan Duo'
+print(f"Testing search: '{search_string}'")
+
+# Test with original implementation (revert my changes temporarily)
+from django.contrib.admin.options import ModelAdmin
+from django.utils.text import smart_split
+from django.db.models import Q
+
+# Original implementation
+queryset = Group.objects.all()
+orm_lookups = ['name__icontains', 'concert__name__icontains', 'members__name__icontains']
+
+print("\n=== ORIGINAL IMPLEMENTATION ===")
+for bit in smart_split(search_string):
+    print(f"Processing word: '{bit}'")
+    or_queries = Q(
+        *((orm_lookup, bit) for orm_lookup in orm_lookups),
+        _connector=Q.OR,
+    )
+    queryset = queryset.filter(or_queries)
+    print(f"SQL after filter: {queryset.query}")
+
+print(f"\nFinal count (original): {queryset.count()}")
+
+# My implementation
+queryset2 = Group.objects.all()
+search_conditions = Q()
+for bit in smart_split(search_string):
+    print(f"\nProcessing word: '{bit}'")
+    bit_conditions = Q()
+    for orm_lookup in orm_lookups:
+        bit_conditions |= Q(**{orm_lookup: bit})
+    search_conditions &= bit_conditions
+    print(f"Bit conditions: {bit_conditions}")
+
+queryset2 = queryset2.filter(search_conditions)
+print(f"\nFinal SQL (my implementation): {queryset2.query}")
+print(f"Final count (my implementation): {queryset2.count()}")
\ No newline at end of file
diff --git a/performance_test.py b/performance_test.py
new file mode 100644
index 0000000000..623c6a4fd7
--- /dev/null
+++ b/performance_test.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python3
+"""
+Performance test to measure the impact of multiple filter() calls.
+"""
+
+import os
+import sys
+import time
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create models with foreign key relationships
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    bio = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class with search fields that include related fields
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author__name', 'author__bio')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+admin.site.register(Author)
+
+def test_performance():
+    """Test performance of multiple filter calls vs single filter call"""
+    from django.db.models import Q
+    
+    # Create test data
+    author = Author.objects.create(name='Test Author', bio='Test bio')
+    for i in range(100):
+        Book.objects.create(title=f'Book {i}', author=author, description=f'Description {i}')
+    
+    # Test with multiple search terms
+    search_term = "test search query with multiple words that should trigger performance issues"
+    
+    print(f"Testing with {len(search_term.split())} search terms")
+    
+    # Test current implementation (multiple filter calls)
+    start_time = time.time()
+    queryset = Book.objects.all()
+    for bit in search_term.split():
+        q_object = Q(title__icontains=bit) | Q(author__name__icontains=bit) | Q(author__bio__icontains=bit)
+        queryset = queryset.filter(q_object)
+    
+    count1 = queryset.count()
+    time1 = time.time() - start_time
+    print(f"Multiple filter calls: {time1:.4f}s, result: {count1}")
+    
+    # Test optimized implementation (single filter call)
+    start_time = time.time()
+    queryset2 = Book.objects.all()
+    search_conditions = Q()
+    for bit in search_term.split():
+        bit_conditions = Q(title__icontains=bit) | Q(author__name__icontains=bit) | Q(author__bio__icontains=bit)
+        search_conditions &= bit_conditions
+    
+    queryset2 = queryset2.filter(search_conditions)
+    count2 = queryset2.count()
+    time2 = time.time() - start_time
+    print(f"Single filter call: {time2:.4f}s, result: {count2}")
+    
+    print(f"Performance improvement: {time1/time2:.2f}x")
+    print(f"Results match: {count1 == count2}")
+
+if __name__ == '__main__':
+    test_performance()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..4334127626
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the unnecessary joins issue in admin changelist queries.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'test_app',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.models import LogEntry
+
+# Create test models similar to the issue description
+class Client(models.Model):
+    name = models.CharField('name', max_length=256)
+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)
+    contact_person = models.CharField('contact person', max_length=256, blank=True, null=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+class ClientOffice(models.Model):
+    name = models.CharField('name', max_length=256)
+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)
+    client = models.ForeignKey(Client, on_delete=models.CASCADE, verbose_name='client')
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create admin classes
+class ClientAdmin(admin.ModelAdmin):
+    search_fields = ('name', 'name2', 'contact_person', 'clientoffice__name', 'clientoffice__name2')
+
+# Register models
+admin.site.register(Client, ClientAdmin)
+admin.site.register(ClientOffice)
+
+def test_search_query():
+    """Test that demonstrates the issue with multiple joins"""
+    from django.contrib.admin.views.main import ChangeList
+    from django.test import RequestFactory
+    
+    # Create a mock request with search query
+    factory = RequestFactory()
+    request = factory.get('/admin/test_app/client/?q=test search query with multiple words')
+    
+    # Create a ChangeList instance
+    model_admin = admin.site._registry[Client]
+    changelist = ChangeList(
+        request=request,
+        model=Client,
+        list_display=model_admin.get_list_display(request),
+        list_display_links=model_admin.get_list_display_links(request, model_admin.get_list_display(request)),
+        list_filter=model_admin.get_list_filter(request),
+        date_hierarchy=model_admin.date_hierarchy,
+        search_fields=model_admin.search_fields,
+        list_select_related=model_admin.list_select_related,
+        list_per_page=model_admin.list_per_page,
+        list_max_show_all=model_admin.list_max_show_all,
+        list_editable=model_admin.list_editable,
+        model_admin=model_admin,
+        sortable_by=model_admin.get_sortable_by(request),
+        search_help_text=model_admin.search_help_text,
+    )
+    
+    # Get the queryset to see the generated SQL
+    queryset = changelist.get_queryset(request)
+    
+    print("Generated SQL query:")
+    print(queryset.query)
+    print("\nNumber of JOIN operations in query:")
+    sql = str(queryset.query)
+    join_count = sql.lower().count('join')
+    print(f"JOIN count: {join_count}")
+    
+    return join_count
+
+if __name__ == '__main__':
+    join_count = test_search_query()
+    print(f"\nTest completed. JOIN count: {join_count}")
+    if join_count > 1:
+        print("ISSUE CONFIRMED: Multiple JOINs detected in search query!")
+    else:
+        print("No issue detected - single JOIN or no JOINs in query.")
\ No newline at end of file
diff --git a/reproduce_with_joins.py b/reproduce_with_joins.py
new file mode 100644
index 0000000000..a745d588cf
--- /dev/null
+++ b/reproduce_with_joins.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the unnecessary joins issue with related models.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create models with foreign key relationships
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    bio = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Review(models.Model):
+    book = models.ForeignKey(Book, on_delete=models.CASCADE)
+    reviewer = models.CharField(max_length=100)
+    content = models.TextField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class with search fields that cause JOINs
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author__name', 'author__bio', 'review__reviewer', 'review__content')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+admin.site.register(Author)
+admin.site.register(Review)
+
+def test_search_method():
+    """Test the get_search_results method directly with related fields"""
+    from django.contrib.admin.options import ModelAdmin
+    
+    # Create a mock model admin
+    model_admin = BookAdmin(Book, admin.site)
+    
+    # Create a mock queryset
+    queryset = Book.objects.all()
+    
+    # Test with multiple search terms that will cause JOINs
+    search_term = "test search query with multiple words"
+    
+    print(f"Testing search with term: '{search_term}'")
+    print(f"Number of words: {len(search_term.split())}")
+    print(f"Search fields: {model_admin.search_fields}")
+    
+    # Call get_search_results directly
+    result_qs, may_have_duplicates = model_admin.get_search_results(None, queryset, search_term)
+    
+    print("Generated SQL query:")
+    sql = str(result_qs.query)
+    print(sql)
+    
+    # Count JOIN operations
+    join_count = sql.lower().count('join')
+    print(f"\nNumber of JOIN operations: {join_count}")
+    
+    return join_count
+
+if __name__ == '__main__':
+    join_count = test_search_method()
+    print(f"\nTest completed. JOIN count: {join_count}")
+    if join_count > 1:
+        print("ISSUE CONFIRMED: Multiple JOINs detected!")
+    else:
+        print("No issue detected - single JOIN or no JOINs in query.")
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..a63a8999a5
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the unnecessary joins issue in admin changelist queries.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create a simple test model
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.CharField(max_length=100)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class with search fields
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author', 'description')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+
+def test_search_method():
+    """Test the get_search_results method directly"""
+    from django.contrib.admin.options import ModelAdmin
+    
+    # Create a mock model admin
+    model_admin = BookAdmin(Book, admin.site)
+    
+    # Create a mock queryset
+    queryset = Book.objects.all()
+    
+    # Test with multiple search terms
+    search_term = "test search query with multiple words"
+    
+    print(f"Testing search with term: '{search_term}'")
+    print(f"Number of words: {len(search_term.split())}")
+    
+    # Call get_search_results directly
+    result_qs, may_have_duplicates = model_admin.get_search_results(None, queryset, search_term)
+    
+    print("Generated SQL query:")
+    sql = str(result_qs.query)
+    print(sql)
+    
+    # Count JOIN operations
+    join_count = sql.lower().count('join')
+    print(f"\nNumber of JOIN operations: {join_count}")
+    
+    return join_count
+
+if __name__ == '__main__':
+    join_count = test_search_method()
+    print(f"\nTest completed. JOIN count: {join_count}")
+    if join_count > 1:
+        print("ISSUE CONFIRMED: Multiple JOINs detected!")
+    else:
+        print("No issue detected - single JOIN or no JOINs in query.")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..ea9156de98
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for unnecessary joins in admin search.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create a simple test model
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+
+def test_fixed_search():
+    """Test the fixed search implementation"""
+    from django.contrib.admin.options import ModelAdmin
+    from django.utils.text import smart_split
+    
+    # Create a mock model admin
+    model_admin = BookAdmin(Book, admin.site)
+    
+    # Create a mock queryset
+    queryset = Book.objects.all()
+    
+    # Test with multiple search terms
+    search_term = "test search query with multiple words"
+    
+    print("=== TESTING FIXED IMPLEMENTATION ===")
+    print(f"Search term: '{search_term}'")
+    print(f"Number of words: {len(list(smart_split(search_term)))}")
+    print(f"Search fields: {model_admin.search_fields}")
+    
+    # Call get_search_results with the fixed implementation
+    result_qs, may_have_duplicates = model_admin.get_search_results(None, queryset, search_term)
+    
+    print("\nGenerated SQL query:")
+    sql = str(result_qs.query)
+    print(sql)
+    
+    # Count conditions in WHERE clause
+    and_count = sql.count('AND')
+    print(f"\nNumber of AND conditions: {and_count}")
+    
+    # The fix should result in fewer AND operations in the query structure
+    # (though the logical result should be the same)
+    word_count = len(list(smart_split(search_term)))
+    print(f"Expected AND count with fix: {word_count - 1} (one less than word count)")
+    
+    return and_count
+
+if __name__ == '__main__':
+    and_count = test_fixed_search()
+    print(f"\nTest completed. AND count: {and_count}")
+    
+    # With the fix, we should see the same number of ANDs as before
+    # but the important thing is that we're only calling filter() once
+    # instead of multiple times, which is more efficient
+    print("Fix applied: Multiple filter() calls replaced with single filter() call")
\ No newline at end of file
diff --git a/test_related_fields.py b/test_related_fields.py
new file mode 100644
index 0000000000..2140aa253b
--- /dev/null
+++ b/test_related_fields.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix works with related fields.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create models with foreign key relationships
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    bio = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create admin class with search fields that include related fields
+class BookAdmin(admin.ModelAdmin):
+    search_fields = ('title', 'author__name', 'author__bio')
+
+# Register model
+admin.site.register(Book, BookAdmin)
+admin.site.register(Author)
+
+def test_related_search():
+    """Test search with related fields"""
+    from django.contrib.admin.options import ModelAdmin
+    
+    # Create a mock model admin
+    model_admin = BookAdmin(Book, admin.site)
+    
+    # Create a mock queryset
+    queryset = Book.objects.all()
+    
+    # Test with multiple search terms
+    search_term = "test search query"
+    
+    print("=== TESTING RELATED FIELDS SEARCH ===")
+    print(f"Search term: '{search_term}'")
+    print(f"Search fields: {model_admin.search_fields}")
+    
+    # Call get_search_results with the fixed implementation
+    result_qs, may_have_duplicates = model_admin.get_search_results(None, queryset, search_term)
+    
+    print("\nGenerated SQL query:")
+    sql = str(result_qs.query)
+    print(sql)
+    
+    # Count JOIN operations
+    join_count = sql.lower().count('join')
+    print(f"\nNumber of JOIN operations: {join_count}")
+    
+    # The key improvement: we should only have the necessary JOINs
+    # not multiple redundant JOINs due to multiple filter() calls
+    return join_count
+
+if __name__ == '__main__':
+    join_count = test_related_search()
+    print(f"\nTest completed. JOIN count: {join_count}")
+    
+    # With related fields, we expect some JOINs, but they should be minimal
+    # and not multiplied by the number of search words
+    if join_count > 0:
+        print("JOINs detected (expected for related fields)")
+    else:
+        print("No JOINs detected (simple case)")
\ No newline at end of file
diff --git a/understand_issue.py b/understand_issue.py
new file mode 100644
index 0000000000..7d2f2e2aae
--- /dev/null
+++ b/understand_issue.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Script to understand the actual JOIN issue with related fields.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib import admin
+
+# Create models with foreign key relationships
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    bio = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    description = models.TextField(blank=True)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_multiple_filters():
+    """Test what happens with multiple filter calls on related fields"""
+    from django.db.models import Q
+    
+    # Create a base queryset
+    queryset = Book.objects.all()
+    
+    print("=== TESTING MULTIPLE FILTER CALLS ===")
+    
+    # Simulate what happens in the current admin search implementation
+    search_terms = ["test", "search", "query"]
+    
+    for i, term in enumerate(search_terms):
+        print(f"\nApplying filter {i+1} for term: '{term}'")
+        
+        # Create a Q object with related field lookups
+        q_object = Q(title__icontains=term) | Q(author__name__icontains=term) | Q(author__bio__icontains=term)
+        
+        # Apply the filter
+        queryset = queryset.filter(q_object)
+        
+        print(f"SQL after filter {i+1}:")
+        sql = str(queryset.query)
+        print(sql)
+        
+        # Count JOIN operations
+        join_count = sql.lower().count('join')
+        print(f"JOIN count: {join_count}")
+
+def test_single_filter():
+    """Test what happens with a single filter call combining all conditions"""
+    from django.db.models import Q
+    
+    print("\n=== TESTING SINGLE FILTER CALL ===")
+    
+    # Create a base queryset
+    queryset = Book.objects.all()
+    
+    search_terms = ["test", "search", "query"]
+    
+    # Combine all conditions into a single Q object
+    combined_q = Q()
+    for term in search_terms:
+        term_q = Q(title__icontains=term) | Q(author__name__icontains=term) | Q(author__bio__icontains=term)
+        combined_q &= term_q
+    
+    # Apply single filter
+    queryset = queryset.filter(combined_q)
+    
+    print("SQL with single filter:")
+    sql = str(queryset.query)
+    print(sql)
+    
+    # Count JOIN operations
+    join_count = sql.lower().count('join')
+    print(f"JOIN count: {join_count}")
+
+if __name__ == '__main__':
+    test_multiple_filters()
+    test_single_filter()
\ No newline at end of file