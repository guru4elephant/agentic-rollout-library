diff --git a/debug_lookup.py b/debug_lookup.py
new file mode 100644
index 0000000000..da86d928ed
--- /dev/null
+++ b/debug_lookup.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the lookup_allowed logic
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.db.models.constants import LOOKUP_SEP
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    class Meta:
+        app_label = 'test'
+
+# Let's debug the lookup logic step by step
+lookup = 'restaurant__place__country'
+parts = lookup.split(LOOKUP_SEP)
+
+print(f"Lookup: {lookup}")
+print(f"Parts: {parts}")
+
+model = Waiter
+prev_field = None
+relation_parts = []
+
+for part in parts:
+    try:
+        field = model._meta.get_field(part)
+        print(f"Part '{part}': field={field}, field_type={type(field)}")
+        print(f"  field.is_relation: {field.is_relation}")
+        print(f"  has path_infos: {hasattr(field, 'path_infos')}")
+        if hasattr(field, 'path_infos') and field.path_infos:
+            print(f"  path_infos[-1].target_fields: {field.path_infos[-1].target_fields}")
+        
+        # Check the condition that determines if we add to relation_parts
+        condition_result = not prev_field or (
+            prev_field.is_relation
+            and field not in prev_field.path_infos[-1].target_fields
+        )
+        print(f"  Condition result: {condition_result}")
+        
+        if condition_result:
+            relation_parts.append(part)
+            print(f"  Added to relation_parts: {part}")
+        
+        if not getattr(field, "path_infos", None):
+            print(f"  Breaking - no path_infos")
+            break
+            
+        prev_field = field
+        model = field.path_infos[-1].to_opts.model
+        print(f"  New model: {model}")
+        
+    except Exception as e:
+        print(f"Part '{part}': Error - {e}")
+        break
+
+print(f"Final relation_parts: {relation_parts}")
+print(f"Valid lookups would be: {LOOKUP_SEP.join(relation_parts)} and {LOOKUP_SEP.join(relation_parts + [parts[-1]])}")
\ No newline at end of file
diff --git a/detailed_debug.py b/detailed_debug.py
new file mode 100644
index 0000000000..89e01dd2ef
--- /dev/null
+++ b/detailed_debug.py
@@ -0,0 +1,126 @@
+#!/usr/bin/env python3
+"""
+Detailed debug script to understand the lookup_allowed logic with our fix
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.db.models.constants import LOOKUP_SEP
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    class Meta:
+        app_label = 'test'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    class Meta:
+        app_label = 'test'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    class Meta:
+        app_label = 'test'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    class Meta:
+        app_label = 'test'
+
+# Let's debug the lookup logic step by step with our fix
+lookup = 'restaurant__place__country'
+parts = lookup.split(LOOKUP_SEP)
+
+print(f"Lookup: {lookup}")
+print(f"Parts: {parts}")
+
+model = Waiter
+prev_field = None
+relation_parts = []
+
+for part in parts:
+    try:
+        field = model._meta.get_field(part)
+        print(f"\nPart '{part}': field={field}, field_type={type(field)}")
+        print(f"  field.is_relation: {field.is_relation}")
+        print(f"  field.primary_key: {getattr(field, 'primary_key', 'N/A')}")
+        print(f"  isinstance(field, models.OneToOneField): {isinstance(field, models.OneToOneField)}")
+        print(f"  has path_infos: {hasattr(field, 'path_infos')}")
+        if hasattr(field, 'path_infos') and field.path_infos:
+            print(f"  path_infos[-1].target_fields: {field.path_infos[-1].target_fields}")
+        
+        # Check the individual parts of our condition
+        has_prev_field = prev_field is not None
+        prev_is_relation = has_prev_field and prev_field.is_relation
+        field_not_in_target = has_prev_field and prev_is_relation and (field not in prev_field.path_infos[-1].target_fields)
+        is_primary_one_to_one = isinstance(field, models.OneToOneField) and field.primary_key
+        
+        print(f"  prev_field: {prev_field}")
+        print(f"  has_prev_field: {has_prev_field}")
+        print(f"  prev_is_relation: {prev_is_relation}")
+        print(f"  field_not_in_target: {field_not_in_target}")
+        print(f"  is_primary_one_to_one: {is_primary_one_to_one}")
+        
+        # The full condition
+        condition_result = not prev_field or (
+            prev_is_relation
+            and (
+                field_not_in_target
+                or is_primary_one_to_one
+            )
+        )
+        print(f"  Condition result: {condition_result}")
+        
+        if condition_result:
+            relation_parts.append(part)
+            print(f"  Added to relation_parts: {part}")
+        
+        if not getattr(field, "path_infos", None):
+            print(f"  Breaking - no path_infos")
+            break
+            
+        prev_field = field
+        model = field.path_infos[-1].to_opts.model
+        print(f"  New model: {model}")
+        
+    except Exception as e:
+        print(f"Part '{part}': Error - {e}")
+        break
+
+print(f"\nFinal relation_parts: {relation_parts}")
+print(f"Valid lookups would be: {LOOKUP_SEP.join(relation_parts)} and {LOOKUP_SEP.join(relation_parts + [parts[-1]])}")
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5240b07cd6..5fe8e958a6 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -466,7 +466,13 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
             # then the id value would be found already from employee__department_id.
             if not prev_field or (
                 prev_field.is_relation
-                and field not in prev_field.path_infos[-1].target_fields
+                and (
+                    field not in prev_field.path_infos[-1].target_fields
+                    or (
+                        isinstance(field, models.OneToOneField)
+                        and field.primary_key
+                    )
+                )
             ):
                 relation_parts.append(part)
             if not getattr(field, "path_infos", None):
diff --git a/edge_case_test.py b/edge_case_test.py
new file mode 100644
index 0000000000..dd8f07ae08
--- /dev/null
+++ b/edge_case_test.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Test edge cases to ensure our fix doesn't break anything
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth', 
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Test case 1: OneToOneField as primary key but NOT in list_filter (should return False)
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = ['restaurant__place__country']  # Only this is allowed
+
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+# These should return True (in list_filter)
+result1 = ma.lookup_allowed('restaurant__place__country', 'test')
+print('Allowed lookup (in list_filter):', result1)
+
+# These should return False (not in list_filter)  
+result2 = ma.lookup_allowed('restaurant__place', 'test')  # Not in list_filter
+print('Disallowed lookup (not in list_filter):', result2)
+
+# Single field lookups return True by default (safe)
+result3 = ma.lookup_allowed('restaurant', 'test')  # Single field, safe
+print('Single field lookup (safe by default):', result3)
+
+# Test case 2: Mixed scenario with both primary key and non-primary key OneToOneFields
+class Parent1(models.Model):
+    name = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class Parent2(models.Model):
+    title = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class Child(models.Model):
+    parent1 = models.OneToOneField(Parent1, models.CASCADE, primary_key=True)  # Primary key
+    parent2 = models.OneToOneField(Parent2, models.CASCADE)  # Not primary key
+    value = models.CharField(max_length=100)
+    class Meta:
+        app_label = 'django.contrib.admin'
+
+class ChildAdmin(ModelAdmin):
+    list_filter = ['parent1__name', 'parent2__title']
+
+child_ma = ChildAdmin(Child, site)
+result4 = child_ma.lookup_allowed('parent1__name', 'test')  # Primary key OneToOne
+result5 = child_ma.lookup_allowed('parent2__title', 'test')  # Regular OneToOne
+
+print('Primary key OneToOne lookup:', result4)
+print('Regular OneToOne lookup:', result5)
+
+# All tests should pass if our fix is correct
+all_passed = result1 and not result2 and result3 and result4 and result5
+print('All edge case tests passed:', all_passed)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..85baf2630c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue described in the GitHub issue:
+ModelAdmin.lookup_allowed() incorrectly raises DisallowedModelAdminLookup 
+when lookup with foreign key as primary key
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models as described in the issue
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Create admin site and test the lookup
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+# This should return True but currently raises DisallowedModelAdminLookup
+try:
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"lookup_allowed result: {result}")
+    print("SUCCESS: No exception raised")
+except Exception as e:
+    print(f"ERROR: {type(e).__name__}: {e}")
+    print("This demonstrates the issue")
\ No newline at end of file
diff --git a/reproduce_issue_simple.py b/reproduce_issue_simple.py
new file mode 100644
index 0000000000..70640d58a8
--- /dev/null
+++ b/reproduce_issue_simple.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the lookup_allowed issue
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.test.utils import isolate_apps
+
+# Use isolate_apps to create the test models
+with isolate_apps('modeladmin'):
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+
+    # Create admin site and test the lookup
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+
+    # This should return True but currently raises DisallowedModelAdminLookup
+    try:
+        result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+        print(f"lookup_allowed result: {result}")
+        print("SUCCESS: No exception raised")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        print("This demonstrates the issue")
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..08e0412d47
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Simple test script to verify the fix for lookup_allowed
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'testapp',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Create the models with explicit app_label
+class Country(models.Model):
+    name = models.CharField(max_length=256)
+    class Meta:
+        app_label = 'testapp'
+
+class Place(models.Model):
+    country = models.ForeignKey(Country, models.CASCADE)
+    class Meta:
+        app_label = 'testapp'
+
+class Restaurant(models.Model):
+    place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+    class Meta:
+        app_label = 'testapp'
+
+class Waiter(models.Model):
+    restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+    class Meta:
+        app_label = 'testapp'
+
+class WaiterAdmin(ModelAdmin):
+    list_filter = [
+        'restaurant__place__country',
+    ]
+
+# Create admin site and test the lookup
+site = AdminSite()
+ma = WaiterAdmin(Waiter, site)
+
+# This should now return True with our fix
+result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+print(f"lookup_allowed('restaurant__place__country', 'test_value') = {result}")
+
+if result:
+    print("SUCCESS: The fix is working correctly!")
+else:
+    print("FAILURE: The fix is not working.")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..3965b48209
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for lookup_allowed
+"""
+
+import os
+import sys
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+# Set Django settings module
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+
+import django
+from django.conf import settings
+
+# Configure minimal settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+from django.test.utils import isolate_apps
+
+# Test the fix
+with isolate_apps('modeladmin'):
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        class Meta:
+            app_label = 'modeladmin'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+
+    # Create admin site and test the lookup
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+
+    # This should now return True with our fix
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"lookup_allowed('restaurant__place__country', 'test_value') = {result}")
+    
+    if result:
+        print("SUCCESS: The fix is working correctly!")
+    else:
+        print("FAILURE: The fix is not working.")
\ No newline at end of file