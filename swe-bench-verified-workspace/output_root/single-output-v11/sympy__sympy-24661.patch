diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..cd183d2053
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Symbol, Lt, Le, Gt, Ge, Eq, Ne
+
+print("Comprehensive test for parse_expr with evaluate=False")
+
+# Test 1: Basic relational operators with numbers
+test_cases = [
+    ('1 < 2', Lt),
+    ('1 <= 2', Le), 
+    ('2 > 1', Gt),
+    ('2 >= 1', Ge),
+    ('1 == 1', Eq),
+    ('1 != 2', Ne)
+]
+
+print("\n1. Testing basic relational operators with numbers:")
+for expr_str, expected_class in test_cases:
+    result = parse_expr(expr_str, evaluate=False)
+    parts = expr_str.split()
+    left = int(parts[0])
+    right = int(parts[2])
+    expected = expected_class(left, right, evaluate=False)
+    
+    success = (type(result) == type(expected)) and (result == expected)
+    print(f"  {expr_str}: {'PASS' if success else 'FAIL'}")
+
+# Test 2: Relational operators with variables
+print("\n2. Testing relational operators with variables:")
+x, y = Symbol('x'), Symbol('y')
+test_cases_vars = [
+    ('x < y', Lt),
+    ('x <= y', Le),
+    ('x > y', Gt), 
+    ('x >= y', Ge),
+    ('x == y', Eq),
+    ('x != y', Ne)
+]
+
+for expr_str, expected_class in test_cases_vars:
+    result = parse_expr(expr_str, evaluate=False)
+    expected = expected_class(x, y, evaluate=False)
+    
+    success = (type(result) == type(expected)) and (str(result) == str(expected))
+    print(f"  {expr_str}: {'PASS' if success else 'FAIL'}")
+
+# Test 3: Mixed expressions (should still work)
+print("\n3. Testing mixed expressions:")
+mixed_tests = [
+    ('2*(x+1)', '2*(x + 1)'),
+    ('x + y < z', 'x + y < z'),
+    ('x**2 == y', 'Eq(x**2, y)')
+]
+
+for expr_str, expected_str in mixed_tests:
+    result = parse_expr(expr_str, evaluate=False)
+    success = str(result) == expected_str
+    print(f"  {expr_str}: {'PASS' if success else 'FAIL'} - Got: {result}")
+
+# Test 4: Evaluate=True should still work (return boolean)
+print("\n4. Testing evaluate=True (should return boolean):")
+bool_tests = ['1 < 2', '2 > 3', '1 == 1', '1 != 2']
+for expr_str in bool_tests:
+    result = parse_expr(expr_str, evaluate=True)
+    success = isinstance(result, (bool, int)) or hasattr(result, 'is_Boolean')
+    print(f"  {expr_str}: {'PASS' if success else 'FAIL'} - Got: {result}")
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..18f07e368f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt
+
+print("Testing the issue with parse_expr and evaluate=False for relationals")
+
+# Test the issue case
+result = parse_expr('1 < 2', evaluate=False)
+print(f"parse_expr('1 < 2', evaluate=False) = {result}")
+print(f"Type: {type(result)}")
+
+# Test what should be returned
+expected = Lt(1, 2, evaluate=False)
+print(f"Lt(1, 2, evaluate=False) = {expected}")
+print(f"Type: {type(expected)}")
+
+# Check if they are equal
+print(f"Are they equal? {result == expected}")
\ No newline at end of file
diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py
index 52711d1324..dd12c04a11 100644
--- a/sympy/parsing/sympy_parser.py
+++ b/sympy/parsing/sympy_parser.py
@@ -1186,6 +1186,40 @@ def visit_BinOp(self, node):
             return new_node
         return node
 
+    def visit_Compare(self, node):
+        # Handle comparison operators like <, >, <=, >=, ==, !=
+        left = self.visit(node.left)
+        comparators = [self.visit(comp) for comp in node.comparators]
+        ops = node.ops
+        
+        # Map AST comparison operators to SymPy relational classes
+        relational_map = {
+            ast.Lt: 'Lt',
+            ast.LtE: 'Le', 
+            ast.Gt: 'Gt',
+            ast.GtE: 'Ge',
+            ast.Eq: 'Eq',
+            ast.NotEq: 'Ne'
+        }
+        
+        # For single comparisons like "a < b"
+        if len(ops) == 1 and len(comparators) == 1:
+            op = ops[0]
+            if op.__class__ in relational_map:
+                sympy_class = relational_map[op.__class__]
+                return ast.Call(
+                    func=ast.Name(id=sympy_class, ctx=ast.Load()),
+                    args=[left, comparators[0]],
+                    keywords=[ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load()))],
+                    starargs=None,
+                    kwargs=None
+                )
+        
+        # For chained comparisons like "a < b < c", we need to handle them as And
+        # This is more complex and may require additional logic
+        # For now, fall back to default behavior for chained comparisons
+        return self.generic_visit(node)
+
     def visit_Call(self, node):
         new_node = self.generic_visit(node)
         if isinstance(node.func, ast.Name) and node.func.id in self.functions:
diff --git a/test_complex_expressions.py b/test_complex_expressions.py
new file mode 100644
index 0000000000..585f240255
--- /dev/null
+++ b/test_complex_expressions.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Symbol
+
+print("Testing complex expressions with relational operators")
+
+x, y, z = Symbol('x'), Symbol('y'), Symbol('z')
+
+# Test complex expressions with relational operators
+complex_exprs = [
+    'x + 1 < y * 2',
+    'x**2 >= y + z',
+    'sin(x) == cos(y)',
+    'x < y < z',  # Chained comparison (should evaluate)
+    '(x + 1) * (y - 2) != 0'
+]
+
+for expr_str in complex_exprs:
+    try:
+        result_false = parse_expr(expr_str, evaluate=False)
+        result_true = parse_expr(expr_str, evaluate=True)
+        print(f"Expression: {expr_str}")
+        print(f"  evaluate=False: {result_false} (type: {type(result_false)})")
+        print(f"  evaluate=True:  {result_true} (type: {type(result_true)})")
+        print()
+    except Exception as e:
+        print(f"Error with {expr_str}: {e}")
+        print()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..0cb53e43d1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt, Le, Gt, Ge, Eq, Ne
+
+print("Testing edge cases for parse_expr with evaluate=False for relationals")
+
+# Test all relational operators
+test_cases = [
+    ('1 < 2', Lt),
+    ('1 <= 2', Le),
+    ('2 > 1', Gt),
+    ('2 >= 1', Ge),
+    ('1 == 1', Eq),
+    ('1 != 2', Ne)
+]
+
+for expr_str, expected_class in test_cases:
+    result = parse_expr(expr_str, evaluate=False)
+    # Parse the numbers from the expression string
+    parts = expr_str.split()
+    left = int(parts[0])
+    right = int(parts[2])
+    expected = expected_class(left, right, evaluate=False)
+    
+    print(f"parse_expr('{expr_str}', evaluate=False) = {result}")
+    print(f"Type: {type(result)}")
+    print(f"Expected: {expected}")
+    print(f"Type matches: {type(result) == type(expected)}")
+    print(f"Value matches: {result == expected}")
+    print("---")
+
+# Test with variables
+print("Testing with variables:")
+result = parse_expr('x < y', evaluate=False)
+print(f"parse_expr('x < y', evaluate=False) = {result}")
+print(f"Type: {type(result)}")
+
+# Test chained comparisons (should fall back to default behavior)
+print("Testing chained comparisons:")
+try:
+    result = parse_expr('1 < 2 < 3', evaluate=False)
+    print(f"parse_expr('1 < 2 < 3', evaluate=False) = {result}")
+    print(f"Type: {type(result)}")
+except Exception as e:
+    print(f"Chained comparison error (expected): {e}")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..cd688a9231
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+
+from sympy.parsing.sympy_parser import parse_expr
+from sympy import Lt
+
+print("Testing the exact case from the GitHub issue")
+
+# Original issue case
+result = parse_expr('1 < 2', evaluate=False)
+expected = Lt(1, 2, evaluate=False)
+
+print(f"parse_expr('1 < 2', evaluate=False) = {result}")
+print(f"Type: {type(result)}")
+print(f"Lt(1, 2, evaluate=False) = {expected}")
+print(f"Type: {type(expected)}")
+print(f"Are they equal? {result == expected}")
+print(f"Type matches? {type(result) == type(expected)}")
+
+# Also test that evaluate=True still returns boolean
+result_true = parse_expr('1 < 2', evaluate=True)
+print(f"\nparse_expr('1 < 2', evaluate=True) = {result_true}")
+print(f"Type: {type(result_true)}")
+print(f"Is boolean? {isinstance(result_true, bool)}")
\ No newline at end of file