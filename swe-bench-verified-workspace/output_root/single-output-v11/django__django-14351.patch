diff --git a/debug_add_fields.py b/debug_add_fields.py
new file mode 100644
index 0000000000..0492f1b5a4
--- /dev/null
+++ b/debug_add_fields.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, Count
+
+# Create simple test models to reproduce the issue
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_add_fields():
+    """Debug what happens when add_fields(['pk']) is called"""
+    
+    # Create database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(PropertyGroup)
+    
+    # Create a subquery
+    subquery = PropertyGroup.objects.all().query
+    print("Initial subquery state:")
+    print("has_select_fields:", subquery.has_select_fields)
+    print("select:", subquery.select)
+    print("default_cols:", subquery.default_cols)
+    
+    # Call clear_select_clause and add_fields as the In lookup would do
+    print("\nAfter clear_select_clause():")
+    subquery.clear_select_clause()
+    print("has_select_fields:", subquery.has_select_fields)
+    print("select:", subquery.select)
+    print("default_cols:", subquery.default_cols)
+    
+    print("\nAfter add_fields(['pk']):")
+    subquery.add_fields(['pk'])
+    print("has_select_fields:", subquery.has_select_fields)
+    print("select:", subquery.select)
+    print("default_cols:", subquery.default_cols)
+    
+    # Let's examine what columns are actually selected
+    from django.db.models.sql.compiler import SQLCompiler
+    compiler = SQLCompiler(subquery, connection, 'default')
+    compiler.setup_query()
+    print("\nAfter compilation:")
+    print("select:", compiler.select)
+    print("Number of columns:", len(compiler.select))
+
+if __name__ == "__main__":
+    debug_add_fields()
\ No newline at end of file
diff --git a/debug_in_lookup.py b/debug_in_lookup.py
new file mode 100644
index 0000000000..49666c70ce
--- /dev/null
+++ b/debug_in_lookup.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, Count
+from django.db.models.lookups import In
+
+# Create simple test models to reproduce the issue
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_in_lookup():
+    """Debug what happens during In lookup processing"""
+    
+    # Create database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(PropertyGroup)
+    
+    # Create a subquery
+    property_groups = PropertyGroup.objects.all()
+    subquery = property_groups.query
+    
+    print("Initial subquery state:")
+    print("has_select_fields:", subquery.has_select_fields)
+    print("select:", subquery.select)
+    print("default_cols:", subquery.default_cols)
+    
+    # Create a mock In lookup to test the process_rhs method
+    from django.db.models.sql.compiler import SQLCompiler
+    from django.db.models.expressions import Col
+    
+    # Create a mock compiler
+    compiler = SQLCompiler(subquery, connection, 'default')
+    
+    # Create a mock lhs for the In lookup
+    lhs = Col('test_propertygroup', PropertyGroup._meta.get_field('id'))
+    
+    # Create the In lookup
+    in_lookup = In(lhs, property_groups)
+    
+    print("\nBefore process_rhs:")
+    print("rhs type:", type(in_lookup.rhs))
+    print("rhs.query.has_select_fields:", in_lookup.rhs.query.has_select_fields)
+    print("rhs.query.select:", in_lookup.rhs.query.select)
+    print("rhs.query.default_cols:", in_lookup.rhs.query.default_cols)
+    
+    # Call process_rhs
+    try:
+        result = in_lookup.process_rhs(compiler, connection)
+        print("\nAfter process_rhs:")
+        print("rhs.has_select_fields:", in_lookup.rhs.has_select_fields)
+        print("rhs.select:", in_lookup.rhs.select)
+        print("rhs.default_cols:", in_lookup.rhs.default_cols)
+        print("process_rhs result:", result)
+    except Exception as e:
+        print("\nError in process_rhs:", str(e))
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_in_lookup()
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..f907ddb767
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,134 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, Count
+
+# Create simple test models to reproduce the issue
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgent(models.Model):
+    name = models.CharField(max_length=100)
+    property_groups = models.ManyToManyField(PropertyGroup, through='ManagementAgentPropertyGroup')
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgentPropertyGroup(models.Model):
+    management_agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    property_group = models.ForeignKey(PropertyGroup, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagerTicketRating(models.Model):
+    agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    rating = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_q_object_or_issue():
+    """Debug the Q object OR issue described in the GitHub issue"""
+    
+    # Create database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(PropertyGroup)
+        schema_editor.create_model(ManagementAgent)
+        schema_editor.create_model(ManagementAgentPropertyGroup)
+        schema_editor.create_model(ManagerTicketRating)
+    
+    # Create some test data
+    pg1 = PropertyGroup.objects.create(name="Group 1")
+    pg2 = PropertyGroup.objects.create(name="Group 2")
+    
+    agent1 = ManagementAgent.objects.create(name="Agent 1")
+    agent2 = ManagementAgent.objects.create(name="Agent 2")
+    
+    # Associate property groups with agents
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg1)
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg2)
+    
+    # Create some ratings
+    ManagerTicketRating.objects.create(agent=agent1, rating=5)
+    ManagerTicketRating.objects.create(agent=agent2, rating=3)
+    
+    # Get property groups for testing
+    property_groups = PropertyGroup.objects.all()
+    
+    # Debug the working case first
+    print("=== Debugging working case (id__in) ===")
+    queryset = ManagerTicketRating.objects.annotate(Count("agent__property_groups"))
+    q1 = Q(agent__property_groups__id__in=property_groups.values_list("id", flat=True))
+    q2 = Q(agent__property_groups__count=0)
+    
+    print("Q1:", q1)
+    print("Q2:", q2)
+    print("Q1 | Q2:", q1 | q2)
+    
+    try:
+        result1 = queryset.filter(q1 | q2).distinct()
+        print("✓ Q with id__in works:", result1.count())
+    except Exception as e:
+        print("✗ Q with id__in failed:", str(e))
+    
+    # Debug the failing case
+    print("\n=== Debugging failing case (__in) ===")
+    queryset = ManagerTicketRating.objects.annotate(Count("agent__property_groups"))
+    q3 = Q(agent__property_groups__in=property_groups)
+    q4 = Q(agent__property_groups__count=0)
+    
+    print("Q3:", q3)
+    print("Q4:", q4)
+    print("Q3 | Q4:", q3 | q4)
+    
+    # Let's examine the subquery that gets created
+    from django.db.models.sql.query import Query
+    from django.db.models.sql.compiler import SQLCompiler
+    
+    # Create the subquery manually to see what happens
+    subquery = property_groups.query
+    print("Subquery has_select_fields:", subquery.has_select_fields)
+    print("Subquery select:", subquery.select)
+    print("Subquery default_cols:", subquery.default_cols)
+    
+    try:
+        result2 = queryset.filter(q3 | q4).distinct()
+        print("✓ Q with __in works:", result2.count())
+    except Exception as e:
+        print("✗ Q with __in failed:", str(e))
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_q_object_or_issue()
\ No newline at end of file
diff --git a/debug_resolve_lookup.py b/debug_resolve_lookup.py
new file mode 100644
index 0000000000..21b2b30212
--- /dev/null
+++ b/debug_resolve_lookup.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, Count
+
+# Create simple test models to reproduce the issue
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgent(models.Model):
+    name = models.CharField(max_length=100)
+    property_groups = models.ManyToManyField(PropertyGroup, through='ManagementAgentPropertyGroup')
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgentPropertyGroup(models.Model):
+    management_agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    property_group = models.ForeignKey(PropertyGroup, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagerTicketRating(models.Model):
+    agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    rating = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_resolve_lookup():
+    """Debug what happens during resolve_lookup_value"""
+    
+    # Create database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(PropertyGroup)
+        schema_editor.create_model(ManagementAgent)
+        schema_editor.create_model(ManagementAgentPropertyGroup)
+        schema_editor.create_model(ManagerTicketRating)
+    
+    # Create some test data
+    pg1 = PropertyGroup.objects.create(name="Group 1")
+    pg2 = PropertyGroup.objects.create(name="Group 2")
+    
+    agent1 = ManagementAgent.objects.create(name="Agent 1")
+    agent2 = ManagementAgent.objects.create(name="Agent 2")
+    
+    # Associate property groups with agents
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg1)
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg2)
+    
+    # Create some ratings
+    ManagerTicketRating.objects.create(agent=agent1, rating=5)
+    ManagerTicketRating.objects.create(agent=agent2, rating=3)
+    
+    # Get property groups for testing
+    property_groups = PropertyGroup.objects.all()
+    
+    # Create a query that will trigger the issue
+    queryset = ManagerTicketRating.objects.annotate(Count("agent__property_groups"))
+    q3 = Q(agent__property_groups__in=property_groups)
+    
+    # Let's manually trace what happens during resolve_lookup_value
+    from django.db.models.sql.query import Query
+    
+    # Create a test query to see what happens
+    test_query = Query(ManagerTicketRating)
+    print("Before resolve_lookup_value:")
+    print("property_groups.query.has_select_fields:", property_groups.query.has_select_fields)
+    print("property_groups.query.select:", property_groups.query.select)
+    print("property_groups.query.default_cols:", property_groups.query.default_cols)
+    
+    # Call resolve_lookup_value manually
+    resolved_value = test_query.resolve_lookup_value(property_groups, None, True)
+    print("\nAfter resolve_lookup_value:")
+    print("resolved_value type:", type(resolved_value))
+    if hasattr(resolved_value, 'has_select_fields'):
+        print("resolved_value.has_select_fields:", resolved_value.has_select_fields)
+    if hasattr(resolved_value, 'select'):
+        print("resolved_value.select:", resolved_value.select)
+    if hasattr(resolved_value, 'default_cols'):
+        print("resolved_value.default_cols:", resolved_value.default_cols)
+
+if __name__ == "__main__":
+    debug_resolve_lookup()
\ No newline at end of file
diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py
index 5089737034..954365a36c 100644
--- a/django/db/models/lookups.py
+++ b/django/db/models/lookups.py
@@ -105,6 +105,10 @@ class Lookup:
             return self.get_db_prep_lookup(value, connection)
 
     def rhs_is_direct_value(self):
+        # QuerySet objects should be treated as subqueries, not direct values
+        # Use string-based check to avoid circular imports
+        if hasattr(self.rhs, '__class__') and self.rhs.__class__.__name__ == 'QuerySet':
+            return False
         return not hasattr(self.rhs, 'as_sql')
 
     def relabeled_clone(self, relabels):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..1127aa471d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q, Count
+
+# Create simple test models to reproduce the issue
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgent(models.Model):
+    name = models.CharField(max_length=100)
+    property_groups = models.ManyToManyField(PropertyGroup, through='ManagementAgentPropertyGroup')
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagementAgentPropertyGroup(models.Model):
+    management_agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    property_group = models.ForeignKey(PropertyGroup, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+class ManagerTicketRating(models.Model):
+    agent = models.ForeignKey(ManagementAgent, on_delete=models.CASCADE)
+    rating = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_q_object_or_issue():
+    """Test the Q object OR issue described in the GitHub issue"""
+    
+    # Create database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(PropertyGroup)
+        schema_editor.create_model(ManagementAgent)
+        schema_editor.create_model(ManagementAgentPropertyGroup)
+        schema_editor.create_model(ManagerTicketRating)
+    
+    # Create some test data
+    pg1 = PropertyGroup.objects.create(name="Group 1")
+    pg2 = PropertyGroup.objects.create(name="Group 2")
+    
+    agent1 = ManagementAgent.objects.create(name="Agent 1")
+    agent2 = ManagementAgent.objects.create(name="Agent 2")
+    
+    # Associate property groups with agents
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg1)
+    ManagementAgentPropertyGroup.objects.create(management_agent=agent1, property_group=pg2)
+    
+    # Create some ratings
+    ManagerTicketRating.objects.create(agent=agent1, rating=5)
+    ManagerTicketRating.objects.create(agent=agent2, rating=3)
+    
+    # Get property groups for testing
+    property_groups = PropertyGroup.objects.all()
+    
+    # This should work (using id__in)
+    print("Testing Q object with id__in...")
+    try:
+        queryset = ManagerTicketRating.objects.annotate(Count("agent__property_groups"))
+        result1 = queryset.filter(
+            Q(agent__property_groups__id__in=property_groups.values_list("id", flat=True))
+            | Q(agent__property_groups__count=0)
+        ).distinct()
+        print("✓ Q with id__in works:", result1.count())
+    except Exception as e:
+        print("✗ Q with id__in failed:", str(e))
+    
+    # This should fail with the described issue (using __in)
+    print("Testing Q object with __in...")
+    try:
+        queryset = ManagerTicketRating.objects.annotate(Count("agent__property_groups"))
+        result2 = queryset.filter(
+            Q(agent__property_groups__in=property_groups)
+            | Q(agent__property_groups__count=0)
+        ).distinct()
+        print("✓ Q with __in works:", result2.count())
+    except Exception as e:
+        print("✗ Q with __in failed:", str(e))
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_q_object_or_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file