diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..e64607e77c
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+"""Comprehensive test for the count query annotation fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        LOGGING={
+            'version': 1,
+            'filters': {
+                'require_debug_true': {
+                    '()': 'django.utils.log.RequireDebugTrue',
+                }
+            },
+            'handlers': {
+                'console': {
+                    'level': 'DEBUG',
+                    'filters': ['require_debug_true'],
+                    'class': 'logging.StreamHandler',
+                }
+            },
+            'loggers': {
+                'django.db.backends': {
+                    'level': 'DEBUG',
+                    'handlers': ['console'],
+                }
+            }
+        }
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Create models
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')
+    
+    class Meta:
+        app_label = 'test'
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Author)
+    schema_editor.create_model(Book)
+
+# Insert test data
+author = Author.objects.create(name="Test Author")
+Book.objects.create(title="Book 1", author=author)
+Book.objects.create(title="Book 2", author=author)
+
+print("=== Test 1: Unused annotation should be stripped ===")
+queryset = Book.objects.annotate(book_count=Count("id"))
+print("Count result:", queryset.count())
+print("Simple count result:", Book.objects.count())
+
+print("\n=== Test 2: Used annotation in filter should be preserved ===")
+queryset = Book.objects.annotate(book_count=Count("id")).filter(book_count__gt=0)
+print("Count result:", queryset.count())
+
+print("\n=== Test 3: Used annotation in ordering should be preserved ===")
+queryset = Book.objects.annotate(book_count=Count("id")).order_by("book_count")
+print("Count result:", queryset.count())
+
+print("\n=== Test 4: Multiple unused annotations should all be stripped ===")
+queryset = Book.objects.annotate(
+    book_count=Count("id"),
+    author_count=Count("author")
+)
+print("Count result:", queryset.count())
+
+print("\n=== Test 5: No annotations should work normally ===")
+print("Count result:", Book.objects.count())
+
+print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/debug_sql.py b/debug_sql.py
new file mode 100644
index 0000000000..15e8c7fcf9
--- /dev/null
+++ b/debug_sql.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""Debug script to see the actual SQL generated by count()."""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        LOGGING={
+            'version': 1,
+            'filters': {
+                'require_debug_true': {
+                    '()': 'django.utils.log.RequireDebugTrue',
+                }
+            },
+            'handlers': {
+                'console': {
+                    'level': 'DEBUG',
+                    'filters': ['require_debug_true'],
+                    'class': 'logging.StreamHandler',
+                }
+            },
+            'loggers': {
+                'django.db.backends': {
+                    'level': 'DEBUG',
+                    'handlers': ['console'],
+                }
+            }
+        }
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Create a simple model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert some test data
+TestModel.objects.create(name="Test 1")
+TestModel.objects.create(name="Test 2")
+
+# Test the issue
+print("Testing count() with unused annotations...")
+
+# Create a queryset with annotation
+queryset = TestModel.objects.annotate(custom_count=Count("id"))
+
+print("Original QuerySet SQL:")
+print(str(queryset.query))
+
+print("\nCount() SQL (should not include custom_count):")
+# Use connection.queries to capture the actual SQL
+from django.db import reset_queries
+reset_queries()
+count_result = queryset.count()
+queries = connection.queries
+if queries:
+    print(queries[-1]['sql'])
+else:
+    print("No SQL captured")
+
+print("\nSimple count SQL:")
+reset_queries()
+simple_count = TestModel.objects.count()
+queries = connection.queries
+if queries:
+    print(queries[-1]['sql'])
+else:
+    print("No SQL captured")
+
+print(f"\nCount results: {count_result} vs {simple_count}")
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 9735ce10c8..b5629a233e 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -545,11 +545,69 @@ class Query(BaseExpression):
 
         return dict(zip(outer_query.annotation_select, result))
 
+    def _get_used_annotation_names(self):
+        """
+        Return a set of annotation names that are actually used in the query.
+        An annotation is used if it's referenced in filters, ordering, other annotations,
+        or group by clauses.
+        """
+        used_annotations = set()
+        
+        # Check if annotations are used in WHERE clause
+        if self.where:
+            # Import here to avoid circular imports
+            from django.db.models.sql.where import WhereNode
+            used_annotations.update(self._get_annotations_from_node(self.where))
+        
+        # Check if annotations are used in ORDER BY
+        for order in self.order_by:
+            if hasattr(order, 'get_source_expressions'):
+                for expr in order.get_source_expressions():
+                    if hasattr(expr, 'name') and expr.name in self.annotations:
+                        used_annotations.add(expr.name)
+        
+        # Check if annotations are used in GROUP BY
+        if isinstance(self.group_by, (list, tuple)):
+            for group in self.group_by:
+                if hasattr(group, 'name') and group.name in self.annotations:
+                    used_annotations.add(group.name)
+        
+        # Check if annotations reference other annotations
+        for alias, annotation in self.annotations.items():
+            if hasattr(annotation, 'get_source_expressions'):
+                for expr in annotation.get_source_expressions():
+                    if hasattr(expr, 'name') and expr.name in self.annotations:
+                        used_annotations.add(expr.name)
+        
+        return used_annotations
+    
+    def _get_annotations_from_node(self, node):
+        """Recursively extract annotation names from a WhereNode or similar."""
+        annotations = set()
+        if hasattr(node, 'children'):
+            for child in node.children:
+                annotations.update(self._get_annotations_from_node(child))
+        elif hasattr(node, 'get_source_expressions'):
+            for expr in node.get_source_expressions():
+                if hasattr(expr, 'name') and expr.name in self.annotations:
+                    annotations.add(expr.name)
+                annotations.update(self._get_annotations_from_node(expr))
+        return annotations
+
     def get_count(self, using):
         """
         Perform a COUNT() query using the current filter constraints.
         """
         obj = self.clone()
+        
+        # Strip unused annotations to avoid unnecessary subqueries
+        used_annotations = obj._get_used_annotation_names()
+        unused_annotations = set(obj.annotations.keys()) - used_annotations
+        
+        # Remove unused annotations
+        for alias in unused_annotations:
+            del obj.annotations[alias]
+        
         obj.add_annotation(Count("*"), alias="__count", is_summary=True)
         return obj.get_aggregation(using, ["__count"])["__count"]
 
diff --git a/edge_case_test.py b/edge_case_test.py
new file mode 100644
index 0000000000..3f3dcf8584
--- /dev/null
+++ b/edge_case_test.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python3
+"""Test edge cases for the count annotation fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        LOGGING={
+            'version': 1,
+            'filters': {
+                'require_debug_true': {
+                    '()': 'django.utils.log.RequireDebugTrue',
+                }
+            },
+            'handlers': {
+                'console': {
+                    'level': 'DEBUG',
+                    'filters': ['require_debug_true'],
+                    'class': 'logging.StreamHandler',
+                }
+            },
+            'loggers': {
+                'django.db.backends': {
+                    'level': 'DEBUG',
+                    'handlers': ['console'],
+                }
+            }
+        }
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert test data
+TestModel.objects.create(name="Test 1")
+TestModel.objects.create(name="Test 2")
+
+print("=== Testing Edge Cases ===")
+
+from django.db import reset_queries
+
+# Test 1: Empty queryset with annotation
+reset_queries()
+result1 = TestModel.objects.filter(id__gt=100).annotate(cnt=Count('id')).count()
+query1 = connection.queries[-1]['sql']
+
+reset_queries()
+result2 = TestModel.objects.filter(id__gt=100).count()
+query2 = connection.queries[-1]['sql']
+
+print(f"Empty filtered count with annotation: {result1}")
+print(f"Empty filtered count without annotation: {result2}")
+print(f"Same results: {result1 == result2}")
+
+if query1 == query2:
+    print("✓ SUCCESS: Empty filtered queryset works correctly")
+else:
+    print("✗ FAILURE: Empty filtered queryset has issues")
+
+# Test 2: Multiple unused annotations
+reset_queries()
+result3 = TestModel.objects.annotate(
+    cnt1=Count('id'),
+    cnt2=Count('id')
+).count()
+query3 = connection.queries[-1]['sql']
+
+reset_queries()
+result4 = TestModel.objects.count()
+query4 = connection.queries[-1]['sql']
+
+print(f"\nMultiple unused annotations count: {result3}")
+print(f"Simple count: {result4}")
+print(f"Same results: {result3 == result4}")
+
+if query3 == query4:
+    print("✓ SUCCESS: Multiple unused annotations are stripped")
+else:
+    print("✗ FAILURE: Multiple unused annotations are not stripped")
+
+# Test 3: No annotations
+reset_queries()
+result5 = TestModel.objects.count()
+query5 = connection.queries[-1]['sql']
+
+print(f"\nNo annotations count: {result5}")
+print(f"SQL: {query5}")
+
+if 'COUNT(' in query5 and 'AS "__count"' in query5:
+    print("✓ SUCCESS: No annotations case works correctly")
+else:
+    print("✗ FAILURE: No annotations case has issues")
+
+print("\nAll edge case tests completed!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..6be045bddc
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+"""Script to reproduce the count query annotation issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create simple models to test with
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Chapter(models.Model):
+    book = models.ForeignKey(Book, on_delete=models.CASCADE, related_name='chapters')
+    title = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the tables using a simpler approach
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Chapter)
+
+# Test the issue
+from django.db.models import Count
+
+print("Testing count() with unused annotations...")
+
+# This should produce SQL with Count('chapters') even though it's not used
+queryset_with_annotation = Book.objects.annotate(Count('chapters'))
+count_with_annotation = queryset_with_annotation.count()
+
+# This is the simple count without annotations
+simple_count = Book.objects.count()
+
+print(f"Count with annotation: {count_with_annotation}")
+print(f"Simple count: {simple_count}")
+
+# Let's see the SQL generated for both
+print("\nSQL for annotated count():")
+print(str(queryset_with_annotation.query))
+
+print("\nSQL for simple count():")
+print(str(Book.objects.query))
+
+print("\nThe issue is that the annotated count() query includes the Count('chapters') annotation")
+print("even though it's not used in filters, ordering, or other operations.")
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..fbee817a60
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""Simple script to reproduce the count query annotation issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Create a simple model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert some test data
+TestModel.objects.create(name="Test 1")
+TestModel.objects.create(name="Test 2")
+
+# Test the issue
+print("Testing count() with unused annotations...")
+
+# Create a queryset with annotation
+queryset = TestModel.objects.annotate(custom_count=Count("id"))
+
+print("QuerySet with annotation:")
+print(str(queryset.query))
+
+print("\nCount() result:", queryset.count())
+
+print("\nSimple count result:", TestModel.objects.count())
+
+# The issue: the count() query includes the custom_count annotation
+# even though it's not used for filtering, ordering, or other operations
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..2d42d8507e
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python3
+"""Simple test for the count annotation fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+        LOGGING={
+            'version': 1,
+            'filters': {
+                'require_debug_true': {
+                    '()': 'django.utils.log.RequireDebugTrue',
+                }
+            },
+            'handlers': {
+                'console': {
+                    'level': 'DEBUG',
+                    'filters': ['require_debug_true'],
+                    'class': 'logging.StreamHandler',
+                }
+            },
+            'loggers': {
+                'django.db.backends': {
+                    'level': 'DEBUG',
+                    'handlers': ['console'],
+                }
+            }
+        }
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Simple model without relationships
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert test data
+TestModel.objects.create(name="Test 1")
+TestModel.objects.create(name="Test 2")
+
+print("=== Testing Basic Annotation Stripping ===")
+
+from django.db import reset_queries
+
+# Test 1: Unused annotation should be stripped
+reset_queries()
+result1 = TestModel.objects.annotate(cnt=Count('id')).count()
+query1 = connection.queries[-1]['sql']
+
+reset_queries()
+result2 = TestModel.objects.count()
+query2 = connection.queries[-1]['sql']
+
+print(f"Count with annotation: {result1}")
+print(f"Count without annotation: {result2}")
+print(f"Same results: {result1 == result2}")
+
+print(f"\nSQL with annotation: {query1}")
+print(f"SQL without annotation: {query2}")
+
+if query1 == query2:
+    print("✓ SUCCESS: Unused annotation was stripped")
+else:
+    print("✗ FAILURE: Unused annotation was not stripped")
+
+print("\n=== Testing Used Annotation Preservation ===")
+# Test 2: Used annotation should be preserved
+reset_queries()
+result3 = TestModel.objects.annotate(cnt=Count('id')).filter(cnt__gt=0).count()
+query3 = connection.queries[-1]['sql']
+
+print(f"Count with used annotation: {result3}")
+print(f"SQL with used annotation: {query3}")
+
+# This should be different from the simple count
+if query3 != query2:
+    print("✓ SUCCESS: Used annotation was preserved")
+else:
+    print("✗ FAILURE: Used annotation was incorrectly stripped")
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..075811b288
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python3
+"""Test the specific scenario from the GitHub issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+from django.db import connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        LOGGING={
+            'version': 1,
+            'filters': {
+                'require_debug_true': {
+                    '()': 'django.utils.log.RequireDebugTrue',
+                }
+            },
+            'handlers': {
+                'console': {
+                    'level': 'DEBUG',
+                    'filters': ['require_debug_true'],
+                    'class': 'logging.StreamHandler',
+                }
+            },
+            'loggers': {
+                'django.db.backends': {
+                    'level': 'DEBUG',
+                    'handlers': ['console'],
+                }
+            }
+        }
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Create models as described in the GitHub issue
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Chapter(models.Model):
+    book = models.ForeignKey(Book, on_delete=models.CASCADE, related_name='chapters')
+    title = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Book)
+    schema_editor.create_model(Chapter)
+
+# Insert test data
+book = Book.objects.create(title="Test Book")
+Chapter.objects.create(title="Chapter 1", book=book)
+Chapter.objects.create(title="Chapter 2", book=book)
+
+print("=== Testing GitHub Issue Scenario ===")
+print("Book.objects.annotate(Count('chapters')).count()")
+
+# This is the exact scenario from the GitHub issue
+from django.db import reset_queries
+
+reset_queries()
+result1 = Book.objects.annotate(Count('chapters')).count()
+queries1 = connection.queries[-1]['sql']
+
+reset_queries()
+result2 = Book.objects.count()
+queries2 = connection.queries[-1]['sql']
+
+print(f"Result with annotation: {result1}")
+print(f"Result without annotation: {result2}")
+print(f"Same results: {result1 == result2}")
+
+print(f"\nSQL with annotation: {queries1}")
+print(f"SQL without annotation: {queries2}")
+
+# The key test: both should generate the same SQL (no subquery)
+if queries1 == queries2:
+    print("✓ SUCCESS: Unused annotation was stripped, no subquery generated")
+else:
+    print("✗ FAILURE: Unused annotation was not stripped, subquery generated")
+
+print("\n=== Testing with used annotation ===")
+# Test that used annotations are preserved
+reset_queries()
+result3 = Book.objects.annotate(chapter_count=Count('chapters')).filter(chapter_count__gt=0).count()
+queries3 = connection.queries[-1]['sql']
+
+print(f"Result with used annotation: {result3}")
+print(f"SQL with used annotation: {queries3}")
+
+# This should use a subquery since the annotation is used in filter
+if 'subquery' in queries3.lower() or 'having' in queries3.lower():
+    print("✓ SUCCESS: Used annotation was preserved, subquery generated")
+else:
+    print("✗ FAILURE: Used annotation was incorrectly stripped")
+
+print("\nAll tests completed!")
\ No newline at end of file