diff --git a/final_test.py b/final_test.py
new file mode 100644
index 000000000..252c255be
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""
+Final test to demonstrate that the :private-members: option now supports specific member names
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import members_option, ALL
+
+def demonstrate_functionality():
+    """Demonstrate the new functionality"""
+    
+    print("=== DEMONSTRATING THE NEW :private-members: FUNCTIONALITY ===")
+    print()
+    
+    # Show how the option handler works
+    print("1. Option handler behavior:")
+    print(f"   members_option(None) = {members_option(None)} (backward compatibility)")
+    print(f"   members_option(True) = {members_option(True)} (backward compatibility)")
+    print(f"   members_option('_private_method') = {members_option('_private_method')} (new functionality)")
+    print(f"   members_option('_private_method,_another_private') = {members_option('_private_method,_another_private')} (new functionality)")
+    print()
+    
+    # Demonstrate the filtering logic
+    print("2. Filtering logic examples:")
+    
+    def simulate_filter(membername, isprivate, private_members_value):
+        """Simulate the filtering logic"""
+        if not isprivate:
+            return True  # Public members always included
+            
+        if private_members_value is ALL:
+            return True  # ALL means show all private members
+        elif isinstance(private_members_value, (list, set)):
+            return membername in private_members_value  # Specific members
+        else:
+            return private_members_value  # Boolean value
+    
+    # Test cases
+    test_cases = [
+        ("public_method", False, False, "✓ (public always included)"),
+        ("_private_method", True, False, "✗ (private with False)"),
+        ("_private_method", True, True, "✓ (private with True)"),
+        ("_private_method", True, ALL, "✓ (private with ALL)"),
+        ("_private_method", True, ["_private_method"], "✓ (private in list)"),
+        ("_another_private", True, ["_private_method"], "✗ (private not in list)"),
+    ]
+    
+    for membername, isprivate, value, expected in test_cases:
+        result = simulate_filter(membername, isprivate, value)
+        status = "✓" if result else "✗"
+        print(f"   {membername} with {value}: {status} {expected}")
+    
+    print()
+    print("3. Usage examples in RST:")
+    print("   Old way (all private members):")
+    print("   :private-members:")
+    print()
+    print("   New way (specific private members):")
+    print("   :private-members: _private_method,_another_private")
+    print("   :private-members: _specific_method")
+    print()
+    print("=== IMPLEMENTATION SUCCESSFUL! ===")
+    print("The :private-members: option now supports specifying specific private members!")
+
+if __name__ == '__main__':
+    demonstrate_functionality()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..0a581b85f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with :private-members: not supporting specific members
+"""
+
+import sys
+
+# Add the sphinx directory to the path so we can import from it
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import members_option, bool_option, ALL
+
+# Test the current behavior of option handlers
+print("Testing current option handlers...")
+
+# Test 1: Current bool_option behavior
+print("\n1. Current bool_option behavior:")
+print(f"   bool_option(None) = {bool_option(None)}")
+print(f"   bool_option(True) = {bool_option(True)}")
+print(f"   bool_option('anything') = {bool_option('anything')}")
+
+# Test 2: Current members_option behavior  
+print("\n2. Current members_option behavior:")
+print(f"   members_option(None) = {members_option(None)}")
+print(f"   members_option(True) = {members_option(True)}")
+print(f"   members_option('method1,method2') = {members_option('method1,method2')}")
+
+# Test 3: The issue
+print("\n3. The issue:")
+print("   Currently 'private-members' uses bool_option, so it can only be True/False")
+print("   We need it to use members_option to support specific members like:")
+print("   :private-members: _private_method,_another_private")
+
+# Test 4: What happens if we try to use members_option for private-members
+print("\n4. Testing what happens with members_option for private-members:")
+private_members_option = members_option('_private_method,_another_private')
+print(f"   members_option('_private_method,_another_private') = {private_members_option}")
+print(f"   This would be a list: {list(private_members_option) if private_members_option != ALL else 'ALL'}")
\ No newline at end of file
diff --git a/setup.py b/setup.py
index a404f1fa5..2c6848797 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index 8c3509c3b..754a4fad9 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -649,15 +649,26 @@ class Documenter:
             elif (namespace, membername) in attr_docs:
                 if want_all and isprivate:
                     # ignore members whose name starts with _ by default
-                    keep = self.options.private_members
+                    if self.options.private_members is ALL:
+                        keep = True
+                    elif isinstance(self.options.private_members, (list, set)):
+                        keep = membername in self.options.private_members
+                    else:
+                        keep = self.options.private_members
                 else:
                     # keep documented attributes
                     keep = True
                 isattr = True
             elif want_all and isprivate:
                 # ignore members whose name starts with _ by default
-                keep = self.options.private_members and \
-                    (has_doc or self.options.undoc_members)
+                if self.options.private_members is ALL:
+                    keep = has_doc or self.options.undoc_members
+                elif isinstance(self.options.private_members, (list, set)):
+                    keep = membername in self.options.private_members and \
+                        (has_doc or self.options.undoc_members)
+                else:
+                    keep = self.options.private_members and \
+                        (has_doc or self.options.undoc_members)
             else:
                 if self.options.members is ALL and is_filtered_inherited_member(membername):
                     keep = False
@@ -859,7 +870,7 @@ class ModuleDocumenter(Documenter):
         'show-inheritance': bool_option, 'synopsis': identity,
         'platform': identity, 'deprecated': bool_option,
         'member-order': member_order_option, 'exclude-members': members_set_option,
-        'private-members': bool_option, 'special-members': members_option,
+        'private-members': members_option, 'special-members': members_option,
         'imported-members': bool_option, 'ignore-module-all': bool_option
     }  # type: Dict[str, Callable]
 
@@ -1279,7 +1290,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:
         'noindex': bool_option, 'inherited-members': inherited_members_option,
         'show-inheritance': bool_option, 'member-order': member_order_option,
         'exclude-members': members_set_option,
-        'private-members': bool_option, 'special-members': members_option,
+        'private-members': members_option, 'special-members': members_option,
     }  # type: Dict[str, Callable]
 
     _signature_class = None  # type: Any
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 000000000..5e06c13b1
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify that :private-members: now supports specific member names
+"""
+
+import tempfile
+import os
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import ModuleDocumenter, ALL
+
+# Create a test module with private members
+test_module_content = '''
+class TestClass:
+    """A test class with private members."""
+    
+    def public_method(self):
+        """A public method."""
+        pass
+    
+    def _private_method(self):
+        """A private method."""
+        pass
+    
+    def _another_private(self):
+        """Another private method."""
+        pass
+    
+    def __private_dunder(self):
+        """A private dunder method."""
+        pass
+'''
+
+# Create a temporary module file
+with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
+    f.write(test_module_content)
+    temp_module_path = f.name
+
+try:
+    # Import the module
+    import importlib.util
+    spec = importlib.util.spec_from_file_location("test_module", temp_module_path)
+    test_module = importlib.util.module_from_spec(spec)
+    spec.loader.exec_module(test_module)
+    
+    # Create a mock documenter to test filtering
+    class MockDocumenter(ModuleDocumenter):
+        def __init__(self):
+            self.object = test_module.TestClass
+            # Create a proper options object with all required attributes
+            self.options = type('Options', (), {
+                'exclude_members': None,
+                'special_members': None,
+                'undoc_members': False,
+                'inherited_members': 'object'
+            })()
+            self.env = type('Env', (), {})()
+            self.env.config = type('Config', (), {})()
+            self.env.config.autodoc_inherit_docstrings = False
+            self.modname = 'test_module'
+            self.objpath = ['TestClass']
+            self.objtype = 'class'
+            self.analyzer = None
+            self.parent = None
+            self.object_name = 'TestClass'
+        
+        def get_attr(self, obj, name, default=None):
+            return getattr(obj, name, default)
+    
+    documenter = MockDocumenter()
+    
+    # Get all members
+    members = [
+        ('public_method', test_module.TestClass.public_method),
+        ('_private_method', test_module.TestClass._private_method),
+        ('_another_private', test_module.TestClass._another_private),
+    ]
+    
+    print("Testing comprehensive private-members functionality...")
+    
+    # Test 1: private-members=False (default behavior)
+    print("\n1. private-members=False (default):")
+    documenter.options.private_members = False
+    filtered = documenter.filter_members(members, want_all=True)
+    print(f"   Filtered members: {[name for name, _, _ in filtered]}")
+    expected = ['public_method']  # Only public members should be included
+    actual = [name for name, _, _ in filtered]
+    assert actual == expected, f"Expected {expected}, got {actual}"
+    
+    # Test 2: private-members=True (all private members)
+    print("\n2. private-members=True (all private members):")
+    documenter.options.private_members = True
+    filtered = documenter.filter_members(members, want_all=True)
+    print(f"   Filtered members: {[name for name, _, _ in filtered]}")
+    expected = ['public_method', '_private_method', '_another_private']  # All members should be included
+    actual = [name for name, _, _ in filtered]
+    assert actual == expected, f"Expected {expected}, got {actual}"
+    
+    # Test 3: private-members with specific members (new functionality)
+    print("\n3. private-members with specific members (new functionality):")
+    documenter.options.private_members = ['_private_method']  # Only include _private_method
+    filtered = documenter.filter_members(members, want_all=True)
+    print(f"   Filtered members: {[name for name, _, _ in filtered]}")
+    expected = ['public_method', '_private_method']  # Public + specified private member
+    actual = [name for name, _, _ in filtered]
+    assert actual == expected, f"Expected {expected}, got {actual}"
+    
+    # Test 4: private-members with multiple specific members
+    print("\n4. private-members with multiple specific members:")
+    documenter.options.private_members = ['_private_method', '_another_private']
+    filtered = documenter.filter_members(members, want_all=True)
+    print(f"   Filtered members: {[name for name, _, _ in filtered]}")
+    expected = ['public_method', '_private_method', '_another_private']  # Public + specified private members
+    actual = [name for name, _, _ in filtered]
+    assert actual == expected, f"Expected {expected}, got {actual}"
+    
+    # Test 5: private-members with ALL (backward compatibility)
+    print("\n5. private-members with ALL (backward compatibility):")
+    documenter.options.private_members = ALL
+    filtered = documenter.filter_members(members, want_all=True)
+    print(f"   Filtered members: {[name for name, _, _ in filtered]}")
+    expected = ['public_method', '_private_method', '_another_private']  # All members should be included
+    actual = [name for name, _, _ in filtered]
+    assert actual == expected, f"Expected {expected},1 got {actual}"
+    
+    print("\nAll comprehensive tests passed! The private-members option now supports specific member names.")
+    
+finally:
+    # Clean up
+    os.unlink(temp_module_path)
\ No newline at end of file
diff --git a/test_filtering.py b/test_filtering.py
new file mode 100644
index 000000000..f35fd875e
--- /dev/null
+++ b/test_filtering.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that the filtering logic works correctly with the new private-members option
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import ALL
+
+def test_filtering_logic():
+    """Test the filtering logic with different private_members values"""
+    
+    print("Testing filtering logic...")
+    
+    # Mock filtering scenarios
+    def test_filter(membername, isprivate, private_members_value, has_doc=True, want_all=True):
+        """Simulate the filtering logic from filter_members method"""
+        
+        # For non-private members, private_members_value should not affect the result
+        if not isprivate:
+            return has_doc  # Public members are handled differently in the actual logic
+            
+        if private_members_value is ALL:
+            # ALL means show all private members
+            return has_doc  # or undoc_members, but we simplify for testing
+        elif isinstance(private_members_value, (list, set)):
+            # Specific members list/set
+            return membername in private_members_value and has_doc
+        else:
+            # Boolean value (backward compatibility)
+            return private_members_value and has_doc
+    
+    # Test cases
+    test_cases = [
+        # (membername, isprivate, private_members_value, expected_result)
+        ('_private_method', True, ALL, True),  # ALL should include all private members
+        ('_private_method', True, ['_private_method'], True),  # Specific member in list
+        ('_private_method', True, ['_other_method'], False),  # Specific member not in list
+        ('_private_method', True, True, True),  # Boolean True (backward compat)
+        ('_private_method', True, False, False),  # Boolean False (backward compat)
+        ('public_method', False, ALL, True),  # Public member should not be affected
+        ('public_method', False, ['_private_method'], True),  # Public member should not be affected
+    ]
+    
+    for i, (membername, isprivate, private_members_value, expected) in enumerate(test_cases):
+        result = test_filter(membername, isprivate, private_members_value)
+        status = "PASS" if result == expected else "FAIL"
+        print(f"{i+1}. {membername}, private={isprivate}, value={private_members_value} -> {result} (expected {expected}) [{status}]")
+        assert result == expected, f"Test case {i+1} failed"
+    
+    print("\nAll filtering tests passed!")
+
+if __name__ == '__main__':
+    test_filtering_logic()
\ No newline at end of file
diff --git a/test_private_members.py b/test_private_members.py
new file mode 100644
index 000000000..b56d2d4d4
--- /dev/null
+++ b/test_private_members.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that :private-members: now supports specific member names
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import members_option, ALL
+
+def test_private_members_option():
+    """Test the new behavior of private-members option"""
+    
+    print("Testing private-members option behavior...")
+    
+    # Test 1: No argument (should return ALL for backward compatibility)
+    result = members_option(None)
+    print(f"1. members_option(None) = {result} (should be ALL)")
+    assert result is ALL, f"Expected ALL, got {result}"
+    
+    # Test 2: True argument (should return ALL for backward compatibility)
+    result = members_option(True)
+    print(f"2. members_option(True) = {result} (should be ALL)")
+    assert result is ALL, f"Expected ALL, got {result}"
+    
+    # Test 3: Specific members (new functionality)
+    result = members_option('_private_method,_another_private')
+    print(f"3. members_option('_private_method,_another_private') = {result}")
+    expected = ['_private_method', '_another_private']
+    assert result == expected, f"Expected {expected}, got {result}"
+    
+    # Test 4: Single member
+    result = members_option('_single_method')
+    print(f"4. members_option('_single_method') = {result}")
+    expected = ['_single_method']
+    assert result == expected, f"Expected {expected}, got {result}"
+    
+    # Test 5: Empty string
+    result = members_option('')
+    print(f"5. members_option('') = {result}")
+    expected = []
+    assert result == expected, f"Expected {expected}, got {result}"
+    
+    print("\nAll tests passed! The private-members option now supports specific member names.")
+
+if __name__ == '__main__':
+    test_private_members_option()
\ No newline at end of file
diff --git a/test_simple.py b/test_simple.py
new file mode 100644
index 000000000..db2c15dd1
--- /dev/null
+++ b/test_simple.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify that :private-members: now supports specific member names
+"""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from sphinx.ext.autodoc import ALL
+
+def test_filtering_logic():
+    """Test the filtering logic directly"""
+    
+    print("Testing private-members filtering logic...")
+    
+    # Simulate the filtering logic from filter_members method
+    def test_filter(membername, isprivate, private_members_value, has_doc=True):
+        """Test the filtering logic directly"""
+        if not isprivate:
+            return True  # Public members are always included
+            
+        if private_members_value is ALL:
+            return has_doc  # ALL means show all private members
+        elif isinstance(private_members_value, (list, set)):
+            return membername in private_members_value and has_doc  # Specific members
+        else:
+            return private_members_value and has_doc  # Boolean value
+    
+    test_cases = [
+        # (membername, isprivate, private_members_value, expected_result)
+        ('public_method', False, False, True),  # Public member should always be included
+        ('_private_method', True, False, False),  # Private member with False
+        ('_private_method', True, True, True),  # Private member with True
+        ('_private_method', True, ALL, True),  # Private member with ALL
+        ('_private_method', True, ['_private_method'], True),  # Private member in list
+        ('_private_method', True, ['_other_method'], False),  # Private member not in list
+        ('_another_private', True, ['_private_method'], False),  # Different private member not in list
+    ]
+    
+    for i, (membername, isprivate, private_members_value, expected) in enumerate(test_cases):
+        result = test_filter(membername, isprivate, private_members_value)
+        status = "PASS" if result == expected else "FAIL"
+        print(f"{i+1}. {membername}, private={isprivate}, value={private_members_value} -> {result} (expected {expected}) [{status}]")
+        assert result == expected, f"Test case {i+1} failed"
+    
+    print("\nAll filtering tests passed!")
+
+if __name__ == '__main__':
+    test_filtering_logic()
\ No newline at end of file
diff --git a/test_sphinx_integration.py b/test_sphinx_integration.py
new file mode 100644
index 000000000..4f0f582c7
--- /dev/null
+++ b/test_sphinx_integration.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+"""
+Test to verify that Sphinx autodoc integration works with the new private-members functionality
+"""
+
+import tempfile
+import os
+import sys
+sys.path.insert(0, '/testbed')
+
+# Create a test module with private members
+test_module_content = '''
+class TestClass:
+    """A test class with private members."""
+    
+    def public_method(self):
+        """A public method."""
+        pass
+    
+    def _private_method(self):
+        """A private method."""
+        pass
+    
+    def _another_private(self):
+        """Another private method."""
+        pass
+'''
+
+# Create test RST content
+test_rst_content = '''
+Test Module
+===========
+
+.. autoclass:: test_module.TestClass
+   :private-members: _private_method
+   :members:
+'''
+
+# Create conf.py content
+conf_py_content = '''
+extensions = ['sphinx.ext.autodoc']
+'''
+
+# Create temporary directory structure
+with tempfile.TemporaryDirectory() as temp_dir:
+    # Create test module
+    with open(os.path.join(temp_dir, 'test_module.py'), 'w') as f:
+        f.write(test_module_content)
+    
+    # Create RST file
+    with open(os.path.join(temp_dir, 'index.rst'), 'w') as f:
+        f.write(test_rst_content)
+    
+    # Create conf.py
+    with open(os.path.join(temp_dir, 'conf.py'), 'w') as f:
+        f.write(conf_py_content)
+    
+    print(f"Created test files in: {temp_dir}")
+    print("Test setup complete. The :private-members: option should now work with specific member names.")
\ No newline at end of file
diff --git a/tox.ini b/tox.ini
index bddd822a6..34baee205 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3