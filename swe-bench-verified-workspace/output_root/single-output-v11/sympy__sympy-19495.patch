diff --git a/debug_assumptions.py b/debug_assumptions.py
new file mode 100644
index 0000000000..6487e8cad2
--- /dev/null
+++ b/debug_assumptions.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Interval, S, oo
+from sympy.sets import ConditionSet
+
+# Try different assumption combinations
+print("=== Testing different assumptions ===")
+
+# Test 1: n and p both positive
+n1, x1, p1 = symbols('n x p', positive=True)
+cond_set1 = ConditionSet(n1, n1 < x1, Interval(0, oo))
+result1 = cond_set1.subs(x1, p1)
+print("1. n and p both positive:")
+print(f"   Original: {cond_set1}")
+print(f"   Result: {result1}")
+print(f"   Condition after subs: {cond_set1.condition.subs(x1, p1)}")
+print(f"   Is S.true? {cond_set1.condition.subs(x1, p1) is S.true}")
+
+# Test 2: Only p positive, n has no assumptions
+n2, x2, p2 = symbols('n x p')
+p2 = symbols('p', positive=True)
+cond_set2 = ConditionSet(n2, n2 < x2, Interval(0, oo))
+result2 = cond_set2.subs(x2, p2)
+print("\n2. Only p positive, n has no assumptions:")
+print(f"   Original: {cond_set2}")
+print(f"   Result: {result2}")
+print(f"   Condition after subs: {cond_set2.condition.subs(x2, p2)}")
+print(f"   Is S.true? {cond_set2.condition.subs(x2, p2) is S.true}")
+
+# Test 3: Check what n < p evaluates to with different assumptions
+print("\n3. Evaluating n < p with different assumptions:")
+n3, p3 = symbols('n p', positive=True)
+print(f"   n < p with both positive: {n3 < p3}")
+
+n4, p4 = symbols('n p')
+p4 = symbols('p', positive=True)
+print(f"   n < p with only p positive: {n4 < p4}")
+
+# Test 4: Check if n < oo evaluates to S.true
+print("\n4. Checking n < oo:")
+n5 = symbols('n', positive=True)
+print(f"   n < oo: {n5 < oo}")
+print(f"   Is S.true? {(n5 < oo) is S.true}")
\ No newline at end of file
diff --git a/debug_condition_evaluation.py b/debug_condition_evaluation.py
new file mode 100644
index 0000000000..d03a42e94a
--- /dev/null
+++ b/debug_condition_evaluation.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Interval, S, oo
+from sympy.sets import ConditionSet
+from sympy.core.logic import fuzzy_bool
+
+n, x, p = symbols('n x p', positive=True)
+
+print("=== Debugging condition evaluation ===")
+
+# Create the ConditionSet
+cond_set = ConditionSet(n, n < x, Interval(0, oo))
+print("Original:", cond_set)
+
+# Check if n < p evaluates to True for any n in [0, oo)
+print(f"\nTesting if n < p is always true for n in [0, oo):")
+
+# Test with some sample values
+test_values = [0, 1, 10, 100, oo]
+for val in test_values:
+    condition_val = (n < p).subs(n, val)
+    print(f"  n = {val}: {condition_val}")
+
+# Maybe there's some fuzzy logic evaluation?
+print(f"\nFuzzy bool evaluation of n < p:")
+fuzzy_result = fuzzy_bool(n < p)
+print(f"  fuzzy_bool(n < p): {fuzzy_result}")
+
+# Check if the condition is S.true when we substitute x with p
+cond_after_subs = cond_set.condition.subs(x, p)
+print(f"\nCondition after subs(x, p): {cond_after_subs}")
+print(f"Is S.true? {cond_after_subs is S.true}")
+
+# Maybe the test is checking if the condition is universally true?
+print(f"\nIs n < p universally true for n in Interval(0, oo)?")
+# This would require p to be oo, which it's not
\ No newline at end of file
diff --git a/debug_p_symbol.py b/debug_p_symbol.py
new file mode 100644
index 0000000000..2f5b60b3e6
--- /dev/null
+++ b/debug_p_symbol.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Interval, S, oo
+from sympy.sets import ConditionSet
+
+# Let me check what assumptions p has in the test
+n, x = symbols('n x', positive=True)
+p = symbols('p', positive=True)  # This is how p is defined in the test
+
+print("=== Checking p symbol assumptions ===")
+print(f"p assumptions: {p.assumptions0}")
+
+# Create the ConditionSet
+cond_set = ConditionSet(n, n < x, Interval(0, oo))
+print(f"\nOriginal: {cond_set}")
+
+# Check if n < p evaluates to True for some reason
+print(f"\nn < p: {n < p}")
+print(f"n < p is S.true: {(n < p) is S.true}")
+
+# Maybe the test expects that since p is positive and n is in [0, oo),
+# n < p is always true?
+print(f"\nIs n < p always true for n in [0, oo)?")
+print("This would require p to be oo, which it's not")
+
+# Let me check if there's some automatic evaluation happening
+from sympy.core.relational import Relational
+print(f"\nType of n < p: {type(n < p)}")
+print(f"Is it a Relational? {isinstance(n < p, Relational)}")
+
+# Maybe the test is wrong or there's some other logic
+print(f"\nMaybe the test expects some other behavior?")
\ No newline at end of file
diff --git a/debug_subs.py b/debug_subs.py
new file mode 100644
index 0000000000..88c222b59f
--- /dev/null
+++ b/debug_subs.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Rational, imageset, Lambda, pi, asin, S, Interval
+from sympy.sets import ConditionSet, Contains
+from sympy.solvers.solveset import solveset_real
+
+x, y, n = symbols('x y n')
+
+print("=== Debugging the substitution process ===")
+
+# Create the problematic ConditionSet
+img_set = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+cond_set = ConditionSet(x, Contains(y, Interval(-1,1)), img_set)
+
+print("Original ConditionSet:")
+print(cond_set)
+print(f"Dummy symbol: {cond_set.sym}")
+print(f"Condition: {cond_set.condition}")
+print(f"Base set: {cond_set.base_set}")
+
+print("\nStep 1: Substitute y with 1/3 in condition")
+cond_after_subs = cond_set.condition.subs(y, Rational(1, 3))
+print(f"Condition after subs: {cond_after_subs}")
+
+print("\nStep 2: Substitute y with 1/3 in base set")
+base_after_subs = cond_set.base_set.subs(y, Rational(1, 3))
+print(f"Base set after subs: {base_after_subs}")
+
+print("\nStep 3: Check if condition is S.true")
+print(f"Is condition S.true? {cond_after_subs is S.true}")
+
+print("\nStep 4: Manual substitution using _eval_subs")
+result = cond_set._eval_subs(y, Rational(1, 3))
+print(f"Result from _eval_subs: {result}")
\ No newline at end of file
diff --git a/debug_test_expectation.py b/debug_test_expectation.py
new file mode 100644
index 0000000000..ca2816a0c8
--- /dev/null
+++ b/debug_test_expectation.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Interval, S, oo
+from sympy.sets import ConditionSet
+
+n, x, p = symbols('n x p', positive=True)
+
+print("=== Testing what the test expects ===")
+
+# Test the exact condition from the test
+cond_set = ConditionSet(n, n < x, Interval(0, oo))
+print("Original:", cond_set)
+
+# The test expects: ConditionSet(n, n < x, Interval(0, oo)).subs(x, p) == Interval(0, oo)
+result = cond_set.subs(x, p)
+print("\nAfter subs(x, p):", result)
+print("Expected: Interval(0, oo)")
+
+# Let me check if there's some evaluation happening
+print(f"\nCondition after substitution: {cond_set.condition.subs(x, p)}")
+print(f"Is S.true? {cond_set.condition.subs(x, p) is S.true}")
+
+# Maybe p is being interpreted as oo?
+print(f"\nIs p == oo? {p == oo}")
+
+# Let me try substituting with oo directly
+result_with_oo = cond_set.subs(x, oo)
+print(f"\nAfter subs(x, oo): {result_with_oo}")
+print(f"Condition with oo: {cond_set.condition.subs(x, oo)}")
+print(f"Is S.true with oo? {cond_set.condition.subs(x, oo) is S.true}")
\ No newline at end of file
diff --git a/debug_test_failure.py b/debug_test_failure.py
new file mode 100644
index 0000000000..6bb80cf1cf
--- /dev/null
+++ b/debug_test_failure.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Interval, S, oo
+from sympy.sets import ConditionSet
+
+n, x, p = symbols('n x p', positive=True)
+
+print("=== Debugging test failure ===")
+
+# Create the ConditionSet from the test
+cond_set = ConditionSet(n, n < x, Interval(0, oo))
+print("Original ConditionSet:")
+print(cond_set)
+
+# Substitute x with p
+result = cond_set.subs(x, p)
+print("\nAfter subs(x, p):")
+print(result)
+
+# Check what the condition becomes after substitution
+print(f"\nCondition after substitution: {cond_set.condition.subs(x, p)}")
+print(f"Is condition S.true? {cond_set.condition.subs(x, p) is S.true}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ce7e4836c0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, Abs, Rational, imageset, Lambda, pi, asin, S, Interval
+from sympy.sets import ConditionSet, Contains
+from sympy.solvers.solveset import solveset_real
+
+print("=== Reproducing the issue ===")
+
+# First case: works correctly
+print("\n1. Working case with FiniteSet:")
+x, y, n = symbols('x y n')
+result1 = solveset_real(Abs(x) - y, x)
+print("solveset_real(Abs(x) - y, x):")
+print(result1)
+
+subs1 = result1.subs(y, Rational(1, 3))
+print("\nAfter subs(y, Rational(1, 3)):")
+print(subs1)
+
+# Second case: the problematic case
+print("\n2. Problematic case with ImageSet:")
+y = symbols('y')
+img_set = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+print("imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers):")
+print(img_set)
+
+cond_set = ConditionSet(x, Contains(y, Interval(-1,1)), img_set)
+print("\nConditionSet(x, Contains(y, Interval(-1,1)), img_set):")
+print(cond_set)
+
+subs2 = cond_set.subs(y, Rational(1, 3))
+print("\nAfter subs(y, Rational(1, 3)):")
+print(subs2)
+
+# Working alternatives
+print("\n3. Working alternatives:")
+xreplace_result = cond_set.xreplace({y: Rational(1, 3)})
+print("xreplace result:")
+print(xreplace_result)
+
+simultaneous_result = cond_set.subs({y: Rational(1, 3)}, simultaneous=True)
+print("\nSimultaneous subs result:")
+print(simultaneous_result)
+
+print("\n=== Issue analysis ===")
+print("The plain subs() gives wrong result, while xreplace() and simultaneous=True work correctly")
\ No newline at end of file
diff --git a/test_condition_true.py b/test_condition_true.py
new file mode 100644
index 0000000000..120237ec31
--- /dev/null
+++ b/test_condition_true.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, S, Interval, Contains
+from sympy.sets import ConditionSet
+
+x, y = symbols('x y')
+
+# Create a ConditionSet where condition will become S.true after substitution
+cond_set = ConditionSet(x, Contains(y, Interval(-1, 1)), S.Integers)
+print("Original ConditionSet:")
+print(cond_set)
+
+# Substitute y with a value that makes Contains(y, Interval(-1,1)) become S.true
+result = cond_set.subs(y, S.Half)
+print("\nAfter subs(y, 1/2):")
+print(result)
+
+# Let's also check what the condition becomes after substitution
+print("\nCondition after substitution:")
+print(cond_set.condition.subs(y, S.Half))
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..064bb7a684
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, S, Interval, Contains, FiniteSet
+from sympy.sets import ConditionSet
+
+x, y, z = symbols('x y z')
+
+print("=== Testing edge cases ===")
+
+# Test 1: Condition becomes S.false
+print("\n1. Condition becomes S.false:")
+cond_set1 = ConditionSet(x, Contains(y, Interval(1, 2)), S.Integers)
+print("Original:", cond_set1)
+result1 = cond_set1.subs(y, S.Half)  # 1/2 is not in [1,2]
+print("After subs(y, 1/2):", result1)
+
+# Test 2: Condition remains unchanged
+print("\n2. Condition remains unchanged:")
+cond_set2 = ConditionSet(x, Contains(z, Interval(-1,1)), S.Integers)
+print("Original:", cond_set2)
+result2 = cond_set2.subs(y, S.Half)  # substituting y, not z
+print("After subs(y, 1/2):", result2)
+
+# Test 3: Condition becomes S.true with FiniteSet base
+print("\n3. Condition becomes S.true with FiniteSet base:")
+cond_set3 = ConditionSet(x, Contains(y, Interval(-1,1)), FiniteSet(1, 2, 3))
+print("Original:", cond_set3)
+result3 = cond_set3.subs(y, S.Half)
+print("After subs(y, 1/2):", result3)
+
+# Test 4: Regular substitution (not making condition S.true)
+print("\n4. Regular substitution:")
+cond_set4 = ConditionSet(x, x + y > 0, S.Integers)
+print("Original:", cond_set4)
+result4 = cond_set4.subs(y, 1)
+print("After subs(y, 1):", result4)
\ No newline at end of file