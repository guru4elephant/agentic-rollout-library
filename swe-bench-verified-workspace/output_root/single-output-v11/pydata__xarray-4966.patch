diff --git a/final_test.py b/final_test.py
new file mode 100644
index 00000000..686ed4d8
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,90 @@
+import numpy as np
+import xarray as xr
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+
+def test_unsigned_integer_coder():
+    """Comprehensive test for UnsignedIntegerCoder functionality"""
+    coder = UnsignedIntegerCoder()
+    
+    print("=== Testing UnsignedIntegerCoder ===")
+    
+    # Test 1: Original issue - unsigned bytes with _Unsigned="false" (OPeNDAP hack)
+    print("\n1. Testing OPeNDAP hack: unsigned bytes with _Unsigned='false'")
+    unsigned_bytes = np.array([128, 255, 0, 1, 2, 255, 127], dtype=np.uint8)
+    variable = Variable(dims=['test'], data=unsigned_bytes, attrs={'_Unsigned': 'false'})
+    result = coder.decode(variable, name='test')
+    expected = np.array([-128, -1, 0, 1, 2, -1, 127], dtype=np.int8)
+    assert np.array_equal(result.data, expected)
+    assert result.data.dtype == np.int8
+    assert '_Unsigned' not in result.attrs
+    print("✓ PASS: Unsigned bytes correctly converted to signed bytes")
+    
+    # Test 2: Normal case - unsigned bytes with _Unsigned="true"
+    print("\n2. Testing normal case: unsigned bytes with _Unsigned='true'")
+    variable = Variable(dims=['test'], data=unsigned_bytes, attrs={'_Unsigned': 'true'})
+    result = coder.decode(variable, name='test')
+    assert np.array_equal(result.data, unsigned_bytes)
+    assert result.data.dtype == np.uint8
+    assert '_Unsigned' not in result.attrs
+    print("✓ PASS: Unsigned bytes remain unsigned")
+    
+    # Test 3: Normal case - signed bytes with _Unsigned="true"
+    print("\n3. Testing normal case: signed bytes with _Unsigned='true'")
+    signed_bytes = np.array([-128, -1, 0, 1, 2, -1, 127], dtype=np.int8)
+    variable = Variable(dims=['test'], data=signed_bytes, attrs={'_Unsigned': 'true'})
+    result = coder.decode(variable, name='test')
+    expected_unsigned = np.array([128, 255, 0, 1, 2, 255, 127], dtype=np.uint8)
+    assert np.array_equal(result.data, expected_unsigned)
+    assert result.data.dtype == np.uint8
+    assert '_Unsigned' not in result.attrs
+    print("✓ PASS: Signed bytes correctly converted to unsigned bytes")
+    
+    # Test 4: Edge case - signed bytes with _Unsigned="false"
+    print("\n4. Testing edge case: signed bytes with _Unsigned='false'")
+    variable = Variable(dims=['test'], data=signed_bytes, attrs={'_Unsigned': 'false'})
+    result = coder.decode(variable, name='test')
+    assert np.array_equal(result.data, signed_bytes)
+    assert result.data.dtype == np.int8
+    assert '_Unsigned' not in result.attrs
+    print("✓ PASS: Signed bytes remain signed")
+    
+    # Test 5: Non-integer data with _Unsigned attribute should warn
+    print("\n5. Testing non-integer data with _Unsigned attribute")
+    float_data = np.array([1.0, 2.0, 3.0], dtype=np.float32)
+    variable = Variable(dims=['test'], data=float_data, attrs={'_Unsigned': 'false'})
+    warnings.filterwarnings("error", category=xr.conventions.SerializationWarning)
+    try:
+        result = coder.decode(variable, name='test')
+        print("✗ FAIL: Should have raised warning")
+    except xr.conventions.SerializationWarning:
+        print("✓ PASS: Warning correctly raised for non-integer data")
+    except Exception as e:
+        print(f"✗ FAIL: Unexpected error: {e}")
+    
+    # Test 6: Different integer sizes (u2/i2, u4/i4)
+    print("\n6. Testing different integer sizes")
+    unsigned_short = np.array([32768, 65535, 0], dtype=np.uint16)
+    variable = Variable(dims=['test'], data=unsigned_short, attrs={'_Unsigned': 'false'})
+    result = coder.decode(variable, name='test')
+    expected_short = np.array([-32768, -1, 0], dtype=np.int16)
+    assert np.array_equal(result.data, expected_short)
+    assert result.data.dtype == np.int16
+    print("✓ PASS: Unsigned short correctly converted to signed short")
+    
+    # Test 7: Fill value handling
+    print("\n7. Testing fill value handling")
+    unsigned_with_fill = np.array([128, 255, 0], dtype=np.uint8)
+    variable = Variable(dims=['test'], data=unsigned_with_fill, attrs={
+        '_Unsigned': 'false', 
+        '_FillValue': 255
+    })
+    result = coder.decode(variable, name='test')
+    assert result.attrs['_FillValue'] == -1  # Should be converted to signed equivalent
+    print("✓ PASS: Fill value correctly converted")
+    
+    print("\n=== All tests passed! ===")
+
+if __name__ == "__main__":
+    test_unsigned_integer_coder()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..03043c94
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+import xarray as xr
+import warnings
+
+# Capture warnings to see the issue
+warnings.filterwarnings("error", category=xr.conventions.SerializationWarning)
+
+try:
+    print("Testing with netcdf4 engine:")
+    ds_netcdf4 = xr.open_dataset(
+        "https://observations.ipsl.fr/thredds/dodsC/EUREC4A/PRODUCTS/testdata/netcdf_testfiles/test_NC_BYTE_neg.nc", 
+        engine="netcdf4"
+    )
+    print(f"netcdf4 result: {ds_netcdf4['test'].values}")
+    print("netcdf4 test coordinate values:", ds_netcdf4.coords['test'].values)
+except Exception as e:
+    print(f"netcdf4 error: {e}")
+
+try:
+    print("\nTesting with pydap engine:")
+    ds_pydap = xr.open_dataset(
+        "https://observations.ipsl.fr/thredds/dodsC/EUREC4A/PRODUCTS/testdata/netcdf_testfiles/test_NC_BYTE_neg.nc", 
+        engine="pydap"
+    )
+    print(f"pydap result: {ds_pydap['test'].values}")
+    print("pydap test coordinate values:", ds_pydap.coords['test'].values)
+except Exception as e:
+    print(f"pydap error: {e}")
\ No newline at end of file
diff --git a/test_comprehensive_unsigned.py b/test_comprehensive_unsigned.py
new file mode 100644
index 00000000..e319f141
--- /dev/null
+++ b/test_comprehensive_unsigned.py
@@ -0,0 +1,82 @@
+import numpy as np
+import xarray as xr
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+
+def test_case(name, data, attrs, expected_dtype):
+    """Test a specific case and verify the result"""
+    print(f"\n=== Testing {name} ===")
+    variable = Variable(dims=['test'], data=data, attrs=attrs)
+    coder = UnsignedIntegerCoder()
+    
+    try:
+        result = coder.decode(variable, name='test')
+        print(f"Input data: {data}")
+        print(f"Input dtype: {data.dtype}")
+        print(f"Output data: {result.data}")
+        print(f"Output dtype: {result.data.dtype}")
+        print(f"Expected dtype: {expected_dtype}")
+        print(f"Attributes: {result.attrs}")
+        
+        # Verify dtype conversion
+        if result.data.dtype == expected_dtype:
+            print("✓ PASS: Correct dtype conversion")
+        else:
+            print("✗ FAIL: Incorrect dtype conversion")
+            
+        # Verify _Unsigned attribute is removed
+        if "_Unsigned" not in result.attrs:
+            print("✓ PASS: _Unsigned attribute removed")
+        else:
+            print("✗ FAIL: _Unsigned attribute not removed")
+            
+    except Exception as e:
+        print(f"Error: {e}")
+
+# Test cases
+
+# 1. Original case: unsigned bytes with _Unsigned="false" (OPeNDAP hack)
+test_case(
+    "Unsigned bytes with _Unsigned=False",
+    np.array([128, 255, 0, 1, 2, 255, 127], dtype=np.uint8),
+    {"_Unsigned": "false"},
+    np.int8
+)
+
+# 2. Regular case: unsigned bytes with _Unsigned="true" (should remain unsigned)
+test_case(
+    "Unsigned bytes with _Unsigned=True",
+    np.array([128, 255, 0, 1, 2, 255, 127], dtype=np.uint8),
+    {"_Unsigned": "true"},
+    np.uint8
+)
+
+# 3. Signed bytes with _Unsigned="true" (should become unsigned)
+test_case(
+    "Signed bytes with _Unsigned=True",
+    np.array([-128, -1, 0, 1, 2, -1, 127], dtype=np.int8),
+    {"_Unsigned": "true"},
+    np.uint8
+)
+
+# 4. Signed bytes with _Unsigned="false" (should remain signed)
+test_case(
+    "Signed bytes with _Unsigned=False",
+    np.array([-128, -1, 0, 1, 2, -1, 127], dtype=np.int8),
+    {"_Unsigned": "false"},
+    np.int8
+)
+
+# 5. Non-integer type with _Unsigned attribute (should warn)
+print("\n=== Testing non-integer type with _Unsigned ===")
+variable = Variable(dims=['test'], data=np.array([1.0, 2.0, 3.0]), attrs={"_Unsigned": "false"})
+coder = UnsignedIntegerCoder()
+warnings.filterwarnings("error", category=xr.conventions.SerializationWarning)
+try:
+    result = coder.decode(variable, name='test')
+    print("Unexpected success - should have warned")
+except xr.conventions.SerializationWarning as w:
+    print(f"✓ PASS: Warning correctly raised: {w}")
+except Exception as e:
+    print(f"Error: {e}")
\ No newline at end of file
diff --git a/test_unsigned_bytes.py b/test_unsigned_bytes.py
new file mode 100644
index 00000000..411aceb0
--- /dev/null
+++ b/test_unsigned_bytes.py
@@ -0,0 +1,31 @@
+import numpy as np
+import xarray as xr
+from xarray.coding.variables import UnsignedIntegerCoder
+from xarray.core.variable import Variable
+import warnings
+
+# Create test data that simulates the OPeNDAP case
+# Unsigned bytes with _Unsigned=False attribute
+unsigned_bytes = np.array([128, 255, 0, 1, 2, 255, 127], dtype=np.uint8)
+attrs = {"_Unsigned": "false"}
+
+variable = Variable(dims=['test'], data=unsigned_bytes, attrs=attrs)
+
+# Test the current decoder
+coder = UnsignedIntegerCoder()
+warnings.filterwarnings("error", category=xr.conventions.SerializationWarning)
+
+try:
+    result = coder.decode(variable, name='test')
+    print("Decoded variable:", result)
+    print("Data:", result.data)
+    print("Data type:", result.data.dtype)
+    print("Attributes:", result.attrs)
+except xr.conventions.SerializationWarning as w:
+    print("Warning caught:", w)
+except Exception as e:
+    print("Error:", e)
+
+# Expected behavior: 
+# Since _Unsigned="false" and data is unsigned bytes (u1),
+# it should convert to signed bytes (i1) with proper handling of values > 127
\ No newline at end of file
diff --git a/xarray/coding/variables.py b/xarray/coding/variables.py
index b035ff82..938752c4 100644
--- a/xarray/coding/variables.py
+++ b/xarray/coding/variables.py
@@ -316,6 +316,14 @@ class UnsignedIntegerCoder(VariableCoder):
                     if "_FillValue" in attrs:
                         new_fill = unsigned_dtype.type(attrs["_FillValue"])
                         attrs["_FillValue"] = new_fill
+            elif data.dtype.kind == "u":
+                if unsigned == "false":
+                    signed_dtype = np.dtype("i%s" % data.dtype.itemsize)
+                    transform = partial(np.asarray, dtype=signed_dtype)
+                    data = lazy_elemwise_func(data, transform, signed_dtype)
+                    if "_FillValue" in attrs:
+                        new_fill = signed_dtype.type(attrs["_FillValue"])
+                        attrs["_FillValue"] = new_fill
             else:
                 warnings.warn(
                     "variable %r has _Unsigned attribute but is not "