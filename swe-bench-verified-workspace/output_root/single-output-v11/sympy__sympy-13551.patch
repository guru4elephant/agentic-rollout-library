diff --git a/analyze_pattern.py b/analyze_pattern.py
new file mode 100644
index 0000000000..cd24471691
--- /dev/null
+++ b/analyze_pattern.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Let's analyze the pattern for small n values
+for n_val in range(1, 5):
+    print(f"n = {n_val}:")
+    
+    # Manual calculation
+    manual_product = 1
+    for i in range(n_val):
+        term = n_val + 1/2**i
+        manual_product *= term
+        print(f"  k={i}: {term}")
+    
+    print(f"  Manual result: {manual_product}")
+    
+    # SymPy calculation
+    sympy_product = Product(n + 1/2**k, (k, 0, n-1)).doit().subs(n, n_val)
+    print(f"  SymPy result: {sympy_product}")
+    
+    # Check if they match
+    if manual_product == sympy_product:
+        print("  ✓ CORRECT")
+    else:
+        print("  ✗ INCORRECT")
+    print()
\ No newline at end of file
diff --git a/debug_as_numer_denom.py b/debug_as_numer_denom.py
new file mode 100644
index 0000000000..13303466af
--- /dev/null
+++ b/debug_as_numer_denom.py
@@ -0,0 +1,29 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Test the as_numer_denom() behavior
+term = n + 1/2**k
+print("Original term:")
+print(term)
+print()
+
+p, q = term.as_numer_denom()
+print("Numerator (p):")
+print(p)
+print()
+
+print("Denominator (q):")
+print(q)
+print()
+
+print("p.as_coeff_Add():")
+print(p.as_coeff_Add())
+print()
+
+# Test what happens when we try to evaluate the product of the denominator
+print("Evaluating product of denominator q:")
+try:
+    q_product = Product(q, (k, 0, n-1)).doit()
+    print(q_product)
+except Exception as e:
+    print(f"Error: {e}")
\ No newline at end of file
diff --git a/debug_free_symbols.py b/debug_free_symbols.py
new file mode 100644
index 0000000000..fb12b3e33d
--- /dev/null
+++ b/debug_free_symbols.py
@@ -0,0 +1,33 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Test free_symbols behavior
+term = n + 1/2**k
+print("Original term free symbols:")
+print(term.free_symbols)
+print()
+
+# Substitute n=2
+term_substituted = term.subs(n, 2)
+print("After substituting n=2:")
+print(term_substituted)
+print("Free symbols:")
+print(term_substituted.free_symbols)
+print()
+
+# Check pattern matching
+from sympy import Wild
+a_wild = Wild('a', exclude=[k])
+b_wild = Wild('b', exclude=[k])
+q_wild = Wild('q', exclude=[k])
+
+pattern_match = term_substituted.match(a_wild * q_wild**k + b_wild)
+print("Pattern match result:")
+print(pattern_match)
+if pattern_match:
+    print("a_val:", pattern_match[a_wild])
+    print("b_val:", pattern_match[b_wild])
+    print("q_val:", pattern_match[q_wild])
+    print("Free symbols in a_val:", pattern_match[a_wild].free_symbols)
+    print("Free symbols in b_val:", pattern_match[b_val].free_symbols)
+    print("Free symbols in q_val:", pattern_match[q_val].free_symbols)
\ No newline at end of file
diff --git a/debug_numerator.py b/debug_numerator.py
new file mode 100644
index 0000000000..cdb71c7338
--- /dev/null
+++ b/debug_numerator.py
@@ -0,0 +1,19 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Test what happens when we try to evaluate the product of the numerator
+p = 2**k*n + 1
+print("Numerator p:")
+print(p)
+print()
+
+print("Trying to compute Product(p, (k, 0, n-1)).doit():")
+try:
+    p_product = Product(p, (k, 0, n-1)).doit()
+    print(p_product)
+    print()
+    
+    print("Substitute n=2:")
+    print(p_product.subs(n, 2))
+except Exception as e:
+    print(f"Error: {e}")
\ No newline at end of file
diff --git a/debug_original.py b/debug_original.py
new file mode 100644
index 0000000000..61773190a1
--- /dev/null
+++ b/debug_original.py
@@ -0,0 +1,29 @@
+from sympy import *
+from sympy.abc import n,k
+
+term = n + 1/2**k
+print("Original term:", term)
+print()
+
+# Check as_numer_denom
+p, q = term.as_numer_denom()
+print("After as_numer_denom():")
+print("Numerator p:", p)
+print("Denominator q:", q)
+print()
+
+# Check pattern matching on numerator
+from sympy import Wild
+a_wild = Wild('a', exclude=[k])
+b_wild = Wild('b', exclude=[k])
+q_wild = Wild('q', exclude=[k])
+
+pattern_match = p.match(a_wild * q_wild**k + b_wild)
+print("Pattern match on numerator:", pattern_match)
+if pattern_match:
+    print("a_val:", pattern_match[a_wild])
+    print("b_val:", pattern_match[b_wild])
+    print("q_val:", pattern_match[q_wild])
+    print("Free symbols in a_val:", pattern_match[a_wild].free_symbols)
+    print("Free symbols in b_val:", pattern_match[b_wild].free_symbols)
+    print("Free symbols in q_val:", pattern_match[q_wild].free_symbols)
\ No newline at end of file
diff --git a/debug_pattern.py b/debug_pattern.py
new file mode 100644
index 0000000000..6fd91c675a
--- /dev/null
+++ b/debug_pattern.py
@@ -0,0 +1,27 @@
+from sympy import *
+from sympy.abc import n,k
+
+term = 2 + 2**(-k)
+print("Term:", term)
+print()
+
+from sympy import Wild
+a_wild = Wild('a', exclude=[k])
+b_wild = Wild('b', exclude=[k])
+q_wild = Wild('q', exclude=[k])
+
+# Try different patterns
+print("Trying pattern: a * q**k + b")
+pattern_match = term.match(a_wild * q_wild**k + b_wild)
+print("Result:", pattern_match)
+print()
+
+print("Trying pattern: b + a * q**k")
+pattern_match = term.match(b_wild + a_wild * q_wild**k)
+print("Result:", pattern_match)
+print()
+
+print("Trying pattern: b + c**k")
+c_wild = Wild('c', exclude=[k])
+pattern_match = term.match(b_wild + c_wild**k)
+print("Result:", pattern_match)
\ No newline at end of file
diff --git a/debug_specific_case.py b/debug_specific_case.py
new file mode 100644
index 0000000000..d3268f2096
--- /dev/null
+++ b/debug_specific_case.py
@@ -0,0 +1,37 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Let's debug the specific case step by step
+term = n + 1/2**k
+print("Original term:")
+print(term)
+print()
+
+# Step 1: as_numer_denom()
+p, q = term.as_numer_denom()
+print("After as_numer_denom():")
+print("Numerator p:", p)
+print("Denominator q:", q)
+print()
+
+# Step 2: Evaluate product of denominator
+print("Product of denominator q:")
+q_product = Product(q, (k, 0, n-1)).doit()
+print(q_product)
+print()
+
+# Step 3: Evaluate product of numerator  
+print("Product of numerator p:")
+p_product = Product(p, (k, 0, n-1)).doit()
+print(p_product)
+print()
+
+# Step 4: Final result
+print("Final result (p_product / q_product):")
+final_result = p_product / q_product
+print(final_result)
+print()
+
+# Step 5: Substitute n=2
+print("Substitute n=2:")
+print(final_result.subs(n, 2))
\ No newline at end of file
diff --git a/debug_structure.py b/debug_structure.py
new file mode 100644
index 0000000000..850c6740bb
--- /dev/null
+++ b/debug_structure.py
@@ -0,0 +1,27 @@
+from sympy import *
+from sympy.abc import n,k
+
+term = 2 + 2**(-k)
+print("Term:", term)
+print("Type:", type(term))
+print("Args:", term.args)
+print()
+
+# Check if it's an Add
+if term.is_Add:
+    print("Is Add:", True)
+    for i, arg in enumerate(term.args):
+        print(f"  Arg {i}: {arg} (type: {type(arg)})")
+        if arg.is_Pow:
+            print(f"    Base: {arg.base}")
+            print(f"    Exp: {arg.exp}")
+print()
+
+# Try to match the pattern more specifically
+from sympy import Wild
+b_wild = Wild('b', exclude=[k])
+pow_wild = Wild('pow', exclude=[k])
+
+# Try to match the pattern: b + something
+pattern_match = term.match(b_wild + pow_wild)
+print("Pattern match b + something:", pattern_match)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9c7c7c2f3a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,23 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Reproduce the issue
+p = Product(n + 1 / 2**k, [k, 0, n-1]).doit()
+print("Result from doit():")
+print(p)
+print()
+
+print("Simplified result:")
+simplified = simplify(p)
+print(simplified)
+print()
+
+print("Substitute n=2:")
+result_n2 = p.subs(n, 2)
+print(result_n2)
+print()
+
+print("Expected result for n=2:")
+print("(2 + 2^0) * (2 + 2^(-1)) = (2 + 1) * (2 + 0.5) = 3 * 2.5 = 7.5")
+print("7.5 should be represented as 15/2 in sympy")
+print("15/2 =", 15/2)
\ No newline at end of file
diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..50915e711f 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -275,18 +275,54 @@ def _eval_product(self, term, limits):
             return poly.LC()**(n - a + 1) * A * B
 
         elif term.is_Add:
+            # Check for patterns of the form a*q^k + b which need special handling
+            # This is a q-Pochhammer symbol and cannot be evaluated by simple decomposition
+            from sympy import Wild
+            a_wild = Wild('a', exclude=[k])
+            b_wild = Wild('b', exclude=[k])
+            q_wild = Wild('q', exclude=[k])
+            
+            # Pattern: a*q^k + b
+            pattern_match = term.match(a_wild * q_wild**k + b_wild)
+            if pattern_match and pattern_match[a_wild] != 0 and pattern_match[q_wild] != 1:
+                a_val = pattern_match[a_wild]
+                b_val = pattern_match[b_wild]
+                q_val = pattern_match[q_wild]
+                
+                # Only handle this as a special case if any of the parameters contain free symbols other than k
+                # If all parameters are concrete, let the normal evaluation proceed
+                if any(len(param.free_symbols.difference({k})) > 0 for param in [a_val, b_val, q_val]):
+                    # This is a q-Pochhammer symbol: ∏(a*q^k + b) from k=0 to n-1
+                    # For the specific case where b=1, we can express this in closed form
+                    if b_val == 1:
+                        from sympy import Product
+                        # ∏(a*q^k + 1) from k=0 to n-1 = (-a; q)_n / q^(n(n-1)/2)
+                        # where (-a; q)_n is the q-Pochhammer symbol
+                        # Since we don't have a direct q-Pochhammer function, we return the product unevaluated
+                        return None
+                    
+                    # For other cases, also return None to avoid incorrect results
+                    return None
+            
             p, q = term.as_numer_denom()
-            q = self._eval_product(q, (k, a, n))
-            if q.is_Number:
+            q_prod = self._eval_product(q, (k, a, n))
+            if q_prod is None:
+                return None
+                
+            if q_prod.is_Number:
 
                 # There is expression, which couldn't change by
                 # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).
                 # We have to catch this case.
 
-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])
+                p_prod = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])
             else:
-                p = self._eval_product(p, (k, a, n))
-            return p / q
+                p_prod = self._eval_product(p, (k, a, n))
+                
+            if p_prod is None:
+                return None
+                
+            return p_prod / q_prod
 
         elif term.is_Mul:
             exclude, include = [], []
diff --git a/test_concrete_values.py b/test_concrete_values.py
new file mode 100644
index 0000000000..fe615f61d0
--- /dev/null
+++ b/test_concrete_values.py
@@ -0,0 +1,28 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Test with concrete n values
+for n_val in range(1, 5):
+    print(f"n = {n_val}:")
+    
+    # Create the product with concrete n
+    product_expr = Product(n_val + 1/2**k, (k, 0, n_val-1))
+    print(f"  Product expression: {product_expr}")
+    
+    # Evaluate it
+    result = product_expr.doit()
+    print(f"  Result: {result}")
+    
+    # Manual calculation
+    manual_result = 1
+    for i in range(n_val):
+        term = n_val + 1/2**i
+        manual_result *= term
+    
+    print(f"  Expected: {manual_result}")
+    
+    if result == manual_result:
+        print("  ✓ CORRECT")
+    else:
+        print("  ✗ INCORRECT")
+    print()
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..a73ba2f983
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,28 @@
+from sympy import *
+from sympy.abc import n,k
+
+# Test the exact case from the GitHub issue
+p = Product(n + 1 / 2**k, [k, 0, n-1]).doit()
+print("Result from doit():")
+print(p)
+print()
+
+print("Simplified result:")
+simplified = simplify(p)
+print(simplified)
+print()
+
+print("Substitute n=2:")
+result_n2 = p.subs(n, 2)
+print(result_n2)
+print()
+
+# Now evaluate the substituted result
+if isinstance(result_n2, Product):
+    print("Evaluating the substituted product:")
+    evaluated = result_n2.doit()
+    print(evaluated)
+    print("This should be 15/2 =", 15/2)
+else:
+    print("Result is already evaluated:", result_n2)
+    print("This should be 15/2 =", 15/2)
\ No newline at end of file