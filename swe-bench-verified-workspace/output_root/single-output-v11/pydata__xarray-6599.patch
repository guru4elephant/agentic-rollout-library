diff --git a/debug_conversion.py b/debug_conversion.py
new file mode 100644
index 00000000..195ce05a
--- /dev/null
+++ b/debug_conversion.py
@@ -0,0 +1,30 @@
+import xarray as xr
+import numpy as np
+from xarray.core.computation import _ensure_numeric
+
+values = np.array(
+    [
+        "2021-04-01T05:25:19.000000000",
+        "2021-04-01T05:25:29.000000000",
+        "2021-04-01T05:25:39.000000000",
+        "2021-04-01T05:25:49.000000000",
+        "2021-04-01T05:25:59.000000000",
+        "2021-04-01T05:26:09.000000000",
+    ],
+    dtype="datetime64[ns]",
+)
+azimuth_time = xr.DataArray(
+    values, name="azimuth_time", coords={"azimuth_time": values - values[0]}
+)
+
+print("Original azimuth_time:")
+print(azimuth_time)
+print("Coordinates dtype:", azimuth_time.coords['azimuth_time'].dtype)
+print("Coordinates values:", azimuth_time.coords['azimuth_time'].values)
+
+# Test the conversion
+converted = _ensure_numeric(azimuth_time)
+print("\nAfter _ensure_numeric conversion:")
+print(converted)
+print("Coordinates dtype:", converted.coords['azimuth_time'].dtype)
+print("Coordinates values:", converted.coords['azimuth_time'].values)
\ No newline at end of file
diff --git a/debug_mixed_case.py b/debug_mixed_case.py
new file mode 100644
index 00000000..9e4711ef
--- /dev/null
+++ b/debug_mixed_case.py
@@ -0,0 +1,29 @@
+import xarray as xr
+import numpy as np
+
+values = np.array(['2021-01-01T00:00:00', '2021-01-01T00:00:01'], dtype='datetime64[s]')
+coord_mixed = xr.DataArray(values, dims='time', coords={'time': values - values[0]})
+coeffs_mixed = xr.DataArray([1, 2, 3], dims='degree', coords={'degree': [0, 1, 2]})
+
+print("Mixed case coord:")
+print(coord_mixed)
+print("Coordinates:", coord_mixed.coords['time'].values)
+print("Coordinates dtype:", coord_mixed.coords['time'].dtype)
+
+# Let's see what happens in the polyval function
+from xarray.core.computation import _ensure_numeric
+
+# Test the conversion
+converted_coords = _ensure_numeric(coord_mixed.coords['time'])
+print("\nConverted coordinates:")
+print(converted_coords.values)
+print("dtype:", converted_coords.dtype)
+
+# Manual polynomial evaluation to see what we should get
+x_values = converted_coords.values
+coeffs = [1, 2, 3]  # 1 + 2x + 3x^2
+
+print("\nManual evaluation:")
+for x in x_values:
+    result = coeffs[0] + x*(coeffs[1] + x*coeffs[2])
+    print(f"x={x}: {result}")
\ No newline at end of file
diff --git a/debug_polyval.py b/debug_polyval.py
new file mode 100644
index 00000000..cbf25dce
--- /dev/null
+++ b/debug_polyval.py
@@ -0,0 +1,46 @@
+import xarray as xr
+import numpy as np
+from xarray.core.computation import _ensure_numeric, _ensure_numeric_coords
+
+values = np.array(
+    [
+        "2021-04-01T05:25:19.000000000",
+        "2021-04-01T05:25:29.000000000",
+        "2021-04-01T05:25:39.000000000",
+        "2021-04-01T05:25:49.000000000",
+        "2021-04-01T05:25:59.000000000",
+        "2021-04-01T05:26:09.000000000",
+    ],
+    dtype="datetime64[ns]",
+)
+azimuth_time = xr.DataArray(
+    values, name="azimuth_time", coords={"azimuth_time": values - values[0]}
+)
+
+polyfit_coefficients = xr.DataArray(
+    [
+        [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],
+        [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],
+        [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],
+        [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],
+        [4.44739216e06, 1.45053974e06, 5.29960857e06],
+    ],
+    dims=("degree", "axis"),
+    coords={"axis": [0, 1, 2], "degree": [4, 3, 2, 1, 0]},
+)
+
+print("Original azimuth_time coordinates:")
+print(azimuth_time.coords['azimuth_time'].values)
+print("dtype:", azimuth_time.coords['azimuth_time'].dtype)
+
+# Test the conversion
+converted_coords = _ensure_numeric(azimuth_time.coords['azimuth_time'])
+print("\nConverted coordinates:")
+print(converted_coords.values)
+print("dtype:", converted_coords.dtype)
+
+# Test the full conversion
+full_converted = _ensure_numeric_coords(_ensure_numeric(azimuth_time))
+print("\nFull converted azimuth_time:")
+print(full_converted)
+print("Coordinates values:", full_converted.coords['azimuth_time'].values)
\ No newline at end of file
diff --git a/manual_polyval_test.py b/manual_polyval_test.py
new file mode 100644
index 00000000..aef0df3d
--- /dev/null
+++ b/manual_polyval_test.py
@@ -0,0 +1,23 @@
+import numpy as np
+import xarray as xr
+
+# Test the polynomial evaluation manually
+# The polynomial coefficients are for a 4th degree polynomial
+# Let's evaluate at x = 0, 10, 20, 30, 40, 50 (nanoseconds)
+
+# Coefficients for axis 0: [4.44739216e06, 5.83965193e-06, -2.50272583e-18, -1.15316667e-30, 2.33333335e-43]
+# In standard polynomial form: c0 + c1*x + c2*x^2 + c3*x^3 + c4*x^4
+
+coeffs = [4.44739216e06, 5.83965193e-06, -2.50272583e-18, -1.15316667e-30, 2.33333335e-43]
+x_values = [0, 10, 20, 30, 40, 50]  # nanoseconds
+
+print("Manual polynomial evaluation:")
+for x in x_values:
+    # Horner's method: c0 + x*(c1 + x*(c2 + x*(c3 + x*c4)))
+    result = coeffs[0] + x*(coeffs[1] + x*(coeffs[2] + x*(coeffs[3] + x*coeffs[4])))
+    print(f"x={x}: {result}")
+
+print("\nExpected values from xarray 2022.3.0:")
+expected = [4447392.16, 4505537.25588366, 4563174.92026797, 4620298.31815291, 4676900.67053846, 4732975.25442459]
+for i, x in enumerate(x_values):
+    print(f"x={x}: {expected[i]}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..90c317a3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,40 @@
+import xarray as xr
+import numpy as np
+
+values = np.array(
+    [
+        "2021-04-01T05:25:19.000000000",
+        "2021-04-01T05:25:29.000000000",
+        "2021-04-01T05:25:39.000000000",
+        "2021-04-01T05:25:49.000000000",
+        "2021-04-01T05:25:59.000000000",
+        "2021-04-01T05:26:09.000000000",
+    ],
+    dtype="datetime64[ns]",
+)
+azimuth_time = xr.DataArray(
+    values, name="azimuth_time", coords={"azimuth_time": values - values[0]}
+)
+
+polyfit_coefficients = xr.DataArray(
+    [
+        [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],
+        [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],
+        [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],
+        [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],
+        [4.44739216e06, 1.45053974e06, 5.29960857e06],
+    ],
+    dims=("degree", "axis"),
+    coords={"axis": [0, 1, 2], "degree": [4, 3, 2, 1, 0]},
+)
+
+print("Input azimuth_time:")
+print(azimuth_time)
+print("\nInput polyfit_coefficients:")
+print(polyfit_coefficients)
+print("\nResult of polyval:")
+result = xr.polyval(azimuth_time, polyfit_coefficients)
+print(result)
+print("\nResult dtype:", result.dtype)
+print("\nResult values:")
+print(result.values)
\ No newline at end of file
diff --git a/test_datetime_conversion.py b/test_datetime_conversion.py
new file mode 100644
index 00000000..a2e3a0b8
--- /dev/null
+++ b/test_datetime_conversion.py
@@ -0,0 +1,19 @@
+import numpy as np
+from xarray.core.duck_array_ops import datetime_to_numeric
+
+# Test with timedelta64 array
+timedelta_array = np.array([0, 10, 20, 30, 40, 50], dtype='timedelta64[ns]')
+print("Original timedelta64 array:", timedelta_array)
+print("dtype:", timedelta_array.dtype)
+
+# Test with the current implementation (with offset)
+result_with_offset = datetime_to_numeric(timedelta_array, offset=np.datetime64("1970-01-01"), datetime_unit="ns")
+print("With offset (current):", result_with_offset)
+
+# Test without offset (what it should be)
+result_without_offset = datetime_to_numeric(timedelta_array, offset=None, datetime_unit="ns")
+print("Without offset (correct):", result_without_offset)
+
+# Test with manual conversion (what we expect)
+manual_conversion = timedelta_array / np.timedelta64(1, 'ns')
+print("Manual conversion:", manual_conversion)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..3bbf0886
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,24 @@
+import xarray as xr
+import numpy as np
+
+print("Test 1: Regular numeric coordinates (should work as before)")
+coord_numeric = xr.DataArray([1, 2, 3, 4, 5], dims='x', coords={'x': [1, 2, 3, 4, 5]})
+coeffs_numeric = xr.DataArray([1, 2, 1], dims='degree', coords={'degree': [0, 1, 2]})
+result1 = xr.polyval(coord_numeric, coeffs_numeric)
+print("Numeric result:", result1.values)
+
+print("\nTest 2: Datetime64 coordinates")
+dates = np.array(['2021-01-01', '2021-01-02', '2021-01-03'], dtype='datetime64[D]')
+coord_datetime = xr.DataArray(dates, dims='time', coords={'time': dates})
+coeffs_datetime = xr.DataArray([1, 0.1, 0.01], dims='degree', coords={'degree': [0, 1, 2]})
+result2 = xr.polyval(coord_datetime, coeffs_datetime)
+print("Datetime result shape:", result2.shape)
+
+print("\nTest 3: Mixed case (datetime data, timedelta coordinates - the original issue)")
+values = np.array(['2021-01-01T00:00:00', '2021-01-01T00:00:01'], dtype='datetime64[s]')
+coord_mixed = xr.DataArray(values, dims='time', coords={'time': values - values[0]})
+coeffs_mixed = xr.DataArray([1, 2, 3], dims='degree', coords={'degree': [0, 1, 2]})
+result3 = xr.polyval(coord_mixed, coeffs_mixed)
+print("Mixed case result:", result3.values)
+
+print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/test_proper_scaling.py b/test_proper_scaling.py
new file mode 100644
index 00000000..e204bbf1
--- /dev/null
+++ b/test_proper_scaling.py
@@ -0,0 +1,30 @@
+import xarray as xr
+import numpy as np
+
+print("Test with properly scaled coefficients (like the original issue)")
+
+# Create timedelta coordinates (1 second intervals)
+values = np.array(['2021-01-01T00:00:00', '2021-01-01T00:00:01', '2021-01-01T00:00:02'], 
+                  dtype='datetime64[s]')
+coord_mixed = xr.DataArray(values, dims='time', coords={'time': values - values[0]})
+
+# Coefficients scaled for nanosecond values (like the original issue)
+# These should produce reasonable results when evaluated at 0, 1e9, 2e9 nanoseconds
+coeffs_mixed = xr.DataArray([
+    [1e-9, 2e-9],    # x term coefficients
+    [1.0, 2.0],       # constant term coefficients
+], dims=('degree', 'axis'), coords={'degree': [1, 0], 'axis': [0, 1]})
+
+result = xr.polyval(coord_mixed, coeffs_mixed)
+print("Result with properly scaled coefficients:")
+print(result.values)
+
+# The expected results should be:
+# For axis 0: 1.0 + 1e-9 * x
+# For axis 1: 2.0 + 2e-9 * x  
+# Where x is 0, 1e9, 2e9 nanoseconds
+
+print("\nExpected results:")
+x_values = [0, 1e9, 2e9]
+for axis in [0, 1]:
+    print(f"Axis {axis}:", [2.0 + 2e-9 * x if axis == 1 else 1.0 + 1e-9 * x for x in x_values])
\ No newline at end of file
diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 823cbe02..5eb518fe 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1905,6 +1905,15 @@ def polyval(
     coeffs = coeffs.reindex(
         {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False
     )
+    # For polynomial evaluation, we should use the coordinates if they exist
+    # This handles the case where coord has datetime64 data but timedelta64 coordinates
+    if hasattr(coord, 'coords') and len(coord.coords) > 0:
+        # Use the first coordinate if it has the same dimension as the data
+        coord_dims = list(coord.dims)
+        coord_coord_dims = list(coord.coords.keys())
+        if len(coord_dims) == 1 and coord_dims[0] in coord_coord_dims:
+            coord = coord.coords[coord_dims[0]]
+    
     coord = _ensure_numeric(coord)  # type: ignore # https://github.com/python/mypy/issues/1533 ?
 
     # using Horner's method
@@ -1933,7 +1942,7 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
     from .dataset import Dataset
 
     def to_floatable(x: DataArray) -> DataArray:
-        if x.dtype.kind in "mM":
+        if x.dtype.kind == "M":  # datetime64
             return x.copy(
                 data=datetime_to_numeric(
                     x.data,
@@ -1941,6 +1950,14 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
                     datetime_unit="ns",
                 ),
             )
+        elif x.dtype.kind == "m":  # timedelta64
+            return x.copy(
+                data=datetime_to_numeric(
+                    x.data,
+                    offset=None,
+                    datetime_unit="ns",
+                ),
+            )
         return x
 
     if isinstance(data, Dataset):
@@ -1949,6 +1966,41 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
         return to_floatable(data)
 
 
+def _ensure_numeric_coords(data: T_Xarray) -> T_Xarray:
+    """Converts all datetime64 coordinates to float64
+    
+    Parameters
+    ----------
+    data : DataArray or Dataset
+        Variables with possible datetime coordinates.
+    
+    Returns
+    -------
+    DataArray or Dataset
+        Variables with datetime64 coordinates converted to float64.
+    """
+    from .dataset import Dataset
+    
+    if isinstance(data, Dataset):
+        # For Dataset, ensure all coordinates are numeric
+        new_coords = {}
+        for name, coord in data.coords.items():
+            if coord.dtype.kind in "mM":
+                new_coords[name] = _ensure_numeric(coord)
+            else:
+                new_coords[name] = coord
+        return data.assign_coords(new_coords)
+    else:
+        # For DataArray, ensure all coordinates are numeric
+        new_coords = {}
+        for name, coord in data.coords.items():
+            if coord.dtype.kind in "mM":
+                new_coords[name] = _ensure_numeric(coord)
+            else:
+                new_coords[name] = coord
+        return data.assign_coords(new_coords)
+
+
 def _calc_idxminmax(
     *,
     array,