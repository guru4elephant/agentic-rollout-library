diff --git a/debug_add_is_zero.py b/debug_add_is_zero.py
new file mode 100644
index 0000000000..f35df8c405
--- /dev/null
+++ b/debug_add_is_zero.py
@@ -0,0 +1,70 @@
+#!/usr/bin/env python3
+
+from sympy import I, Add
+
+# Test the _eval_is_zero method directly with detailed debugging
+e = -2*I + (1 + I)**2
+print("Expression:", e)
+print("e._eval_is_zero():", e._eval_is_zero())
+
+# Let's manually trace through the _eval_is_zero method
+print("\nManual trace of _eval_is_zero:")
+print("self.is_commutative:", e.is_commutative)
+
+nz = []
+z = 0
+im_or_z = False
+im = False
+
+for i, a in enumerate(e.args):
+    print(f"\nArgument {i}: {a}")
+    print(f"  a.is_real: {a.is_real}")
+    print(f"  a.is_imaginary: {a.is_imaginary}")
+    print(f"  a.is_zero: {a.is_zero}")
+    
+    if a.is_real:
+        if a.is_zero:
+            z += 1
+            print(f"    Added to z, z={z}")
+        elif a.is_zero is False:
+            nz.append(a)
+            print(f"    Added to nz, nz={nz}")
+        else:
+            print("    Returning None from real branch")
+            # return None
+    elif a.is_imaginary:
+        im = True
+        print(f"    Setting im=True")
+    elif (I*a).is_real:
+        im_or_z = True
+        print(f"    Setting im_or_z=True")
+    else:
+        print("    Returning None from else branch")
+        # return None
+
+print(f"\nAfter loop:")
+print(f"z: {z}")
+print(f"nz: {nz}")
+print(f"im_or_z: {im_or_z}")
+print(f"im: {im}")
+
+if z == len(e.args):
+    print("All arguments are zero, returning True")
+    # return True
+
+if len(nz) == len(e.args):
+    print("All arguments are non-zero, returning None")
+    # return None
+
+b = Add(*nz)
+print(f"b = Add(*nz) = {b}")
+print(f"b.is_zero: {b.is_zero}")
+
+if b.is_zero:
+    if not im_or_z and not im:
+        print("b.is_zero is True and no imaginary parts, returning True")
+    if im and not im_or_z:
+        print("b.is_zero is True and imaginary parts, returning False")
+        
+if b.is_zero is False:
+    print("b.is_zero is False, returning False")
\ No newline at end of file
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..cd0763b67c
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+from sympy import I, simplify, ask, Q
+
+# Reproduce the issue from the GitHub issue
+e = -2*I + (1 + I)**2
+print("Expression:", e)
+print("e.is_zero:", e.is_zero)
+print("simplify(e).is_zero:", simplify(e).is_zero)
+
+# Let's also see what the simplified expression looks like
+simplified_e = simplify(e)
+print("Simplified expression:", simplified_e)
+print("Simplified expression type:", type(simplified_e))
+
+# Let's check what (1 + I)**2 evaluates to
+part1 = (1 + I)**2
+print("(1 + I)**2 =", part1)
+print("Type of (1 + I)**2:", type(part1))
+
+# Let's check if the expression is real
+print("e.is_real:", e.is_real)
+print("simplify(e).is_real:", simplified_e.is_real)
+
+# Let's check using the ask system
+print("ask(Q.zero(e)):", ask(Q.zero(e)))
+print("ask(Q.zero(simplify(e))):", ask(Q.zero(simplify(e))))
+
+# Let's check what ask(Q.nonzero(e)) returns
+print("ask(Q.nonzero(e)):", ask(Q.nonzero(e)))
+print("ask(Q.nonzero(simplify(e))):", ask(Q.nonzero(simplify(e))))
+
+# Let's check if the expression is real using ask
+print("ask(Q.real(e)):", ask(Q.real(e)))
+print("ask(Q.real(simplify(e))):", ask(Q.real(simplify(e))))
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d74a49e53a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,14 @@
+#!/usr/bin/env python3
+
+from sympy import I, simplify
+
+# Reproduce the issue from the GitHub issue
+e = -2*I + (1 + I)**2
+print("Expression:", e)
+print("e.is_zero:", e.is_zero)
+print("simplify(e).is_zero:", simplify(e).is_zero)
+
+# Let's also see what the simplified expression looks like
+simplified_e = simplify(e)
+print("Simplified expression:", simplified_e)
+print("Simplified expression type:", type(simplified_e))
\ No newline at end of file
diff --git a/sympy/core/add.py b/sympy/core/add.py
index 83a5f2aedc..99abb7049a 100644
--- a/sympy/core/add.py
+++ b/sympy/core/add.py
@@ -558,10 +558,9 @@ def _eval_is_zero(self):
             return None
         b = self.func(*nz)
         if b.is_zero:
-            if not im_or_z and not im:
-                return True
-            if im and not im_or_z:
-                return False
+            # If the sum of non-zero real parts is zero, then the entire
+            # expression is zero regardless of imaginary parts
+            return True
         if b.is_zero is False:
             return False
 
diff --git a/test_add_is_zero.py b/test_add_is_zero.py
new file mode 100644
index 0000000000..0e4a9ff599
--- /dev/null
+++ b/test_add_is_zero.py
@@ -0,0 +1,24 @@
+#!/usr/bin/env python3
+
+from sympy import I, Add
+
+# Test the _eval_is_zero method directly
+e = -2*I + (1 + I)**2
+print("Expression:", e)
+print("e._eval_is_zero():", e._eval_is_zero())
+
+# Let's examine the arguments
+print("Arguments:", e.args)
+for i, arg in enumerate(e.args):
+    print(f"arg[{i}]: {arg}")
+    print(f"  is_real: {arg.is_real}")
+    print(f"  is_imaginary: {arg.is_imaginary}")
+    print(f"  is_zero: {arg.is_zero}")
+    if not arg.is_real and not arg.is_imaginary:
+        imag_unit_test = (I * arg).is_real
+        print(f"  (I * arg).is_real: {imag_unit_test}")
+
+# Let's also test a simpler case that should work
+simple_expr = I + (-I)
+print("Simple expression:", simple_expr)
+print("simple_expr._eval_is_zero():", simple_expr._eval_is_zero())
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..5175ed0a3a
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python3
+
+from sympy import I, simplify
+
+# Test various edge cases to ensure our fix doesn't break anything
+
+# Case 1: Original issue - complex expression that simplifies to zero
+e1 = -2*I + (1 + I)**2
+print("Case 1 - Complex zero:")
+print("Expression:", e1)
+print("is_zero:", e1.is_zero)
+print("Simplified:", simplify(e1))
+print("Simplified is_zero:", simplify(e1).is_zero)
+
+# Case 2: Real expression that is zero
+from sympy import S
+e2 = S(1) - S(1)
+print("\nCase 2 - Real zero:")
+print("Expression:", e2)
+print("is_zero:", e2.is_zero)
+
+# Case 3: Real expression that is not zero
+e3 = S(1) + S(1)
+print("\nCase 3 - Real non-zero:")
+print("Expression:", e3)
+print("is_zero:", e3.is_zero)
+
+# Case 4: Complex expression that is not zero
+e4 = I + 1
+print("\nCase 4 - Complex non-zero:")
+print("Expression:", e4)
+print("is_zero:", e4.is_zero)
+
+# Case 5: Mixed real and imaginary that cancels to zero
+e5 = I + (-I)
+print("\nCase 5 - Imaginary cancellation:")
+print("Expression:", e5)
+print("is_zero:", e5.is_zero)
+
+# Case 6: More complex case with both real and imaginary parts
+e6 = (1 + I) + (1 - I) - 2
+print("\nCase 6 - Mixed cancellation:")
+print("Expression:", e6)
+print("is_zero:", e6.is_zero)
+print("Simplified:", simplify(e6))
+print("Simplified is_zero:", simplify(e6).is_zero)
+
+# Case 7: Expression that should return None (can't determine)
+e7 = I + I  # This is 2I, which is not zero
+print("\nCase 7 - Non-zero imaginary:")
+print("Expression:", e7)
+print("is_zero:", e7.is_zero)
+
+# Case 8: Expression with undefined symbols
+from sympy import Symbol
+x = Symbol('x')
+e8 = x - x
+print("\nCase 8 - Symbolic cancellation:")
+print("Expression:", e8)
+print("is_zero:", e8.is_zero)
\ No newline at end of file