diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 00000000..76133eab
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""
+Final verification that our fix handles all edge cases correctly
+"""
+
+def test_method_conversion(method):
+    """Test the exact conversion logic from our fix"""
+    print(f"Input: {method} (type: {type(method)})")
+    
+    # This is the exact logic from our fix in sessions.py
+    if isinstance(method, bytes):
+        method = method.decode('utf-8')
+        print(f"  After decode: {method} (type: {type(method)})")
+    if method is not None:
+        method = str(method)  # builtin_str is just str
+        print(f"  After builtin_str: {method} (type: {type(method)})")
+        method = method.upper()
+        print(f"  After upper: {method} (type: {type(method)})")
+    
+    return method
+
+# Test cases from the GitHub issue and edge cases
+test_cases = [
+    b'GET',      # The main issue from GitHub
+    b'POST',     # Other HTTP methods
+    b'DELETE',
+    b'PUT',
+    b'HEAD',
+    b'OPTIONS',
+    'GET',       # Regular strings (should not break)
+    'POST',
+    None,        # Edge case
+    b'',         # Empty bytes
+    '',          # Empty string
+]
+
+print("Testing method conversion logic:")
+print("=" * 50)
+
+for i, method in enumerate(test_cases):
+    print(f"\nTest case {i+1}:")
+    try:
+        result = test_method_conversion(method)
+        print(f"  Final result: {result} (type: {type(result)})")
+        
+        # Verify the result makes sense
+        if isinstance(method, bytes):
+            expected = method.decode('utf-8').upper()
+            if result == expected:
+                print(f"  ✓ PASS: Binary method converted correctly")
+            else:
+                print(f"  ✗ FAIL: Expected {expected}, got {result}")
+        elif method is None:
+            print(f"  ✓ PASS: None handled gracefully")
+        else:
+            expected = str(method).upper()
+            if result == expected:
+                print(f"  ✓ PASS: String method handled correctly")
+            else:
+                print(f"  ✗ FAIL: Expected {expected}, got {result}")
+                
+    except Exception as e:
+        print(f"  ✗ ERROR: {e}")
+
+print("\n" + "=" * 50)
+print("SUMMARY: Our fix should handle binary strings properly")
+print("while maintaining backward compatibility.")
+print("=" * 50)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..4a0697f0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with builtin_str converting binary strings
+to literal string representations instead of proper decoded strings.
+"""
+
+from requests.compat import builtin_str
+
+# Simulate the issue described in the GitHub issue
+# This is what happens when neutronclient passes a binary string
+binary_method = b'GET'
+print(f"Original binary method: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+# This is what requests does currently
+converted_method = builtin_str(binary_method)
+print(f"After builtin_str conversion: {converted_method}")
+print(f"Type: {type(converted_method)}")
+
+# This causes the issue - the method becomes "b'GET'" instead of "GET"
+print(f"Upper case version: {converted_method.upper()}")
+
+# Expected behavior would be to decode the binary string properly
+expected_method = binary_method.decode('utf-8')
+print(f"Expected result (after decode): {expected_method}")
+print(f"Type: {type(expected_method)}")
+print(f"Expected upper case: {expected_method.upper()}")
\ No newline at end of file
diff --git a/requests/sessions.py b/requests/sessions.py
index d701ff2e..451a500a 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -425,11 +425,15 @@ class Session(SessionRedirectMixin):
             If Tuple, ('cert', 'key') pair.
         """
 
-        method = builtin_str(method)
+        # Handle binary strings properly - decode them before converting to string
+        if isinstance(method, bytes):
+            method = method.decode('utf-8')
+        if method is not None:
+            method = builtin_str(method)
 
         # Create the Request.
         req = Request(
-            method = method.upper(),
+            method = method.upper() if method is not None else method,
             url = url,
             headers = headers,
             files = files,
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 00000000..4a31b06f
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the method conversion fix
+"""
+
+from requests.sessions import Session
+from requests.compat import builtin_str
+
+# Test various edge cases
+test_cases = [
+    b'GET',       # Basic case from the issue
+    b'POST',      # Another HTTP method
+    b'DELETE',    # Another HTTP method
+    b'PUT',       # Another HTTP method
+    b'HEAD',      # Another HTTP method
+    b'OPTIONS',   # Another HTTP method
+    b'PATCH',     # Another HTTP method
+    'GET',        # Regular string (should not break)
+    'POST',       # Regular string (should not break)
+    None,         # Edge case: None
+    123,          # Edge case: integer
+]
+
+session = Session()
+
+for i, method in enumerate(test_cases):
+    print(f"\nTest case {i+1}: {method} (type: {type(method)})")
+    
+    try:
+        # Simulate what happens in our fixed sessions.py
+        if isinstance(method, bytes):
+            decoded_method = method.decode('utf-8')
+            final_method = builtin_str(decoded_method)
+        else:
+            final_method = builtin_str(method)
+        
+        print(f"  Fixed conversion result: {final_method}")
+        print(f"  Type: {type(final_method)}")
+        
+        # Test upper case conversion (what happens in the Request creation)
+        if final_method is not None:
+            upper_method = final_method.upper()
+            print(f"  Upper case: {upper_method}")
+        else:
+            print(f"  Upper case: None")
+            
+    except Exception as e:
+        print(f"  Error: {e}")
+
+# Test empty bytes
+print(f"\nTest case: Empty bytes")
+empty_bytes = b''
+print(f"Input: {empty_bytes} (type: {type(empty_bytes)})")
+
+try:
+    if isinstance(empty_bytes, bytes):
+        decoded_method = empty_bytes.decode('utf-8')
+        final_method = builtin_str(decoded_method)
+    else:
+        final_method = builtin_str(empty_bytes)
+    
+    print(f"  Fixed conversion result: {final_method}")
+    print(f"  Type: {type(final_method)}")
+    print(f"  Upper case: {final_method.upper()}")
+    
+except Exception as e:
+    print(f"  Error: {e}")
\ No newline at end of file
diff --git a/test_final_fix.py b/test_final_fix.py
new file mode 100644
index 00000000..8f5e8375
--- /dev/null
+++ b/test_final_fix.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix works correctly by testing the actual Session.request method
+"""
+
+from requests.sessions import Session
+
+# Create a session
+session = Session()
+
+# Test the specific issue from the GitHub issue
+print("Testing the specific issue from GitHub issue:")
+binary_method = b'GET'
+print(f"Input: {binary_method} (type: {type(binary_method)})")
+
+try:
+    # This should work with our fix
+    req = session.prepare_request(session.request(method=binary_method, url='http://example.com'))
+    print(f"✓ SUCCESS: Request preparation worked")
+    print(f"  Final method: {req.method}")
+    print(f"  Final method type: {type(req.method)}")
+    
+    # Verify the method is properly converted
+    if req.method == 'GET':
+        print("  ✓ Method was properly converted from b'GET' to 'GET'")
+    else:
+        print(f"  ✗ Method was converted to '{req.method}' instead of 'GET'")
+        
+except Exception as e:
+    print(f"✗ FAILURE: {e}")
+
+# Test that regular strings still work
+print("\nTesting that regular strings still work:")
+string_method = 'GET'
+print(f"Input: {string_method} (type: {type(string_method)})")
+
+try:
+    req = session.prepare_request(session.request(method=string_method, url='http://example.com'))
+    print(f"✓ SUCCESS: Request preparation worked")
+    print(f"  Final method: {req.method}")
+    print(f"  Final method type: {type(req.method)}")
+    
+    if req.method == 'GET':
+        print("  ✓ String method still works correctly")
+    else:
+        print(f"  ✗ String method was converted to '{req.method}'")
+        
+except Exception as e:
+    print(f"✗ FAILURE: {e}")
+
+# Test None handling
+print("\nTesting None handling:")
+none_method = None
+print(f"Input: {none_method} (type: {type(none_method)})")
+
+try:
+    req = session.prepare_request(session.request(method=none_method, url='http://example.com'))
+    print(f"✓ SUCCESS: Request preparation worked")
+    print(f"  Final method: {req.method}")
+    print(f"  Final method type: {type(req.method)}")
+    
+    # None should be handled gracefully (might be converted to string or handled differently)
+    print(f"  Note: None was converted to '{req.method}'")
+        
+except Exception as e:
+    print(f"✗ FAILURE: {e}")
+
+print("\n" + "="*50)
+print("SUMMARY: The fix should properly handle binary strings while")
+print("maintaining backward compatibility with regular strings.")
+print("="*50)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 00000000..b0759d4e
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for the builtin_str method issue.
+This script tests the Session.request method with binary strings.
+"""
+
+import requests
+from requests.sessions import Session
+
+# Create a session
+session = Session()
+
+# Test with binary method (simulating neutronclient behavior)
+binary_method = b'GET'
+print(f"Testing with binary method: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+try:
+    # This should now work properly with our fix
+    response = session.request(method=binary_method, url='http://httpbin.org/get')
+    print(f"Request successful! Status code: {response.status_code}")
+    print(f"Response text: {response.text[:100]}...")  # Show first 100 chars
+except Exception as e:
+    print(f"Request failed with error: {e}")
+
+# Test with regular string method (should still work)
+string_method = 'GET'
+print(f"\nTesting with string method: {string_method}")
+print(f"Type: {type(string_method)}")
+
+try:
+    response = session.request(method=string_method, url='http://httpbin.org/get')
+    print(f"Request successful! Status code: {response.status_code}")
+    print(f"Response text: {response.text[:100]}...")  # Show first 100 chars
+except Exception as e:
+    print(f"Request failed with error: {e}")
+
+# Test edge case: binary string with different content
+binary_post = b'POST'
+print(f"\nTesting with binary POST method: {binary_post}")
+print(f"Type: {type(binary_post)}")
+
+try:
+    response = session.request(method=binary_post, url='http://httpbin.org/post', data={'test': 'data'})
+    print(f"Request successful! Status code: {response.status_code}")
+    print(f"Response text: {response.text[:100]}...")  # Show first 100 chars
+except Exception as e:
+    print(f"Request failed with error: {e}")
\ No newline at end of file
diff --git a/test_fix_offline.py b/test_fix_offline.py
new file mode 100644
index 00000000..9883196d
--- /dev/null
+++ b/test_fix_offline.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+"""
+Offline test script to verify the fix for the builtin_str method issue.
+This script tests the Session.request method with binary strings without network access.
+"""
+
+import requests
+from requests.sessions import Session
+from requests.models import Request
+
+# Create a session
+session = Session()
+
+# Test with binary method (simulating neutronclient behavior)
+binary_method = b'GET'
+print(f"Testing with binary method: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+try:
+    # This should now work properly with our fix
+    req = session.prepare_request(Request(method=binary_method, url='http://example.com'))
+    print(f"Request preparation successful!")
+    print(f"Final method: {req.method}")
+    print(f"Final method type: {type(req.method)}")
+except Exception as e:
+    print(f"Request preparation failed with error: {e}")
+
+# Test with regular string method (should still work)
+string_method = 'GET'
+print(f"\nTesting with string method: {string_method}")
+print(f"Type: {type(string_method)}")
+
+try:
+    req = session.prepare_request(Request(method=string_method, url='http://example.com'))
+    print(f"Request preparation successful!")
+    print(f"Final method: {req.method}")
+    print(f"Final method type: {type(req.method)}")
+except Exception as e:
+    print(f"Request preparation failed with error: {e}")
+
+# Test edge case: binary string with different content
+binary_post = b'POST'
+print(f"\nTesting with binary POST method: {binary_post}")
+print(f"Type: {type(binary_post)}")
+
+try:
+    req = session.prepare_request(Request(method=binary_post, url='http://example.com'))
+    print(f"Request preparation successful!")
+    print(f"Final method: {req.method}")
+    print(f"Final method type: {type(req.method)}")
+except Exception as e:
+    print(f"Request preparation failed with error: {e}")
+
+# Test the direct method conversion that was causing the issue
+print(f"\nTesting direct method conversion:")
+from requests.compat import builtin_str
+
+# Old behavior (what was causing the issue)
+old_result = builtin_str(binary_method)
+print(f"Old builtin_str result: {old_result}")
+
+# New behavior (what our fix should achieve)
+if isinstance(binary_method, bytes):
+    new_result = binary_method.decode('utf-8')
+    new_result = builtin_str(new_result)
+else:
+    new_result = builtin_str(binary_method)
+print(f"New fixed result: {new_result}")
\ No newline at end of file
diff --git a/test_method_conversion.py b/test_method_conversion.py
new file mode 100644
index 00000000..c699972e
--- /dev/null
+++ b/test_method_conversion.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Test the method conversion specifically without network calls
+"""
+
+from requests.sessions import Session
+from requests.compat import builtin_str
+
+# Create a session
+session = Session()
+
+# Test the specific conversion that was happening in sessions.py line 428
+binary_method = b'GET'
+print(f"Original binary method: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+# Old behavior (what was causing the issue)
+old_result = builtin_str(binary_method)
+print(f"builtin_str result (old behavior): {old_result}")
+print(f"Type: {type(old_result)}")
+
+# New behavior (what our fix should do)
+if isinstance(binary_method, bytes):
+    new_result = binary_method.decode('utf-8')
+    new_result = builtin_str(new_result)
+else:
+    new_result = builtin_str(binary_method)
+print(f"Fixed result: {new_result}")
+print(f"Type: {type(new_result)}")
+
+# Test that our fix is actually in place by checking the method after session.request processing
+# We'll mock the network part by creating the request but not sending it
+try:
+    # Create the request object that would be created in session.request
+    from requests.models import Request
+    req = Request(method=binary_method, url='http://example.com')
+    
+    # This simulates what happens in session.request after our fix
+    if isinstance(req.method, bytes):
+        req.method = req.method.decode('utf-8')
+    req.method = builtin_str(req.method)
+    
+    print(f"\nAfter our fix simulation:")
+    print(f"Method: {req.method}")
+    print(f"Type: {type(req.method)}")
+    print(f"Upper case: {req.method.upper()}")
+    
+    if req.method == 'GET':
+        print("✓ SUCCESS: Method was properly converted from b'GET' to 'GET'")
+    else:
+        print(f"✗ FAILURE: Method was converted to '{req.method}' instead of 'GET'")
+        
+except Exception as e:
+    print(f"Error: {e}")
+
+# Test with string method to ensure we didn't break anything
+print(f"\nTesting with string method:")
+string_method = 'GET'
+req = Request(method=string_method, url='http://example.com')
+if isinstance(req.method, bytes):
+    req.method = req.method.decode('utf-8')
+req.method = builtin_str(req.method)
+
+print(f"Method: {req.method}")
+print(f"Type: {type(req.method)}")
+print(f"Upper case: {req.method.upper()}")
+
+if req.method == 'GET':
+    print("✓ SUCCESS: String method still works correctly")
+else:
+    print(f"✗ FAILURE: String method was converted to '{req.method}'")
\ No newline at end of file
diff --git a/test_prepare_method.py b/test_prepare_method.py
new file mode 100644
index 00000000..c7c0748d
--- /dev/null
+++ b/test_prepare_method.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""
+Test the prepare_method function to see if it also needs fixing
+"""
+
+from requests.models import PreparedRequest
+
+# Test prepare_method with binary string
+binary_method = b'GET'
+print(f"Testing prepare_method with binary: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+req = PreparedRequest()
+req.prepare_method(binary_method)
+print(f"After prepare_method: {req.method}")
+print(f"Type: {type(req.method)}")
+print(f"Upper case result: {req.method.upper()}")
+
+# Test prepare_method with regular string
+string_method = 'GET'
+print(f"\nTesting prepare_method with string: {string_method}")
+print(f"Type: {type(string_method)}")
+
+req = PreparedRequest()
+req.prepare_method(string_method)
+print(f"After prepare_method: {req.method}")
+print(f"Type: {type(req.method)}")
+print(f"Upper case result: {req.method.upper()}")
+
+# Test what happens when we try to use the binary method in string operations
+print(f"\nTesting string operations with binary method:")
+binary_result = req.method  # This would be b'GET' if prepare_method doesn't handle bytes
+try:
+    # This might fail if the method is still bytes
+    string_operation = "Method: " + binary_result
+    print(f"String concatenation result: {string_operation}")
+except Exception as e:
+    print(f"String concatenation failed: {e}")
+
+try:
+    # This might fail if the method is still bytes
+    format_operation = "Method: {}".format(binary_result)
+    print(f"String formatting result: {format_operation}")
+except Exception as e:
+    print(f"String formatting failed: {e}")
\ No newline at end of file
diff --git a/test_simple_fix.py b/test_simple_fix.py
new file mode 100644
index 00000000..cd9994b6
--- /dev/null
+++ b/test_simple_fix.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Simple test to verify the fix works without network calls
+"""
+
+from requests.sessions import Session
+
+# Create a session
+session = Session()
+
+# Test the specific conversion that was causing the issue
+print("Testing method conversion in Session.request:")
+
+# Test binary method
+binary_method = b'GET'
+print(f"Binary input: {binary_method} (type: {type(binary_method)})")
+
+# Simulate what happens in our fixed Session.request method
+if isinstance(binary_method, bytes):
+    method = binary_method.decode('utf-8')
+    print(f"After decode: {method} (type: {type(method)})")
+if method is not None:
+    method = str(method)
+    print(f"After builtin_str: {method} (type: {type(method)})")
+    method = method.upper()
+    print(f"After upper: {method} (type: {type(method)})")
+
+print(f"\nFinal result: {method}")
+if method == "GET":
+    print("✓ SUCCESS: Binary method was properly converted")
+else:
+    print(f"✗ FAILURE: Expected 'GET', got '{method}'")
+
+# Test string method
+print("\nTesting string method:")
+string_method = 'GET'
+print(f"String input: {string_method} (type: {type(string_method)})")
+
+if isinstance(string_method, bytes):
+    method = string_method.decode('utf-8')
+    print(f"After decode: {method} (type: {type(method)})")
+if method is not None:
+    method = str(method)
+    print(f"After builtin_str: {method} (type: {type(method)})")
+    method = method.upper()
+    print(f"After upper: {method} (type: {type(method)})")
+
+print(f"\nFinal result: {method}")
+if method == "GET":
+    print("✓ SUCCESS: String method still works correctly")
+else:
+    print(f"✗ FAILURE: Expected 'GET', got '{method}'")
+
+# Test None method
+print("\nTesting None method:")
+none_method = None
+print(f"None input: {none_method} (type: {type(none_method)})")
+
+if isinstance(none_method, bytes):
+    method = none_method.decode('utf-8')
+    print(f"After decode: {method} (type: {type(method)})")
+if method is not None:
+    method = str(method)
+    print(f"After builtin_str: {method} (type: {type(method)})")
+    method = method.upper()
+    print(f"After upper: {method} (type: {type(method)})")
+else:
+    method = none_method
+    print(f"Method remains: {method} (type: {type(method)})")
+
+print(f"\nFinal result: {method}")
+print("✓ SUCCESS: None method handled gracefully")
\ No newline at end of file
diff --git a/test_specific_issue.py b/test_specific_issue.py
new file mode 100644
index 00000000..0c852af5
--- /dev/null
+++ b/test_specific_issue.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Test the specific issue mentioned in the GitHub issue:
+method = builtin_str(method) converts b'GET' to "b'GET'" instead of "GET"
+"""
+
+from requests.sessions import Session
+from requests.compat import builtin_str
+
+# Test the specific line mentioned in the issue
+binary_method = b'GET'
+print(f"Original binary method: {binary_method}")
+print(f"Type: {type(binary_method)}")
+
+# This is what was happening before our fix
+old_result = builtin_str(binary_method)
+print(f"builtin_str result (old behavior): {old_result}")
+print(f"Type: {type(old_result)}")
+
+# Test what happens in the Session.request method
+session = Session()
+
+# Create a request with binary method and see what happens during preparation
+try:
+    # This should trigger our fix in sessions.py
+    req = session.prepare_request(session.request(method=binary_method, url='http://example.com'))
+    print(f"Request preparation successful!")
+    print(f"Final method: {req.method}")
+    print(f"Final method type: {type(req.method)}")
+    
+    # Check if the method is properly converted
+    if req.method == 'GET':
+        print("✓ SUCCESS: Method was properly converted from b'GET' to 'GET'")
+    else:
+        print(f"✗ FAILURE: Method was converted to '{req.method}' instead of 'GET'")
+        
+except Exception as e:
+    print(f"Request preparation failed with error: {e}")
+
+# Test with string method to ensure we didn't break anything
+string_method = 'GET'
+print(f"\nTesting with string method: {string_method}")
+try:
+    req = session.prepare_request(session.request(method=string_method, url='http://example.com'))
+    print(f"Request preparation successful!")
+    print(f"Final method: {req.method}")
+    print(f"Final method type: {type(req.method)}")
+    
+    if req.method == 'GET':
+        print("✓ SUCCESS: String method still works correctly")
+    else:
+        print(f"✗ FAILURE: String method was converted to '{req.method}'")
+        
+except Exception as e:
+    print(f"Request preparation failed with error: {e}")
\ No newline at end of file