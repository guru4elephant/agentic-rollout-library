diff --git a/add_debug_output.py b/add_debug_output.py
new file mode 100644
index 0000000000..82ab363535
--- /dev/null
+++ b/add_debug_output.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""
+Add debug output to generate_altered_fields method.
+"""
+
+import os
+import sys
+
+# Read the original file
+with open('/testbed/django/db/migrations/autodetector.py', 'r') as f:
+    content = f.read()
+
+# Add debug output to generate_altered_fields method
+debug_patch = '''            # DEBUG: Print field comparison info
+            print(f"DEBUG: Comparing {app_label}.{model_name}.{field_name}")
+            print(f"DEBUG: Old field: {type(old_field)}")
+            print(f"DEBUG: New field: {type(new_field)}")
+            print(f"DEBUG: Old deconstruction: {old_field_dec}")
+            print(f"DEBUG: New deconstruction: {new_field_dec}")
+            print(f"DEBUG: Are equal: {old_field_dec == new_field_dec}")
+            print(f"DEBUG: both_m2m: {both_m2m}, neither_m2m: {neither_m2m}")
+'''
+
+# Find the location to insert the debug code
+lines = content.split('\n')
+for i, line in enumerate(lines):
+    if 'if old_field_dec != new_field_dec:' in line:
+        # Insert debug code after this line
+        lines.insert(i + 1, debug_patch)
+        break
+
+# Write the patched file
+with open('/testbed/django/db/migrations/autodetector.py', 'w') as f:
+    f.write('\n'.join(lines))
+
+print("Debug output added to generate_altered_fields method!")
\ No newline at end of file
diff --git a/debug_altered_fields.py b/debug_altered_fields.py
new file mode 100644
index 0000000000..6b80288218
--- /dev/null
+++ b/debug_altered_fields.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+"""
+Debug script to specifically check generate_altered_fields method.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True,  unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+# Now we can access the field keys
+print("Field keys:")
+print("old_field_keys:", autodetector.old_field_keys)
+print("new_field_keys:", autodetector.new_field_keys)
+print("intersection:", autodetector.old_field_keys & autodetector.new_field_keys)
+
+# Check if 'another_app' is in the intersection
+field_in_intersection = any(
+    field_name == 'another_app' for app_label, model_name, field_name in autodetector.old_field_keys & autodetector.new_field_keys
+)
+print(f"'another_app' field in intersection: {field_in_intersection}")
+
+# Check generated operations
+print("\nGenerated operations:")
+for app_label, ops in autodetector.generated_operations.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
\ No newline at end of file
diff --git a/debug_deconstruct.py b/debug_deconstruct.py
new file mode 100644
index 0000000000..a620028c8c
--- /dev/null
+++ b/debug_deconstruct.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand deep_deconstruct behavior.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create autodetector with dummy states
+from django.db.migrations.state import ProjectState
+dummy_state = ProjectState()
+autodetector = MigrationAutodetector(dummy_state, dummy_state)
+
+# Create the fields
+uuid_field = models.UUIDField(null=True, blank=True)
+fk_field = models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)
+
+# Test deep_deconstruct
+uuid_deconstruct = autodetector.deep_deconstruct(uuid_field)
+fk_deconstruct = autodetector.deep_deconstruct(fk_field)
+
+print("UUIDField deconstruction:")
+print(uuid_deconstruct)
+print("\nForeignKey deconstruction:")
+print(fk_deconstruct)
+print("\nAre they equal?", uuid_deconstruct == fk_deconstruct)
+
+# Let's also check the individual components
+print("\nDetailed comparison:")
+print("Path equal:", uuid_deconstruct[0] == fk_deconstruct[0])
+print("Args equal:", uuid_deconstruct[1] == fk_deconstruct[1])
+print("Kwargs equal:", uuid_deconstruct[2] == fk_deconstruct[2])
+
+print("\nUUIDField kwargs:", uuid_deconstruct[2])
+print("ForeignKey kwargs:", fk_deconstruct[2])
\ No newline at end of file
diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..c91c158bc6
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Detailed debug script to see what operations are generated.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+print("Detected changes:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        if hasattr(op, 'field'):
+            print(f"    Field type: {type(op.field)}")
+            if hasattr(op.field, 'remote_field') and op.field.remote_field:
+                print(f"    Remote field: {op.field.remote_field}")
+                if hasattr(op.field.remote_field, 'model'):
+                    print(f"    Related model: {op.field.remote_field.model}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
+        print()
+
+# Also check the generated_operations directly
+print("\nGenerated operations (direct):")
+for app_label, ops in autodetector.generated_operations.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
\ No newline at end of file
diff --git a/debug_detect_changes.py b/debug_detect_changes.py
new file mode 100644
index 0000000000..575e21e3b5
--- /dev/null
+++ b/debug_detect_changes.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+"""
+Debug script to see what's happening in _detect_changes.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text',  models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector
+autodetector = MigrationAutodetector(initial_state, target_state)
+
+# Add debug output to see what's happening
+print("Before _detect_changes:")
+print("initial_state.models:", list(initial_state.models))
+print("target_state.models:", list(target_state.models))
+
+# Call _detect_changes
+changes = autodetector._detect_changes()
+
+print("\nAfter _detect_changes:")
+print("autodetector.old_model_keys:", autodetector.old_model_keys)
+print("autodetector.new_model_keys:", autodetector.new_model_keys)
+print("autodetector.old_field_keys:", autodetector.old_field_keys)
+print("autodetector.new_field_keys:", autodetector.new_field_keys)
+
+print("\nChanges:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
\ No newline at end of file
diff --git a/debug_field_comparison.py b/debug_field_comparison.py
new file mode 100644
index 0000000000..8764510436
--- /dev/null
+++ b/debug_field_comparison.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand field comparison in autodetector.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector
+autodetector = MigrationAutodetector(initial_state, target_state)
+
+# Debug field comparison
+print("Field keys comparison:")
+print("old_field_keys:", autodetector.old_field_keys)
+print("new_field_keys:", autodetector.new_field_keys)
+print("intersection:", autodetector.old_field_keys & autodetector.new_field_keys)
+
+# Manually check the fields
+old_model = initial_state.apps.get_model('testapp1', 'App1')
+new_model = target_state.apps.get_model('testapp1', 'App1')
+
+old_field = old_model._meta.get_field('another_app')
+new_field = new_model._meta.get_field('another_app')
+
+print(f"\nOld field type: {type(old_field)}")
+print(f"New field type: {type(new_field)}")
+print(f"Old field many_to_many: {old_field.many_to_many}")
+print(f"New field many_to_many: {new_field.many_to_many}")
+print(f"Old field is_relation: {old_field.is_relation}")
+print(f"New field is_relation: {new_field.is_relation}")
+
+# Check deep deconstruction
+old_field_dec = autodetector.deep_deconstruct(old_field)
+new_field_dec = autodetector.deep_deconstruct(new_field)
+
+print(f"\nOld field deconstruction: {old_field_dec}")
+print(f"New field deconstruction: {new_field_dec}")
+print(f"Are they equal? {old_field_dec == new_field_dec}")
+
+# Check the logic from generate_altered_fields
+both_m2m = old_field.many_to_many and new_field.many_to_many
+neither_m2m = not old_field.many_to_many and not new_field.many_to_many
+
+print(f"\nboth_m2m: {both_m2m}")
+print(f"neither_m2m: {neither_m2m}")
+print(f"both_m2m or neither_m2m: {both_m2m or neither_m2m}")
\ No newline at end of file
diff --git a/debug_field_comparison2.py b/debug_field_comparison2.py
new file mode 100644
index 0000000000..ee2737b0b4
--- /dev/null
+++ b/debug_field_comparison2.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand field comparison in autodetector - version 2.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4,  editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+# Now we can access the field keys
+print("Field keys comparison:")
+print("old_field_keys:", autodetector.old_field_keys)
+print("new_field_keys:", autodetector.new_field_keys)
+print("intersection:", autodetector.old_field_keys & autodetector.new_field_keys)
+
+# Check if 'another_app' field is in the intersection
+field_in_intersection = any(
+    field_name == 'another_app' for app_label, model_name, field_name in autodetector.old_field_keys & autodetector.new_field_keys
+)
+print(f"'another_app' field in intersection: {field_in_intersection}")
+
+# Manually check the fields
+old_model = initial_state.apps.get_model('testapp1', 'App1')
+new_model = target_state.apps.get_model('testapp1', 'App1')
+
+old_field = old_model._meta.get_field('another_app')
+new_field = new_model._meta.get_field('another_app')
+
+print(f"\nOld field type: {type(old_field)}")
+print(f"New field type: {type(new_field)}")
+print(f"Old field many_to_many: {old_field.many_to_many}")
+print(f"New field many_to_many: {new_field.many_to_many}")
+print(f"Old field is_relation: {old_field.is_relation}")
+print(f"New field is_relation: {new_field.is_relation}")
+
+# Check deep deconstruction
+old_field_dec = autodetector.deep_deconstruct(old_field)
+new_field_dec = autodetector.deep_deconstruct(new_field)
+
+print(f"\nOld field deconstruction: {old_field_dec}")
+print(f"New field deconstruction: {new_field_dec}")
+print(f"Are they equal? {old_field_dec == new_field_dec}")
+
+# Check the logic from generate_altered_fields
+both_m2m = old_field.many_to_many and new_field.many_to_many
+neither_m2m = not old_field.many_to_many and not new_field.many_to_many
+
+print(f"\nboth_m2m: {both_m2m}")
+print(f"neither_m2m: {neither_m2m}")
+print(f"both_m2m or neither_m2m: {both_m2m or neither_m2m}")
\ No newline at end of file
diff --git a/patch_debug.py b/patch_debug.py
new file mode 100644
index 0000000000..9bbc6ad866
--- /dev/null
+++ b/patch_debug.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""
+Patch to add debug output to generate_altered_fields method.
+"""
+
+import os
+import sys
+
+# Read the original file
+with open('/testbed/django/db/migrations/autodetector.py', 'r') as f:
+    content = f.read()
+
+# Add debug output to generate_altered_fields method
+debug_patch = '''
+            # DEBUG: Print field comparison info
+            print(f"DEBUG: Comparing {app_label}.{model_name}.{field_name}")
+            print(f"DEBUG: Old field type: {type(old_field)}")
+            print(f"DEBUG: New field type: {type(new_field)}")
+            print(f"DEBUG: Old field deconstruction: {old_field_dec}")
+            print(f"DEBUG: New field deconstruction: {new_field_dec}")
+            print(f"DEBUG: Are they equal? {old_field_dec == new_field_dec}")
+            print(f"DEBUG: both_m2m: {both_m2m}, neither_m2m: {neither_m2m}")
+'''
+
+# Find the location to insert the debug code
+lines = content.split('\n')
+for i, line in enumerate(lines):
+    if 'if old_field_dec != new_field_dec:' in line:
+        # Insert debug code after this line
+        lines.insert(i + 1, debug_patch)
+        break
+
+# Write the patched file
+with open('/testbed/django/db/migrations/autodetector.py', 'w') as f:
+    f.write('\n'.join(lines))
+
+print("Debug patch applied successfully!")
\ No newline at end of file
diff --git a/patch_debug_proper.py b/patch_debug_proper.py
new file mode 100644
index 0000000000..0db6a93f93
--- /dev/null
+++ b/patch_debug_proper.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""
+Proper patch to add debug output to generate_altered_fields method.
+"""
+
+import os
+import sys
+
+# Read the original file
+with open('/testbed/django/db/migrations/autodetector.py', 'r') as f:
+    content = f.read()
+
+# Add debug output to generate_altered_fields method
+debug_patch = '''            # DEBUG: Print field comparison info
+            print(f"DEBUG: Comparing {app_label}.{model_name}.{field_name}")
+            print(f"DEBUG: Old field type: {type(old_field)}")
+            print(f"DEBUG: New field type: {type(new_field)}")
+            print(f"DEBUG: Old field deconstruction: {old_field_dec}")
+            print(f"DEBUG: New field deconstruction: {new_field_dec}")
+            print(f"DEBUG: Are they equal? {old_field_dec == new_field_dec}")
+            print(f"DEBUG: both_m2m: {both_m2m}, neither_m2m: {neither_m2m}")
+'''
+
+# Find the location to insert the debug code
+lines = content.split('\n')
+for i, line in enumerate(lines):
+    if 'if old_field_dec != new_field_dec:' in line:
+        # Insert debug code after this line
+        lines.insert(i + 1, debug_patch)
+        break
+
+# Write the patched file
+with open('/testbed/django/db/migrations/autodetector.py', 'w') as f:
+    f.write('\n'.join(lines))
+
+print("Debug patch applied successfully!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..99e0016ff1
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the UUID field to FK dependency issue.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create models directly using model state instead of actual model classes
+def create_model_state(app_label, model_name, fields):
+    """Create a model state for testing"""
+    from django.db.migrations.state import ModelState
+    return ModelState(
+        app_label=app_label,
+        name=model_name,
+        fields=fields,
+        options={},
+        bases=(models.Model,),
+        managers=[],
+    )
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(create_model_state(
+    'testapp1', 'App1', [
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ]
+))
+initial_state.add_model(create_model_state(
+    'testapp2', 'App2', [
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ]
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(create_model_state(
+    'testapp1', 'App1', [
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ]
+))
+target_state.add_model(create_model_state(
+    'testapp2', 'App2', [
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ]
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+print("Detected changes:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
+
+# Check if the AlterField operation has the correct dependencies
+for app_label, ops in changes.items():
+    for op in ops:
+        if hasattr(op, 'name') and op.name == 'another_app':
+            print(f"\nFound operation for another_app:")
+            print(f"  Operation: {op}")
+            print(f"  Dependencies: {getattr(op, '_auto_deps', [])}")
+            # Check if it has dependency on testapp2.App2
+            has_dependency = any(
+                dep[0] == 'testapp2' and dep[1] == 'app2' 
+                for dep in getattr(op, '_auto_deps', [])
+            )
+            print(f"  Has dependency on testapp2.App2: {has_dependency}")
+            if not has_dependency:
+                print("ERROR: Missing dependency on testapp2.App2!")
+                sys.exit(1)
+            else:
+                print("SUCCESS: Dependency found!")
+                sys.exit(0)
+
+print("No operation found for another_app")
+sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue2.py b/reproduce_issue2.py
new file mode 100644
index 0000000000..71ba1dc327
--- /dev/null
+++ b/reproduce_issue2.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the UUID field to FK dependency issue - version 2.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+print("Detected changes:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        print(f"    Name: {getattr(op, 'name', 'N/A')}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
+
+# Check if we have both RemoveField and AddField operations
+remove_field_ops = []
+add_field_ops = []
+for app_label, ops in changes.items():
+    for op in ops:
+        if hasattr(op, 'name') and op.name == 'another_app':
+            if op.__class__.__name__ == 'RemoveField':
+                remove_field_ops.append(op)
+            elif op.__class__.__name__ == 'AddField':
+                add_field_ops.append(op)
+
+print(f"\nRemoveField operations for another_app: {len(remove_field_ops)}")
+print(f"AddField operations for another_app: {len(add_field_ops)}")
+
+# Check if AddField operation has the correct dependencies
+for op in add_field_ops:
+    print(f"\nAddField operation:")
+    print(f"  Dependencies: {getattr(op, '_auto_deps', [])}")
+    # Check if it has dependency on testapp2.App2
+    has_dependency = any(
+        dep[0] == 'testapp2' and dep[1] == 'app2' 
+        for dep in getattr(op, '_auto_deps', [])
+    )
+    print(f"  Has dependency on testapp2.App2: {has_dependency}")
+    if not has_dependency:
+        print("ERROR: Missing dependency on testapp2.App2!")
+        sys.exit(1)
+    else:
+        print("SUCCESS: Dependency found!")
+        sys.exit(0)
+
+print("No AddField operation found for another_app")
+sys.exit(1)
\ No newline at end of file
diff --git a/test_deconstruct.py b/test_deconstruct.py
new file mode 100644
index 0000000000..34ef101c8a
--- /dev/null
+++ b/test_deconstruct.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Test script to understand how deep_deconstruct behaves with UUIDField vs ForeignKey.
+"""
+
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create autodetector with dummy states
+from django.db.migrations.state import ProjectState
+dummy_state = ProjectState()
+autodetector = MigrationAutodetector(dummy_state, dummy_state)
+
+# Test UUIDField
+uuid_field = models.UUIDField(null=True, blank=True)
+uuid_deconstruct = autodetector.deep_deconstruct(uuid_field)
+print("UUIDField deconstruction:")
+print(uuid_deconstruct)
+
+# Test ForeignKey
+fk_field = models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)
+fk_deconstruct = autodetector.deep_deconstruct(fk_field)
+print("\nForeignKey deconstruction:")
+print(fk_deconstruct)
+
+# Compare the two
+print("\nAre they equal?", uuid_deconstruct == fk_deconstruct)
\ No newline at end of file
diff --git a/test_field_comparison.py b/test_field_comparison.py
new file mode 100644
index 0000000000..5562d9d137
--- /dev/null
+++ b/test_field_comparison.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Test field comparison logic directly.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create autodetector with dummy states
+from django.db.migrations.state import ProjectState
+dummy_state = ProjectState()
+autodetector = MigrationAutodetector(dummy_state, dummy_state)
+
+# Test UUIDField
+uuid_field = models.UUIDField(null=True, blank=True)
+uuid_deconstruct = autodetector.deep_deconstruct(uuid_field)
+print("UUIDField deconstruction:")
+print(uuid_deconstruct)
+
+# Test ForeignKey
+fk_field = models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)
+fk_deconstruct = autodetector.deep_deconstruct(fk_field)
+print("\nForeignKey deconstruction:")
+print(fk_deconstruct)
+
+# Compare the two
+print("\nAre they equal?", uuid_deconstruct == fk_deconstruct)
+
+# Test the logic from generate_altered_fields
+both_m2m = uuid_field.many_to_many and fk_field.many_to_many
+neither_m2m = not uuid_field.many_to_many and not fk_field.many_to_many
+
+print(f"\nboth_m2m: {both_m2m}")
+print(f"neither_m2m: {neither_m2m}")
+print(f"both_m2m or neither_m2m: {both_m2m or neither_m2m}")
+
+# Check if they should result in AlterField or RemoveField/AddField
+if both_m2m or neither_m2m:
+    print("Should create AlterField operation")
+else:
+    print("Should create RemoveField + AddField operations")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..f65b0064cc
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for UUID field to FK dependency issue.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations import operations
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+print("Detected changes:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
+
+# Manually check if the AlterField operation has the correct dependencies
+for app_label, ops in changes.items():
+    for op in ops:
+        if isinstance(op, operations.AlterField) and hasattr(op, 'name') and op.name == 'another_app':
+            print(f"\nFound AlterField operation for another_app:")
+            print(f"  Operation: {op}")
+            print(f"  Dependencies: {getattr(op, '_auto_deps', [])}")
+            # Check if it has dependency on testapp2.App2
+            has_dependency = any(
+                dep[0] == 'testapp2' and dep[1] == 'app2' 
+                for dep in getattr(op, '_auto_deps', [])
+            )
+            print(f"  Has dependency on testapp2.App2: {has_dependency}")
+            if not has_dependency:
+                print("ERROR: Missing dependency on testapp2.App2!")
+                sys.exit(1)
+            else:
+                print("SUCCESS: Dependency found!")
+                sys.exit(0)
+
+print("No AlterField operation found for another_app")
+sys.exit(1)
\ No newline at end of file
diff --git a/test_generate_altered_fields.py b/test_generate_altered_fields.py
new file mode 100644
index 0000000000..8f7b3c1816
--- /dev/null
+++ b/test_generate_altered_fields.py
@@ -0,0 +1,146 @@
+#!/usr/bin/env python3
+"""
+Test script to directly call generate_altered_fields.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState, ModelState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create initial state with UUID field
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.UUIDField(null=True, blank=True)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+initial_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create target state with FK field
+target_state = ProjectState()
+target_state.add_model(ModelState(
+    app_label='testapp1',
+    name='App1',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+        ('another_app', models.ForeignKey('testapp2.App2', null=True, blank=True, on_delete=models.SET_NULL)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+target_state.add_model(ModelState(
+    app_label='testapp2',
+    name='App2',
+    fields=[
+        ('id', models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),
+        ('text', models.CharField(max_length=100)),
+    ],
+    options={},
+    bases=(models.Model,),
+    managers=[],
+))
+
+# Create autodetector
+autodetector = MigrationAutodetector(initial_state, target_state)
+
+# Initialize the necessary attributes (similar to _detect_changes)
+autodetector.old_apps = autodetector.from_state.concrete_apps
+autodetector.new_apps = autodetector.to_state.apps
+autodetector.old_model_keys = set()
+autodetector.new_model_keys = set()
+autodetector.old_proxy_keys = set()
+autodetector.new_proxy_keys = set()
+autodetector.old_unmanaged_keys = set()
+autodetector.new_unmanaged_keys = set()
+
+for al, mn in autodetector.from_state.models:
+    model = autodetector.old_apps.get_model(al, mn)
+    if not model._meta.managed:
+        autodetector.old_unmanaged_keys.add((al, mn))
+    elif al in autodetector.from_state.real_apps:
+        if model._meta.proxy:
+            autodetector.old_proxy_keys.add((al, mn))
+        else:
+            autodetector.old_model_keys.add((al, mn))
+
+for al, mn in autodetector.to_state.models:
+    model = autodetector.new_apps.get_model(al, mn)
+    if not model._meta.managed:
+        autodetector.new_unmanaged_keys.add((al, mn))
+    elif (al in autodetector.from_state.real_apps or 
+          (hasattr(autodetector, 'convert_apps') and al in autodetector.convert_apps)):
+        if model._meta.proxy:
+            autodetector.new_proxy_keys.add((al, mn))
+        else:
+            autodetector.new_model_keys.add((al, mn))
+
+# Initialize renamed_models (empty for our case)
+autodetector.renamed_models = {}
+
+# Prepare field lists
+autodetector._prepare_field_lists()
+
+print("Field keys:")
+print("old_field_keys:", autodetector.old_field_keys)
+print("new_field_keys:", autodetector.new_field_keys)
+print("intersection:", autodetector.old_field_keys & autodetector.new_field_keys)
+
+# Check if 'another_app' is in the intersection
+field_in_intersection = any(
+    field_name == 'another_app' for app_label, model_name, field_name in autodetector.old_field_keys & autodetector.new_field_keys
+)
+print(f"'another_app' field in intersection: {field_in_intersection}")
+
+# Now manually call generate_altered_fields
+print("\nCalling generate_altered_fields...")
+autodetector.generate_altered_fields()
+
+print("\nGenerated operations after generate_altered_fields:")
+for app_label, ops in autodetector.generated_operations.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
\ No newline at end of file
diff --git a/test_makemigrations.py b/test_makemigrations.py
new file mode 100644
index 0000000000..e3f2c9688d
--- /dev/null
+++ b/test_makemigrations.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Test using the actual makemigrations command to generate the migration.
+"""
+
+import os
+import sys
+import tempfile
+import uuid
+from django.conf import settings
+from django.db import models
+from django.core.management import call_command
+
+# Create a temporary directory for the test
+with tempfile.TemporaryDirectory() as temp_dir:
+    # Configure Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': os.path.join(temp_dir, 'test.db'),
+                }
+            },
+            INSTALLED_APPS=['testapp'],
+            USE_TZ=True,
+        )
+
+    # Initialize Django
+    import django
+    django.setup()
+
+    # Create the testapp directory
+    testapp_dir = os.path.join(temp_dir, 'testapp')
+    os.makedirs(testapp_dir)
+    
+    # Create __init__.py
+    with open(os.path.join(testapp_dir, '__init__.py'), 'w') as f:
+        f.write('')
+    
+    # Create models.py with initial UUID field
+    with open(os.path.join(testapp_dir, 'models.py'), 'w') as f:
+        f.write('''
+import uuid
+from django.db import models
+
+class App1(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+    another_app = models.UUIDField(null=True, blank=True)
+
+    class Meta:
+        app_label = 'testapp'
+
+class App2(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'testapp'
+''')
+
+    # Create initial migration
+    call_command('makemigrations', 'testapp', verbosity=0)
+    
+    # Now update models.py to change UUIDField to ForeignKey
+    with open(os.path.join(testapp_dir, 'models.py'), 'w') as f:
+        f.write('''
+import uuid
+from django.db import models
+
+class App1(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+    another_app = models.ForeignKey('App2', null=True, blank=True, on_delete=models.SET_NULL)
+
+    class Meta:
+        app_label = 'testapp'
+
+class App2(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'testapp'
+''')
+
+    # Generate the migration that changes UUIDField to ForeignKey
+    call_command('makemigrations', 'testapp', verbosity=2)
+    
+    # Check the generated migration file
+    migration_files = [f for f in os.listdir(os.path.join(testapp_dir, 'migrations')) if f.startswith('0002')]
+    if migration_files:
+        migration_file = os.path.join(testapp_dir, 'migrations', migration_files[0])
+        with open(migration_file, 'r') as f:
+            migration_content = f.read()
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if the migration has the correct dependencies
+        if 'dependencies' in migration_content and 'App2' in migration_content:
+            print("SUCCESS: Migration has dependency on App2!")
+            sys.exit(0)
+        else:
+            print("ERROR: Migration missing dependency on App2!")
+            sys.exit(1)
+    else:
+        print("ERROR: No migration generated!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/test_simple.py b/test_simple.py
new file mode 100644
index 0000000000..5b9ac0b419
--- /dev/null
+++ b/test_simple.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+"""
+Simple test using actual Django model classes.
+"""
+
+import os
+import sys
+import uuid
+from django.conf import settings
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.state import ProjectState
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=['migrations'],
+        USE_TZ=True,
+    )
+
+# Initialize Django
+import django
+django.setup()
+
+# Create model classes
+class App1(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+    another_app = models.UUIDField(null=True, blank=True)
+
+    class Meta:
+        app_label = 'migrations'
+
+class App2(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'migrations'
+
+# Create initial state
+initial_state = ProjectState()
+initial_state.add_model(App1._meta)
+initial_state.add_model(App2._meta)
+
+# Create model classes for target state
+class App1WithFK(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+    another_app = models.ForeignKey(App2, null=True, blank=True, on_delete=models.SET_NULL)
+
+    class Meta:
+        app_label = 'migrations'
+
+class App2Same(models.Model):
+    id = models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)
+    text = models.CharField(max_length=100)
+
+    class Meta:
+        app_label = 'migrations'
+
+# Create target state
+target_state = ProjectState()
+target_state.add_model(App1WithFK._meta)
+target_state.add_model(App2Same._meta)
+
+# Create autodetector and detect changes
+autodetector = MigrationAutodetector(initial_state, target_state)
+changes = autodetector._detect_changes()
+
+print("Detected changes:")
+for app_label, ops in changes.items():
+    print(f"\nApp: {app_label}")
+    for op in ops:
+        print(f"  Operation: {op.__class__.__name__}")
+        if hasattr(op, 'name'):
+            print(f"    Name: {op.name}")
+        print(f"    Dependencies: {getattr(op, '_auto_deps', [])}")
+
+# Check for AlterField operation
+for app_label, ops in changes.items():
+    for op in ops:
+        if hasattr(op, 'name') and op.name == 'another_app':
+            print(f"\nFound operation for another_app:")
+            print(f"  Operation: {op.__class__.__name__}")
+            print(f"  Dependencies: {getattr(op, '_auto_deps', [])}")
+            # Check if it has dependency on migrations.App2
+            has_dependency = any(
+                dep[0] == 'migrations' and dep[1] == 'app2' 
+                for dep in getattr(op, '_auto_deps', [])
+            )
+            print(f"  Has dependency on migrations.App2: {has_dependency}")
+            if not has_dependency:
+                print("ERROR: Missing dependency on migrations.App2!")
+                sys.exit(1)
+            else:
+                print("SUCCESS: Dependency found!")
+                sys.exit(0)
+
+print("No operation found for another_app")
+sys.exit(1)
\ No newline at end of file