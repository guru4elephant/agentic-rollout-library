diff --git a/django/core/management/commands/flush.py b/django/core/management/commands/flush.py
index e8ed3967f7..bc8021cf4e 100644
--- a/django/core/management/commands/flush.py
+++ b/django/core/management/commands/flush.py
@@ -60,7 +60,7 @@ Are you sure you want to do this?
 
         if confirm == 'yes':
             try:
-                connection.ops.execute_sql_flush(database, sql_list)
+                connection.ops.execute_sql_flush(sql_list)
             except Exception as exc:
                 raise CommandError(
                     "Database %s couldn't be flushed. Possible reasons:\n"
diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py
index 70ac07ae09..f07580c18b 100644
--- a/django/db/backends/base/operations.py
+++ b/django/db/backends/base/operations.py
@@ -400,9 +400,9 @@ class BaseDatabaseOperations:
         """
         raise NotImplementedError('subclasses of BaseDatabaseOperations must provide a sql_flush() method')
 
-    def execute_sql_flush(self, using, sql_list):
+    def execute_sql_flush(self, sql_list):
         """Execute a list of SQL statements to flush the database."""
-        with transaction.atomic(using=using, savepoint=self.connection.features.can_rollback_ddl):
+        with transaction.atomic(using=self.connection.alias, savepoint=self.connection.features.can_rollback_ddl):
             with self.connection.cursor() as cursor:
                 for sql in sql_list:
                     cursor.execute(sql)
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..b67d7e9c1e
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+
+"""Final test to verify all changes work correctly"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import connection
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_all_changes():
+    """Test all aspects of the execute_sql_flush signature change"""
+    
+    print("1. Testing method signature...")
+    ops = BaseDatabaseOperations(connection=connection)
+    import inspect
+    sig = inspect.signature(ops.execute_sql_flush)
+    params = list(sig.parameters.keys())
+    
+    assert len(params) == 1, f"Expected 1 parameter, got {len(params)}"
+    assert params[0] == 'sql_list', f"Expected parameter 'sql_list', got '{params[0]}'"
+    print("   ✓ Signature is correct: execute_sql_flush(sql_list)")
+    
+    print("2. Testing method functionality...")
+    sql_list = []
+    try:
+        ops.execute_sql_flush(sql_list)
+        print("   ✓ Method executes successfully with empty SQL list")
+    except Exception as e:
+        print(f"   ✗ Method execution failed: {e}")
+        return False
+    
+    print("3. Testing connection alias consistency...")
+    assert connection.alias == ops.connection.alias, "Connection aliases should match"
+    print(f"   ✓ Connection aliases match: {connection.alias}")
+    
+    print("4. Testing flush command integration...")
+    from django.core.management.commands.flush import Command
+    from django.core.management import call_command
+    
+    try:
+        call_command('flush', '--noinput', '--database=default')
+        print("   ✓ Flush command works with new signature")
+    except Exception as e:
+        print(f"   ✗ Flush command failed: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    print("Running final comprehensive test...")
+    
+    if test_all_changes():
+        print("\n✓ All tests passed! The signature change is complete and working correctly.")
+        print("\nSummary of changes:")
+        print("1. Simplified execute_sql_flush signature from execute_sql_flush(using, sql_list) to execute_sql_flush(sql_list)")
+        print("2. Updated all callers to remove the using parameter")
+        print("3. The using parameter is now inferred from self.connection.alias")
+    else:
+        print("\n✗ Some tests failed!")
+        exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..3f82ea0906
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+
+"""Script to reproduce the execute_sql_flush signature issue"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+from django.db import connection
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_new_signature():
+    """Test the new signature of execute_sql_flush"""
+    ops = BaseDatabaseOperations(connection=connection)
+    
+    # Check the new signature
+    import inspect
+    sig = inspect.signature(ops.execute_sql_flush)
+    print(f"New signature: {sig}")
+    
+    # Check if using parameter can be inferred from connection
+    print(f"Connection alias: {connection.alias}")
+    print(f"Self connection alias: {ops.connection.alias}")
+    
+    # Test calling with new signature
+    sql_list = []
+    try:
+        ops.execute_sql_flush(sql_list)
+        print("New signature works")
+    except Exception as e:
+        print(f"Error with new signature: {e}")
+
+if __name__ == "__main__":
+    test_new_signature()
\ No newline at end of file
diff --git a/test_changes.py b/test_changes.py
new file mode 100644
index 0000000000..fa30bd4ce2
--- /dev/null
+++ b/test_changes.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+
+"""Test script to verify the execute_sql_flush signature changes work"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.backends',
+        ],
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import connection
+from django.core.management.color import no_style
+from django.db.backends.base.operations import BaseDatabaseOperations
+
+def test_signature_change():
+    """Test that the execute_sql_flush signature has been simplified"""
+    ops = BaseDatabaseOperations(connection=connection)
+    
+    # Check the signature
+    import inspect
+    sig = inspect.signature(ops.execute_sql_flush)
+    print(f"Signature: {sig}")
+    
+    # Verify it only takes sql_list parameter
+    params = list(sig.parameters.keys())
+    assert len(params) == 1, f"Expected 1 parameter, got {len(params)}: {params}"
+    assert params[0] == 'sql_list', f"Expected parameter 'sql_list', got '{params[0]}'"
+    
+    # Test calling the method
+    sql_list = []
+    try:
+        ops.execute_sql_flush(sql_list)
+        print("✓ Method call successful")
+    except Exception as e:
+        print(f"✗ Method call failed: {e}")
+        return False
+    
+    return True
+
+def test_connection_alias_match():
+    """Test that connection.alias and self.connection.alias match"""
+    ops = BaseDatabaseOperations(connection=connection)
+    
+    print(f"connection.alias: {connection.alias}")
+    print(f"ops.connection.alias: {ops.connection.alias}")
+    
+    assert connection.alias == ops.connection.alias, "Connection aliases should match"
+    print("✓ Connection aliases match")
+    return True
+
+if __name__ == "__main__":
+    print("Testing execute_sql_flush signature changes...")
+    
+    success = True
+    success &= test_signature_change()
+    success &= test_connection_alias_match()
+    
+    if success:
+        print("\n✓ All tests passed! The signature change is working correctly.")
+    else:
+        print("\n✗ Some tests failed.")
+        exit(1)
\ No newline at end of file
diff --git a/test_flush_command.py b/test_flush_command.py
new file mode 100644
index 0000000000..02c7718ebd
--- /dev/null
+++ b/test_flush_command.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+
+"""Test script to verify the flush command still works with the new signature"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.core.management.commands.flush import Command
+from django.core.management import call_command
+
+def test_flush_command():
+    """Test that the flush command still works"""
+    try:
+        # Test calling flush command with --noinput to avoid interactive prompt
+        call_command('flush', '--noinput', '--database=default')
+        print("✓ Flush command executed successfully")
+        return True
+    except Exception as e:
+        print(f"✗ Flush command failed: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing flush command with new execute_sql_flush signature...")
+    
+    if test_flush_command():
+        print("\n✓ Flush command test passed!")
+    else:
+        print("\n✗ Flush command test failed!")
+        exit(1)
\ No newline at end of file
diff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py
index 0485fe8465..b0ffe958c8 100644
--- a/tests/backends/base/test_operations.py
+++ b/tests/backends/base/test_operations.py
@@ -172,7 +172,7 @@ class SqlFlushTests(TransactionTestCase):
             reset_sequences=True,
             allow_cascade=True,
         )
-        connection.ops.execute_sql_flush(connection.alias, sql_list)
+        connection.ops.execute_sql_flush(sql_list)
 
         with transaction.atomic():
             self.assertIs(Author.objects.exists(), False)
diff --git a/tests/backends/tests.py b/tests/backends/tests.py
index d6c2331378..40fc6de7fc 100644
--- a/tests/backends/tests.py
+++ b/tests/backends/tests.py
@@ -162,7 +162,7 @@ class LongNameTest(TransactionTestCase):
             VLM_m2m._meta.db_table,
         ]
         sql_list = connection.ops.sql_flush(no_style(), tables, reset_sequences=True)
-        connection.ops.execute_sql_flush(connection.alias, sql_list)
+        connection.ops.execute_sql_flush(sql_list)
 
 
 class SequenceResetTest(TestCase):