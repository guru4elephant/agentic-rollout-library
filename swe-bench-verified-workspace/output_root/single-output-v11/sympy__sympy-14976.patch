diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..301f2f8e21
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+
+from sympy import Eq, rf, S, lambdify, nsolve, Float, symbols
+import inspect
+
+x = symbols('x')
+
+print("=== Final Test: GitHub Issue Reproduction ===")
+
+# Exact reproduction from the GitHub issue
+eqn = Eq(rf(18, x), 77 + S(1)/3)
+f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+
+print("Generated function source:")
+print(inspect.getsource(f))
+
+# Test the function
+result = f(1.5)
+print(f"Function evaluation at x=1.5: {result}")
+
+# Test nsolve precision
+x0 = nsolve(eqn, Float('1.5', 64), prec=64)
+rf_result = rf(18, x0).evalf(64)
+
+print(f"nsolve result: {x0}")
+print(f"rf(18, x0).evalf(64): {rf_result}")
+
+# Verify that we now have full precision
+expected = 77 + S(1)/3
+print(f"Expected value: {expected.evalf(64)}")
+
+# Check if we have full precision (should be exactly 77.333... with 64 digits)
+rf_str = str(rf_result)
+expected_str = str(expected.evalf(64))
+
+print(f"Precision check: {rf_str == expected_str}")
+
+if rf_str == expected_str:
+    print("SUCCESS: Full precision achieved!")
+else:
+    print("WARNING: Precision mismatch")
+    print(f"Got:      {rf_str}")
+    print(f"Expected: {expected_str}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ed50097b94
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+
+from sympy import Eq, rf, S, lambdify, nsolve, Float, symbols
+import inspect
+
+x = symbols('x')
+
+# Reproduce the issue described in the GitHub issue
+print("=== Reproducing the issue ===")
+
+# Create the equation
+eqn = Eq(rf(18, x), 77 + S(1)/3)
+print(f"Equation: {eqn}")
+
+# Lambdify with mpmath
+f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+print("\nGenerated function source:")
+print(inspect.getsource(f))
+
+# Test the function
+print(f"\nFunction evaluation at x=1.5: {f(1.5)}")
+
+# Try nsolve
+print("\n=== Testing nsolve ===")
+try:
+    x0 = nsolve(eqn, Float('1.5', 64), prec=64)
+    print(f"nsolve result: {x0}")
+    print(f"rf(18, x0).evalf(64): {rf(18, x0).evalf(64)}")
+except Exception as e:
+    print(f"nsolve failed: {e}")
+
+# Let's also check what the rational evaluates to in mpmath
+print("\n=== Testing mpmath directly ===")
+try:
+    import mpmath
+    print(f"mpmath.mpf(232/3): {mpmath.mpf(232/3)}")
+    print(f"mpmath.mpf(232)/mpmath.mpf(3): {mpmath.mpf(232)/mpmath.mpf(3)}")
+except ImportError:
+    print("mpmath not available")
\ No newline at end of file
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index d06901425d..160ffc7b23 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -9,6 +9,13 @@
 from functools import wraps
 from itertools import chain
 from sympy.core import sympify, S
+from sympy.core.numbers import Rational
+
+# Import MPMATH_TRANSLATIONS from lambdify
+try:
+    from sympy.utilities.lambdify import MPMATH_TRANSLATIONS
+except ImportError:
+    MPMATH_TRANSLATIONS = {}
 from .precedence import precedence
 from .codeprinter import CodePrinter
 
@@ -319,7 +326,8 @@ class MpmathPrinter(PythonCodePrinter):
 
     _kf = dict(chain(
         _known_functions.items(),
-        [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()]
+        [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()],
+        [(k, 'mpmath.' + v) for k, v in MPMATH_TRANSLATIONS.items()]
     ))
 
     def _print_Float(self, e):
@@ -331,6 +339,13 @@ def _print_Float(self, e):
         args = str(tuple(map(int, e._mpf_)))
         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
 
+    def _print_Rational(self, e):
+        # Convert rational numbers to mpmath.mpf for high precision
+        return '{0}({1})/{0}({2})'.format(
+            self._module_format('mpmath.mpf'),
+            self._print(e.p),
+            self._print(e.q))
+
 
     def _print_uppergamma(self, e):
         return "{0}({1}, {2}, {3})".format(
diff --git a/test_rational_fix.py b/test_rational_fix.py
new file mode 100644
index 0000000000..07cb64ba23
--- /dev/null
+++ b/test_rational_fix.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+
+from sympy import Eq, rf, S, lambdify, nsolve, Float, symbols, Rational
+import inspect
+
+x = symbols('x')
+
+print("=== Testing Rational fix ===")
+
+# Test 1: Simple rational
+print("\nTest 1: Simple rational")
+expr = S(1)/3
+f = lambdify([], expr, 'mpmath')
+print(f"Expression: {expr}")
+print(f"Generated source: {inspect.getsource(f)}")
+print(f"Result: {f()}")
+
+# Test 2: Negative rational
+print("\nTest 2: Negative rational")
+expr = -S(232)/3
+f = lambdify([], expr, 'mpmath')
+print(f"Expression: {expr}")
+print(f"Generated source: {inspect.getsource(f)}")
+print(f"Result: {f()}")
+
+# Test 3: Integer rational (should not be wrapped)
+print("\nTest 3: Integer rational")
+expr = S(5)/1
+f = lambdify([], expr, 'mpmath')
+print(f"Expression: {expr}")
+print(f"Generated source: {inspect.getsource(f)}")
+print(f"Result: {f()}")
+
+# Test 4: Complex expression with rationals
+print("\nTest 4: Complex expression")
+expr = S(1)/3 + S(2)/5
+f = lambdify([], expr, 'mpmath')
+print(f"Expression: {expr}")
+print(f"Generated source: {inspect.getsource(f)}")
+print(f"Result: {f()}")
+
+# Test 5: Original issue reproduction
+print("\nTest 5: Original issue")
+eqn = Eq(rf(18, x), 77 + S(1)/3)
+f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+print(f"Equation: {eqn}")
+print(f"Generated source: {inspect.getsource(f)}")
+print(f"Result at x=1.5: {f(1.5)}")
+
+# Test nsolve precision
+try:
+    x0 = nsolve(eqn, Float('1.5', 64), prec=64)
+    print(f"nsolve result: {x0}")
+    print(f"rf(18, x0).evalf(64): {rf(18, x0).evalf(64)}")
+except Exception as e:
+    print(f"nsolve failed: {e}")
\ No newline at end of file
diff --git a/test_rising_factorial.py b/test_rising_factorial.py
new file mode 100644
index 0000000000..72fe74c54d
--- /dev/null
+++ b/test_rising_factorial.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+from sympy import rf, lambdify, symbols
+import inspect
+
+x = symbols('x')
+
+print("=== Testing RisingFactorial translation ===")
+
+# Test RisingFactorial with mpmath
+expr = rf(18, x)
+f = lambdify(x, expr, 'mpmath')
+print(f"Expression: {expr}")
+print(f"Generated source: {inspect.getsource(f)}")
+
+# Test if it works
+try:
+    result = f(1.5)
+    print(f"Result at x=1.5: {result}")
+except Exception as e:
+    print(f"Error: {e}")
+
+# Test with explicit mpmath import
+try:
+    import mpmath
+    print(f"mpmath.rf(18, 1.5): {mpmath.rf(18, 1.5)}")
+except ImportError:
+    print("mpmath not available")
\ No newline at end of file