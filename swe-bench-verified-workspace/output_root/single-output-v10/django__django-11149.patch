diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..4ecebd6db7
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,170 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix for the ManyToMany inline permissions issue.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+        ROOT_URLCONF='test_urls',
+    )
+
+django.setup()
+
+from django.contrib.auth.models import User
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+from django.test import RequestFactory
+
+# Create a mock user with specific permissions
+class MockUser:
+    def __init__(self, perms):
+        self.perms = perms
+    
+    def has_perm(self, perm):
+        return perm in self.perms
+
+# Create test models as described in the issue
+class Photo(models.Model):
+    class Meta:
+        app_label = 'test_app'
+
+class Report(models.Model):
+    photos = models.ManyToManyField(Photo)
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create admin configuration as described in the issue
+class ReportPhotoInlineModelAdmin(admin.TabularInline):
+    model = Report.photos.through
+    show_change_link = True
+
+def test_permission_scenarios():
+    """Test various permission scenarios for ManyToMany inlines"""
+    print("Testing various permission scenarios for ManyToMany inlines...")
+    
+    # Create a request factory
+    factory = RequestFactory()
+    
+    # Get the inline admin instance
+    admin_site = AdminSite()
+    inline_admin = ReportPhotoInlineModelAdmin(Report, admin_site)
+    
+    # Test 1: User with only view permission
+    print("\n1. Testing user with only view permission:")
+    user_view_only = MockUser(['test_app.view_photo', 'test_app.view_report'])
+    request = factory.get('/admin/test_app/report/1/')
+    request.user = user_view_only
+    
+    print(f"  has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"  has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"  has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"  has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # View-only user should only have view permission
+    assert inline_admin.has_view_permission(request) == True
+    assert inline_admin.has_change_permission(request, None) == False
+    assert inline_admin.has_add_permission(request, None) == False
+    assert inline_admin.has_delete_permission(request, None) == False
+    print("  ✅ PASS: View-only user permissions are correct")
+    
+    # Test 2: User with change permission
+    print("\n2. Testing user with change permission:")
+    user_change = MockUser(['test_app.view_photo', 'test_app.view_report', 'test_app.change_photo'])
+    request.user = user_change
+    
+    print(f"  has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"  has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"  has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"  has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # User with change permission should have change, add, and delete permission
+    assert inline_admin.has_view_permission(request) == True
+    assert inline_admin.has_change_permission(request, None) == True
+    assert inline_admin.has_add_permission(request, None) == True
+    assert inline_admin.has_delete_permission(request, None) == True
+    print("  ✅ PASS: User with change permission has correct permissions")
+    
+    # Test 3: User with add permission
+    print("\n3. Testing user with add permission:")
+    user_add = MockUser(['test_app.view_photo', 'test_app.view_report', 'test_app.add_photo'])
+    request.user = user_add
+    
+    print(f"  has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"  has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"  has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"  has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # User with add permission should NOT have any inline permissions (only change grants them)
+    assert inline_admin.has_view_permission(request) == True
+    assert inline_admin.has_change_permission(request, None) == False
+    assert inline_admin.has_add_permission(request, None) == False
+    assert inline_admin.has_delete_permission(request, None) == False
+    print("  ✅ PASS: User with add permission has correct permissions")
+    
+    # Test 4: User with delete permission
+    print("\n4. Testing user with delete permission:")
+    user_delete = MockUser(['test_app.view_photo', 'test_app.view_report', 'test_app.delete_photo'])
+    request.user = user_delete
+    
+    print(f"  has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"  has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"  has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"  has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # User with delete permission should have delete permission but not change/add
+    assert inline_admin.has_view_permission(request) == True
+    assert inline_admin.has_change_permission(request, None) == False
+    assert inline_admin.has_add_permission(request, None) == False
+    assert inline_admin.has_delete_permission(request, None) == True
+    print("  ✅ PASS: User with delete permission has correct permissions")
+    
+    # Test 5: User with all permissions
+    print("\n5. Testing user with all permissions:")
+    user_all = MockUser([
+        'test_app.view_photo', 'test_app.view_report',
+        'test_app.change_photo', 'test_app.add_photo', 'test_app.delete_photo'
+    ])
+    request.user = user_all
+    
+    print(f"  has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"  has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"  has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"  has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # User with all permissions should have all permissions
+    assert inline_admin.has_view_permission(request) == True
+    assert inline_admin.has_change_permission(request, None) == True
+    assert inline_admin.has_add_permission(request, None) == True
+    assert inline_admin.has_delete_permission(request, None) == True
+    print("  ✅ PASS: User with all permissions has correct permissions")
+    
+    print("\n🎉 All tests passed! The fix is working correctly.")
+    return True
+
+if __name__ == '__main__':
+    success = test_permission_scenarios()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 880a2cc17b..4b3253cfad 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -2115,27 +2115,51 @@ class InlineModelAdmin(BaseModelAdmin):
         if self.opts.auto_created:
             # We're checking the rights to an auto-created intermediate model,
             # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
+            # to have the change permission for the related model in order to
+            # be able to add to the intermediate model.
+            opts = self.opts
+            # The model was auto-created as intermediary for a many-to-many
+            # relationship; find the target model.
+            for field in opts.fields:
+                if field.remote_field and field.remote_field.model != self.parent_model:
+                    opts = field.remote_field.model._meta
+                    break
+            return request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('change', opts)))
         return super().has_add_permission(request)
 
     def has_change_permission(self, request, obj=None):
         if self.opts.auto_created:
             # We're checking the rights to an auto-created intermediate model,
             # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
+            # to have the change permission for the related model in order to
+            # be able to change the intermediate model.
+            opts = self.opts
+            # The model was auto-created as intermediary for a many-to-many
+            # relationship; find the target model.
+            for field in opts.fields:
+                if field.remote_field and field.remote_field.model != self.parent_model:
+                    opts = field.remote_field.model._meta
+                    break
+            return request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('change', opts)))
         return super().has_change_permission(request)
 
     def has_delete_permission(self, request, obj=None):
         if self.opts.auto_created:
             # We're checking the rights to an auto-created intermediate model,
             # which doesn't have its own individual permissions. The user needs
-            # to have the view permission for the related model in order to
-            # be able to do anything with the intermediate model.
-            return self.has_view_permission(request, obj)
+            # to have the delete or change permission for the related model in order to
+            # be able to delete from the intermediate model.
+            opts = self.opts
+            # The model was auto-created as intermediary for a many-to-many
+            # relationship; find the target model.
+            for field in opts.fields:
+                if field.remote_field and field.remote_field.model != self.parent_model:
+                    opts = field.remote_field.model._meta
+                    break
+            return (
+                request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('delete', opts))) or
+                request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename('change', opts)))
+            )
         return super().has_delete_permission(request, obj)
 
     def has_view_permission(self, request, obj=None):
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..eaf8c48216
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where admin inlines for auto-created ManyToManyFields
+are editable even when the user only has view permission.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+        ROOT_URLCONF='test_urls',
+    )
+
+django.setup()
+
+# Create database tables
+from django.core.management import execute_from_command_line
+execute_from_command_line(['migrate', '--run-syncdb'])
+
+from django.contrib.auth.models import User, Permission
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+from django.test import RequestFactory
+
+# Create test models as described in the issue
+class Photo(models.Model):
+    class Meta:
+        app_label = 'test_app'
+
+class Report(models.Model):
+    photos = models.ManyToManyField(Photo)
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create admin configuration as described in the issue
+class ReportPhotoInlineModelAdmin(admin.TabularInline):
+    model = Report.photos.through
+    show_change_link = True
+
+class ReportAdmin(admin.ModelAdmin):
+    inlines = [ReportPhotoInlineModelAdmin]
+
+# Set up admin site
+admin_site = AdminSite()
+admin_site.register(Report, ReportAdmin)
+admin_site.register(Photo)
+
+def test_view_only_permissions():
+    """Test that a user with only view permission cannot edit ManyToMany inlines"""
+    print("Testing view-only permissions for ManyToMany inlines...")
+    
+    # Create a user with only view permission
+    user = User.objects.create_user(username='viewer', password='password')
+    
+    # Grant only view permission for both models
+    view_photo_perm = Permission.objects.get(codename='view_photo')
+    view_report_perm = Permission.objects.get(codename='view_report')
+    user.user_permissions.add(view_photo_perm, view_report_perm)
+    
+    # Create a request factory
+    factory = RequestFactory()
+    
+    # Create a request with the view-only user
+    request = factory.get('/admin/test_app/report/1/')
+    request.user = user
+    
+    # Create a report instance
+    report = Report.objects.create()
+    
+    # Get the inline admin instance
+    inline_admin = ReportPhotoInlineModelAdmin(Report, admin_site)
+    
+    # Test permissions
+    print(f"User has view permission for Photo: {user.has_perm('test_app.view_photo')}")
+    print(f"User has change permission for Photo: {user.has_perm('test_app.change_photo')}")
+    print(f"User has add permission for Photo: {user.has_perm('test_app.add_photo')}")
+    print(f"User has delete permission for Photo: {user.has_perm('test_app.delete_photo')}")
+    
+    print(f"Inline has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"Inline has_change_permission: {inline_admin.has_change_permission(request)}")
+    print(f"Inline has_add_permission: {inline_admin.has_add_permission(request)}")
+    print(f"Inline has_delete_permission: {inline_admin.has_delete_permission(request)}")
+    
+    # The issue: has_change_permission should return False for view-only users
+    # but currently returns True because it falls back to has_view_permission
+    if inline_admin.has_change_permission(request):
+        print("❌ BUG: User with only view permission can change ManyToMany inline!")
+        return False
+    else:
+        print("✅ OK: User with only view permission cannot change ManyToMany inline")
+        return True
+
+if __name__ == '__main__':
+    success = test_view_only_permissions()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..6499373f1e
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3
+"""
+Simplified script to reproduce the issue where admin inlines for auto-created ManyToManyFields
+are editable even when the user only has view permission.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'django.contrib.admin',
+            'django.contrib.messages',
+            'django.contrib.sessions',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+        ROOT_URLCONF='test_urls',
+    )
+
+django.setup()
+
+from django.contrib.auth.models import User
+from django.db import models
+from django.contrib import admin
+from django.contrib.admin.sites import AdminSite
+from django.test import RequestFactory
+
+# Create a mock user with specific permissions
+class MockUser:
+    def __init__(self, perms):
+        self.perms = perms
+    
+    def has_perm(self, perm):
+        return perm in self.perms
+
+# Create test models as described in the issue
+class Photo(models.Model):
+    class Meta:
+        app_label = 'test_app'
+
+class Report(models.Model):
+    photos = models.ManyToManyField(Photo)
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create admin configuration as described in the issue
+class ReportPhotoInlineModelAdmin(admin.TabularInline):
+    model = Report.photos.through
+    show_change_link = True
+
+def test_view_only_permissions():
+    """Test that a user with only view permission cannot edit ManyToMany inlines"""
+    print("Testing view-only permissions for ManyToMany inlines...")
+    
+    # Create a user with only view permission
+    user = MockUser(['test_app.view_photo', 'test_app.view_report'])
+    
+    # Create a request factory
+    factory = RequestFactory()
+    
+    # Create a request with the view-only user
+    request = factory.get('/admin/test_app/report/1/')
+    request.user = user
+    
+    # Get the inline admin instance
+    admin_site = AdminSite()
+    inline_admin = ReportPhotoInlineModelAdmin(Report, admin_site)
+    
+    # Test permissions
+    print(f"User has view permission for Photo: {user.has_perm('test_app.view_photo')}")
+    print(f"User has change permission for Photo: {user.has_perm('test_app.change_photo')}")
+    print(f"User has add permission for Photo: {user.has_perm('test_app.add_photo')}")
+    print(f"User has delete permission for Photo: {user.has_perm('test_app.delete_photo')}")
+    
+    print(f"Inline has_view_permission: {inline_admin.has_view_permission(request)}")
+    print(f"Inline has_change_permission: {inline_admin.has_change_permission(request, None)}")
+    print(f"Inline has_add_permission: {inline_admin.has_add_permission(request, None)}")
+    print(f"Inline has_delete_permission: {inline_admin.has_delete_permission(request, None)}")
+    
+    # The issue: has_change_permission should return False for view-only users
+    # but currently returns True because it falls back to has_view_permission
+    if inline_admin.has_change_permission(request, None):
+        print("❌ BUG: User with only view permission can change ManyToMany inline!")
+        return False
+    else:
+        print("✅ OK: User with only view permission cannot change ManyToMany inline")
+        return True
+
+if __name__ == '__main__':
+    success = test_view_only_permissions()
+    sys.exit(0 if success else 1)
\ No newline at end of file