diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..9cbd954c46
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import tempfile
+import django
+from django.conf import settings
+
+# Add the Django project to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+TMPDIR = tempfile.mkdtemp(prefix='django_')
+TEMPLATE_DIR = os.path.join(TMPDIR, 'templates')
+
+# Basic Django settings configuration
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    order = models.IntegerField()
+    description = models.TextField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_comprehensive():
+    # Test 1: Basic union with different values_list calls
+    print("=== Test 1: Basic union with different values_list calls ===")
+    qs1 = TestModel.objects.all()
+    
+    union1 = qs1.union(qs1).values_list('name', 'order')
+    sql1, _ = union1.query.sql_with_params()
+    print(f"values_list('name', 'order'): {sql1}")
+    
+    union2 = qs1.union(qs1).values_list('order')
+    sql2, _ = union2.query.sql_with_params()
+    print(f"values_list('order'): {sql2}")
+    
+    if sql1 != sql2:
+        print("✓ PASS: Different SQL generated for different values_list calls")
+    else:
+        print("✗ FAIL: Same SQL generated for different values_list calls")
+    
+    # Test 2: Multiple fields
+    print("\n=== Test 2: Multiple fields ===")
+    union3 = qs1.union(qs1).values_list('name', 'description')
+    sql3, _ = union3.query.sql_with_params()
+    print(f"values_list('name', 'description'): {sql3}")
+    
+    if 'description' in sql3 and 'order' not in sql3:
+        print("✓ PASS: Correct fields selected")
+    else:
+        print("✗ FAIL: Wrong fields selected")
+    
+    # Test 3: Chained operations
+    print("\n=== Test 3: Chained operations ===")
+    union4 = qs1.union(qs1).values_list('name').union(qs1).values_list('order')
+    sql4, _ = union4.query.sql_with_params()
+    print(f"Chained union with values_list: {sql4}")
+    
+    if 'order' in sql4 and 'name' not in sql4:
+        print("✓ PASS: Chained operations work correctly")
+    else:
+        print("✗ FAIL: Chained operations not working correctly")
+    
+    # Test 4: Intersection and difference
+    print("\n=== Test 4: Intersection and difference ===")
+    intersection = qs1.intersection(qs1).values_list('name')
+    sql_int, _ = intersection.query.sql_with_params()
+    print(f"Intersection values_list('name'): {sql_int}")
+    
+    difference = qs1.difference(qs1).values_list('order')
+    sql_diff, _ = difference.query.sql_with_params()
+    print(f"Difference values_list('order'): {sql_diff}")
+    
+    if 'name' in sql_int and 'order' in sql_diff:
+        print("✓ PASS: Intersection and difference work correctly")
+    else:
+        print("✗ FAIL: Intersection and difference not working correctly")
+    
+    print("\n=== All tests completed ===")
+
+if __name__ == '__main__':
+    test_comprehensive()
\ No newline at end of file
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 08d7faf194..7bd253aa97 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -2061,6 +2061,12 @@ class Query(BaseExpression):
 
         self.values_select = tuple(field_names)
         self.add_fields(field_names, True)
+        
+        # If this is a combinator query (e.g., union, intersection, difference),
+        # propagate the values selection to all combined queries.
+        if self.combined_queries:
+            for query in self.combined_queries:
+                query.set_values(fields)
 
     @property
     def annotation_select(self):
diff --git a/original_issue_test.py b/original_issue_test.py
new file mode 100644
index 0000000000..7a902f2978
--- /dev/null
+++ b/original_issue_test.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import tempfile
+import django
+from django.conf import settings
+
+# Add the Django project to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings
+TMPDIR = tempfile.mkdtemp(prefix='django_')
+
+# Basic Django settings configuration
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+
+# Create the ReservedName model as mentioned in the issue
+class ReservedName(models.Model):
+    name = models.CharField(max_length=100)
+    order = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_original_issue():
+    # Create the query set
+    qs1 = ReservedName.objects.all()
+    
+    print("Testing the exact scenario from the GitHub issue:")
+    print(">>> ReservedName.objects.create(name='a', order=2)")
+    print(">>> qs1 = ReservedName.objects.all()")
+    
+    print("Testing SQL generation (the actual issue was in SQL generation):")
+    
+    # Test the SQL generation for the first query
+    union_query1 = qs1.union(qs1).values_list('name', 'order')
+    sql1, params1 = union_query1.query.sql_with_params()
+    print(f">>> qs1.union(qs1).values_list('name', 'order')")
+    print(f"SQL: {sql1}")
+    
+    # Test the SQL generation for the second query  
+    union_query2 = qs1.union(qs1).values_list('order')
+    sql2, params2 = union_query2.query.sql_with_params()
+    print(f">>> qs1.union(qs1).values_list('order')")
+    print(f"SQL: {sql2}")
+    
+    # The issue was that both queries generated the same SQL
+    # Before the fix: both would select "name", "order"
+    # After the fix: first selects "name", "order", second selects only "order"
+    if sql1 != sql2:
+        print("✓ Issue is FIXED: Different SQL generated for different values_list calls")
+        
+        # More precise check: look for field selection patterns
+        selects_sql1 = sql1.split('SELECT ')[1].split(' FROM')[0]
+        selects_sql2 = sql2.split('SELECT ')[1].split(' FROM')[0]
+        
+        print(f"First query selects: {selects_sql1}")
+        print(f"Second query selects: {selects_sql2}")
+        
+        if '"name"' in selects_sql1 and '"order"' in selects_sql1 and '"name"' not in selects_sql2 and '"order"' in selects_sql2:
+            print("✓ SQL generation is correct - proper fields are selected")
+        else:
+            print("⚠ SQL generation may have issues - check field selection")
+    else:
+        print("✗ Issue EXISTS: Same SQL generated for different values_list calls")
+        print("Both queries generate the same SQL despite different values_list() calls")
+
+if __name__ == '__main__':
+    test_original_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..77f983eb32
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import tempfile
+import django
+from django.conf import settings
+from django.db import connection, connections
+from django.test.utils import get_runner
+
+# Add the Django project to the Python path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings similar to runtests.py
+TMPDIR = tempfile.mkdtemp(prefix='django_')
+TEMPLATE_DIR = os.path.join(TMPDIR, 'templates')
+
+# Basic Django settings configuration
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models
+
+# Create a simple model for testing
+class ReservedName(models.Model):
+    name = models.CharField(max_length=100)
+    order = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+def test_issue():
+    # Create the query set (we won't actually execute it, just examine the SQL)
+    qs1 = ReservedName.objects.all()
+    
+    print("Testing union query generation...")
+    
+    # Get the SQL for the first query
+    union_query1 = qs1.union(qs1).values_list('name', 'order')
+    sql1, params1 = union_query1.query.sql_with_params()
+    print(f"SQL for values_list('name', 'order'): {sql1}")
+    
+    # Get the SQL for the second query  
+    union_query2 = qs1.union(qs1).values_list('order')
+    sql2, params2 = union_query2.query.sql_with_params()
+    print(f"SQL for values_list('order'): {sql2}")
+    
+    # The issue should be visible in the generated SQL
+    # Both queries should have different SELECT clauses but the bug causes them to be the same
+    if sql1 != sql2:
+        print("✓ SQL queries are different - issue may be fixed")
+    else:
+        print("✗ SQL queries are the same - issue exists")
+        print("Both queries generate the same SQL despite different values_list() calls")
+
+if __name__ == '__main__':
+    test_issue()
\ No newline at end of file