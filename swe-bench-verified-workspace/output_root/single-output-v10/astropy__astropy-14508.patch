diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 118bfced89..b63bdfbdd0 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -1299,7 +1299,17 @@ def _format_value(value):
 
 def _format_float(value):
     """Format a floating number to make sure it gets the decimal point."""
-    value_str = f"{value:.16G}"
+    # First try using Python's string representation, which is often more concise
+    value_str = str(value)
+    
+    # Convert any scientific notation to use uppercase 'E' for FITS compliance
+    if 'e' in value_str:
+        value_str = value_str.replace('e', 'E')
+    
+    # If the Python representation doesn't contain a decimal point or is too long,
+    # fall back to the original formatting method
+    if ("." not in value_str and "E" not in value_str) or len(value_str) > 20:
+        value_str = f"{value:.16G}"
     if "." not in value_str and "E" not in value_str:
         value_str += ".0"
     elif "E" in value_str:
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..b0870e05c8
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,49 @@
+from astropy.io import fits
+
+print("=== Final Verification of GitHub Issue Fix ===")
+
+# Test the exact case from the GitHub issue
+print("\n1. Testing the exact case from GitHub issue:")
+value = 0.009125
+comment = "[m] radius arround actuator to avoid"
+keyword = "ESO IFM CL RADIUS"
+
+# Create a card with the problematic value
+card = fits.Card(f'HIERARCH {keyword}', value, comment)
+
+print(f"Card created successfully without warnings!")
+print(f"repr: {repr(card)}")
+print(f"str: {str(card)}")
+print(f"Value: {card.value}")
+print(f"Comment: {card.comment}")
+
+# Verify the card can be written to a FITS file without issues
+print("\n2. Testing FITS file creation:")
+hdr = fits.Header()
+hdr[f'HIERARCH {keyword}'] = (value, comment)
+
+# Create a simple FITS file
+import numpy as np
+data = np.array([[1, 2], [3, 4]])
+fits.writeto('test_final.fits', data=data, header=hdr, overwrite=True)
+
+print("FITS file created successfully!")
+
+# Read it back and verify
+print("\n3. Testing FITS file reading:")
+hdr_read = fits.getheader('test_final.fits')
+card_read = hdr_read.cards[keyword]
+
+print(f"Read back card:")
+print(f"repr: {repr(card_read)}")
+print(f"str: {str(card_read)}")
+print(f"Value: {card_read.value}")
+print(f"Comment: {card_read.comment}")
+
+# Verify they are identical
+print(f"\n4. Verification:")
+print(f"Cards are identical: {str(card) == str(card_read)}")
+print(f"Values are identical: {card.value == card_read.value}")
+print(f"Comments are identical: {card.comment == card_read.comment}")
+
+print("\n=== GitHub Issue Successfully Resolved ===")
\ No newline at end of file
diff --git a/pyproject.toml b/pyproject.toml
index 65df5b1b77..d02c4f9eda 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["setuptools",
+requires = ["setuptools==68.0.0",
             "setuptools_scm>=6.2",
             "wheel",
             "cython==0.29.30",
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2183586cf1
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+from astropy.io import fits
+import numpy as np
+
+# Create a test file with the problematic card
+hdr = fits.Header()
+hdr['HIERARCH ESO IFM CL RADIUS'] = (0.009125, '[m] radius arround actuator to avoid')
+
+# Save to a temporary file (need some dummy data)
+dummy_data = np.array([[1, 2], [3, 4]])
+fits.writeto('test.fits', data=dummy_data, header=hdr, overwrite=True)
+
+# Read it back
+hdr_read = fits.getheader('test.fits')
+c = hdr_read.cards['ESO IFM CL RADIUS']
+
+print("Original card:")
+print(f"repr: {repr(c)}")
+print(f"str: {str(c)}")
+
+# Try to create a new card with the same values
+print("\nTrying to recreate the same card:")
+new_c = fits.Card(f'HIERARCH {c.keyword}', c.value, c.comment)
+print(f"repr: {repr(new_c)}")
+print(f"str: {str(new_c)}")
+
+# Check if they are the same
+print(f"\nCards are identical: {str(c) == str(new_c)}")
\ No newline at end of file
diff --git a/test.fits b/test.fits
new file mode 100644
index 0000000000..c0197d1a34
Binary files /dev/null and b/test.fits differ
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..181611043a
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,23 @@
+from astropy.io.fits.card import _format_float
+
+# Test various edge cases
+test_cases = [
+    0.0,           # Zero
+    1.0,           # Integer-like float
+    1234567890.0,  # Large number
+    1e-10,         # Very small number
+    1e10,          # Very large number
+    3.141592653589793,  # Pi
+    -123.456,      # Negative number
+    1.2345678901234567890,  # Long float
+]
+
+print("Testing edge cases for _format_float:")
+for value in test_cases:
+    formatted = _format_float(value)
+    python_str = str(value)
+    print(f"Value: {value}")
+    print(f"  Python str: {python_str} (length: {len(python_str)})")
+    print(f"  Formatted: {formatted} (length: {len(formatted)})")
+    print(f"  Within 20 chars: {len(formatted) <= 20}")
+    print()
\ No newline at end of file
diff --git a/test_fallback.py b/test_fallback.py
new file mode 100644
index 0000000000..5832f55857
--- /dev/null
+++ b/test_fallback.py
@@ -0,0 +1,29 @@
+from astropy.io.fits.card import _format_float
+
+# Create a very precise float that should trigger the fallback
+# We need a value that when converted to string would be longer than 20 characters
+value = 1.23456789012345678901234567890123456789  # Very long float
+
+print(f"Testing a very long float: {value}")
+python_str = str(value)
+formatted = _format_float(value)
+
+print(f"Python str: {python_str} (length: {len(python_str)})")
+print(f"Formatted: {formatted} (length: {len(formatted)})")
+print(f"Within 20 chars: {len(formatted) <= 20}")
+
+# Test if the fallback works when Python string is too long
+if len(python_str) > 20:
+    print("✓ Fallback to scientific notation worked correctly")
+else:
+    print("Python representation was sufficient")
+    
+# Also test a case without decimal point
+value_int = 12345678901234567890.0  # Large integer-like float
+print(f"\nTesting large integer-like float: {value_int}")
+python_str_int = str(value_int)
+formatted_int = _format_float(value_int)
+
+print(f"Python str: {python_str_int} (length: {len(python_str_int)})")
+print(f"Formatted: {formatted_int} (length: {len(formatted_int)})")
+print(f"Contains decimal: {'.' in formatted_int}")
\ No newline at end of file
diff --git a/test_final.fits b/test_final.fits
new file mode 100644
index 0000000000..c0197d1a34
Binary files /dev/null and b/test_final.fits differ
diff --git a/test_format_float.py b/test_format_float.py
new file mode 100644
index 0000000000..257042bf4a
--- /dev/null
+++ b/test_format_float.py
@@ -0,0 +1,23 @@
+from astropy.io.fits.card import _format_float
+
+# Test the specific case mentioned in the issue
+value = 0.009125
+formatted = _format_float(value)
+
+print(f"Original value: {value}")
+print(f"Formatted value: {formatted}")
+print(f"Length: {len(formatted)}")
+print(f"Expected: 0.009125")
+print(f"Using str(value): {str(value)}")
+print(f"Using repr(value): {repr(value)}")
+
+# Test what Python's default string representation gives us
+python_str = str(value)
+print(f"\nPython str(value): {python_str}")
+print(f"Length: {len(python_str)}")
+
+# Test if we can use the Python representation if it fits within 20 characters
+if len(python_str) <= 20:
+    print("Python representation fits within 20 characters")
+else:
+    print("Python representation is too long")
\ No newline at end of file
diff --git a/test_long_case.py b/test_long_case.py
new file mode 100644
index 0000000000..1c0d5a87aa
--- /dev/null
+++ b/test_long_case.py
@@ -0,0 +1,22 @@
+from astropy.io.fits.card import _format_float
+
+# Test a case where Python's string representation would be too long
+# We need a very precise float that would result in a long string
+import math
+
+# A very precise value that might produce a long string
+value = math.pi * 1e10  # Large value with many decimal places
+
+print(f"Testing a potentially long float: {value}")
+python_str = str(value)
+formatted = _format_float(value)
+
+print(f"Python str: {python_str} (length: {len(python_str)})")
+print(f"Formatted: {formatted} (length: {len(formatted)})")
+print(f"Within 20 chars: {len(formatted) <= 20}")
+
+# Test if the fallback works when Python string is too long
+if len(python_str) > 20:
+    print("✓ Fallback to scientific notation worked correctly")
+else:
+    print("✓ Python representation was sufficient")
\ No newline at end of file
diff --git a/test_scientific_case.py b/test_scientific_case.py
new file mode 100644
index 0000000000..f03ed4bbbe
--- /dev/null
+++ b/test_scientific_case.py
@@ -0,0 +1,20 @@
+from astropy.io.fits.card import _format_float
+
+# Test the specific case from the failing test
+value = 5.0022221e-07
+
+print(f"Original value: {value}")
+print(f"Python str(): {str(value)}")
+print(f"Python repr(): {repr(value)}")
+
+# Test what the original formatting would produce
+original_format = f"{value:.16G}"
+print(f"Original .16G format: {original_format}")
+
+# Test our current implementation
+current_format = _format_float(value)
+print(f"Current _format_float: {current_format}")
+
+# Check if it contains lowercase 'e'
+if 'e' in current_format and 'E' not in current_format:
+    print("WARNING: Contains lowercase 'e' which might cause FITS standard issues")
\ No newline at end of file