diff --git a/debug_save.py b/debug_save.py
new file mode 100644
index 0000000000..550a06b984
--- /dev/null
+++ b/debug_save.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings - use a minimal setup
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    SECRET_KEY='test-secret-key',
+    USE_TZ=True,
+)
+
+# Initialize Django
+django.setup()
+
+from django.db import models
+from django.db import connection
+
+# Monkey patch the _save_table method to add debugging
+from django.db.models.base import Model
+
+original_save_table = Model._save_table
+
+def debug_save_table(self, raw=False, cls=None, force_insert=False,
+                    force_update=False, using=None, update_fields=None):
+    print(f"=== _save_table called ===")
+    print(f"self.pk: {getattr(self, 'pk', 'N/A')}")
+    print(f"self._state.adding: {self._state.adding}")
+    print(f"force_insert: {force_insert}")
+    print(f"force_update: {force_update}")
+    
+    # Call the original method
+    result = original_save_table(self, raw, cls, force_insert, force_update, using, update_fields)
+    
+    print(f"=== _save_table result: {result} ===")
+    return result
+
+# Apply the monkey patch
+Model._save_table = debug_save_table
+
+# Define the models from the issue
+class Item(models.Model):
+    uid = models.AutoField(primary_key=True, editable=False)
+    f = models.BooleanField(default=False)
+    
+    def reset(self):
+        self.uid = None
+        self.f = False
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_test():
+    print("=== Debug Test ===")
+    
+    # Create the first object
+    derived = Item.objects.create(f=True)
+    print(f"Created first object with pk: {derived.pk}, f: {derived.f}")
+    
+    # Get the item object
+    item = Item.objects.get(pk=derived.pk)
+    print(f"Retrieved object with pk: {item.pk}, f: {item.f}")
+    
+    # Check the state before reset
+    print(f"Before reset - _state.adding: {item._state.adding}")
+    
+    # Reset the object (set pk to None)
+    item.reset()
+    print(f"After reset - pk: {item.pk}, f: {item.f}, _state.adding: {item._state.adding}")
+    
+    # Save the reset object
+    item.save()
+    print(f"After save - pk: {item.pk}, f: {item.f}, _state.adding: {item._state.adding}")
+    
+    # Check if the original object was overwritten or a new one was created
+    try:
+        original_obj = Item.objects.get(pk=derived.pk)
+        print(f"Original object still exists: pk: {original_obj.pk}, f: {original_obj.f}")
+        print("ISSUE: The original object was overwritten instead of creating a new one!")
+        return False
+    except Item.DoesNotExist:
+        print("SUCCESS: Original object was deleted and a new one was created!")
+        return True
+
+if __name__ == "__main__":
+    # Create test database tables using Django's schema editor
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Item)
+    
+    # Run the test
+    success = debug_test()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..62e203cc06
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings - use a minimal setup
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    SECRET_KEY='test-secret-key',
+    USE_TZ=True,
+)
+
+# Initialize Django
+django.setup()
+
+from django.db import models
+from django.db import connection
+
+# Define the models from the issue
+class Item(models.Model):
+    uid = models.AutoField(primary_key=True, editable=False)
+    f = models.BooleanField(default=False)
+    
+    def reset(self):
+        self.uid = None
+        self.f = False
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_test():
+    print("=== Debug Test ===")
+    
+    # Create the first object
+    derived = Item.objects.create(f=True)
+    print(f"Created first object with pk: {derived.pk}, f: {derived.f}")
+    
+    # Get the item object
+    item = Item.objects.get(pk=derived.pk)
+    print(f"Retrieved object with pk: {item.pk}, f: {item.f}")
+    
+    # Check the state before reset
+    print(f"Before reset - _state.adding: {item._state.adding}")
+    
+    # Reset the object (set pk to None)
+    item.reset()
+    print(f"After reset - pk: {item.pk}, f: {item.f}, _state.adding: {item._state.adding}")
+    
+    # Save the reset object
+    item.save()
+    print(f"After save - pk: {item.pk}, f: {item.f}, _state.adding: {item._state.adding}")
+    
+    # Check if the original object was overwritten or a new one was created
+    try:
+        original_obj = Item.objects.get(pk=derived.pk)
+        print(f"Original object still exists: pk: {original_obj.pk}, f: {original_obj.f}")
+        print("ISSUE: The original object was overwritten instead of creating a new one!")
+        return False
+    except Item.DoesNotExist:
+        print("SUCCESS: Original object was deleted and a new one was created!")
+        return True
+
+if __name__ == "__main__":
+    # Create test database tables using Django's schema editor
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Item)
+    
+    # Run the test
+    success = debug_test()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/django/db/models/base.py b/django/db/models/base.py
index 844c01e95e..4b9238cc05 100644
--- a/django/db/models/base.py
+++ b/django/db/models/base.py
@@ -393,11 +393,14 @@ class ModelStateFieldsCacheDescriptor:
 class ModelState:
     """Store model instance state."""
     db = None
-    # If true, uniqueness validation checks will consider this a new, unsaved
+    # If true, uniqueness validation checks will consider this a new, 4unsaved
     # object. Necessary for correct validation of new instances of objects with
     # explicit (non-auto) PKs. This impacts validation only; it has no effect
     # on the actual save.
     adding = True
+    # Flag to track if adding was originally False before being set to True
+    # due to explicit primary key reset to None
+    adding_was_false_before = False
     fields_cache = ModelStateFieldsCacheDescriptor()
 
 
@@ -843,18 +846,34 @@ class Model(metaclass=ModelBase):
         if pk_val is None:
             pk_val = meta.pk.get_pk_value_on_save(self)
             setattr(self, meta.pk.attname, pk_val)
+            # If we generated a new primary key value for an existing object,
+            # treat this as a new object to handle the case where user explicitly set pk to None
+            if not self._state.adding:
+                print(f"DEBUG: Changing _state.adding from {self._state.adding} to True")
+                self._state.adding = True
+                # Set a custom flag to indicate this was originally an existing object
+                self._state.adding_was_false_before = True
+                print(f"DEBUG: Setting adding_was_false_before to {self._state.adding_was_false_before}")
         pk_set = pk_val is not None
         if not pk_set and (force_update or update_fields):
             raise ValueError("Cannot force an update in save() with no primary key.")
         updated = False
         # Skip an UPDATE when adding an instance and primary key has a default.
+        # Also force insert when user explicitly set primary key to None on an existing object
+        print(f"DEBUG: Condition check - raw: {raw}, force_insert: {force_insert}, self._state.adding: {self._state.adding}, pk_val: {pk_val}")
         if (
-            not raw and
+            (not raw and
             not force_insert and
             self._state.adding and
             self._meta.pk.default and
-            self._meta.pk.default is not NOT_PROVIDED
+            self._meta.pk.default is not NOT_PROVIDED)
+            or
+            (not raw and
+            not force_insert and
+            self._state.adding and
+            self._state.adding_was_false_before)  # Custom flag to detect explicit None set
         ):
+            print("DEBUG: Setting force_insert = True")
             force_insert = True
         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
         if pk_set and not force_insert:
@@ -869,6 +888,7 @@ class Model(metaclass=ModelBase):
             if update_fields and not updated:
                 raise DatabaseError("Save with update_fields did not affect any rows.")
         if not updated:
+            print(f"DEBUG: Doing INSERT - pk_set: {pk_set}, force_insert: {force_insert}")
             if meta.order_with_respect_to:
                 # If this is a model with an order_with_respect_to
                 # autopopulate the _order field
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a435231a6f
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings - use a minimal setup similar to runtests.py
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    SECRET_KEY='test-secret-key',
+    USE_TZ=True,
+)
+
+# Initialize Django
+django.setup()
+
+from django.db import models
+from django.test import TestCase
+import uuid
+
+# Define the models from the issue
+class Item(models.Model):
+    # uid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    uid = models.AutoField(primary_key=True, editable=False)
+    f = models.BooleanField(default=False)
+    
+    def reset(self):
+        self.uid = None
+        self.f = False
+    
+    class Meta:
+        app_label = 'test'
+
+class Derived(Item):
+    class Meta:
+        app_label = 'test'
+
+def test_issue():
+    print("Testing the issue...")
+    
+    # Create the first object
+    derived = Derived.objects.create(f=True)
+    print(f"Created first object with pk: {derived.pk}, f: {derived.f}")
+    
+    # Get the item and its derived object
+    item = Item.objects.get(pk=derived.pk)
+    obj1 = item.derived
+    print(f"Retrieved derived object with pk: {obj1.pk}, f: {obj1.f}")
+    
+    # Reset the object (set pk to None)
+    obj1.reset()
+    print(f"After reset - pk: {obj1.pk}, f: {obj1.f}")
+    
+    # Save the reset object - this should create a new object, not overwrite
+    obj1.save()
+    print(f"After save - pk: {obj1.pk}, f: {obj1.f}")
+    
+    # Check if the original object was overwritten or a new one was created
+    try:
+        original_obj = Item.objects.get(pk=derived.pk)
+        print(f"Original object still exists: pk: {original_obj.pk}, f: {original_obj.f}")
+        print("ISSUE: The original object was overwritten instead of creating a new one!")
+        return False
+    except Item.DoesNotExist:
+        print("SUCCESS: Original object was deleted and a new one was created!")
+        return True
+
+if __name__ == "__main__":
+    # Create test database tables using Django's schema editor
+    from django.db import connection
+    
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Item)
+        schema_editor.create_model(Derived)
+    
+    # Run the test
+    success = test_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file