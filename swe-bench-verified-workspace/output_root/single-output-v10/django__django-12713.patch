diff --git a/advanced_test.py b/advanced_test.py
new file mode 100644
index 0000000000..4058a135bd
--- /dev/null
+++ b/advanced_test.py
@@ -0,0 +1,146 @@
+#!/usr/bin/env python3
+"""
+Advanced test to understand when the widget override issue occurs.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.contrib import admin
+from django.contrib.auth.models import User, Group
+
+# Create test models
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key_field = models.ForeignKey(User, on_delete=models.CASCADE)
+    many_to_many_field = models.ManyToManyField(Group)
+    
+    class Meta:
+        app_label = 'test'
+
+# Custom admin that simulates different admin configurations
+class TestModelAdmin(admin.ModelAdmin):
+    # Set up different admin configurations
+    autocomplete_fields = ['foreign_key_field', 'many_to_many_field']
+    raw_id_fields = ['foreign_key_field', 'many_to_many_field']
+    
+    def formfield_for_foreignkey(self, db_field, request, **kwargs):
+        """Test what happens in different scenarios"""
+        print(f"\n=== formfield_for_foreignkey for {db_field.name} ===")
+        print(f"kwargs before: {list(kwargs.keys())}")
+        if 'widget' in kwargs:
+            print(f"Widget before: {type(kwargs['widget']).__name__}")
+        
+        # Let's see what the original implementation does
+        result = super().formfield_for_foreignkey(db_field, request, **kwargs)
+        
+        print(f"kwargs after: {list(kwargs.keys())}")
+        if 'widget' in kwargs:
+            print(f"Widget after: {type(kwargs['widget']).__name__}")
+        print(f"Result widget: {type(result.widget).__name__}")
+        return result
+    
+    def formfield_for_manytomany(self, db_field, request, **kwargs):
+        """Test what happens in different scenarios"""
+        print(f"\n=== formfield_for_manytomany for {db_field.name} ===")
+        print(f"kwargs before: {list(kwargs.keys())}")
+        if 'widget' in kwargs:
+            print(f"Widget before: {type(kwargs['widget']).__name__}")
+        
+        # Let's see what the original implementation does
+        result = super().formfield_for_manytomany(db_field, request, **kwargs)
+        
+        print(f"kwargs after: {list(kwargs.keys())}")
+        if 'widget' in kwargs:
+            print(f"Widget after: {type(kwargs['widget']).__name__}")
+        print(f"Result widget: {type(result.widget).__name__}")
+        return result
+
+def test_scenarios():
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    # Get the fields
+    foreign_key_field = TestModel._meta.get_field('foreign_key_field')
+    many_to_many_field = TestModel._meta.get_field('many_to_many_field')
+    
+    # Custom widget
+    custom_widget = forms.TextInput()
+    
+    print("="*60)
+    print("TEST 1: With custom widget, field in autocomplete_fields")
+    print("="*60)
+    
+    result_fk = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None,
+        widget=custom_widget
+    )
+    
+    result_m2m = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None,
+        widget=custom_widget
+    )
+    
+    print("\n" + "="*60)
+    print("TEST 2: With custom widget, field in raw_id_fields")  
+    print("="*60)
+    
+    # Reset the admin instance to clear any cached state
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    result_fk2 = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None,
+        widget=custom_widget
+    )
+    
+    result_m2m2 = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None,
+        widget=custom_widget
+    )
+    
+    print("\n" + "="*60)
+    print("TEST 3: Without custom widget (default behavior)")
+    print("="*60)
+    
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    result_fk3 = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None
+    )
+    
+    result_m2m3 = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None
+    )
+
+if __name__ == '__main__':
+    test_scenarios()
\ No newline at end of file
diff --git a/better_reproduce.py b/better_reproduce.py
new file mode 100644
index 0000000000..88cb2c0600
--- /dev/null
+++ b/better_reproduce.py
@@ -0,0 +1,113 @@
+#!/usr/bin/env python3
+"""
+Better reproduction script to demonstrate the widget override issue.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.contrib import admin
+from django.contrib.auth.models import User, Group
+
+# Create test models
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key_field = models.ForeignKey(User, on_delete=models.CASCADE)
+    many_to_many_field = models.ManyToManyField(Group)
+    
+    class Meta:
+        app_label = 'test'
+
+# Custom admin to test widget override
+class TestModelAdmin(admin.ModelAdmin):
+    def formfield_for_foreignkey(self, db_field, request, **kwargs):
+        """This should allow widget override"""
+        print(f"\n=== formfield_for_foreignkey for {db_field.name} ===")
+        print(f"kwargs contains widget: {'widget' in kwargs}")
+        if 'widget' in kwargs:
+            print(f"Widget type: {type(kwargs['widget']).__name__}")
+        result = super().formfield_for_foreignkey(db_field, request, **kwargs)
+        print(f"Final widget type: {type(result.widget).__name__}")
+        return result
+    
+    def formfield_for_manytomany(self, db_field, request, **kwargs):
+        """This currently doesn't allow widget override"""
+        print(f"\n=== formfield_for_manytomany for {db_field.name} ===")
+        print(f"kwargs contains widget: {'widget' in kwargs}")
+        if 'widget' in kwargs:
+            print(f"Widget type: {type(kwargs['widget']).__name__}")
+        result = super().formfield_for_manytomany(db_field, request, **kwargs)
+        print(f"Final widget type: {type(result.widget).__name__}")
+        return result
+
+def test_widget_override():
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    # Get the fields
+    foreign_key_field = TestModel._meta.get_field('foreign_key_field')
+    many_to_many_field = TestModel._meta.get_field('many_to_many_field')
+    
+    # Custom widget
+    custom_widget = forms.TextInput()
+    
+    print("Testing ForeignKey with custom widget...")
+    result_fk = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None,
+        widget=custom_widget
+    )
+    print(f"Custom widget preserved: {result_fk.widget == custom_widget}")
+    
+    print("\nTesting ManyToMany with custom widget...")
+    result_m2m = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None,
+        widget=custom_widget
+    )
+    print(f"Custom widget preserved: {result_m2m.widget == custom_widget}")
+    
+    # Test without custom widget to see default behavior
+    print("\n" + "="*50)
+    print("Testing default behavior (no custom widget)...")
+    
+    print("\nForeignKey default:")
+    result_fk_default = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None
+    )
+    print(f"Default widget type: {type(result_fk_default.widget).__name__}")
+    
+    print("\nManyToMany default:")
+    result_m2m_default = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None
+    )
+    print(f"Default widget type: {type(result_m2m_default.widget).__name__}")
+
+if __name__ == '__main__':
+    test_widget_override()
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 69a5fbf389..b3c4020f39 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -250,15 +250,16 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
         db = kwargs.get('using')
 
         autocomplete_fields = self.get_autocomplete_fields(request)
-        if db_field.name in autocomplete_fields:
-            kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)
-        elif db_field.name in self.raw_id_fields:
-            kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)
-        elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:
-            kwargs['widget'] = widgets.FilteredSelectMultiple(
-                db_field.verbose_name,
-                db_field.name in self.filter_vertical
-            )
+        if 'widget' not in kwargs:
+            if db_field.name in autocomplete_fields:
+                kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)
+            elif db_field.name in self.raw_id_fields:
+                kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)
+            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:
+                kwargs['widget'] = widgets.FilteredSelectMultiple(
+                    db_field.verbose_name,
+                    db_field.name in self.filter_vertical
+                )
 
         if 'queryset' not in kwargs:
             queryset = self.get_field_queryset(db, db_field, request)
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..1dd0a0ce46
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+"""
+Final test to confirm the fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.contrib import admin
+from django.contrib.auth.models import User, Group
+
+# Create test models
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key_field = models.ForeignKey(User, on_delete=models.CASCADE)
+    many_to_many_field = models.ManyToManyField(Group)
+    
+    class Meta:
+        app_label = 'test'
+
+# Custom admin with autocomplete fields
+class TestModelAdmin(admin.ModelAdmin):
+    autocomplete_fields = ['foreign_key_field', 'many_to_many_field']
+    
+    def formfield_for_foreignkey(self, db_field, request, **kwargs):
+        result = super().formfield_for_foreignkey(db_field, request, **kwargs)
+        return result
+    
+    def formfield_for_manytomany(self, db_field, request, **kwargs):
+        result = super().formfield_for_manytomany(db_field, request, **kwargs)
+        return result
+
+def test_fix():
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    # Get the fields
+    foreign_key_field = TestModel._meta.get_field('foreign_key_field')
+    many_to_many_field = TestModel._meta.get_field('many_to_many_field')
+    
+    # Test different widget types
+    widget_types = [
+        forms.TextInput,
+        forms.Textarea,
+        forms.NumberInput,
+    ]
+    
+    print("Testing widget override functionality...")
+    print("="*50)
+    
+    for widget_class in widget_types:
+        custom_widget = widget_class()
+        
+        print(f"\nTesting with {widget_class.__name__}:")
+        
+        # Test ForeignKey
+        result_fk = admin_instance.formfield_for_foreignkey(
+            foreign_key_field, 
+            None,
+            widget=custom_widget
+        )
+        fk_success = isinstance(result_fk.widget, widget_class)
+        print(f"  ForeignKey: {fk_success} ({type(result_fk.widget).__name__})")
+        
+        # Test ManyToMany
+        result_m2m = admin_instance.formfield_for_manytomany(
+            many_to_many_field,
+            None,
+            widget=custom_widget
+        )
+        m2m_success = isinstance(result_m2m.widget, widget_class)
+        print(f"  ManyToMany: {m2m_success} ({type(result_m2m.widget).__name__})")
+        
+        # Both should work now
+        if fk_success and m2m_success:
+            print(f"  ✓ SUCCESS: Both methods preserve {widget_class.__name__}")
+        else:
+            print(f"  ✗ FAILURE: Widget override not working correctly")
+    
+    print("\n" + "="*50)
+    print("Testing default behavior (no custom widget):")
+    
+    # Test default behavior
+    result_fk_default = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None
+    )
+    result_m2m_default = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None
+    )
+    
+    print(f"  ForeignKey default: {type(result_fk_default.widget).__name__}")
+    print(f"  ManyToMany default: {type(result_m2m_default.widget).__name__}")
+    
+    # Default behavior should still use admin widgets
+    from django.contrib.admin.widgets import AutocompleteSelect, AutocompleteSelectMultiple
+    fk_default_ok = isinstance(result_fk_default.widget, AutocompleteSelect)
+    m2m_default_ok = isinstance(result_m2m_default.widget, AutocompleteSelectMultiple)
+    
+    if fk_default_ok and m2m_default_ok:
+        print("  ✓ SUCCESS: Default behavior works correctly")
+    else:
+        print("  ✗ FAILURE: Default behavior broken")
+
+if __name__ == '__main__':
+    test_fix()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5349e91a3b
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+"""
+Reproduction script to demonstrate the issue with formfield_for_manytomany
+not allowing widget override unlike formfield_for_foreignkey.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.contrib import admin
+from django.contrib.auth.models import User, Group
+
+# Create a simple test model with both ForeignKey and ManyToMany fields
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key_field = models.ForeignKey(User, on_delete=models.CASCADE)
+    many_to_many_field = models.ManyToManyField(Group)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create a custom admin that tries to override widgets
+class TestModelAdmin(admin.ModelAdmin):
+    def formfield_for_foreignkey(self, db_field, request, **kwargs):
+        """This should allow widget override"""
+        print(f"formfield_for_foreignkey called for {db_field.name}")
+        print(f"kwargs before processing: {kwargs}")
+        result = super().formfield_for_foreignkey(db_field, request, **kwargs)
+        print(f"formfield_for_foreignkey result widget: {result.widget}")
+        return result
+    
+    def formfield_for_manytomany(self, db_field, request, **kwargs):
+        """This currently doesn't allow widget override"""
+        print(f"formfield_for_manytomany called for {db_field.name}")
+        print(f"kwargs before processing: {kwargs}")
+        result = super().formfield_for_manytomany(db_field, request, **kwargs)
+        print(f"formfield_for_manytomany result widget: {result.widget}")
+        return result
+
+# Test the behavior
+def test_widget_override():
+    print("=== Testing ForeignKey widget override ===")
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    # Get the foreign key field
+    foreign_key_field = TestModel._meta.get_field('foreign_key_field')
+    
+    # Test with custom widget
+    custom_widget = forms.TextInput()  # A simple custom widget
+    print(f"\nTesting with custom widget: {custom_widget}")
+    
+    try:
+        result = admin_instance.formfield_for_foreignkey(
+            foreign_key_field, 
+            None,  # request
+            widget=custom_widget
+        )
+        print(f"Success! Final widget: {result.widget}")
+        print(f"Widget is custom: {result.widget == custom_widget}")
+    except Exception as e:
+        print(f"Error: {e}")
+    
+    print("\n=== Testing ManyToMany widget override ===")
+    
+    # Get the many to many field
+    many_to_many_field = TestModel._meta.get_field('many_to_many_field')
+    
+    # Test with custom widget
+    print(f"\nTesting with custom widget: {custom_widget}")
+    
+    try:
+        result = admin_instance.formfield_for_manytomany(
+            many_to_many_field,
+            None,  # request
+            widget=custom_widget
+        )
+        print(f"Result widget: {result.widget}")
+        print(f"Widget is custom: {result.widget == custom_widget}")
+        if result.widget != custom_widget:
+            print("BUG: ManyToMany field doesn't respect widget override!")
+        else:
+            print("Success! Widget override works.")
+    except Exception as e:
+        print(f"Error: {e}")
+
+if __name__ == '__main__':
+    test_widget_override()
\ No newline at end of file
diff --git a/targeted_test.py b/targeted_test.py
new file mode 100644
index 0000000000..5976fdf6bf
--- /dev/null
+++ b/targeted_test.py
@@ -0,0 +1,104 @@
+#!/usr/bin/env python3
+"""
+Targeted test to show the difference between formfield_for_foreignkey and formfield_for_manytomany
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.contrib import admin
+from django.contrib.auth.models import User, Group
+
+# Create test models
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    foreign_key_field = models.ForeignKey(User, on_delete=models.CASCADE)
+    many_to_many_field = models.ManyToManyField(Group)
+    
+    class Meta:
+        app_label = 'test'
+
+# Custom admin to test the specific behavior
+class TestModelAdmin(admin.ModelAdmin):
+    def formfield_for_foreignkey(self, db_field, request, **kwargs):
+        """Test what happens when we provide a widget"""
+        print(f"\n=== formfield_for_foreignkey for {db_field.name} ===")
+        print(f"kwargs before: {kwargs}")
+        
+        # Let's see what the original implementation does
+        result = super().formfield_for_foreignkey(db_field, request, **kwargs)
+        
+        print(f"kwargs after: {kwargs}")
+        print(f"Result widget type: {type(result.widget).__name__}")
+        return result
+    
+    def formfield_for_manytomany(self, db_field, request, **kwargs):
+        """Test what happens when we provide a widget"""
+        print(f"\n=== formfield_for_manytomany for {db_field.name} ===")
+        print(f"kwargs before: {kwargs}")
+        
+        # Let's see what the original implementation does
+        result = super().formfield_for_manytomany(db_field, request, **kwargs)
+        
+        print(f"kwargs after: {kwargs}")
+        print(f"Result widget type: {type(result.widget).__name__}")
+        return result
+
+def test_difference():
+    admin_instance = TestModelAdmin(TestModel, admin.site)
+    
+    # Get the fields
+    foreign_key_field = TestModel._meta.get_field('foreign_key_field')
+    many_to_many_field = TestModel._meta.get_field('many_to_many_field')
+    
+    # Custom widget
+    custom_widget = forms.TextInput()
+    
+    print("Testing with custom TextInput widget...")
+    
+    print("\n1. ForeignKey field:")
+    result_fk = admin_instance.formfield_for_foreignkey(
+        foreign_key_field, 
+        None,
+        widget=custom_widget
+    )
+    
+    print("\n2. ManyToMany field:")
+    result_m2m = admin_instance.formfield_for_manytomany(
+        many_to_many_field,
+        None,
+        widget=custom_widget
+    )
+    
+    print("\n" + "="*50)
+    print("KEY DIFFERENCE ANALYSIS:")
+    print("The issue is that formfield_for_manytomany doesn't check if 'widget' is already in kwargs")
+    print("before setting its own widget, while formfield_for_foreignkey does.")
+
+if __name__ == '__main__':
+    test_difference()
\ No newline at end of file