diff --git a/django/core/files/locks.py b/django/core/files/locks.py
index c46b00b905..4938347ea7 100644
--- a/django/core/files/locks.py
+++ b/django/core/files/locks.py
@@ -107,9 +107,15 @@ else:
             return True
     else:
         def lock(f, flags):
-            ret = fcntl.flock(_fd(f), flags)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), flags)
+                return True
+            except OSError:
+                return False
 
         def unlock(f):
-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)
-            return ret == 0
+            try:
+                fcntl.flock(_fd(f), fcntl.LOCK_UN)
+                return True
+            except OSError:
+                return False
diff --git a/final_comprehensive_test.py b/final_comprehensive_test.py
new file mode 100644
index 0000000000..b42092e61a
--- /dev/null
+++ b/final_comprehensive_test.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test to verify the posix file locking fix works correctly.
+"""
+import tempfile
+import os
+import fcntl
+from django.core.files import locks
+
+def test_comprehensive():
+    """Comprehensive test of the file locking functionality"""
+    print("Running comprehensive file locking tests...")
+    
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Basic functionality
+        print("\n=== Test 1: Basic lock/unlock ===")
+        with open(temp_file_path, 'r+') as f:
+            lock_result = locks.lock(f, locks.LOCK_EX)
+            print(f"Lock result: {lock_result} (expected: True)")
+            assert lock_result == True, "Lock should return True on success"
+            
+            unlock_result = locks.unlock(f)
+            print(f"Unlock result: {unlock_result} (expected: True)")
+            assert unlock_result == True, "Unlock should return True on success"
+        
+        # Test 2: Non-blocking lock on already locked file
+        print("\n=== Test 2: Non-blocking lock on locked file ===")
+        with open(temp_file_path, 'r+') as f1, open(temp_file_path, 'r+') as f2:
+            # Lock with first handle
+            lock1_result = locks.lock(f1, locks.LOCK_EX)
+            print(f"First lock result: {lock1_result} (expected: True)")
+            assert lock1_result == True
+            
+            # Try non-blocking lock with second handle (should fail)
+            lock2_result = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock result: {lock2_result} (expected: False)")
+            assert lock2_result == False, "Non-blocking lock should return False when blocked"
+            
+            # Clean up
+            unlock_result = locks.unlock(f1)
+            print(f"Unlock result: {unlock_result} (expected: True)")
+            assert unlock_result == True
+        
+        # Test 3: Shared locks
+        print("\n=== Test 3: Shared locks ===")
+        with open(temp_file_path, 'r+') as f1, open(temp_file_path, 'r+') as f2:
+            # Both should be able to get shared locks
+            lock1_result = locks.lock(f1, locks.LOCK_SH)
+            lock2_result = locks.lock(f2, locks.LOCK_SH)
+            print(f"Shared lock 1 result: {lock1_result} (expected: True)")
+            print(f"Shared lock 2 result: {lock2_result} (expected: True)")
+            assert lock1_result == True and lock2_result == True
+            
+            # Clean up
+            locks.unlock(f1)
+            locks.unlock(f2)
+        
+        # Test 4: Verify constants are correctly imported
+        print("\n=== Test 4: Lock constants ===")
+        print(f"LOCK_EX: {locks.LOCK_EX} (fcntl.LOCK_EX: {fcntl.LOCK_EX})")
+        print(f"LOCK_SH: {locks.LOCK_SH} (fcntl.LOCK_SH: {fcntl.LOCK_SH})")
+        print(f"LOCK_NB: {locks.LOCK_NB} (fcntl.LOCK_NB: {fcntl.LOCK_NB})")
+        assert locks.LOCK_EX == fcntl.LOCK_EX
+        assert locks.LOCK_SH == fcntl.LOCK_SH
+        assert locks.LOCK_NB == fcntl.LOCK_NB
+        
+        print("\n✅ All tests passed! The fix is working correctly.")
+        
+    except Exception as e:
+        print(f"\n❌ Test failed: {e}")
+        raise
+    finally:
+        # Clean up temporary file
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_comprehensive()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..a675e98018
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with posix file locking in Django.
+"""
+import tempfile
+import os
+from django.core.files import locks
+
+def test_lock_behavior():
+    """Test the current lock behavior"""
+    print("Testing posix file locking behavior...")
+    
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Try to acquire a lock (should succeed)
+        print("\nTest 1: Acquiring exclusive lock (should succeed)")
+        with open(temp_file_path, 'r+') as f:
+            result = locks.lock(f, locks.LOCK_EX)
+            print(f"Lock result: {result}")
+            print(f"Expected: True, Got: {result}")
+            
+            # Test 2: Try to unlock (should succeed)
+            print("\nTest 2: Unlocking (should succeed)")
+            unlock_result = locks.unlock(f)
+            print(f"Unlock result: {unlock_result}")
+            print(f"Expected: True, Got: {unlock_result}")
+        
+        # Test 3: Try non-blocking lock on already locked file (should fail)
+        print("\nTest 3: Non-blocking lock on already locked file (should fail)")
+        with open(temp_file_path, 'r+') as f1, open(temp_file_path, 'r+') as f2:
+            # Lock with first file handle
+            locks.lock(f1, locks.LOCK_EX)
+            
+            # Try non-blocking lock with second file handle
+            result = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)
+            print(f"Non-blocking lock result: {result}")
+            print(f"Expected: False, Got: {result}")
+            
+            # Clean up
+            locks.unlock(f1)
+            
+    finally:
+        # Clean up temporary file
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_lock_behavior()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..1cd7922cb4
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the posix file locking fix.
+"""
+import tempfile
+import os
+from django.core.files import locks
+
+def test_edge_cases():
+    """Test edge cases for file locking"""
+    print("Testing edge cases for posix file locking...")
+    
+    # Create a temporary file
+    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as f:
+        temp_file_path = f.name
+    
+    try:
+        # Test 1: Multiple locks and unlocks
+        print("\nTest 1: Multiple locks and unlocks")
+        with open(temp_file_path, 'r+') as f:
+            # Lock and unlock multiple times
+            for i in range(3):
+                lock_result = locks.lock(f, locks.LOCK_EX)
+                print(f"Lock {i+1} result: {lock_result}")
+                unlock_result = locks.unlock(f)
+                print(f"Unlock {i+1} result: {unlock_result}")
+        
+        # Test 2: Shared lock
+        print("\nTest 2: Shared lock")
+        with open(temp_file_path, 'r+') as f1, open(temp_file_path, 'r+') as f2:
+            # Both should be able to get shared locks
+            result1 = locks.lock(f1, locks.LOCK_SH)
+            result2 = locks.lock(f2, locks.LOCK_SH)
+            print(f"Shared lock 1 result: {result1}")
+            print(f"Shared lock 2 result: {result2}")
+            
+            # Clean up
+            locks.unlock(f1)
+            locks.unlock(f2)
+        
+        # Test 3: Invalid file descriptor
+        print("\nTest 3: Invalid file descriptor")
+        try:
+            # Try to lock with an invalid file descriptor
+            result = locks.lock(999999, locks.LOCK_EX)  # Invalid fd
+            print(f"Invalid fd lock result: {result}")
+        except Exception as e:
+            print(f"Invalid fd lock exception (expected): {type(e).__name__}: {e}")
+            
+    finally:
+        # Clean up temporary file
+        os.unlink(temp_file_path)
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file