diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..a72568927c
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,128 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.core.files.storage import Storage, default_storage
+
+# Test models for different scenarios
+class TestModelCallable(models.Model):
+    """Model with callable storage"""
+    file_field = models.FileField(storage=lambda: Storage())
+    
+    class Meta:
+        app_label = 'test'
+
+class TestModelObject(models.Model):
+    """Model with storage object"""
+    file_field = models.FileField(storage=Storage())
+    
+    class Meta:
+        app_label = 'test'
+
+class TestModelDefault(models.Model):
+    """Model with default storage"""
+    file_field = models.FileField(storage=None)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_deconstruction_preserves_callable():
+    """Test that callable storage is preserved during deconstruction"""
+    print("Testing callable storage deconstruction...")
+    
+    field = TestModelCallable._meta.get_field('file_field')
+    name, path, args, kwargs = field.deconstruct()
+    
+    storage_arg = kwargs.get('storage')
+    assert callable(storage_arg), "Callable storage should be preserved as callable"
+    print("‚úì Callable storage preserved correctly")
+
+def test_deconstruction_preserves_object():
+    """Test that storage object is preserved during deconstruction"""
+    print("Testing storage object deconstruction...")
+    
+    field = TestModelObject._meta.get_field('file_field')
+    name, path, args, kwargs = field.deconstruct()
+    
+    storage_arg = kwargs.get('storage')
+    assert not callable(storage_arg), "Storage object should not be callable"
+    assert isinstance(storage_arg, Storage), "Storage object should be preserved"
+    print("‚úì Storage object preserved correctly")
+
+def test_deconstruction_default_storage():
+    """Test that default storage is handled correctly"""
+    print("Testing default storage deconstruction...")
+    
+    field = TestModelDefault._meta.get_field('file_field')
+    name, path, args, kwargs = field.deconstruct()
+    
+    # Default storage should not be in kwargs
+    assert 'storage' not in kwargs, "Default storage should not be in deconstructed kwargs"
+    print("‚úì Default storage handled correctly")
+
+def test_reconstruction():
+    """Test that deconstructed field can be reconstructed"""
+    print("Testing field reconstruction...")
+    
+    # Test with callable storage
+    original_field = TestModelCallable._meta.get_field('file_field')
+    name, path, args, kwargs = original_field.deconstruct()
+    
+    # Reconstruct the field using importlib
+    import importlib
+    module_path, class_name = path.rsplit('.', 1)
+    module = importlib.import_module(module_path)
+    field_class = getattr(module, class_name)
+    reconstructed_field = field_class(*args, **kwargs)
+    
+    # The reconstructed field should have the same storage behavior
+    assert callable(reconstructed_field._storage), "Reconstructed field should preserve callable storage"
+    print("‚úì Field reconstruction works correctly")
+
+def test_functional_behavior():
+    """Test that the field still functions correctly"""
+    print("Testing functional behavior...")
+    
+    field = TestModelCallable._meta.get_field('file_field')
+    
+    # The field should still evaluate the callable when accessed
+    assert isinstance(field.storage, Storage), "Field should evaluate callable to get storage"
+    print("‚úì Functional behavior preserved")
+
+if __name__ == '__main__':
+    try:
+        test_deconstruction_preserves_callable()
+        test_deconstruction_preserves_object()
+        test_deconstruction_default_storage()
+        test_reconstruction()
+        test_functional_behavior()
+        print("\nüéâ All tests passed! The fix is working correctly.")
+    except Exception as e:
+        print(f"\n‚ùå Test failed: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
\ No newline at end of file
diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py
index e10a5bb6d9..d0535bf831 100644
--- a/django/db/models/fields/files.py
+++ b/django/db/models/fields/files.py
@@ -227,7 +227,8 @@ class FileField(Field):
     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):
         self._primary_key_set_explicitly = 'primary_key' in kwargs
 
-        self.storage = storage or default_storage
+        self._storage = storage or default_storage
+        self.storage = self._storage
         if callable(self.storage):
             self.storage = self.storage()
             if not isinstance(self.storage, Storage):
@@ -278,8 +279,8 @@ class FileField(Field):
         if kwargs.get("max_length") == 100:
             del kwargs["max_length"]
         kwargs['upload_to'] = self.upload_to
-        if self.storage is not default_storage:
-            kwargs['storage'] = self.storage
+        if self._storage is not default_storage:
+            kwargs['storage'] = self._storage
         return name, path, args, kwargs
 
     def get_internal_type(self):
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..e50c9ee8de
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.core.files.storage import Storage, default_storage
+
+def test_original_issue():
+    """Test the exact scenario described in the GitHub issue"""
+    print("Testing the original GitHub issue scenario...")
+    
+    # Create a callable storage function
+    def runtime_storage():
+        """A callable that returns different storage based on environment"""
+        print("Runtime storage callable executed!")
+        return Storage()
+    
+    # Create FileField with callable storage
+    class TestModel(models.Model):
+        file_field = models.FileField(storage=runtime_storage)
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Get the field and test deconstruction
+    field = TestModel._meta.get_field('file_field')
+    name, path, args, kwargs = field.deconstruct()
+    
+    # The deconstructed storage should be the original callable, not the evaluated storage
+    deconstructed_storage = kwargs.get('storage')
+    
+    print(f"Original callable: {runtime_storage}")
+    print(f"Deconstructed storage: {deconstructed_storage}")
+    print(f"Are they the same: {deconstructed_storage is runtime_storage}")
+    print(f"Is deconstructed callable: {callable(deconstructed_storage)}")
+    
+    # Verify the fix
+    assert deconstructed_storage is runtime_storage, "Deconstructed storage should be the original callable"
+    assert callable(deconstructed_storage), "Deconstructed storage should be callable"
+    assert not isinstance(deconstructed_storage, Storage), "Deconstructed storage should not be a Storage instance"
+    
+    print("‚úì Original issue is fixed: callable storage is preserved during deconstruction")
+
+def test_backward_compatibility():
+    """Test that existing behavior is not broken"""
+    print("\nTesting backward compatibility...")
+    
+    # Test with regular storage object
+    class TestModel1(models.Model):
+        file_field = models.FileField(storage=Storage())
+        
+        class Meta:
+            app_label = 'test1'
+    
+    field1 = TestModel1._meta.get_field('file_field')
+    name, path, args, kwargs = field1.deconstruct()
+    storage_arg = kwargs.get('storage')
+    
+    assert isinstance(storage_arg, Storage), "Storage object should be preserved as-is"
+    assert not callable(storage_arg), "Storage object should not be callable"
+    print("‚úì Regular storage objects work correctly")
+    
+    # Test with default storage
+    class TestModel2(models.Model):
+        file_field = models.FileField(storage=None)
+        
+        class Meta:
+            app_label = 'test2'
+    
+    field2 = TestModel2._meta.get_field('file_field')
+    name, path, args, kwargs = field2.deconstruct()
+    
+    assert 'storage' not in kwargs, "Default storage should not be in deconstructed kwargs"
+    print("‚úì Default storage works correctly")
+
+if __name__ == '__main__':
+    try:
+        test_original_issue()
+        test_backward_compatibility()
+        print("\nüéâ All verification tests passed!")
+        print("The fix successfully resolves the GitHub issue while maintaining backward compatibility.")
+    except Exception as e:
+        print(f"\n‚ùå Verification failed: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..0c4219a2b8
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.core.files.storage import Storage
+
+# Create a simple callable storage for testing
+def get_storage():
+    """A callable that returns a storage instance"""
+    print("Callable storage is being evaluated!")
+    return Storage()
+
+class TestModel(models.Model):
+    file_field = models.FileField(storage=get_storage)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_deconstruction():
+    print("Testing FileField deconstruction with callable storage...")
+    
+    # Create the field
+    field = TestModel._meta.get_field('file_field')
+    
+    print(f"Field storage type: {type(field.storage)}")
+    
+    # Test deconstruction
+    name, path, args, kwargs = field.deconstruct()
+    
+    print(f"Deconstructed kwargs['storage'] type: {type(kwargs.get('storage'))}")
+    print(f"Deconstructed kwargs['storage']: {kwargs.get('storage')}")
+    
+    # Check if it's the original callable or the evaluated storage
+    storage_arg = kwargs.get('storage')
+    if callable(storage_arg):
+        print("SUCCESS: Storage parameter preserved as callable during deconstruction")
+    else:
+        print("FAILURE: Storage parameter was evaluated during deconstruction")
+        print("This breaks the runtime storage selection feature!")
+
+if __name__ == '__main__':
+    test_deconstruction()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..39407b1a84
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.core.files.storage import Storage, default_storage
+
+# Test case 1: Regular storage object (not callable)
+class TestModel1(models.Model):
+    file_field = models.FileField(storage=Storage())
+    
+    class Meta:
+        app_label = 'test1'
+
+# Test case 2: Default storage
+class TestModel2(models.Model):
+    file_field = models.FileField(storage=None)  # Should use default_storage
+    
+    class Meta:
+        app_label = 'test2'
+
+# Test case 3: Callable that returns default storage
+def get_default_storage():
+    return default_storage
+
+class TestModel3(models.Model):
+    file_field = models.FileField(storage=get_default_storage)
+    
+    class Meta:
+        app_label = 'test3'
+
+def test_edge_cases():
+    print("Testing edge cases...")
+    
+    # Test case 1: Regular storage object
+    print("\n1. Testing with regular storage object:")
+    field1 = TestModel1._meta.get_field('file_field')
+    name, path, args, kwargs = field1.deconstruct()
+    storage_arg = kwargs.get('storage')
+    print(f"Storage type: {type(storage_arg)}")
+    print(f"Is callable: {callable(storage_arg)}")
+    
+    # Test case 2: Default storage
+    print("\n2. Testing with default storage:")
+    field2 = TestModel2._meta.get_field('file_field')
+    name, path, args, kwargs = field2.deconstruct()
+    storage_arg = kwargs.get('storage')
+    print(f"Storage in kwargs: {'storage' in kwargs}")
+    print(f"Should be None (not in kwargs): {storage_arg}")
+    
+    # Test case 3: Callable returning default storage
+    print("\n3. Testing with callable returning default storage:")
+    field3 = TestModel3._meta.get_field('file_field')
+    name, path, args, kwargs = field3.deconstruct()
+    storage_arg = kwargs.get('storage')
+    print(f"Storage type: {type(storage_arg)}")
+    print(f"Is callable: {callable(storage_arg)}")
+    print(f"Is same function: {storage_arg == get_default_storage}")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_imagefield.py b/test_imagefield.py
new file mode 100644
index 0000000000..cce8a69306
--- /dev/null
+++ b/test_imagefield.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.core.files.storage import Storage
+
+# Test ImageField with callable storage
+def get_image_storage():
+    """A callable that returns a storage instance for images"""
+    print("Callable image storage is being evaluated!")
+    return Storage()
+
+class TestImageModel(models.Model):
+    image_field = models.ImageField(storage=get_image_storage)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_imagefield_deconstruction():
+    print("Testing ImageField deconstruction with callable storage...")
+    
+    # Create the field
+    field = TestImageModel._meta.get_field('image_field')
+    
+    print(f"Field storage type: {type(field.storage)}")
+    
+    # Test deconstruction
+    name, path, args, kwargs = field.deconstruct()
+    
+    print(f"Deconstructed kwargs['storage'] type: {type(kwargs.get('storage'))}")
+    print(f"Deconstructed kwargs['storage']: {kwargs.get('storage')}")
+    
+    # Check if it's the original callable or the evaluated storage
+    storage_arg = kwargs.get('storage')
+    if callable(storage_arg):
+        print("SUCCESS: ImageField storage parameter preserved as callable during deconstruction")
+        print(f"Is same function: {storage_arg == get_image_storage}")
+    else:
+        print("FAILURE: ImageField storage parameter was evaluated during deconstruction")
+
+if __name__ == '__main__':
+    test_imagefield_deconstruction()
\ No newline at end of file