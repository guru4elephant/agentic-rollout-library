diff --git a/debug_hash_issue.py b/debug_hash_issue.py
new file mode 100644
index 0000000000..61b4e779a9
--- /dev/null
+++ b/debug_hash_issue.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+"""Debug script to understand the Field.__hash__() issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def debug_hash_changes():
+    """Debug what changes in the hash calculation."""
+    print("Debugging Field.__hash__() changes...")
+    
+    # Create a field instance
+    f = models.CharField(max_length=200)
+    print(f"Field before assignment: {f}")
+    print(f"Has model attribute: {hasattr(f, 'model')}")
+    print(f"Hash before assignment: {hash(f)}")
+    
+    # Check what goes into the hash calculation
+    if hasattr(f, 'model'):
+        print(f"Model app_label: {f.model._meta.app_label}")
+        print(f"Model model_name: {f.model._meta.model_name}")
+    print(f"Creation counter: {f.creation_counter}")
+    
+    # Put the field in a dictionary
+    d = {f: 1}
+    print(f"Dictionary contains field: {f in d}")
+    
+    # Assign the field to a model class
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"\nField after assignment: {f}")
+    print(f"Has model attribute: {hasattr(f, 'model')}")
+    print(f"Hash after assignment: {hash(f)}")
+    
+    # Check what goes into the hash calculation now
+    if hasattr(f, 'model'):
+        print(f"Model app_label: {f.model._meta.app_label}")
+        print(f"Model model_name: {f.model._meta.model_name}")
+    print(f"Creation counter: {f.creation_counter}")
+    
+    print(f"Dictionary contains field after assignment: {f in d}")
+    
+    # Let's manually check the hash components
+    hash_before = hash((
+        f.creation_counter,
+        None,  # model was None before
+        None   # model was None before
+    ))
+    
+    hash_after = hash((
+        f.creation_counter,
+        f.model._meta.app_label if hasattr(f, 'model') else None,
+        f.model._meta.model_name if hasattr(f, 'model') else None,
+    ))
+    
+    print(f"Manual hash calculation before: {hash_before}")
+    print(f"Manual hash calculation after: {hash_after}")
+    
+    # This should pass but currently fails
+    try:
+        assert f in d
+        print("SUCCESS: Field is still in dictionary after assignment")
+    except AssertionError:
+        print("FAILURE: Field is no longer in dictionary after assignment")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = debug_hash_changes()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 88c9ca9f28..fcea1597ef 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):
         return NotImplemented
 
     def __hash__(self):
-        return hash((
-            self.creation_counter,
-            self.model._meta.app_label if hasattr(self, 'model') else None,
-            self.model._meta.model_name if hasattr(self, 'model') else None,
-        ))
+        return hash(self.creation_counter)
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
diff --git a/reproduce_exact_issue.py b/reproduce_exact_issue.py
new file mode 100644
index 0000000000..6d447b74b5
--- /dev/null
+++ b/reproduce_exact_issue.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""Script to reproduce the exact Field.__hash__() issue from the GitHub issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_exact_issue():
+    """Test the exact issue described in the GitHub issue."""
+    print("Testing exact issue from GitHub...")
+    
+    # Exact code from the GitHub issue
+    f = models.CharField(max_length=200)
+    d = {f: 1}
+    
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    # This assertion should fail according to the issue
+    try:
+        assert f in d
+        print("SUCCESS: Field is still in dictionary after assignment")
+        return True
+    except AssertionError:
+        print("FAILURE: Field is no longer in dictionary after assignment")
+        return False
+
+if __name__ == "__main__":
+    success = test_exact_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..16d0a03cbb
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+"""Script to reproduce the Field.__hash__() issue."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_field_hash_issue():
+    """Test that demonstrates the Field.__hash__() issue."""
+    print("Testing Field.__hash__() issue...")
+    
+    # Create a field instance
+    f = models.CharField(max_length=200)
+    print(f"Field before assignment: {f}")
+    print(f"Hash before assignment: {hash(f)}")
+    
+    # Put the field in a dictionary
+    d = {f: 1}
+    print(f"Dictionary contains field: {f in d}")
+    
+    # Assign the field to a model class
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    print(f"Field after assignment: {f}")
+    print(f"Hash after assignment: {hash(f)}")
+    print(f"Dictionary contains field after assignment: {f in d}")
+    
+    # This should pass but currently fails
+    try:
+        assert f in d
+        print("SUCCESS: Field is still in dictionary after assignment")
+    except AssertionError:
+        print("FAILURE: Field is no longer in dictionary after assignment")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_field_hash_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_equality_edge_cases.py b/test_equality_edge_cases.py
new file mode 100644
index 0000000000..1560ddaab9
--- /dev/null
+++ b/test_equality_edge_cases.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""Test edge cases for Field equality with the new hash implementation."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_equality_edge_cases():
+    """Test edge cases for Field equality."""
+    print("Testing Field equality edge cases...")
+    
+    # Test 1: Fields with same creation counter but different models
+    f1 = models.CharField(max_length=100)
+    f2 = models.CharField(max_length=100)
+    
+    # Manually set creation_counter to be the same (simulating edge case)
+    f1.creation_counter = 999
+    f2.creation_counter = 999
+    
+    class ModelA(models.Model):
+        field_a = f1
+        
+        class Meta:
+            app_label = 'test'
+    
+    class ModelB(models.Model):
+        field_b = f2
+        
+        class Meta:
+            app_label = 'test'
+    
+    # They should not be equal because they have different models
+    assert f1 != f2, "Fields with same creation counter but different models should not be equal"
+    print("✓ Test 1 passed: Fields with same creation counter but different models are not equal")
+    
+    # Test 2: Fields with different creation counters
+    f3 = models.IntegerField()
+    f4 = models.IntegerField()
+    
+    # f3 and f4 have different creation counters by default
+    assert f3 != f4, "Fields with different creation counters should not be equal"
+    assert hash(f3) != hash(f4), "Fields with different creation counters should have different hashes"
+    print("✓ Test 2 passed: Fields with different creation counters are not equal")
+    
+    # Test 3: Same field instance
+    f5 = models.BooleanField()
+    assert f5 == f5, "Field should be equal to itself"
+    assert hash(f5) == hash(f5), "Field should have consistent hash"
+    print("✓ Test 3 passed: Field is equal to itself")
+    
+    # Test 4: Field compared to non-Field object
+    f6 = models.TextField()
+    assert f6 != "not a field", "Field should not be equal to non-Field object"
+    print("✓ Test 4 passed: Field is not equal to non-Field object")
+    
+    print("All equality edge case tests passed!")
+    return True
+
+if __name__ == "__main__":
+    success = test_equality_edge_cases()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_field_hash_comprehensive.py b/test_field_hash_comprehensive.py
new file mode 100644
index 0000000000..011b9d2f13
--- /dev/null
+++ b/test_field_hash_comprehensive.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python3
+"""Comprehensive test for Field.__hash__() fix."""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_field_hash_immutability():
+    """Test that Field.__hash__() is immutable."""
+    print("Testing Field.__hash__() immutability...")
+    
+    # Test 1: Basic field hash immutability
+    f = models.CharField(max_length=200)
+    original_hash = hash(f)
+    
+    # Put field in dictionary and set
+    d = {f: 'test_value'}
+    s = {f}
+    
+    # Assign to model
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Hash should remain the same
+    assert hash(f) == original_hash, f"Hash changed from {original_hash} to {hash(f)}"
+    assert f in d, "Field should still be in dictionary"
+    assert f in s, "Field should still be in set"
+    print("✓ Test 1 passed: Field hash is immutable")
+    
+    # Test 2: Multiple fields
+    f1 = models.IntegerField()
+    f2 = models.BooleanField()
+    
+    d_multi = {f1: 1, f2: 2}
+    s_multi = {f1, f2}
+    
+    class MultiModel(models.Model):
+        num = f1
+        flag = f2
+        
+        class Meta:
+            app_label = 'test'
+    
+    assert f1 in d_multi, "First field should still be in dictionary"
+    assert f2 in d_multi, "Second field should still be in dictionary"
+    assert f1 in s_multi, "First field should still be in set"
+    assert f2 in s_multi, "Second field should still be in set"
+    print("✓ Test 2 passed: Multiple fields work correctly")
+    
+    # Test 3: Equality still works
+    f3 = models.CharField(max_length=100)
+    f4 = models.CharField(max_length=100)
+    
+    # Different creation counters, should not be equal
+    assert f3 != f4, "Fields with different creation counters should not be equal"
+    assert hash(f3) != hash(f4), "Fields with different creation counters should have different hashes"
+    print("✓ Test 3 passed: Equality and hashing work correctly")
+    
+    # Test 4: Same field instance in multiple models
+    shared_field = models.TextField()
+    original_hash_shared = hash(shared_field)
+    
+    d_shared = {shared_field: 'shared'}
+    
+    class ModelA(models.Model):
+        content = shared_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    class ModelB(models.Model):
+        description = shared_field
+        
+        class Meta:
+            app_label = 'test'
+    
+    assert hash(shared_field) == original_hash_shared, "Shared field hash should not change"
+    assert shared_field in d_shared, "Shared field should still be in dictionary"
+    print("✓ Test 4 passed: Shared field across multiple models works correctly")
+    
+    print("All tests passed! Field.__hash__() is now immutable.")
+    return True
+
+if __name__ == "__main__":
+    success = test_field_hash_immutability()
+    sys.exit(0 if success else 1)
\ No newline at end of file