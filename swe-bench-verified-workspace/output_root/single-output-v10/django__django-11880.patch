diff --git a/django/forms/fields.py b/django/forms/fields.py
index 03cd8af8d7..18007accab 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -199,6 +199,7 @@ class Field:
         result = copy.copy(self)
         memo[id(self)] = result
         result.widget = copy.deepcopy(self.widget, memo)
+        result.error_messages = copy.deepcopy(self.error_messages, memo)
         result.validators = self.validators[:]
         return result
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..bd552a0fa9
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the deepcopy issue with Form Field error_messages.
+"""
+
+import copy
+from django.forms import CharField
+
+def test_deepcopy_error_messages():
+    print("Testing deepcopy issue with Form Field error_messages...")
+    
+    # Create two CharField instances
+    field1 = CharField(error_messages={'required': 'Custom required message 1'})
+    field2 = CharField(error_messages={'required': 'Custom required message 2'})
+    
+    print(f"Original field1 error_messages: {field1.error_messages}")
+    print(f"Original field2 error_messages: {field2.error_messages}")
+    
+    # Deep copy the fields
+    field1_copy = copy.deepcopy(field1)
+    field2_copy = copy.deepcopy(field2)
+    
+    print(f"Copied field1 error_messages: {field1_copy.error_messages}")
+    print(f"Copied field2 error_messages: {field2_copy.error_messages}")
+    
+    # Modify the error messages of the copies
+    field1_copy.error_messages['required'] = 'Modified message 1'
+    field2_copy.error_messages['required'] = 'Modified message 2'
+    
+    print("\nAfter modifying copies:")
+    print(f"field1_copy error_messages: {field1_copy.error_messages}")
+    print(f"field2_copy error_messages: {field2_copy.error_messages}")
+    
+    # Check if the original fields were affected (they shouldn't be!)
+    print(f"field1 error_messages (should be unchanged): {field1.error_messages}")
+    print(f"field2 error_messages (should be unchanged): {field2.error_messages}")
+    
+    # The bug: if the original fields were changed, it means error_messages wasn't deep copied
+    if field1.error_messages['required'] != 'Custom required message 1':
+        print("❌ BUG CONFIRMED: field1 was affected by changes to field1_copy")
+        return False
+    if field2.error_messages['required'] != 'Custom required message 2':
+        print("❌ BUG CONFIRMED: field2 was affected by changes to field2_copy")
+        return False
+    
+    print("✅ No bug detected: error_messages were properly deep copied")
+    return True
+
+if __name__ == "__main__":
+    test_deepcopy_error_messages()
\ No newline at end of file
diff --git a/test_basic_functionality.py b/test_basic_functionality.py
new file mode 100644
index 0000000000..e86374f580
--- /dev/null
+++ b/test_basic_functionality.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python3
+"""
+Test basic form functionality to ensure our deepcopy fix doesn't break anything.
+"""
+
+from django.forms import Form, CharField
+
+class TestForm(Form):
+    name = CharField(error_messages={'required': 'Name is required'})
+    email = CharField(error_messages={'required': 'Email is required'})
+
+def test_basic_functionality():
+    print("Testing basic form functionality...")
+    
+    # Create form instances
+    form1 = TestForm()
+    form2 = TestForm()
+    
+    # Verify they have the same initial error messages
+    assert form1.fields['name'].error_messages['required'] == 'Name is required'
+    assert form1.fields['email'].error_messages['required'] == 'Email is required'
+    assert form2.fields['name'].error_messages['required'] == 'Name is required'
+    assert form2.fields['email'].error_messages['required'] == 'Email is required'
+    
+    # Modify error messages in one form
+    form1.fields['name'].error_messages['required'] = 'Custom name required'
+    form1.fields['email'].error_messages['required'] = 'Custom email required'
+    
+    # Verify the other form is unchanged
+    assert form2.fields['name'].error_messages['required'] == 'Name is required'
+    assert form2.fields['email'].error_messages['required'] == 'Email is required'
+    
+    # Verify the first form was modified
+    assert form1.fields['name'].error_messages['required'] == 'Custom name required'
+    assert form1.fields['email'].error_messages['required'] == 'Custom email required'
+    
+    print("✅ Basic form functionality test passed!")
+
+if __name__ == "__main__":
+    test_basic_functionality()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..5f7ad09ab1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the deepcopy fix of Form Field error_messages.
+"""
+
+import copy
+from django.forms import CharField
+
+def test_edge_cases():
+    print("Testing edge cases for deepcopy fix...")
+    
+    # Test 1: Empty error_messages
+    field1 = CharField(error_messages={})
+    field1_copy = copy.deepcopy(field1)
+    field1_copy.error_messages['required'] = 'Modified message'
+    print(f"Empty error_messages test: original={field1.error_messages}, copy={field1_copy.error_messages}")
+    assert field1.error_messages == {}, "Empty error_messages test failed"
+    
+    # Test 2: Nested dictionaries in error_messages (though unlikely in practice)
+    field2 = CharField(error_messages={'required': 'Message', 'nested': {'key': 'value'}})
+    field2_copy = copy.deepcopy(field2)
+    field2_copy.error_messages['nested']['key'] = 'modified_value'
+    print(f"Nested error_messages test: original={field2.error_messages}, copy={field2_copy.error_messages}")
+    assert field2.error_messages['nested']['key'] == 'value', "Nested error_messages test failed"
+    
+    # Test 3: Multiple error messages
+    field3 = CharField(error_messages={'required': 'Required', 'invalid': 'Invalid'})
+    field3_copy = copy.deepcopy(field3)
+    field3_copy.error_messages['required'] = 'Modified required'
+    field3_copy.error_messages['invalid'] = 'Modified invalid'
+    print(f"Multiple error_messages test: original={field3.error_messages}, copy={field3_copy.error_messages}")
+    assert field3.error_messages['required'] == 'Required', "Multiple error_messages test failed"
+    assert field3.error_messages['invalid'] == 'Invalid', "Multiple error_messages test failed"
+    
+    # Test 4: Default error messages (no custom error_messages provided)
+    field4 = CharField()
+    field4_copy = copy.deepcopy(field4)
+    field4_copy.error_messages['required'] = 'Modified default'
+    print(f"Default error_messages test: original={field4.error_messages}, copy={field4_copy.error_messages}")
+    assert field4.error_messages['required'] != 'Modified default', "Default error_messages test failed"
+    
+    print("✅ All edge case tests passed!")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 0000000000..cf4f991eee
--- /dev/null
+++ b/test_final_verification.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+"""
+Final verification test for the deepcopy fix.
+"""
+
+import copy
+from django.forms import CharField
+
+def test_deepcopy_fix():
+    print("Final verification of deepcopy fix...")
+    
+    # Create original fields with custom error messages
+    field1 = CharField(error_messages={'required': 'Custom required 1'})
+    field2 = CharField(error_messages={'required': 'Custom required 2'})
+    
+    # Store original values
+    original_msg1 = field1.error_messages['required']
+    original_msg2 = field2.error_messages['required']
+    
+    # Create deep copies
+    field1_copy = copy.deepcopy(field1)
+    field2_copy = copy.deepcopy(field2)
+    
+    # Modify the copies
+    field1_copy.error_messages['required'] = 'Modified 1'
+    field2_copy.error_messages['required'] = 'Modified 2'
+    
+    # Check that originals are unchanged
+    if field1.error_messages['required'] != original_msg1:
+        print("❌ FAIL: field1 was modified by changes to field1_copy")
+        return False
+    if field2.error_messages['required'] != original_msg2:
+        print("❌ FAIL: field2 was modified by changes to field2_copy")
+        return False
+    
+    # Check that copies were modified
+    if field1_copy.error_messages['required'] != 'Modified 1':
+        print("❌ FAIL: field1_copy was not properly modified")
+        return False
+    if field2_copy.error_messages['required'] != 'Modified 2':
+        print("❌ FAIL: field2_copy was not properly modified")
+        return False
+    
+    print("✅ SUCCESS: Deepcopy fix is working correctly!")
+    print(f"Original field1: {original_msg1}")
+    print(f"Original field2: {original_msg2}")
+    print(f"Copy field1: {field1_copy.error_messages['required']}")
+    print(f"Copy field2: {field2_copy.error_messages['required']}")
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_deepcopy_fix()
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_other_attributes.py b/test_other_attributes.py
new file mode 100644
index 0000000000..6d3f481d05
--- /dev/null
+++ b/test_other_attributes.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+"""
+Test that other attributes are still properly handled by deepcopy.
+"""
+
+import copy
+from django.forms import CharField
+
+def test_other_attributes():
+    print("Testing that other attributes are still properly deep copied...")
+    
+    # Create a field with various attributes
+    field = CharField(
+        label='Test Label',
+        help_text='Test help text',
+        required=True,
+        error_messages={'required': 'Custom required'}
+    )
+    
+    # Create a deep copy
+    field_copy = copy.deepcopy(field)
+    
+    # Modify the copy
+    field_copy.label = 'Modified Label'
+    field_copy.help_text = 'Modified help text'
+    field_copy.required = False
+    field_copy.error_messages['required'] = 'Modified required'
+    
+    # Check that original is unchanged
+    assert field.label == 'Test Label', "Label was modified in original"
+    assert field.help_text == 'Test help text', "Help text was modified in original"
+    assert field.required == True, "Required was modified in original"
+    assert field.error_messages['required'] == 'Custom required', "Error messages were modified in original"
+    
+    # Check that copy was modified
+    assert field_copy.label == 'Modified Label', "Label was not modified in copy"
+    assert field_copy.help_text == 'Modified help text', "Help text was not modified in copy"
+    assert field_copy.required == False, "Required was not modified in copy"
+    assert field_copy.error_messages['required'] == 'Modified required', "Error messages were not modified in copy"
+    
+    print("✅ All other attributes are properly handled by deepcopy!")
+
+if __name__ == "__main__":
+    test_other_attributes()
\ No newline at end of file
diff --git a/test_simple_edge_cases.py b/test_simple_edge_cases.py
new file mode 100644
index 0000000000..89368cb9b4
--- /dev/null
+++ b/test_simple_edge_cases.py
@@ -0,0 +1,39 @@
+#!/usr/bin/env python3
+"""
+Simple test edge cases for the deepcopy fix of Form Field error_messages.
+Avoids Django translation issues by using simple strings.
+"""
+
+import copy
+from django.forms import CharField
+
+def test_simple_edge_cases():
+    print("Testing simple edge cases for deepcopy fix...")
+    
+    # Test 1: Empty error_messages
+    field1 = CharField(error_messages={})
+    field1_copy = copy.deepcopy(field1)
+    field1_copy.error_messages['required'] = 'Modified message'
+    print(f"Empty error_messages test: original keys={list(field1.error_messages.keys())}, copy keys={list(field1_copy.error_messages.keys())}")
+    assert field1.error_messages == {}, "Empty error_messages test failed"
+    
+    # Test 2: Multiple error messages with simple strings
+    field2 = CharField(error_messages={'required': 'Required message', 'invalid': 'Invalid message'})
+    field2_copy = copy.deepcopy(field2)
+    field2_copy.error_messages['required'] = 'Modified required'
+    field2_copy.error_messages['invalid'] = 'Modified invalid'
+    print(f"Multiple error_messages test: original required={field2.error_messages.get('required')}, copy required={field2_copy.error_messages.get('required')}")
+    assert field2.error_messages['required'] == 'Required message', "Multiple error_messages test failed"
+    assert field2.error_messages['invalid'] == 'Invalid message', "Multiple error_messages test failed"
+    
+    # Test 3: Verify deepcopy works with nested structures (though unlikely in error_messages)
+    field3 = CharField(error_messages={'nested': {'key': 'value'}})
+    field3_copy = copy.deepcopy(field3)
+    field3_copy.error_messages['nested']['key'] = 'modified_value'
+    print(f"Nested error_messages test: original nested value={field3.error_messages['nested']['key']}, copy nested value={field3_copy.error_messages['nested']['key']}")
+    assert field3.error_messages['nested']['key'] == 'value', "Nested error_messages test failed"
+    
+    print("✅ All simple edge case tests passed!")
+
+if __name__ == "__main__":
+    test_simple_edge_cases()
\ No newline at end of file