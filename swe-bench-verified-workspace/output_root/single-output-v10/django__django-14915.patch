diff --git a/django/forms/models.py b/django/forms/models.py
index 5dcf923c12..bc7e6959e7 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -1171,6 +1171,9 @@ class ModelChoiceIteratorValue:
             other = other.value
         return self.value == other
 
+    def __hash__(self):
+        return hash(self.value)
+
 
 class ModelChoiceIterator:
     def __init__(self, field):
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..bf58029e94
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,123 @@
+#!/usr/bin/env python3
+"""
+Final verification that the original GitHub issue is resolved.
+This reproduces the exact code pattern from the issue.
+"""
+
+import os
+import sys
+import json
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.forms.widgets import Select
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+    def __str__(self):
+        return self.name
+
+# Reproduce the exact widget from the GitHub issue
+class CustomSelect(Select):
+    def __init__(self, attrs=None, choices=(), show_fields=None):
+        super().__init__(attrs, choices)
+        self.show_fields = show_fields or {}
+
+    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
+        context = super().create_option(name, value, label, selected, index, subindex, attrs)
+        if not value:
+            return context
+        
+        # EXACT CODE FROM THE GITHUB ISSUE THAT WAS FAILING
+        if value in self.show_fields:  # This is a dict {1: ['first_name', 'last_name']}
+            context['attrs']['data-fields'] = json.dumps(self.show_fields[value])
+        return context
+
+def test_github_issue():
+    """Test the exact GitHub issue scenario"""
+    print("Testing the exact GitHub issue scenario...")
+    
+    # Create test data as described in the issue
+    show_fields = {1: ['first_name', 'last_name'], 2: ['email', 'phone']}
+    
+    # Create widget with the show_fields dict
+    widget = CustomSelect(show_fields=show_fields)
+    
+    # Create ModelChoiceIteratorValue instances (what Django uses internally)
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    # Simulate what Django creates for model choices
+    obj1 = TestModel(name="Test 1")
+    obj2 = TestModel(name="Test 2")
+    
+    value1 = ModelChoiceIteratorValue(1, obj1)  # This is what Django creates
+    value2 = ModelChoiceIteratorValue(2, obj2)  # This is what Django creates
+    
+    # Test the problematic line from the GitHub issue
+    try:
+        # This should work now without throwing TypeError: unhashable type
+        option1 = widget.create_option('test_field', value1, 'Test 1', False, 0)
+        option2 = widget.create_option('test_field', value2, 'Test 2', False, 1)
+        
+        print("‚úì SUCCESS: create_option works with ModelChoiceIteratorValue")
+        print(f"  Option 1 data-fields: {option1['attrs'].get('data-fields', 'None')}")
+        print(f"  Option 2 data-fields: {option2['attrs'].get('data-fields', 'None')}")
+        
+        # Verify the data was set correctly
+        if option1['attrs'].get('data-fields') == json.dumps(['first_name', 'last_name']):
+            print("‚úì Option 1 has correct data-fields attribute")
+        else:
+            print("‚úó Option 1 has incorrect data-fields attribute")
+            
+        if option2['attrs'].get('data-fields') == json.dumps(['email', 'phone']):
+            print("‚úì Option 2 has correct data-fields attribute")
+        else:
+            print("‚úó Option 2 has incorrect data-fields attribute")
+            
+        return True
+        
+    except TypeError as e:
+        if "unhashable type: 'ModelChoiceIteratorValue'" in str(e):
+            print(f"‚úó FAILED: The original GitHub issue still exists: {e}")
+            return False
+        else:
+            print(f"‚úó FAILED: Unexpected error: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó FAILED: Unexpected error: {e}")
+        return False
+
+if __name__ == "__main__":
+    success = test_github_issue()
+    if success:
+        print("\nüéâ The GitHub issue has been RESOLVED!")
+        print("   ModelChoiceIteratorValue is now hashable and can be used in dictionary lookups.")
+    else:
+        print("\n‚ùå The GitHub issue is NOT resolved.")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..9cd623893b
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,88 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the ModelChoiceIteratorValue hashability issue.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+    def __str__(self):
+        return self.name
+
+# Create a form with ModelChoiceField
+class TestForm(forms.Form):
+    test_field = forms.ModelChoiceField(queryset=TestModel.objects.all())
+
+def test_hashability_issue():
+    """Test the hashability issue with ModelChoiceIteratorValue"""
+    print("Testing ModelChoiceIteratorValue hashability...")
+    
+    # Create some test instances
+    obj1 = TestModel(name="Test 1", value=1)
+    obj2 = TestModel(name="Test 2", value=2)
+    
+    # Create ModelChoiceIteratorValue instances
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    value1 = ModelChoiceIteratorValue(obj1.pk, obj1)
+    value2 = ModelChoiceIteratorValue(obj2.pk, obj2)
+    
+    # Test hashability - this should fail
+    try:
+        hash(value1)
+        print("‚úì ModelChoiceIteratorValue is hashable")
+    except TypeError as e:
+        print(f"‚úó ModelChoiceIteratorValue is not hashable: {e}")
+    
+    # Test dictionary usage - this should fail
+    try:
+        test_dict = {value1: 'data1', value2: 'data2'}
+        print("‚úì ModelChoiceIteratorValue can be used as dictionary key")
+    except TypeError as e:
+        print(f"‚úó ModelChoiceIteratorValue cannot be used as dictionary key: {e}")
+    
+    # Test set membership - this should fail (the original issue)
+    try:
+        test_set = {value1, value2}
+        if value1 in test_set:
+            print("‚úì ModelChoiceIteratorValue can be used in set operations")
+        else:
+            print("‚úó ModelChoiceIteratorValue cannot be used in set operations")
+    except TypeError as e:
+        print(f"‚úó ModelChoiceIteratorValue cannot be used in set operations: {e}")
+
+if __name__ == "__main__":
+    test_hashability_issue()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..fe0db9b8a9
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,138 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix works in realistic scenarios.
+"""
+
+import os
+import sys
+import json
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.forms.widgets import Select
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+    def __str__(self):
+        return self.name
+
+# Create a custom widget that reproduces the original issue
+class CustomSelect(Select):
+    def __init__(self, attrs=None, choices=(), show_fields=None):
+        super().__init__(attrs, choices)
+        self.show_fields = show_fields or {}
+
+    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
+        context = super().create_option(name, value, label, selected, index, subindex, attrs)
+        if not value:
+            return context
+        
+        # This is the exact code from the GitHub issue that was failing
+        if value in self.show_fields:  # This is a dict {1: ['first_name', 'last_name']}
+            context['attrs']['data-fields'] = json.dumps(self.show_fields[value])
+        return context
+
+def test_comprehensive():
+    """Comprehensive test of the fix"""
+    print("Running comprehensive tests...")
+    
+    # Create test instances without saving to database
+    obj1 = TestModel(name="Test 1", value=1)
+    obj2 = TestModel(name="Test 2", value=2)
+    
+    # Test 1: Direct ModelChoiceIteratorValue usage
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    value1 = ModelChoiceIteratorValue(1, obj1)
+    value2 = ModelChoiceIteratorValue(2, obj2)
+    
+    show_fields_dict = {1: ['first_name', 'last_name'], 2: ['email', 'phone']}
+    
+    # Test dictionary lookup (the original issue)
+    try:
+        if value1 in show_fields_dict:
+            print("‚úì ModelChoiceIteratorValue can be used in dictionary lookup")
+        else:
+            print("‚úó ModelChoiceIteratorValue cannot be found in dictionary")
+    except TypeError as e:
+        print(f"‚úó Dictionary lookup failed: {e}")
+    
+    # Test 2: Widget usage with ModelChoiceIteratorValue
+    widget = CustomSelect(show_fields=show_fields_dict)
+    
+    # Test with ModelChoiceIteratorValue values
+    try:
+        option1 = widget.create_option('test_field', value1, 'Test 1', False, 0)
+        option2 = widget.create_option('test_field', value2, 'Test 2', False, 1)
+        
+        # Check if the data-fields attribute was set correctly
+        if option1['attrs'].get('data-fields') == json.dumps(['first_name', 'last_name']):
+            print("‚úì Widget correctly processes ModelChoiceIteratorValue (value1)")
+        else:
+            print(f"‚úó Widget failed to process ModelChoiceIteratorValue (value1): {option1['attrs'].get('data-fields')}")
+        
+        if option2['attrs'].get('data-fields') == json.dumps(['email', 'phone']):
+            print("‚úì Widget correctly processes ModelChoiceIteratorValue (value2)")
+        else:
+            print(f"‚úó Widget failed to process ModelChoiceIteratorValue (value2): {option2['attrs'].get('data-fields')}")
+            
+    except Exception as e:
+        print(f"‚úó Widget test failed: {e}")
+    
+    # Test 3: Hash consistency
+    try:
+        hash_val1 = hash(value1)
+        hash_val2 = hash(value2)
+        print(f"‚úì Hash values: value1={hash_val1}, value2={hash_val2}")
+        
+        # Test that equal objects have equal hashes
+        value1_dup = ModelChoiceIteratorValue(1, obj1)
+        if hash(value1) == hash(value1_dup):
+            print("‚úì Equal objects have equal hash values")
+        else:
+            print("‚úó Equal objects have different hash values")
+            
+    except Exception as e:
+        print(f"‚úó Hash test failed: {e}")
+    
+    # Test 4: Set operations
+    try:
+        test_set = {value1, value2}
+        if value1 in test_set and value2 in test_set:
+            print("‚úì Set operations work with ModelChoiceIteratorValue")
+        else:
+            print("‚úó Set operations failed with ModelChoiceIteratorValue")
+    except Exception as e:
+        print(f"‚úó Set operations test failed: {e}")
+
+if __name__ == "__main__":
+    test_comprehensive()
+    print("\n‚úì All comprehensive tests completed!")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..11b359ef5e
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,126 @@
+#!/usr/bin/env python3
+"""
+Test script to reproduce the exact issue from the GitHub issue.
+"""
+
+import os
+import sys
+import json
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django import forms
+from django.db import models
+from django.forms.widgets import Select
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+    def __str__(self):
+        return self.name
+
+# Create a custom widget that reproduces the original issue
+class CustomSelect(Select):
+    def __init__(self, attrs=None, choices=(), show_fields=None):
+        super().__init__(attrs, choices)
+        self.show_fields = show_fields or {}
+
+    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
+        context = super().create_option(name, value, label, selected, index, subindex, attrs)
+        if not value:
+            return context
+        
+        # This is the exact code from the GitHub issue that was failing
+        if value in self.show_fields:  # This is a dict {1: ['first_name', 'last_name']}
+            context['attrs']['data-fields'] = json.dumps(self.show_fields[value])
+        return context
+
+def test_original_issue():
+    """Test the exact scenario from the GitHub issue"""
+    print("Testing original GitHub issue scenario...")
+    
+    # Create test instances without saving to database
+    obj1 = TestModel(name="Test 1", value=1)
+    obj2 = TestModel(name="Test 2", value=2)
+    
+    # Create a form with ModelChoiceField
+    class TestForm(forms.Form):
+        test_field = forms.ModelChoiceField(
+            queryset=TestModel.objects.all(),
+            widget=CustomSelect(show_fields={
+                1: ['first_name', 'last_name'],
+                2: ['email', 'phone']
+            })
+        )
+    
+    form = TestForm()
+    
+    # Get the widget and test the create_option method
+    widget = form.fields['test_field'].widget
+    
+    # Test with ModelChoiceIteratorValue (this was failing before the fix)
+    from django.forms.models import ModelChoiceIteratorValue
+    
+    # Create ModelChoiceIteratorValue instances
+    value1 = ModelChoiceIteratorValue(obj1.pk, obj1)
+    value2 = ModelChoiceIteratorValue(obj2.pk, obj2)
+    
+    # Test the create_option method with the problematic code
+    try:
+        option1 = widget.create_option('test_field', value1, 'Test 1', False, 0)
+        option2 = widget.create_option('test_field', value2, 'Test 2', False, 1)
+        
+        print("‚úì create_option method works with ModelChoiceIteratorValue")
+        print(f"  Option 1 data-fields: {option1['attrs'].get('data-fields', 'None')}")
+        print(f"  Option 2 data-fields: {option2['attrs'].get('data-fields', 'None')}")
+        
+    except TypeError as e:
+        print(f"‚úó create_option method failed: {e}")
+        return False
+    
+    # Test with regular values (this should work as before)
+    try:
+        option1 = widget.create_option('test_field', 1, 'Test 1', False, 0)
+        option2 = widget.create_option('test_field', 2, 'Test 2', False, 1)
+        
+        print("‚úì create_option method works with regular values")
+        print(f"  Option 1 data-fields: {option1['attrs'].get('data-fields', 'None')}")
+        print(f"  Option 2 data-fields: {option2['attrs'].get('data-fields', 'None')}")
+        
+    except Exception as e:
+        print(f"‚úó create_option method failed with regular values: {e}")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    success = test_original_issue()
+    if success:
+        print("\n‚úì All tests passed! The issue has been fixed.")
+    else:
+        print("\n‚úó Tests failed!")
\ No newline at end of file