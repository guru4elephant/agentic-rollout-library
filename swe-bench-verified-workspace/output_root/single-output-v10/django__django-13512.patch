diff --git a/django/forms/fields.py b/django/forms/fields.py
index 9de2c60b35..8ba0013871 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -1258,7 +1258,7 @@ class JSONField(CharField):
     def prepare_value(self, value):
         if isinstance(value, InvalidJSONInput):
             return value
-        return json.dumps(value, cls=self.encoder)
+        return json.dumps(value, cls=self.encoder, ensure_ascii=False)
 
     def has_changed(self, initial, data):
         if super().has_changed(initial, data):
@@ -1266,6 +1266,6 @@ class JSONField(CharField):
         # For purposes of seeing whether something has changed, True isn't the
         # same as 1 and the order of keys doesn't matter.
         return (
-            json.dumps(initial, sort_keys=True, cls=self.encoder) !=
-            json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)
+            json.dumps(initial, sort_keys=True, cls=self.encoder, ensure_ascii=False) !=
+            json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder, ensure_ascii=False)
         )
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..8a20b817b1
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Final test to demonstrate the GitHub issue has been resolved.
+This reproduces the exact scenario described in the issue.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django import forms
+
+# Reproduce the exact issue from GitHub
+print("=== Testing the GitHub Issue Scenario ===")
+
+# Test the original problem
+print("1. Testing json.dumps with default behavior (ASCII):")
+ascii_result = json.dumps('中国')
+print(f"   json.dumps('中国') = {ascii_result}")
+
+print("2. Testing json.dumps with ensure_ascii=False (what we want):")
+unicode_result = json.dumps('中国', ensure_ascii=False)
+print(f"   json.dumps('中国', ensure_ascii=False) = {unicode_result}")
+
+print("3. Testing Django JSONField prepare_value (should show unicode):")
+class TestForm(forms.Form):
+    json_field = forms.JSONField()
+
+form = TestForm()
+test_data = {'chinese_text': '中国', 'other_data': 'test'}
+result = form.fields['json_field'].prepare_value(test_data)
+print(f"   JSONField.prepare_value({{'chinese_text': '中国', 'other_data': 'test'}}) = {result}")
+
+# Verify the fix
+if '\\u4e2d\\u56fd' in result:
+    print("\n❌ ISSUE STILL EXISTS: Chinese characters are escaped as Unicode sequences")
+    print("   This means the fix did not work properly")
+elif '中国' in result:
+    print("\n✅ ISSUE RESOLVED: Chinese characters are displayed properly")
+    print("   The fix is working correctly!")
+else:
+    print("\n⚠️  UNEXPECTED RESULT: Something unexpected happened")
+
+print("\n=== Additional Verification ===")
+print("Testing that the fix works in Django admin context:")
+
+# Simulate what happens in admin when editing a JSONField
+def simulate_admin_display(json_data):
+    """Simulate how Django admin displays JSONField data"""
+    field = forms.JSONField()
+    return field.prepare_value(json_data)
+
+admin_display = simulate_admin_display({'country': '中国', 'city': '北京'})
+print(f"Admin display of {{'country': '中国', 'city': '北京'}}:")
+print(f"   {admin_display}")
+
+if '中国' in admin_display and '北京' in admin_display:
+    print("✅ Admin display shows Chinese characters correctly")
+else:
+    print("❌ Admin display does not show Chinese characters correctly")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..976c3b034a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the JSONField unicode display issue in Django admin.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django import forms
+
+# Test the current behavior
+class TestForm(forms.Form):
+    json_field = forms.JSONField()
+
+# Create a form instance with Chinese characters
+test_data = {'chinese': '中国', 'other': 'data'}
+
+# Test the prepare_value method (this is what's used in admin)
+form = TestForm()
+prepared_value = form.fields['json_field'].prepare_value(test_data)
+
+print("Original data:", test_data)
+print("Prepared value (current behavior):", prepared_value)
+print("Type:", type(prepared_value))
+
+# Test what we want it to be
+desired_output = json.dumps(test_data, ensure_ascii=False)
+print("Desired output (ensure_ascii=False):", desired_output)
+
+# Verify the issue
+if '\\u4e2d\\u56fd' in prepared_value:
+    print("\n❌ ISSUE CONFIRMED: Chinese characters are escaped as Unicode sequences")
+else:
+    print("\n✅ No issue found")
\ No newline at end of file
diff --git a/test_custom_encoder.py b/test_custom_encoder.py
new file mode 100644
index 0000000000..8bbc70017b
--- /dev/null
+++ b/test_custom_encoder.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+"""
+Test that custom encoders still work with our ensure_ascii=False fix.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django.forms import JSONField
+from django.core.serializers.json import DjangoJSONEncoder
+
+def test_custom_encoder():
+    # Test with default encoder (should work with unicode)
+    field_default = JSONField()
+    result1 = field_default.prepare_value({'chinese': '中国'})
+    expected1 = '{"chinese": "中国"}'
+    print(f"Test 1 - Default encoder: {'PASS' if result1 == expected1 else 'FAIL'}")
+    print(f"  Result: {result1}")
+    
+    # Test with custom DjangoJSONEncoder
+    field_custom = JSONField(encoder=DjangoJSONEncoder)
+    result2 = field_custom.prepare_value({'chinese': '中国'})
+    expected2 = '{"chinese": "中国"}'
+    print(f"Test 2 - DjangoJSONEncoder: {'PASS' if result2 == expected2 else 'FAIL'}")
+    print(f"  Result: {result2}")
+    
+    # Test that ensure_ascii=False doesn't interfere with custom encoder functionality
+    class TestEncoder(json.JSONEncoder):
+        def encode(self, o):
+            # Custom encoding logic
+            return super().encode(o)
+    
+    field_test = JSONField(encoder=TestEncoder)
+    result3 = field_test.prepare_value({'chinese': '中国'})
+    expected3 = '{"chinese": "中国"}'
+    print(f"Test 3 - Custom encoder: {'PASS' if result3 == expected3 else 'FAIL'}")
+    print(f"  Result: {result3}")
+
+if __name__ == '__main__':
+    test_custom_encoder()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..043af3e0af
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the JSONField unicode fix.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django import forms
+
+class TestForm(forms.Form):
+    json_field = forms.JSONField()
+
+def test_edge_cases():
+    form = TestForm()
+    
+    # Test 1: Chinese characters
+    test_data_1 = {'chinese': '中国', 'other': 'data'}
+    result_1 = form.fields['json_field'].prepare_value(test_data_1)
+    expected_1 = json.dumps(test_data_1, ensure_ascii=False)
+    print(f"Test 1 - Chinese: {'PASS' if result_1 == expected_1 else 'FAIL'}")
+    print(f"  Result: {result_1}")
+    
+    # Test 2: Japanese characters
+    test_data_2 = {'japanese': '日本語', 'number': 123}
+    result_2 = form.fields['json_field'].prepare_value(test_data_2)
+    expected_2 = json.dumps(test_data_2, ensure_ascii=False)
+    print(f"Test 2 - Japanese: {'PASS' if result_2 == expected_2 else 'FAIL'}")
+    print(f"  Result: {result_2}")
+    
+    # Test 3: Korean characters
+    test_data_3 = {'korean': '한국어', 'boolean': True}
+    result_3 = form.fields['json_field'].prepare_value(test_data_3)
+    expected_3 = json.dumps(test_data_3, ensure_ascii=False)
+    print(f"Test 3 - Korean: {'PASS' if result_3 == expected_3 else 'FAIL'}")
+    print(f"  Result: {result_3}")
+    
+    # Test 4: Mixed unicode and ASCII
+    test_data_4 = {'unicode': 'Hello 世界', 'list': [1, 2, 3]}
+    result_4 = form.fields['json_field'].prepare_value(test_data_4)
+    expected_4 = json.dumps(test_data_4, ensure_ascii=False)
+    print(f"Test 4 - Mixed: {'PASS' if result_4 == expected_4 else 'FAIL'}")
+    print(f"  Result: {result_4}")
+    
+    # Test 5: Empty values
+    test_data_5 = {'empty_string': '', 'null_value': None}
+    result_5 = form.fields['json_field'].prepare_value(test_data_5)
+    expected_5 = json.dumps(test_data_5, ensure_ascii=False)
+    print(f"Test 5 - Empty values: {'PASS' if result_5 == expected_5 else 'FAIL'}")
+    print(f"  Result: {result_5}")
+    
+    # Test 6: Nested structures with unicode
+    test_data_6 = {
+        'nested': {
+            'chinese': '中文',
+            'deep': {'japanese': '日本'}
+        },
+        'array': ['Hello', '世界']
+    }
+    result_6 = form.fields['json_field'].prepare_value(test_data_6)
+    expected_6 = json.dumps(test_data_6, ensure_ascii=False)
+    print(f"Test 6 - Nested: {'PASS' if result_6 == expected_6 else 'FAIL'}")
+    print(f"  Result: {result_6}")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..cd6fef3c2d
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python3
+"""
+Test that existing JSONField functionality still works after our fix.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django.forms import JSONField
+
+def test_existing_functionality():
+    field = JSONField()
+    
+    # Test basic functionality from the existing test
+    print("Testing basic prepare_value functionality:")
+    
+    # Test 1: Basic dict
+    result1 = field.prepare_value({'a': 'b'})
+    expected1 = '{"a": "b"}'
+    print(f"  Test 1 - Basic dict: {'PASS' if result1 == expected1 else 'FAIL'}")
+    print(f"    Result: {result1}")
+    print(f"    Expected: {expected1}")
+    
+    # Test 2: None value
+    result2 = field.prepare_value(None)
+    expected2 = 'null'
+    print(f"  Test 2 - None value: {'PASS' if result2 == expected2 else 'FAIL'}")
+    print(f"    Result: {result2}")
+    print(f"    Expected: {expected2}")
+    
+    # Test 3: String value
+    result3 = field.prepare_value('foo')
+    expected3 = '"foo"'
+    print(f"  Test 3 - String value: {'PASS' if result3 == expected3 else 'FAIL'}")
+    print(f"    Result: {result3}")
+    print(f"    Expected: {expected3}")
+    
+    # Test 4: Number value
+    result4 = field.prepare_value(42)
+    expected4 = '42'
+    print(f"  Test 4 - Number value: {'PASS' if result4 == expected4 else 'FAIL'}")
+    print(f"    Result: {result4}")
+    print(f"    Expected: {expected4}")
+    
+    # Test 5: Boolean value
+    result5 = field.prepare_value(True)
+    expected5 = 'true'
+    print(f"  Test 5 - Boolean value: {'PASS' if result5 == expected5 else 'FAIL'}")
+    print(f"    Result: {result5}")
+    print(f"    Expected: {expected5}")
+    
+    # Test 6: List value
+    result6 = field.prepare_value([1, 2, 3])
+    expected6 = '[1, 2, 3]'
+    print(f"  Test 6 - List value: {'PASS' if result6 == expected6 else 'FAIL'}")
+    print(f"    Result: {result6}")
+    print(f"    Expected: {expected6}")
+    
+    print("\nTesting that ensure_ascii=False works correctly:")
+    
+    # Test 7: Unicode characters (our fix)
+    result7 = field.prepare_value({'chinese': '中国'})
+    expected7 = '{"chinese": "中国"}'
+    print(f"  Test 7 - Unicode chars: {'PASS' if result7 == expected7 else 'FAIL'}")
+    print(f"    Result: {result7}")
+    print(f"    Expected: {expected7}")
+    
+    # Verify our fix doesn't break normal ASCII
+    result8 = field.prepare_value({'ascii': 'hello'})
+    expected8 = '{"ascii": "hello"}'
+    print(f"  Test 8 - ASCII chars: {'PASS' if result8 == expected8 else 'FAIL'}")
+    print(f"    Result: {result8}")
+    print(f"    Expected: {expected8}")
+
+if __name__ == '__main__':
+    test_existing_functionality()
\ No newline at end of file
diff --git a/test_has_changed.py b/test_has_changed.py
new file mode 100644
index 0000000000..38ab36fc98
--- /dev/null
+++ b/test_has_changed.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+"""
+Test that the has_changed method works correctly with our ensure_ascii=False fix.
+"""
+
+import json
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='dummy-secret-key-for-testing',
+    )
+    django.setup()
+
+from django.forms import JSONField
+
+def test_has_changed():
+    field = JSONField()
+    
+    # Test with unicode characters
+    initial = {'chinese': '中国', 'other': 'data'}
+    data = '{"chinese": "中国", "other": "data"}'
+    
+    # Should return False since the data hasn't changed
+    result1 = field.has_changed(initial, data)
+    print(f"Test 1 - No change with unicode: {'PASS' if not result1 else 'FAIL'}")
+    print(f"  Result: {result1}")
+    print(f"  Expected: False")
+    
+    # Test with changed unicode data
+    changed_data = '{"chinese": "中文", "other": "data"}'
+    result2 = field.has_changed(initial, changed_data)
+    print(f"Test 2 - Changed unicode: {'PASS' if result2 else 'FAIL'}")
+    print(f"  Result: {result2}")
+    print(f"  Expected: True")
+    
+    # Test with ASCII data (should still work)
+    initial_ascii = {'ascii': 'hello', 'number': 123}
+    ascii_data = '{"ascii": "hello", "number": 123}'
+    
+    result3 = field.has_changed(initial_ascii, ascii_data)
+    print(f"Test 3 - No change with ASCII: {'PASS' if not result3 else 'FAIL'}")
+    print(f"  Result: {result3}")
+    print(f"  Expected: False")
+    
+    # Test with changed ASCII data
+    changed_ascii_data = '{"ascii": "world", "number": 123}'
+    result4 = field.has_changed(initial_ascii, changed_ascii_data)
+    print(f"Test 4 - Changed ASCII: {'PASS' if result4 else 'FAIL'}")
+    print(f"  Result: {result4}")
+    print(f"  Expected: True")
+
+if __name__ == '__main__':
+    test_has_changed()
\ No newline at end of file