diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py
index 9b00e24509..3d579f6b17 100644
--- a/django/urls/resolvers.py
+++ b/django/urls/resolvers.py
@@ -45,7 +45,22 @@ class ResolverMatch:
         self.namespaces = [x for x in namespaces if x] if namespaces else []
         self.namespace = ':'.join(self.namespaces)
 
-        if not hasattr(func, '__name__'):
+        # Handle functools.partial objects
+        if isinstance(func, functools.partial):
+            # Unwrap the partial to get the underlying function
+            unwrapped_func = func.func
+            # Build a string representation that includes partial arguments
+            partial_args = []
+            if func.args:
+                partial_args.extend(repr(arg) for arg in func.args)
+            if func.keywords:
+                partial_args.extend(f"{k}={repr(v)}" for k, v in func.keywords.items())
+            if partial_args:
+                partial_str = ", ".join(partial_args)
+                self._func_path = f"functools.partial({self._get_func_path(unwrapped_func)}, {partial_str})"
+            else:
+                self._func_path = f"functools.partial({self._get_func_path(unwrapped_func)})"
+        elif not hasattr(func, '__name__'):
             # A class-based view
             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__
         else:
@@ -55,6 +70,15 @@ class ResolverMatch:
         view_path = url_name or self._func_path
         self.view_name = ':'.join(self.namespaces + [view_path])
 
+    def _get_func_path(self, func):
+        """Helper method to get the function path string representation."""
+        if not hasattr(func, '__name__'):
+            # A class-based view
+            return func.__class__.__module__ + '.' + func.__class__.__name__
+        else:
+            # A function-based view
+            return func.__module__ + '.' + func.__name__
+
     def __getitem__(self, index):
         return (self.func, self.args, self.kwargs)[index]
 
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c5f318ab9c
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2):
+    return f"Hello {arg1} {arg2}"
+
+# Create a partial function
+partial_view = functools.partial(my_view, arg1="World")
+
+# Create ResolverMatch with the partial function
+resolver_match = ResolverMatch(
+    func=partial_view,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+print("ResolverMatch repr:")
+print(repr(resolver_match))
+print("\nExpected: Should show the underlying function 'my_view' and partial arguments")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..8b361e46c1
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2):
+    return f"Hello {arg1} {arg2}"
+
+# Test case 1: Partial with args only
+partial_args = functools.partial(my_view, "World")
+resolver_match1 = ResolverMatch(
+    func=partial_args,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+# Test case 2: Partial with kwargs only
+partial_kwargs = functools.partial(my_view, arg1="World")
+resolver_match2 = ResolverMatch(
+    func=partial_kwargs,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+# Test case 3: Partial with both args and kwargs
+partial_both = functools.partial(my_view, "Hello", arg2="World")
+resolver_match3 = ResolverMatch(
+    func=partial_both,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+# Test case 4: Regular function (should work as before)
+resolver_match4 = ResolverMatch(
+    func=my_view,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+print("Test 1 - Partial with args:")
+print(repr(resolver_match1))
+print("\nTest 2 - Partial with kwargs:")
+print(repr(resolver_match2))
+print("\nTest 3 - Partial with both args and kwargs:")
+print(repr(resolver_match3))
+print("\nTest 4 - Regular function:")
+print(repr(resolver_match4))
\ No newline at end of file
diff --git a/test_nested_partials.py b/test_nested_partials.py
new file mode 100644
index 0000000000..44a09737f5
--- /dev/null
+++ b/test_nested_partials.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+import functools
+from django.urls.resolvers import ResolverMatch
+
+def my_view(request, arg1, arg2, arg3):
+    return f"Hello {arg1} {arg2} {arg3}"
+
+# Test nested partials
+partial1 = functools.partial(my_view, "Hello")
+partial2 = functools.partial(partial1, arg2="World")
+partial3 = functools.partial(partial2, arg3="!")
+
+resolver_match = ResolverMatch(
+    func=partial3,
+    args=(),
+    kwargs={},
+    url_name=None,
+    app_names=None,
+    namespaces=None,
+    route=None,
+    tried=None
+)
+
+print("Nested partials test:")
+print(repr(resolver_match))
\ No newline at end of file