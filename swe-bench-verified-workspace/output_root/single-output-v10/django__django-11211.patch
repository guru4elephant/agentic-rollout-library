diff --git a/django/contrib/contenttypes/fields.py b/django/contrib/contenttypes/fields.py
index ed98ecb48c..e2b92f2748 100644
--- a/django/contrib/contenttypes/fields.py
+++ b/django/contrib/contenttypes/fields.py
@@ -202,8 +202,12 @@ class GenericForeignKey(FieldCacheMixin):
             else:
                 model = self.get_content_type(id=ct_id,
                                               using=obj._state.db).model_class()
-                return (model._meta.pk.get_prep_value(getattr(obj, self.fk_field)),
-                        model)
+                fk_value = getattr(obj, self.fk_field)
+                # Convert the foreign key value to match the target model's primary key format
+                # Use to_python to properly convert string representations to the correct type
+                if hasattr(model._meta.pk, 'to_python'):
+                    fk_value = model._meta.pk.to_python(fk_value)
+                return (fk_value, model)
 
         return (
             ret_val,
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..6e9898cf38
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings FIRST
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.contenttypes.fields import GenericForeignKey
+from django.contrib.contenttypes.models import ContentType
+
+# Create models as described in the issue
+class Foo(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo_content_type = models.ForeignKey(
+        ContentType, related_name='actor',
+        on_delete=models.CASCADE, db_index=True
+    )
+    foo_object_id = models.CharField(max_length=255, db_index=True)
+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_complete_fix():
+    """Test the complete fix with actual database operations"""
+    print("Testing complete fix...")
+    
+    # Create database tables manually
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ContentType)
+        schema_editor.create_model(Foo)
+        schema_editor.create_model(Bar)
+    
+    # Create test data
+    foo1 = Foo.objects.create(name="Foo 1")
+    foo2 = Foo.objects.create(name="Foo 2")
+    
+    content_type = ContentType.objects.get_for_model(Foo)
+    
+    bar1 = Bar.objects.create(
+        foo_content_type=content_type,
+        foo_object_id=str(foo1.id),
+        name="Bar 1"
+    )
+    bar2 = Bar.objects.create(
+        foo_content_type=content_type,
+        foo_object_id=str(foo2.id),
+        name="Bar 2"
+    )
+    
+    print("Created test data:")
+    print(f"Foo 1: {foo1.id} ({type(foo1.id)})")
+    print(f"Foo 2: {foo2.id} ({type(foo2.id)})")
+    print(f"Bar 1 foo_object_id: {bar1.foo_object_id} ({type(bar1.foo_object_id)})")
+    print(f"Bar 2 foo_object_id: {bar2.foo_object_id} ({type(bar2.foo_object_id)})")
+    
+    # Test prefetch_related
+    print("\nTesting prefetch_related:")
+    bars = Bar.objects.all().prefetch_related('foo')
+    
+    success_count = 0
+    failure_count = 0
+    
+    for bar in bars:
+        print(f"Bar {bar.name}: foo = {bar.foo}")
+        if bar.foo is None:
+            print(f"  ERROR: foo is None for bar {bar.name}!")
+            failure_count += 1
+        else:
+            print(f"  Success: foo = {bar.foo.name}")
+            success_count += 1
+    
+    print(f"\nResults: {success_count} successes, {failure_count} failures")
+    
+    if failure_count == 0:
+        print("SUCCESS: All prefetched objects were properly loaded!")
+    else:
+        print("FAILURE: Some prefetched objects were None!")
+
+if __name__ == '__main__':
+    test_complete_fix()
\ No newline at end of file
diff --git a/real_test.py b/real_test.py
new file mode 100644
index 0000000000..5a23892510
--- /dev/null
+++ b/real_test.py
@@ -0,0 +1,123 @@
+#!/usr/bin/env python
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings FIRST
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.contenttypes.fields import GenericForeignKey
+from django.contrib.contenttypes.models import ContentType
+
+# Create models as described in the issue
+class Foo(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo_content_type = models.ForeignKey(
+        ContentType, related_name='actor',
+        on_delete=models.CASCADE, db_index=True
+    )
+    foo_object_id = models.CharField(max_length=255, db_index=True)
+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_actual_issue():
+    """Test the actual issue by examining the key generation"""
+    print("Testing actual UUID prefetch issue...")
+    
+    # Create a mock instance to test the get_prefetch_queryset method
+    class MockInstance:
+        def __init__(self, ct_id, fk_val):
+            self.foo_content_type_id = ct_id
+            self.foo_object_id = fk_val
+            self._state = type('MockState', (), {'db': 'default'})()
+    
+    # Create mock instances with UUID values (as strings)
+    uuid1 = str(uuid.uuid4())
+    uuid2 = str(uuid.uuid4())
+    
+    mock_instances = [
+        MockInstance(1, uuid1),
+        MockInstance(1, uuid2)
+    ]
+    
+    # Create a GenericForeignKey
+    gfk = GenericForeignKey('foo_content_type', 'foo_object_id')
+    gfk.name = 'foo'
+    
+    # Set up the model
+    gfk.model = Bar
+    
+    # Mock the content type methods to return the actual Foo model
+    def mock_get_content_type(id=None, using=None):
+        class MockContentType:
+            def model_class(self):
+                return Foo
+            def get_all_objects_for_this_type(self, **kwargs):
+                return []
+        return MockContentType()
+    
+    gfk.get_content_type = mock_get_content_type
+    
+    # Test the get_prefetch_queryset method
+    print(f"UUID 1: {uuid1} (string)")
+    print(f"UUID 2: {uuid2} (string)")
+    
+    try:
+        result = gfk.get_prefetch_queryset(mock_instances)
+        print("get_prefetch_queryset executed successfully")
+        
+        # Test the gfk_key function
+        gfk_key_func = result[2]
+        for instance in mock_instances:
+            key = gfk_key_func(instance)
+            print(f"gfk_key result for instance with fk_val {instance.foo_object_id}: {key}")
+            print(f"  Key type: {type(key[0])}")
+            print(f"  Key value: {key[0]}")
+            
+        # Test what the lambda function would return for a Foo object
+        foo_obj = Foo(id=uuid.UUID(uuid1), name="Test")
+        lambda_func = result[1]
+        lambda_key = lambda_func(foo_obj)
+        print(f"Lambda key for Foo object: {lambda_key}")
+        print(f"  Lambda key type: {type(lambda_key[0])}")
+        print(f"  Lambda key value: {lambda_key[0]}")
+        
+        # Check if they match
+        gfk_key = gfk_key_func(mock_instances[0])
+        print(f"Keys match: {gfk_key[0] == lambda_key[0] and gfk_key[1] == lambda_key[1]}")
+        
+    except Exception as e:
+        print(f"Error in get_prefetch_queryset: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_actual_issue()
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d81e1d7313
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,140 @@
+#!/usr/bin/env python
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings FIRST
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Now import Django modules
+from django.db import models
+from django.contrib.contenttypes.fields import GenericForeignKey
+from django.contrib.contenttypes.models import ContentType
+
+# Create models as described in the issue
+class Foo(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo_content_type = models.ForeignKey(
+        ContentType, related_name='actor',
+        on_delete=models.CASCADE, db_index=True
+    )
+    foo_object_id = models.CharField(max_length=255, db_index=True)
+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_prefetch_related_with_uuid():
+    # Let's focus on testing the core issue - the get_prefetch_queryset method
+    # We'll manually test the logic without database operations
+    
+    # Create a mock instance to test the get_prefetch_queryset method
+    class MockInstance:
+        def __init__(self, ct_id, fk_val):
+            self.ct_id = ct_id
+            self.fk_val = fk_val
+            self._state = type('MockState', (), {'db': 'default'})()
+    
+    # Create mock instances with UUID values (as strings)
+    uuid1 = str(uuid.uuid4())
+    uuid2 = str(uuid.uuid4())
+    
+    mock_instances = [
+        MockInstance(1, uuid1),
+        MockInstance(1, uuid2)
+    ]
+    
+    # Add the required attributes to mock instances
+    for instance in mock_instances:
+        instance.foo_content_type_id = instance.ct_id
+        setattr(instance, 'foo_object_id', instance.fk_val)
+    
+    # Create a mock GenericForeignKey
+    gfk = GenericForeignKey('foo_content_type', 'foo_object_id')
+    gfk.name = 'foo'  # Add the required name attribute
+    
+    # Create a proper mock model with meta that can handle get_field calls
+    class MockField:
+        def get_attname(self):
+            return 'foo_content_type_id'
+    
+    class MockMeta:
+        def get_field(self, field_name):
+            return MockField()
+    
+    class MockModel:
+        _meta = MockMeta()
+    
+    gfk.model = MockModel()
+    
+    # Test the get_prefetch_queryset method
+    print("Testing get_prefetch_queryset with UUID values:")
+    print(f"UUID 1: {uuid1}")
+    print(f"UUID 2: {uuid2}")
+    
+    # Mock the content type methods
+    def mock_get_content_type(id=None, using=None):
+        class MockContentType:
+            def get_all_objects_for_this_type(self, **kwargs):
+                # Return mock objects with UUID primary keys
+                class MockObject:
+                    def __init__(self, pk):
+                        self.pk = pk
+                if 'pk__in' in kwargs:
+                    return [MockObject(pk) for pk in kwargs['pk__in']]
+                return []
+            
+            def model_class(self):
+                # Return a mock model class
+                class MockModelClass:
+                    class _meta:
+                        pk = type('MockPK', (), {'get_prep_value': lambda self, value: value})()
+                return MockModelClass
+        
+        return MockContentType()
+    
+    gfk.get_content_type = mock_get_content_type
+    
+    try:
+        result = gfk.get_prefetch_queryset(mock_instances)
+        print("get_prefetch_queryset executed successfully")
+        print(f"Result objects: {len(result[0])}")
+        
+        # Test the gfk_key function
+        gfk_key_func = result[2]
+        for instance in mock_instances:
+            key = gfk_key_func(instance)
+            print(f"gfk_key result for instance with fk_val {instance.fk_val}: {key}")
+            
+    except Exception as e:
+        print(f"Error in get_prefetch_queryset: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_prefetch_related_with_uuid()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..6f4b0c881e
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings FIRST
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.contenttypes.fields import GenericForeignKey
+
+# Create models as described in the issue
+class Foo(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_key_conversion():
+    """Test that the key conversion works correctly"""
+    print("Testing key conversion...")
+    
+    # Create a mock instance
+    class MockInstance:
+        def __init__(self, fk_val):
+            self.foo_object_id = fk_val
+            self._state = type('MockState', (), {'db': 'default'})()
+    
+    # Test with UUID string
+    uuid_str = str(uuid.uuid4())
+    mock_instance = MockInstance(uuid_str)
+    
+    # Create a GenericForeignKey
+    gfk = GenericForeignKey('foo_content_type', 'foo_object_id')
+    gfk.name = 'foo'
+    gfk.model = type('MockModel', (), {'_meta': type('MockMeta', (), {'get_field': lambda self, field_name: type('MockField', (), {'get_attname': lambda: 'foo_content_type_id'})()})()})()
+    
+    # Mock the content type methods to return the actual Foo model
+    def mock_get_content_type(id=None, using=None):
+        class MockContentType:
+            def model_class(self):
+                return Foo
+        return MockContentType()
+    
+    gfk.get_content_type = mock_get_content_type
+    
+    # Test the gfk_key function logic directly
+    ct_attname = 'foo_content_type_id'
+    ct_id = 1  # Mock content type ID
+    
+    # This is the logic from the fixed get_prefetch_queryset method
+    model = gfk.get_content_type(id=ct_id, using=mock_instance._state.db).model_class()
+    fk_value = getattr(mock_instance, gfk.fk_field)
+    
+    print(f"Original fk_value: {fk_value} ({type(fk_value)})")
+    
+    # Apply the fix
+    if hasattr(model._meta.pk, 'to_python'):
+        fk_value = model._meta.pk.to_python(fk_value)
+    
+    print(f"Converted fk_value: {fk_value} ({type(fk_value)})")
+    
+    # Test what a Foo object's pk would be
+    foo_obj = Foo(id=uuid.UUID(uuid_str), name="Test")
+    print(f"Foo object pk: {foo_obj.pk} ({type(foo_obj.pk)})")
+    
+    # Check if they match
+    print(f"Values match: {fk_value == foo_obj.pk}")
+    print(f"Types match: {type(fk_value) == type(foo_obj.pk)}")
+
+if __name__ == '__main__':
+    test_key_conversion()
\ No newline at end of file
diff --git a/test_uuid_prefetch.py b/test_uuid_prefetch.py
new file mode 100644
index 0000000000..50c0ce7afe
--- /dev/null
+++ b/test_uuid_prefetch.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python
+import os
+import sys
+import uuid
+import django
+from django.conf import settings
+
+# Configure Django settings FIRST
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.contrib.contenttypes.fields import GenericForeignKey
+from django.contrib.contenttypes.models import ContentType
+
+# Create models as described in the issue
+class Foo(models.Model):
+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Bar(models.Model):
+    foo_content_type = models.ForeignKey(
+        ContentType, related_name='actor',
+        on_delete=models.CASCADE, db_index=True
+    )
+    foo_object_id = models.CharField(max_length=255, db_index=True)
+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_uuid_prefetch_issue():
+    """Test the actual issue with UUID prefetching"""
+    print("Testing UUID prefetch issue...")
+    
+    # Create a mock instance to test the get_prefetch_queryset method
+    class MockInstance:
+        def __init__(self, ct_id, fk_val):
+            self.foo_content_type_id = ct_id
+            self.foo_object_id = fk_val
+            self._state = type('MockState', (), {'db': 'default'})()
+    
+    # Create mock instances with UUID values (as strings)
+    uuid1 = str(uuid.uuid4())
+    uuid2 = str(uuid.uuid4())
+    
+    mock_instances = [
+        MockInstance(1, uuid1),
+        MockInstance(1, uuid2)
+    ]
+    
+    # Create a mock GenericForeignKey
+    gfk = GenericForeignKey('foo_content_type', 'foo_object_id')
+    gfk.name = 'foo'
+    
+    # Create a proper mock model with meta that can handle get_field calls
+    class MockField:
+        def get_attname(self):
+            return 'foo_content_type_id'
+    
+    class MockMeta:
+        def get_field(self, field_name):
+            return MockField()
+    
+    class MockModel:
+        _meta = MockMeta()
+    
+    gfk.model = MockModel()
+    
+    # Mock the content type methods
+    def mock_get_content_type(id=None, using=None):
+        class MockContentType:
+            def get_all_objects_for_this_type(self, **kwargs):
+                # Return mock objects with UUID primary keys
+                class MockObject:
+                    def __init__(self, pk):
+                        self.pk = pk
+                if 'pk__in' in kwargs:
+                    return [MockObject(pk) for pk in kwargs['pk__in']]
+                return []
+            
+            def model_class(self):
+                # Return a mock model class that simulates Foo with UUIDField
+                class MockModelClass:
+                    class _meta:
+                        pk = models.UUIDField()  # This should simulate a UUIDField
+                return MockModelClass
+        
+        return MockContentType()
+    
+    gfk.get_content_type = mock_get_content_type
+    
+    # Test the get_prefetch_queryset method
+    print(f"UUID 1: {uuid1}")
+    print(f"UUID 2: {uuid2}")
+    
+    try:
+        result = gfk.get_prefetch_queryset(mock_instances)
+        print("get_prefetch_queryset executed successfully")
+        
+        # Test the gfk_key function
+        gfk_key_func = result[2]
+        for instance in mock_instances:
+            key = gfk_key_func(instance)
+            print(f"gfk_key result for instance with fk_val {instance.foo_object_id}: {key}")
+            print(f"  Key type: {type(key[0])}")
+            
+    except Exception as e:
+        print(f"Error in get_prefetch_queryset: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_uuid_prefetch_issue()
\ No newline at end of file