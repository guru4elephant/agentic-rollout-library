diff --git a/django/utils/dateformat.py b/django/utils/dateformat.py
index 38e89c47bb..7185c6921c 100644
--- a/django/utils/dateformat.py
+++ b/django/utils/dateformat.py
@@ -314,7 +314,7 @@ class DateFormat(TimeFormat):
 
     def Y(self):
         "Year, 4 digits; e.g. '1999'"
-        return self.data.year
+        return '%04d' % self.data.year
 
     def z(self):
         """Day of the year, i.e. 1 to 366."""
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..54da1b5272
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.utils.dateformat import DateFormat
+
+def test_year_formatting():
+    # Test years that should be zero-padded
+    test_years = [1, 10, 100, 999, 1000, 2023]
+    
+    for year in test_years:
+        # Create a date with the specific year
+        test_date = datetime.date(year, 1, 1)
+        df = DateFormat(test_date)
+        
+        result = df.Y()
+        print(f"Year {year}: '{result}' (length: {len(str(result))})")
+        
+        # Check if the result is properly zero-padded to 4 digits
+        if len(str(result)) != 4:
+            print(f"  ERROR: Year {year} is not zero-padded to 4 digits!")
+        else:
+            print(f"  OK: Year {year} is properly zero-padded")
+
+if __name__ == "__main__":
+    test_year_formatting()
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..f03389a77a
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.utils.dateformat import DateFormat, format
+
+def test_year_padding():
+    """Test that Y format specifier returns 4-digit zero-padded years"""
+    test_cases = [
+        (1, '0001'),
+        (10, '0010'), 
+        (100, '0100'),
+        (999, '0999'),
+        (1000, '1000'),
+        (2023, '2023'),
+    ]
+    
+    all_passed = True
+    
+    for year, expected in test_cases:
+        test_date = datetime.date(year, 1, 1)
+        
+        # Test using DateFormat directly
+        df = DateFormat(test_date)
+        result1 = df.Y()
+        
+        # Test using format function
+        result2 = format(test_date, 'Y')
+        
+        if result1 == expected and result2 == expected and len(result1) == 4:
+            print(f"✓ Year {year}: '{result1}' (properly zero-padded)")
+        else:
+            print(f"✗ Year {year}: expected '{expected}', got '{result1}' from DateFormat, '{result2}' from format()")
+            all_passed = False
+    
+    return all_passed
+
+if __name__ == '__main__':
+    if test_year_padding():
+        print("\nAll tests passed! ✅")
+    else:
+        print("\nSome tests failed! ❌")
\ No newline at end of file
diff --git a/test_direct.py b/test_direct.py
new file mode 100644
index 0000000000..88619d0577
--- /dev/null
+++ b/test_direct.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.utils.dateformat import DateFormat
+
+def test_direct():
+    """Test DateFormat directly to avoid settings issues"""
+    
+    # Test cases from the existing Django test suite
+    my_birthday = datetime.date(1979, 7, 8)
+    the_future = datetime.date(2100, 10, 25)
+    
+    # Test the Y format specifier with existing test data
+    test_cases = [
+        (my_birthday, '1979'),
+        (the_future, '2100'),
+    ]
+    
+    all_passed = True
+    
+    for test_date, expected in test_cases:
+        df = DateFormat(test_date)
+        result = df.Y()
+        if result == expected:
+            print(f"✓ Date {test_date}: '{result}' (matches expected)")
+        else:
+            print(f"✗ Date {test_date}: expected '{expected}', got '{result}'")
+            all_passed = False
+    
+    return all_passed
+
+if __name__ == '__main__':
+    if test_direct():
+        print("\nAll direct tests passed! ✅")
+    else:
+        print("\nSome direct tests failed! ❌")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d5be3ece43
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.utils.dateformat import DateFormat
+
+def test_edge_cases():
+    # Test edge cases including negative years (BC dates) and very large years
+    test_years = [-1, 0, 1, 10, 100, 999, 1000, 9999, 10000, 2023]
+    
+    for year in test_years:
+        try:
+            # Create a date with the specific year
+            test_date = datetime.date(year, 1, 1)
+            df = DateFormat(test_date)
+            
+            result = df.Y()
+            print(f"Year {year}: '{result}' (length: {len(str(result))})")
+            
+            # Check if the result is properly zero-padded to 4 digits
+            if len(str(result)) != 4:
+                print(f"  ERROR: Year {year} is not zero-padded to 4 digits!")
+            else:
+                print(f"  OK: Year {year} is properly zero-padded")
+        except ValueError as e:
+            print(f"Year {year}: ValueError - {e}")
+
+if __name__ == "__main__":
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_existing_functionality.py b/test_existing_functionality.py
new file mode 100644
index 0000000000..1c49084915
--- /dev/null
+++ b/test_existing_functionality.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.utils.dateformat import format
+
+def test_existing_functionality():
+    """Test that existing functionality still works after our fix"""
+    
+    # Test cases from the existing Django test suite
+    my_birthday = datetime.datetime(1979, 7, 8, 22, 0)
+    the_future = datetime.datetime(2100, 10, 25, 0, 0)
+    
+    # Test the Y format specifier with existing test data
+    test_cases = [
+        (my_birthday, '1979'),
+        (the_future, '2100'),
+    ]
+    
+    all_passed = True
+    
+    for test_date, expected in test_cases:
+        result = format(test_date, 'Y')
+        if result == expected:
+            print(f"✓ Date {test_date}: '{result}' (matches expected)")
+        else:
+            print(f"✗ Date {test_date}: expected '{expected}', got '{result}'")
+            all_passed = False
+    
+    return all_passed
+
+if __name__ == '__main__':
+    if test_existing_functionality():
+        print("\nAll existing functionality tests passed! ✅")
+    else:
+        print("\nSome existing functionality tests failed! ❌")
\ No newline at end of file
diff --git a/test_year_padding.py b/test_year_padding.py
new file mode 100644
index 0000000000..81466c74bc
--- /dev/null
+++ b/test_year_padding.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+import datetime
+from django.test import SimpleTestCase
+from django.utils.dateformat import format
+
+class YearPaddingTests(SimpleTestCase):
+    
+    def test_year_zero_padding(self):
+        """Test that Y format specifier returns 4-digit zero-padded years"""
+        test_cases = [
+            (1, '0001'),
+            (10, '0010'), 
+            (100, '0100'),
+            (999, '0999'),
+            (1000, '1000'),
+            (2023, '2023'),
+        ]
+        
+        for year, expected in test_cases:
+            with self.subTest(year=year):
+                test_date = datetime.date(year, 1, 1)
+                result = format(test_date, 'Y')
+                self.assertEqual(result, expected)
+                self.assertEqual(len(result), 4)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file