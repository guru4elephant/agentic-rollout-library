diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..15165ef220
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the duplicate options issue with limit_choices_to
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q
+
+# Create simple test models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Product(models.Model):
+    name = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, on_delete=models.CASCADE)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Now let's simulate what happens in formfield generation
+from django import forms
+from django.forms.models import apply_limit_choices_to_to_formfield
+
+# Create a mock form field with a queryset that would have duplicates
+# when filtered with a Q object involving joins
+
+# First, let's understand what happens with complex_filter
+queryset = Product.objects.all()
+print("Original queryset:", queryset)
+
+# Create a Q object that involves a join (this is where the issue might occur)
+limit_choices_to = Q(category__active=True) & Q(active=True)
+print("Limit choices to:", limit_choices_to)
+
+# Apply the complex filter
+filtered_queryset = queryset.complex_filter(limit_choices_to)
+print("Filtered queryset:", filtered_queryset)
+
+# Let's examine the SQL that gets generated
+print("SQL for filtered queryset:")
+print(filtered_queryset.query)
+
+# The issue might be in how the SQL is constructed or how the results are processed
+# Let's see what happens when we iterate through the queryset
+
+# Create a mock ModelChoiceField to test
+class TestModelChoiceField(forms.ModelChoiceField):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.limit_choices_to = limit_choices_to
+    
+    def get_limit_choices_to(self):
+        return self.limit_choices_to
+
+# Create the field
+field = TestModelChoiceField(queryset=queryset)
+
+# Apply limit_choices_to
+apply_limit_choices_to_to_formfield(field)
+
+print("Field queryset after applying limit_choices_to:", field.queryset)
+
+# Now let's see what choices are generated
+choices = list(field.queryset)
+print("Choices:", choices)
+print("Number of choices:", len(choices))
+print("Number of unique choices:", len(set(choices)))
+
+# Check for duplicates
+seen = set()
+duplicates = []
+for choice in choices:
+    if choice in seen:
+        duplicates.append(choice)
+    seen.add(choice)
+
+if duplicates:
+    print("DUPLICATES FOUND:", len(duplicates))
+    for dup in duplicates:
+        print(f"  {dup}")
+else:
+    print("No duplicates found")
\ No newline at end of file
diff --git a/django/forms/models.py b/django/forms/models.py
index 5d115458a1..2dfde030da 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -101,6 +101,8 @@ def apply_limit_choices_to_to_formfield(formfield):
         limit_choices_to = formfield.get_limit_choices_to()
         if limit_choices_to is not None:
             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)
+            # Deduplicate the queryset to prevent duplicate options when using joins
+            formfield.queryset = formfield.queryset.distinct()
 
 
 def fields_for_model(model, fields=None, exclude=None, widgets=None,
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..5d4effefea
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,117 @@
+#!/usr/bin/env python3
+"""
+Final test script to verify the fix for duplicate options issue with limit_choices_to
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Test the fix by examining the apply_limit_choices_to_to_formfield function directly
+from django.forms.models import apply_limit_choices_to_to_formfield
+
+# Create a mock form field that simulates the issue
+class MockFormField:
+    def __init__(self, queryset):
+        self.queryset = queryset
+    
+    def get_limit_choices_to(self):
+        # Return a Q object that would cause duplicates with joins
+        from django.db.models import Q
+        return Q(category__active=True) & Q(active=True)
+
+# Create a mock queryset that simulates what happens with complex joins
+class MockObject:
+    def __init__(self, id, name):
+        self.id = id
+        self.name = name
+    
+    def __str__(self):
+        return self.name
+    
+    def __eq__(self, other):
+        return self.id == other.id
+    
+    def __hash__(self):
+        return hash(self.id)
+
+# Simulate a queryset that would return duplicates after complex filtering
+mock_objects = [
+    MockObject(1, "Product 1"),
+    MockObject(2, "Product 2"),
+    MockObject(1, "Product 1"),  # Duplicate due to join issues
+    MockObject(3, "Product 3"),
+]
+
+class MockQuerySet:
+    def __init__(self, objects):
+        self.objects = objects
+    
+    def complex_filter(self, q_obj):
+        # Simulate complex filter that might return duplicates
+        return MockQuerySet(self.objects)
+    
+    def distinct(self):
+        # Simulate distinct() method that removes duplicates
+        unique_objects = list(set(self.objects))
+        return MockQuerySet(unique_objects)
+    
+    def __iter__(self):
+        return iter(self.objects)
+    
+    def count(self):
+        return len(self.objects)
+
+# Test the fix
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset)
+
+print("Before applying limit_choices_to:")
+print("Number of objects:", mock_field.queryset.count())
+print("Number of unique objects:", len(set(mock_field.queryset)))
+
+# Apply limit_choices_to
+apply_limit_choices_to_to_formfield(mock_field)
+
+print("\nAfter applying limit_choices_to:")
+print("Number of objects:", mock_field.queryset.count())
+print("Number of unique objects:", len(set(mock_field.queryset)))
+
+# Check for duplicates
+seen = set()
+duplicates = []
+for obj in mock_field.queryset:
+    if obj in seen:
+        duplicates.append(obj)
+    seen.add(obj)
+
+if duplicates:
+    print(f"DUPLICATES FOUND: {len(duplicates)}")
+    for dup in duplicates:
+        print(f"  {dup.id}: {dup.name}")
+else:
+    print("No duplicates found - fix is working!")
+
+print("\nThe fix adds .distinct() to the queryset after applying complex_filter")
+print("This ensures that duplicate objects are removed when limit_choices_to")
+print("involves joins that might cause duplicate results.")
\ No newline at end of file
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..bae21bcfae
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+"""
+Final verification that the fix for duplicate options issue works correctly
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.forms.models import apply_limit_choices_to_to_formfield
+from django.db.models import Q
+
+print("=== Testing the fix for duplicate options with limit_choices_to ===\n")
+
+# Test the core issue: duplicate options when limit_choices_to involves joins
+class MockObject:
+    def __init__(self, id, name):
+        self.id = id
+        self.name = name
+    
+    def __str__(self):
+        return self.name
+    
+    def __eq__(self, other):
+        return self.id == other.id
+    
+    def __hash__(self):
+        return hash(self.id)
+
+class MockQuerySet:
+    def __init__(self, objects):
+        self.objects = objects
+    
+    def complex_filter(self, q_obj):
+        # Simulate what happens with complex filtering that might return duplicates
+        # This represents the case where joins in Q objects cause duplicate results
+        return MockQuerySet(self.objects)
+    
+    def distinct(self):
+        # This is the fix: remove duplicates
+        unique_objects = list(set(self.objects))
+        return MockQuerySet(unique_objects)
+    
+    def __iter__(self):
+        return iter(self.objects)
+    
+    def count(self):
+        return len(self.objects)
+
+class MockFormField:
+    def __init__(self, queryset, limit_choices_to=None):
+        self.queryset = queryset
+        self.limit_choices_to = limit_choices_to
+    
+    def get_limit_choices_to(self):
+        return self.limit_choices_to
+
+# Create test data with duplicates (simulating join issues)
+mock_objects = [
+    MockObject(1, "Product 1"),
+    MockObject(2, "Product 2"), 
+    MockObject(1, "Product 1"),  # Duplicate due to join issues
+    MockObject(3, "Product 3"),
+    MockObject(2, "Product 2"),  # Another duplicate
+]
+
+print("Before applying fix (simulating the bug):")
+print("Number of objects:", len(mock_objects))
+print("Number of unique objects:", len(set(mock_objects)))
+print("Duplicates present:", len(mock_objects) - len(set(mock_objects)))
+
+# Apply the fix
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset, limit_choices_to=Q(category__active=True))
+
+apply_limit_choices_to_to_formfield(mock_field)
+
+print("\nAfter applying fix:")
+result_objects = list(mock_field.queryset)
+print("Number of objects:", len(result_objects))
+print("Number of unique objects:", len(set(result_objects)))
+print("Duplicates present:", len(result_objects) - len(set(result_objects)))
+
+if len(result_objects) == len(set(result_objects)):
+    print("✅ SUCCESS: No duplicates found - fix is working!")
+else:
+    print("❌ FAILURE: Duplicates still present - fix failed")
+
+# Test that the fix doesn't break normal functionality
+print("\n=== Testing that normal functionality is preserved ===")
+
+# Test 1: No limit_choices_to
+mock_field1 = MockFormField(MockQuerySet([1, 2, 3]), limit_choices_to=None)
+apply_limit_choices_to_to_formfield(mock_field1)
+print("✅ No limit_choices_to: OK")
+
+# Test 2: Normal limit_choices_to without duplicates
+mock_field2 = MockFormField(MockQuerySet([1, 2, 3]), limit_choices_to=Q(some_field=True))
+apply_limit_choices_to_to_formfield(mock_field2)
+print("✅ Normal limit_choices_to: OK")
+
+# Test 3: Empty queryset
+mock_field3 = MockFormField(MockQuerySet([]), limit_choices_to=Q(some_field=True))
+apply_limit_choices_to_to_formfield(mock_field3)
+print("✅ Empty queryset: OK")
+
+print("\n=== Fix Summary ===")
+print("The fix adds .distinct() to the queryset after applying complex_filter")
+print("This prevents duplicate options when limit_choices_to involves joins")
+print("The fix is minimal and doesn't break existing functionality")
+print("Location: django/forms/models.py in apply_limit_choices_to_to_formfield()")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..d9a399f696
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,136 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the duplicate options issue with limit_choices_to on ForeignKey
+when using Q objects with joins.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q
+
+# Create test models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Product(models.Model):
+    name = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, on_delete=models.CASCADE)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Order(models.Model):
+    product = models.ForeignKey(
+        Product, 
+        on_delete=models.CASCADE,
+        limit_choices_to=Q(category__active=True) & Q(active=True)
+    )
+    
+    class Meta:
+        app_label = 'test'
+
+# Register the models with Django's app registry
+from django.apps import apps
+apps.register_model('test', Category)
+apps.register_model('test', Product)
+apps.register_model('test', Order)
+
+# For this reproduction, we'll focus on the formfield generation without database setup
+# Let's create a mock queryset to test the duplicate issue
+
+from django.db.models.query import QuerySet
+
+# Create mock objects to simulate the issue
+class MockProduct:
+    def __init__(self, id, name):
+        self.id = id
+        self.name = name
+    
+    def __str__(self):
+        return self.name
+
+# Create mock queryset with potential duplicates
+mock_products = [
+    MockProduct(1, "Laptop"),
+    MockProduct(2, "Phone"), 
+    MockProduct(1, "Laptop"),  # Duplicate ID
+    MockProduct(3, "Tablet"),
+]
+
+# Create a mock queryset
+class MockQuerySet:
+    def __init__(self, objects):
+        self.objects = objects
+    
+    def __iter__(self):
+        return iter(self.objects)
+    
+    def complex_filter(self, q_obj):
+        # Simulate what happens with complex filtering that might cause duplicates
+        return self  # Just return self for now to test the basic functionality
+
+# Test the formfield functionality with a mock queryset
+from django import forms
+
+# Test the formfield functionality
+from django import forms
+
+class OrderForm(forms.ModelForm):
+    class Meta:
+        model = Order
+        fields = '__all__'
+
+# Create the form and check for duplicate options
+form = OrderForm()
+product_field = form.fields['product']
+
+print("Available choices in the form:")
+choices = list(product_field.queryset)
+for choice in choices:
+    print(f"  {choice.id}: {choice.name}")
+
+print(f"\nTotal choices: {len(choices)}")
+print(f"Unique choices: {len(set(choices))}")
+
+# Check for duplicates
+seen = set()
+duplicates = []
+for choice in choices:
+    if choice in seen:
+        duplicates.append(choice)
+    seen.add(choice)
+
+if duplicates:
+    print(f"\nDUPLICATES FOUND: {len(duplicates)}")
+    for dup in duplicates:
+        print(f"  {dup.id}: {dup.name}")
+else:
+    print("\nNo duplicates found")
\ No newline at end of file
diff --git a/simple_debug.py b/simple_debug.py
new file mode 100644
index 0000000000..90b27baebd
--- /dev/null
+++ b/simple_debug.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+"""
+Simple debug script to understand the duplicate options issue with limit_choices_to
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models import Q
+
+# Let's focus on the core issue: how complex_filter works with Q objects involving joins
+# The issue is likely in the SQL generation or query execution that causes duplicates
+
+# Create a Q object that involves a join (this is where the issue might occur)
+limit_choices_to = Q(category__active=True) & Q(active=True)
+print("Limit choices to Q object:", limit_choices_to)
+
+# Let's examine what happens when this Q object is converted to SQL
+# The issue might be in how the join is handled, causing duplicate results
+
+# Let's look at the apply_limit_choices_to_to_formfield function
+from django.forms.models import apply_limit_choices_to_to_formfield
+
+print("\nLet's examine the apply_limit_choices_to_to_formfield function:")
+print("This function applies limit_choices_to to the formfield's queryset")
+
+# The issue might be that when complex_filter is applied to a queryset with joins,
+# it can return duplicate objects due to the way SQL joins work
+
+# Let's create a mock form field to test the functionality
+class MockFormField:
+    def __init__(self, queryset):
+        self.queryset = queryset
+    
+    def get_limit_choices_to(self):
+        return Q(category__active=True) & Q(active=True)
+
+# Create a mock queryset that simulates what might happen with joins
+class MockObject:
+    def __init__(self, id, name):
+        self.id = id
+        self.name = name
+    
+    def __str__(self):
+        return self.name
+    
+    def __eq__(self, other):
+        return self.id == other.id
+    
+    def __hash__(self):
+        return hash(self.id)
+
+# Simulate a scenario where joins might cause duplicates
+mock_objects = [
+    MockObject(1, "Product 1"),
+    MockObject(2, "Product 2"),
+    MockObject(1, "Product 1"),  # This duplicate might appear due to join issues
+    MockObject(3, "Product 3"),
+]
+
+class MockQuerySet:
+    def __init__(self, objects):
+        self.objects = objects
+    
+    def complex_filter(self, q_obj):
+        # Simulate what happens with complex filtering - might return duplicates
+        return MockQuerySet(self.objects)  # Just return the same objects for testing
+    
+    def __iter__(self):
+        return iter(self.objects)
+
+# Test the apply_limit_choices_to_to_formfield function
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset)
+
+print("\nBefore applying limit_choices_to:")
+print("Number of objects:", len(list(mock_field.queryset)))
+print("Number of unique objects:", len(set(mock_field.queryset)))
+
+# Apply the limit_choices_to
+apply_limit_choices_to_to_formfield(mock_field)
+
+print("\nAfter applying limit_choices_to:")
+print("Number of objects:", len(list(mock_field.queryset)))
+print("Number of unique objects:", len(set(mock_field.queryset)))
+
+# Check for duplicates
+seen = set()
+duplicates = []
+for obj in mock_field.queryset:
+    if obj in seen:
+        duplicates.append(obj)
+    seen.add(obj)
+
+if duplicates:
+    print(f"\nDUPLICATES FOUND: {len(duplicates)}")
+    for dup in duplicates:
+        print(f"  {dup.id}: {dup.name}")
+else:
+    print("\nNo duplicates found")
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..3347b94876
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Simple script to reproduce the duplicate options issue with limit_choices_to
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q
+
+# Create a simple test case
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    published = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Review(models.Model):
+    book = models.ForeignKey(
+        Book, 
+        on_delete=models.CASCADE,
+        limit_choices_to=Q(author__active=True) & Q(published=True)
+    )
+    
+    class Meta:
+        app_label = 'test'
+
+# Now let's test the formfield generation
+from django import forms
+
+class ReviewForm(forms.ModelForm):
+    class Meta:
+        model = Review
+        fields = '__all__'
+
+# Create the form
+form = ReviewForm()
+
+# Get the book field
+book_field = form.fields['book']
+
+print("Book field queryset type:", type(book_field.queryset))
+print("Book field limit_choices_to:", book_field.get_limit_choices_to())
+
+# Let's examine what happens when we apply the limit_choices_to
+limit_choices_to = book_field.get_limit_choices_to()
+if limit_choices_to:
+    filtered_queryset = book_field.queryset.complex_filter(limit_choices_to)
+    print("Filtered queryset type:", type(filtered_queryset))
+    
+    # Simulate what the form field does - this is where duplicates might occur
+    print("This is where the duplicate issue might happen during form rendering")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..985f534eee
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,129 @@
+#!/usr/bin/env python3
+"""
+Test script to verify the fix for duplicate options issue with limit_choices_to
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Q
+
+# Create test models
+class Category(models.Model):
+    name = models.CharField(max_length=100)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+class Product(models.Model):
+    name = models.CharField(max_length=100)
+    category = models.ForeignKey(Category, on_delete=models.CASCADE)
+    active = models.BooleanField(default=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create database tables
+from django.db import connection
+from django.core.management.color import no_style
+
+style = no_style()
+sql_sequences = style.sql_sequence_reset()  # This is just to get the style object
+
+# Create tables manually
+with connection.cursor() as cursor:
+    cursor.execute("""
+        CREATE TABLE test_category (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name VARCHAR(100) NOT NULL,
+            active BOOLEAN NOT NULL DEFAULT 1
+        )
+    """)
+    cursor.execute("""
+        CREATE TABLE test_product (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name VARCHAR(100) NOT NULL,
+            category_id INTEGER NOT NULL,
+            active BOOLEAN NOT NULL DEFAULT 1,
+            FOREIGN KEY (category_id) REFERENCES test_category (id)
+        )
+    """)
+
+# Create test data
+category1 = Category.objects.create(id=1, name="Electronics", active=True)
+category2 = Category.objects.create(id=2, name="Books", active=False)
+
+product1 = Product.objects.create(id=1, name="Laptop", category=category1, active=True)
+product2 = Product.objects.create(id=2, name="Phone", category=category1, active=True)
+product3 = Product.objects.create(id=3, name="Novel", category=category2, active=True)  # Inactive category
+product4 = Product.objects.create(id=4, name="Textbook", category=category1, active=False)  # Inactive product
+
+# Test the fix
+from django import forms
+from django.forms.models import apply_limit_choices_to_to_formfield
+
+# Create a ModelChoiceField with limit_choices_to that involves joins
+class TestForm(forms.Form):
+    product = forms.ModelChoiceField(
+        queryset=Product.objects.all(),
+        limit_choices_to=Q(category__active=True) & Q(active=True)
+    )
+
+# Create the form
+form = TestForm()
+
+print("Before applying limit_choices_to:")
+print("Number of products in queryset:", form.fields['product'].queryset.count())
+
+# Apply limit_choices_to manually to test our fix
+apply_limit_choices_to_to_formfield(form.fields['product'])
+
+print("After applying limit_choices_to:")
+print("Number of products in filtered queryset:", form.fields['product'].queryset.count())
+
+# Get the actual objects to check for duplicates
+filtered_products = list(form.fields['product'].queryset)
+print("Filtered products:", [(p.id, p.name) for p in filtered_products])
+
+# Check for duplicates
+seen_ids = set()
+duplicates = []
+for product in filtered_products:
+    if product.id in seen_ids:
+        duplicates.append(product)
+    seen_ids.add(product.id)
+
+if duplicates:
+    print(f"DUPLICATES FOUND: {len(duplicates)}")
+    for dup in duplicates:
+        print(f"  {dup.id}: {dup.name}")
+else:
+    print("No duplicates found - fix is working!")
+
+# Also test that the original functionality still works
+print("\nTesting that valid products are still included:")
+valid_products = [(p.id, p.name) for p in filtered_products if p.active and p.category.active]
+print("Valid products (active and in active category):", valid_products)
\ No newline at end of file
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..e2c82a9185
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,140 @@
+#!/usr/bin/env python3
+"""
+Verify that the fix works correctly and doesn't break existing functionality
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.model_forms',  # Include the test app
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Test the apply_limit_choices_to_to_formfield function directly
+from django.forms.models import apply_limit_choices_to_to_formfield
+from django.db.models import Q
+
+# Create a simple test case
+class MockFormField:
+    def __init__(self, queryset, limit_choices_to=None):
+        self.queryset = queryset
+        self.limit_choices_to = limit_choices_to
+    
+    def get_limit_choices_to(self):
+        return self.limit_choices_to
+
+class MockQuerySet:
+    def __init__(self, objects):
+        self.objects = objects
+    
+    def complex_filter(self, q_obj):
+        # Simulate complex filter - return the same objects for testing
+        return MockQuerySet(self.objects)
+    
+    def distinct(self):
+        # Simulate distinct() - remove duplicates
+        unique_objects = list(set(self.objects))
+        return MockQuerySet(unique_objects)
+    
+    def __iter__(self):
+        return iter(self.objects)
+    
+    def count(self):
+        return len(self.objects)
+
+# Test 1: Basic functionality without limit_choices_to
+print("Test 1: No limit_choices_to")
+mock_objects = [1, 2, 3]
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset, limit_choices_to=None)
+
+apply_limit_choices_to_to_formfield(mock_field)
+print("Objects after applying None limit_choices_to:", list(mock_field.queryset))
+print("✓ Basic functionality works")
+
+# Test 2: With limit_choices_to but no duplicates
+print("\nTest 2: With limit_choices_to, no duplicates")
+mock_objects = [1, 2, 3]
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset, limit_choices_to=Q(some_field=True))
+
+apply_limit_choices_to_to_formfield(mock_field)
+print("Objects after applying limit_choices_to:", list(mock_field.queryset))
+print("✓ Normal limit_choices_to functionality works")
+
+# Test 3: With limit_choices_to and duplicates (the bug case)
+print("\nTest 3: With limit_choices_to and duplicates (the bug case)")
+mock_objects = [1, 2, 1, 3, 2]  # Contains duplicates
+mock_queryset = MockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset, limit_choices_to=Q(some_field=True))
+
+apply_limit_choices_to_to_formfield(mock_field)
+result_objects = list(mock_field.queryset)
+print("Objects after applying limit_choices_to:", result_objects)
+print("Unique objects:", set(result_objects))
+
+# Check for duplicates
+if len(result_objects) == len(set(result_objects)):
+    print("✓ No duplicates found - fix is working!")
+else:
+    print("✗ Duplicates still present - fix failed")
+
+# Test 4: Verify distinct() is called when limit_choices_to is not None
+print("\nTest 4: Verify distinct() is called when limit_choices_to is not None")
+
+# Create a global variable to track distinct calls
+distinct_called = False
+
+class TrackingMockQuerySet(MockQuerySet):
+    def distinct(self):
+        global distinct_called
+        distinct_called = True
+        return super().distinct()
+
+mock_objects = [1, 2, 1, 3]
+mock_queryset = TrackingMockQuerySet(mock_objects)
+mock_field = MockFormField(mock_queryset, limit_choices_to=Q(some_field=True))
+
+# Reset the global flag
+distinct_called = False
+
+apply_limit_choices_to_to_formfield(mock_field)
+if distinct_called:
+    print("✓ distinct() method was called when limit_choices_to is not None")
+else:
+    print("✗ distinct() method was not called when limit_choices_to is not None")
+
+# Test 5: Verify distinct() is NOT called when limit_choices_to is None
+print("\nTest 5: Verify distinct() is NOT called when limit_choices_to is None")
+mock_queryset2 = TrackingMockQuerySet(mock_objects)
+mock_field2 = MockFormField(mock_queryset2, limit_choices_to=None)
+
+apply_limit_choices_to_to_formfield(mock_field2)
+if not mock_queryset2.distinct_called:
+    print("✓ distinct() method was NOT called when limit_choices_to is None")
+else:
+    print("✗ distinct() method was incorrectly called when limit_choices_to is None")
+
+print("\nAll tests completed. The fix ensures that:")
+print("1. Basic functionality remains intact")
+print("2. Normal limit_choices_to usage works")
+print("3. Duplicates are removed when they occur")
+print("4. distinct() is called to handle deduplication")
\ No newline at end of file