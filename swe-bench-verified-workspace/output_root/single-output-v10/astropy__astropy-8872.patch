diff --git a/astropy/units/core.py b/astropy/units/core.py
index 288c528be4..7f8dbd04b7 100644
--- a/astropy/units/core.py
+++ b/astropy/units/core.py
@@ -696,7 +696,11 @@ class UnitBase(metaclass=InheritDocstrings):
         # Cannot handle this as Unit, re-try as Quantity.
         try:
             from .quantity import Quantity
-            return Quantity(1, self) * m
+            # Preserve the dtype of the multiplier
+            if hasattr(m, 'dtype'):
+                return Quantity(m, self)
+            else:
+                return Quantity(1, self) * m
         except TypeError:
             return NotImplemented
 
diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py
index ded609cbe9..0fe292b377 100644
--- a/astropy/units/quantity.py
+++ b/astropy/units/quantity.py
@@ -380,7 +380,9 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
         if dtype is None and (not (np.can_cast(np.float32, value.dtype)
                                    or value.dtype.fields)
                               or value.dtype.kind == 'O'):
-            value = value.astype(float)
+            # Don't cast if the input is already a float type
+            if value.dtype.kind != 'f':
+                value = value.astype(float)
 
         value = value.view(cls)
         value._set_unit(value_unit)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c8ebeba3b0
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import astropy.units as u
+
+print("Testing float16 dtype preservation in Quantity operations...")
+
+# Test the issue: float16 gets upgraded to float64
+float16_val = np.float16(1)
+print(f"Original float16 value: {float16_val}, dtype: {float16_val.dtype}")
+
+quantity_float16 = float16_val * u.km
+print(f"Quantity from float16: {quantity_float16}, dtype: {quantity_float16.dtype}")
+
+# Test other float types to confirm they work correctly
+print("\nTesting other float types:")
+for float_type in [np.float32, np.float64, np.float128]:
+    val = float_type(1)
+    quantity = val * u.km
+    print(f"{float_type.__name__}: {val} -> {quantity}, dtype: {quantity.dtype}")
+
+# Test numpy's float_ as well
+print("\nTesting numpy float_:")
+val = np.float_(1)
+quantity = val * u.km
+print(f"np.float_: {val} -> {quantity}, dtype: {quantity.dtype}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d4df7f2bbb
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import astropy.units as u
+
+print("Testing edge cases to ensure no regressions:")
+
+# Test integer types (should still be cast to float64)
+int_val = 1
+quantity_int = int_val * u.km
+print(f"int: {int_val} -> {quantity_int}, dtype: {quantity_int.dtype}")
+
+# Test numpy integer types
+int32_val = np.int32(1)
+quantity_int32 = int32_val * u.km
+print(f"int32: {int32_val} -> {quantity_int32}, dtype: {quantity_int32.dtype}")
+
+# Test boolean types (should still be cast to float64)
+bool_val = True
+quantity_bool = bool_val * u.km
+print(f"bool: {bool_val} -> {quantity_bool}, dtype: {quantity_bool.dtype}")
+
+# Test numpy boolean types
+bool_val_np = np.bool_(True)
+quantity_bool_np = bool_val_np * u.km
+print(f"np.bool_: {bool_val_np} -> {quantity_bool_np}, dtype: {quantity_bool_np.dtype}")
+
+# Test complex types
+complex_val = np.complex64(1+2j)
+quantity_complex = complex_val * u.km
+print(f"complex64: {complex_val} -> {quantity_complex}, dtype: {quantity_complex.dtype}")
+
+# Test with explicit dtype parameter
+float16_val = np.float16(1)
+quantity_explicit = u.Quantity(float16_val, u.km, dtype=np.float32)
+print(f"float16 with explicit float32 dtype: {quantity_explicit}, dtype: {quantity_explicit.dtype}")
\ No newline at end of file
diff --git a/test_quantity_creation.py b/test_quantity_creation.py
new file mode 100644
index 0000000000..f19de65c62
--- /dev/null
+++ b/test_quantity_creation.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import astropy.units as u
+
+print("Testing Quantity creation with different dtypes:")
+
+# Test creating Quantity directly with float16
+float16_val = np.float16(1)
+quantity_direct = u.Quantity(float16_val, u.km)
+print(f"Direct Quantity creation with float16: {quantity_direct}, dtype: {quantity_direct.dtype}")
+
+# Test multiplication path
+unit = u.km
+quantity_from_unit = u.Quantity(1, unit) * float16_val
+print(f"Quantity from unit multiplication: {quantity_from_unit}, dtype: {quantity_from_unit.dtype}")
+
+# Test the reverse multiplication
+quantity_reverse = float16_val * u.Quantity(1, unit)
+print(f"Reverse multiplication: {quantity_reverse}, dtype: {quantity_reverse.dtype}")
\ No newline at end of file
diff --git a/test_rmul.py b/test_rmul.py
new file mode 100644
index 0000000000..3b4089c32d
--- /dev/null
+++ b/test_rmul.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+import numpy as np
+import astropy.units as u
+
+print("Testing __rmul__ specifically:")
+
+# Test the reverse multiplication path (float16 * unit)
+float16_val = np.float16(1)
+unit = u.km
+
+# This should call unit.__rmul__(float16_val)
+result = float16_val * unit
+print(f"float16 * unit: {result}, dtype: {result.dtype}")
+
+# Test the forward multiplication path (unit * float16)
+# This should call unit.__mul__(float16_val)
+result2 = unit * float16_val
+print(f"unit * float16: {result2}, dtype: {result2.dtype}")
\ No newline at end of file