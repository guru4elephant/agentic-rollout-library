diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..50db71def9
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,160 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for the get_FOO_display() fix
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_original_issue():
+    """Test the original issue from the GitHub report"""
+    class FooBar(models.Model):
+        foo_bar = models.CharField("foo", choices=[(1, 'foo'), (2, 'bar')])
+        
+        class Meta:
+            app_label = 'test'
+        
+        def __str__(self):
+            return self.get_foo_bar_display()
+        
+        def get_foo_bar_display(self):
+            return "something"
+    
+    instance = FooBar(foo_bar=1)
+    result = instance.get_foo_bar_display()
+    expected = "something"
+    
+    print(f"Original issue test: '{result}'")
+    if result == expected:
+        print("‚úÖ SUCCESS: Original issue is fixed!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected '{expected}', got '{result}'")
+        return False
+
+def test_normal_behavior():
+    """Test that normal get_FOO_display() behavior still works"""
+    class NormalModel(models.Model):
+        choice_field = models.CharField("Choice", choices=[('a', 'Alpha'), ('b', 'Beta')])
+        
+        class Meta:
+            app_label = 'test'
+    
+    instance = NormalModel(choice_field='a')
+    result = instance.get_choice_field_display()
+    expected = "Alpha"
+    
+    print(f"Normal behavior test: '{result}'")
+    if result == expected:
+        print("‚úÖ SUCCESS: Normal behavior works!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected '{expected}', got '{result}'")
+        return False
+
+def test_inheritance():
+    """Test that inheritance works correctly"""
+    class BaseModel(models.Model):
+        base_choice = models.CharField("Base", choices=[(1, 'Base1'), (2, 'Base2')])
+        
+        class Meta:
+            app_label = 'test'
+        
+        def get_base_choice_display(self):
+            return "CUSTOM_BASE"
+    
+    class DerivedModel(BaseModel):
+        derived_choice = models.CharField("Derived", choices=[(3, 'Derived3'), (4, 'Derived4')])
+        
+        class Meta:
+            app_label = 'test'
+        
+        def get_derived_choice_display(self):
+            return "CUSTOM_DERIVED"
+    
+    base_instance = BaseModel(base_choice=1)
+    derived_instance = DerivedModel(base_choice=1, derived_choice=3)
+    
+    base_result = base_instance.get_base_choice_display()
+    derived_base_result = derived_instance.get_base_choice_display()
+    derived_result = derived_instance.get_derived_choice_display()
+    
+    print(f"Inheritance test: Base='{base_result}', DerivedBase='{derived_base_result}', Derived='{derived_result}'")
+    
+    if (base_result == "CUSTOM_BASE" and 
+        derived_base_result == "CUSTOM_BASE" and 
+        derived_result == "CUSTOM_DERIVED"):
+        print("‚úÖ SUCCESS: Inheritance works correctly!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Inheritance test failed")
+        return False
+
+def test_edge_case_nonexistent_method():
+    """Test that non-existent methods don't cause issues"""
+    class SimpleModel(models.Model):
+        simple_field = models.CharField("Simple", choices=[(1, 'One'), (2, 'Two')])
+        
+        class Meta:
+            app_label = 'test'
+    
+    instance = SimpleModel(simple_field=1)
+    
+    # This should work normally
+    try:
+        result = instance.get_simple_field_display()
+        print(f"Non-existent method test: '{result}'")
+        if result == "One":
+            print("‚úÖ SUCCESS: Non-existent method handled correctly!")
+            return True
+        else:
+            print(f"‚ùå FAILURE: Expected 'One', got '{result}'")
+            return False
+    except AttributeError:
+        print("‚ùå FAILURE: Method should exist but doesn't")
+        return False
+
+if __name__ == "__main__":
+    print("Running comprehensive tests for get_FOO_display() fix...")
+    
+    tests = [
+        test_original_issue,
+        test_normal_behavior,
+        test_inheritance,
+        test_edge_case_nonexistent_method,
+    ]
+    
+    results = []
+    for test in tests:
+        results.append(test())
+        print()
+    
+    if all(results):
+        print("üéâ ALL COMPREHENSIVE TESTS PASSED!")
+        sys.exit(0)
+    else:
+        print("üí• SOME COMPREHENSIVE TESTS FAILED!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index ee45bb941e..b2a1c4f6e9 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -763,8 +763,10 @@ class Field(RegisterLookupMixin):
             if not getattr(cls, self.attname, None):
                 setattr(cls, self.attname, self.descriptor_class(self))
         if self.choices is not None:
-            setattr(cls, 'get_%s_display' % self.name,
-                    partialmethod(cls._get_FIELD_display, field=self))
+            # Don't override custom get_FOO_display() methods
+            if not getattr(cls, 'get_%s_display' % self.name, None):
+                setattr(cls, 'get_%s_display' % self.name,
+                        partialmethod(cls._get_FIELD_display, field=self))
 
     def get_filter_kwargs_for_object(self, obj):
         """
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..001f7af766
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python3
+"""
+Final verification that the fix doesn't break existing Django functionality
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_basic_model_operations():
+    """Test that basic model operations still work"""
+    class TestModel(models.Model):
+        name = models.CharField(max_length=100)
+        status = models.CharField(max_length=10, choices=[('active', 'Active'), ('inactive', 'Inactive')])
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Test model creation
+    instance = TestModel(name="Test", status="active")
+    
+    # Test that get_FOO_display works normally
+    display_result = instance.get_status_display()
+    print(f"Basic model test - get_status_display(): '{display_result}'")
+    
+    # Test that the method exists and works
+    if display_result == "Active":
+        print("‚úÖ SUCCESS: Basic model operations work!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected 'Active', got '{display_result}'")
+        return False
+
+def test_custom_method_preserved():
+    """Test that custom methods are preserved"""
+    class CustomModel(models.Model):
+        category = models.CharField(max_length=10, choices=[('a', 'Category A'), ('b', 'Category B')])
+        
+        class Meta:
+            app_label = 'test'
+        
+        def get_category_display(self):
+            return "CUSTOM_CATEGORY"
+    
+    instance = CustomModel(category="a")
+    result = instance.get_category_display()
+    print(f"Custom method test: '{result}'")
+    
+    if result == "CUSTOM_CATEGORY":
+        print("‚úÖ SUCCESS: Custom method preserved!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected 'CUSTOM_CATEGORY', got '{result}'")
+        return False
+
+if __name__ == "__main__":
+    print("Running final verification tests...")
+    
+    success1 = test_basic_model_operations()
+    success2 = test_custom_method_preserved()
+    
+    if success1 and success2:
+        print("\nüéâ FINAL VERIFICATION PASSED!")
+        print("The fix successfully resolves the issue without breaking existing functionality.")
+        sys.exit(0)
+    else:
+        print("\nüí• FINAL VERIFICATION FAILED!")
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..e5e62219c2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the get_FOO_display() override issue in Django 2.2+
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create a test model
+class FooBar(models.Model):
+    foo_bar = models.CharField("foo", choices=[(1, 'foo'), (2, 'bar')])
+    
+    class Meta:
+        app_label = 'test'
+    
+    def __str__(self):
+        return self.get_foo_bar_display()  # This should return 'something' but returns 'foo' or 'bar'
+    
+    def get_foo_bar_display(self):
+        return "something"
+
+# Test the behavior
+def test_get_foo_bar_display():
+    # Create an instance
+    instance = FooBar(foo_bar=1)
+    
+    # Test the method
+    result = instance.get_foo_bar_display()
+    print(f"get_foo_bar_display() returned: '{result}'")
+    print(f"Expected: 'something'")
+    
+    if result == "something":
+        print("‚úÖ SUCCESS: Custom get_foo_bar_display() method is working!")
+        return True
+    else:
+        print("‚ùå FAILURE: Custom get_foo_bar_display() method was overridden!")
+        return False
+
+if __name__ == "__main__":
+    success = test_get_foo_bar_display()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..b2a5bc2672
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+"""
+Script to test edge cases for the get_FOO_display() fix
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test Case 1: Normal behavior without custom method
+class TestModel1(models.Model):
+    choice_field = models.CharField("Choice", choices=[(1, 'First'), (2, 'Second')])
+    
+    class Meta:
+        app_label = 'test'
+
+# Test Case 2: Custom method that should be preserved
+class TestModel2(models.Model):
+    choice_field = models.CharField("Choice", choices=[(1, 'First'), (2, 'Second')])
+    
+    class Meta:
+        app_label = 'test'
+    
+    def get_choice_field_display(self):
+        return "CUSTOM_DISPLAY"
+
+# Test Case 3: Multiple choice fields with custom methods
+class TestModel3(models.Model):
+    choice_field1 = models.CharField("Choice 1", choices=[(1, 'First'), (2, 'Second')])
+    choice_field2 = models.CharField("Choice 2", choices=[('a', 'Alpha'), ('b', 'Beta')])
+    
+    class Meta:
+        app_label = 'test'
+    
+    def get_choice_field1_display(self):
+        return "CUSTOM_1"
+    
+    def get_choice_field2_display(self):
+        return "CUSTOM_2"
+
+def test_case_1():
+    """Test normal behavior without custom method"""
+    instance = TestModel1(choice_field=1)
+    result = instance.get_choice_field_display()
+    print(f"Test Case 1 - Normal behavior: '{result}'")
+    expected = "First"
+    if result == expected:
+        print("‚úÖ SUCCESS: Normal get_FOO_display() method works!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected '{expected}', got '{result}'")
+        return False
+
+def test_case_2():
+    """Test custom method preservation"""
+    instance = TestModel2(choice_field=1)
+    result = instance.get_choice_field_display()
+    print(f"Test Case 2 - Custom method: '{result}'")
+    expected = "CUSTOM_DISPLAY"
+    if result == expected:
+        print("‚úÖ SUCCESS: Custom get_FOO_display() method preserved!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected '{expected}', got '{result}'")
+        return False
+
+def test_case_3():
+    """Test multiple custom methods"""
+    instance = TestModel3(choice_field1=1, choice_field2='a')
+    result1 = instance.get_choice_field1_display()
+    result2 = instance.get_choice_field2_display()
+    print(f"Test Case 3 - Multiple custom methods: '{result1}', '{result2}'")
+    expected1 = "CUSTOM_1"
+    expected2 = "CUSTOM_2"
+    if result1 == expected1 and result2 == expected2:
+        print("‚úÖ SUCCESS: Multiple custom get_FOO_display() methods preserved!")
+        return True
+    else:
+        print(f"‚ùå FAILURE: Expected '{expected1}' and '{expected2}', got '{result1}' and '{result2}'")
+        return False
+
+if __name__ == "__main__":
+    print("Testing edge cases for get_FOO_display() fix...")
+    
+    success1 = test_case_1()
+    success2 = test_case_2()  
+    success3 = test_case_3()
+    
+    if success1 and success2 and success3:
+        print("\nüéâ ALL TESTS PASSED!")
+        sys.exit(0)
+    else:
+        print("\nüí• SOME TESTS FAILED!")
+        sys.exit(1)
\ No newline at end of file