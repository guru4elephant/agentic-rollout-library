diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..337c4e011a
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+
+# Test case 1: models.Model in bases parameter (the original issue)
+class TestMigration1(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=(models.Model,),
+        ),
+    ]
+
+# Test case 2: models.Model in a tuple with other bases
+class TestMigration2(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=('app.models.MyMixin', models.Model),
+        ),
+    ]
+
+# Test case 3: Single models.Model base
+class TestMigration3(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=(models.Model,),
+        ),
+    ]
+
+def test_migration(migration_class, test_name):
+    print(f"\n=== {test_name} ===")
+    try:
+        migration = migration_class('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        # Check if models is properly imported
+        if 'models.Model' in migration_content:
+            if 'from django.db import migrations, models' in migration_content or 'import models' in migration_content:
+                print("SUCCESS: models is properly imported")
+                return True
+            else:
+                print("FAIL: models.Model is used but not imported")
+                print("Migration content:")
+                print(migration_content)
+                return False
+        else:
+            print("SKIP: models.Model not used in this migration")
+            return True
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run all tests
+results = []
+results.append(test_migration(TestMigration1, "models.Model in bases parameter"))
+results.append(test_migration(TestMigration2, "models.Model in tuple with other bases"))
+results.append(test_migration(TestMigration3, "Single models.Model base"))
+
+print(f"\n=== SUMMARY ===")
+print(f"Passed: {sum(results)}/{len(results)}")
+if all(results):
+    print("All tests passed! The fix is working correctly.")
+else:
+    print("Some tests failed. The fix needs more work.")
\ No newline at end of file
diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index e19c881cda..072a2efc14 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -273,7 +273,7 @@ class TupleSerializer(BaseSequenceSerializer):
 class TypeSerializer(BaseSerializer):
     def serialize(self):
         special_cases = [
-            (models.Model, "models.Model", []),
+            (models.Model, "models.Model", ["from django.db import models"]),
             (type(None), 'type(None)', []),
         ]
         for case, string, imports in special_cases:
diff --git a/explicit_bases_test.py b/explicit_bases_test.py
new file mode 100644
index 0000000000..2ff696a576
--- /dev/null
+++ b/explicit_bases_test.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+
+# Test case: Explicitly set bases to include models.Model
+class TestMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=(models.Model,),  # Explicitly set bases
+        ),
+    ]
+
+def test_migration():
+    print("Testing explicit models.Model usage...")
+    try:
+        migration = TestMigration('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if models is properly imported
+        if 'models.Model' in migration_content:
+            if 'from django.db import migrations, models' in migration_content or 'import models' in migration_content:
+                print("SUCCESS: models is properly imported")
+                return True
+            else:
+                print("FAIL: models.Model is used but not imported")
+                return False
+        else:
+            print("FAIL: models.Model should be used but wasn't")
+            return False
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run test
+result = test_migration()
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/force_models_test.py b/force_models_test.py
new file mode 100644
index 0000000000..f5cd4c29ee
--- /dev/null
+++ b/force_models_test.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+from django.db.migrations.operations.models import CreateModel
+
+# Create a custom operation that forces models.Model to be used
+class CustomCreateModel(CreateModel):
+    def __init__(self, *args, **kwargs):
+        # Force bases to include models.Model
+        kwargs['bases'] = (models.Model,)
+        super().__init__(*args, **kwargs)
+
+# Test case: Force models.Model to be used
+class TestMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        CustomCreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+        ),
+    ]
+
+def test_migration():
+    print("Testing forced models.Model usage...")
+    try:
+        migration = TestMigration('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if models is properly imported
+        if 'models.Model' in migration_content:
+            if 'from django.db import migrations, models' in migration_content or 'import models' in migration_content:
+                print("SUCCESS: models is properly imported")
+                return True
+            else:
+                print("FAIL: models.Model is used but not imported")
+                return False
+        else:
+            print("FAIL: models.Model should be used but wasn't")
+            return False
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run test
+result = test_migration()
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/github_issue_test.py b/github_issue_test.py
new file mode 100644
index 0000000000..88fd825368
--- /dev/null
+++ b/github_issue_test.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+
+# Create a mixin class like in the GitHub issue
+class MyMixin:
+    pass
+
+# Recreate the exact scenario from the GitHub issue
+class TestMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', 'app.models.MyField(primary_key=True, serialize=False)'),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=('app.models.MyMixin', models.Model),  # This is the exact pattern from the issue
+        ),
+    ]
+
+def test_migration():
+    print("Testing GitHub issue scenario...")
+    try:
+        migration = TestMigration('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if the migration would cause a NameError
+        if 'models.Model' in migration_content:
+            if 'from django.db import migrations, models' in migration_content:
+                print("SUCCESS: models is properly imported via combined import")
+                # Try to import the migration to verify it works
+                try:
+                    # Create a simple test module
+                    test_module_content = migration_content.replace('app.models.MyField', 'models.CharField').replace('app.models.MyMixin', '__main__.MyMixin')
+                    exec(test_module_content, {'__name__': '__main__', 'MyMixin': MyMixin})
+                    print("SUCCESS: Migration can be imported without NameError")
+                    return True
+                except NameError as e:
+                    if 'models' in str(e):
+                        print(f"FAIL: NameError still occurs: {e}")
+                        return False
+                    else:
+                        print(f"Other NameError (not related to models): {e}")
+                        return False
+                except Exception as e:
+                    print(f"Other error during import: {e}")
+                    return False
+            else:
+                print("FAIL: models.Model is used but not imported")
+                return False
+        else:
+            print("INFO: models.Model not used in this migration (optimized away)")
+            return True
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run test
+result = test_migration()
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/mixed_bases_test.py b/mixed_bases_test.py
new file mode 100644
index 0000000000..dc8171c392
--- /dev/null
+++ b/mixed_bases_test.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+
+# Create a simple mixin class
+class MyMixin:
+    pass
+
+# Test case: Use a mixin + models.Model in bases
+class TestMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=(MyMixin, models.Model),  # Mixin + models.Model
+        ),
+    ]
+
+def test_migration():
+    print("Testing mixed bases with models.Model...")
+    try:
+        migration = TestMigration('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if models is properly imported
+        if 'models.Model' in migration_content:
+            if 'from django.db import migrations, models' in migration_content or 'import models' in migration_content:
+                print("SUCCESS: models is properly imported")
+                return True
+            else:
+                print("FAIL: models.Model is used but not imported")
+                return False
+        else:
+            print("FAIL: models.Model should be used but wasn't")
+            return False
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run test
+result = test_migration()
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/no_models_test.py b/no_models_test.py
new file mode 100644
index 0000000000..6027d01466
--- /dev/null
+++ b/no_models_test.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+
+# Test case: Migration without models.Model in bases
+class TestMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'abstract': False,
+            },
+            # No bases parameter - should use default (models.Model) but be optimized away
+        ),
+    ]
+
+def test_migration():
+    print("Testing migration without explicit models.Model usage...")
+    try:
+        migration = TestMigration('0001_initial', 'app')
+        writer = MigrationWriter(migration)
+        migration_content = writer.as_string()
+        
+        print("Generated migration content:")
+        print(migration_content)
+        
+        # Check if models import is present (it should be for the fields)
+        has_models_import = 'from django.db import migrations, models' in migration_content or 'import models' in migration_content
+        
+        if has_models_import:
+            print("SUCCESS: models import is present (needed for fields)")
+        else:
+            print("INFO: models import not present (not needed)")
+            
+        # Check if models.Model is used (it shouldn't be since it's optimized away)
+        has_models_model = 'models.Model' in migration_content
+        if has_models_model:
+            print("WARNING: models.Model is present but shouldn't be")
+        else:
+            print("SUCCESS: models.Model is optimized away as expected")
+            
+        return True
+            
+    except Exception as e:
+        print(f"ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+# Run test
+result = test_migration()
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..75b7671206
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,145 @@
+#!/usr/bin/env python3
+import os
+import sys
+import tempfile
+import shutil
+from pathlib import Path
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Set up a temporary Django project
+temp_dir = tempfile.mkdtemp()
+print(f"Creating test project in: {temp_dir}")
+
+# Create the directory structure
+project_dir = os.path.join(temp_dir, 'test_project')
+app_dir = os.path.join(project_dir, 'app')
+migrations_dir = os.path.join(app_dir, 'migrations')
+
+os.makedirs(project_dir)
+os.makedirs(app_dir)
+os.makedirs(migrations_dir)
+
+# Create __init__.py files
+with open(os.path.join(project_dir, '__init__.py'), 'w') as f:
+    f.write('')
+with open(os.path.join(app_dir, '__init__.py'), 'w') as f:
+    f.write('')
+with open(os.path.join(migrations_dir, '__init__.py'), 'w') as f:
+    f.write('')
+
+# Create models.py with the problematic content
+models_content = '''from django.db import models
+
+class MyField(models.TextField):
+    pass
+
+class MyBaseModel(models.Model):
+    class Meta:
+        abstract = True
+
+class MyMixin:
+    pass
+
+class MyModel(MyMixin, MyBaseModel):
+    name = MyField(primary_key=True)
+'''
+
+with open(os.path.join(app_dir, 'models.py'), 'w') as f:
+    f.write(models_content)
+
+# Create settings.py
+settings_content = '''import os
+
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+SECRET_KEY = 'test-secret-key'
+DEBUG = True
+
+INSTALLED_APPS = [
+    'django.contrib.auth',
+    'django.contrib.contenttypes',
+    'app',
+]
+
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
+    }
+}
+
+USE_TZ = False
+'''
+
+with open(os.path.join(project_dir, 'settings.py'), 'w') as f:
+    f.write(settings_content)
+
+# Create manage.py
+manage_content = '''#!/usr/bin/env python
+import os
+import sys
+
+if __name__ == "__main__":
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")
+    
+    # Add the current directory to Python path
+    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+    
+    from django.core.management import execute_from_command_line
+    
+    execute_from_command_line(sys.argv)
+'''
+
+with open(os.path.join(project_dir, 'manage.py'), 'w') as f:
+    f.write(manage_content)
+    os.chmod(os.path.join(project_dir, 'manage.py'), 0o755)
+
+# Change to the project directory and run makemigrations
+original_cwd = os.getcwd()
+os.chdir(project_dir)
+
+try:
+    print("Running makemigrations...")
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_project.settings")
+    
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(['manage.py', 'makemigrations', 'app'])
+    
+    # Check if migration file was created
+    migration_files = list(Path(migrations_dir).glob('*.py'))
+    if migration_files:
+        print(f"Migration file created: {migration_files[0]}")
+        
+        # Read and display the migration content
+        with open(migration_files[0], 'r') as f:
+            migration_content = f.read()
+            print("Migration content:")
+            print(migration_content)
+            
+            # Try to import the migration to see if it has the NameError
+            try:
+                # Add migrations directory to path
+                sys.path.insert(0, app_dir)
+                migration_module_name = f"app.migrations.{migration_files[0].stem}"
+                import importlib
+                importlib.import_module(migration_module_name)
+                print("SUCCESS: Migration imported without errors!")
+            except NameError as e:
+                print(f"ERROR: {e}")
+                print("This confirms the bug exists.")
+            except Exception as e:
+                print(f"Other error during import: {e}")
+    else:
+        print("No migration files were created")
+        
+except Exception as e:
+    print(f"Error running makemigrations: {e}")
+    import traceback
+    traceback.print_exc()
+
+finally:
+    os.chdir(original_cwd)
+    # Clean up
+    shutil.rmtree(temp_dir)
+    print(f"Cleaned up temporary directory: {temp_dir}")
\ No newline at end of file
diff --git a/simple_reproduce.py b/simple_reproduce.py
new file mode 100644
index 0000000000..54a68882f3
--- /dev/null
+++ b/simple_reproduce.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+import os
+import sys
+
+# Add the current directory to Python path
+sys.path.insert(0, '.')
+
+# Configure Django settings
+from django.conf import settings
+if not settings.configured:
+    settings.configure(
+        USE_TZ=False,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+
+from django.db import migrations, models
+from django.db.migrations.writer import MigrationWriter
+from django.db.migrations.operations.models import CreateModel
+
+# Simulate the problematic migration structure
+class MockMigration(migrations.Migration):
+    initial = True
+    dependencies = []
+    
+    operations = [
+        migrations.CreateModel(
+            name='MyModel',
+            fields=[
+                ('name', 'app.models.MyField(primary_key=True, serialize=False)'),
+            ],
+            options={
+                'abstract': False,
+            },
+            bases=('app.models.MyMixin', models.Model),
+        ),
+    ]
+
+# Create a mock migration instance
+migration = MockMigration('0001_initial', 'app')
+
+# Try to write the migration
+try:
+    writer = MigrationWriter(migration)
+    migration_content = writer.as_string()
+    print("Generated migration content:")
+    print(migration_content)
+    
+    # Try to check if 'models' is imported
+    if 'models.Model' in migration_content and ('from django.db import models' not in migration_content and 'import models' not in migration_content and 'migrations, models' not in migration_content):
+        print("\nERROR: 'models' is not imported in the migration!")
+        print("This is the bug we need to fix.")
+    else:
+        print("\nSUCCESS: 'models' is properly imported.")
+        
+except Exception as e:
+    print(f"Error generating migration: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file