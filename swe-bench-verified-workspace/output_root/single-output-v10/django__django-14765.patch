diff --git a/django/db/migrations/state.py b/django/db/migrations/state.py
index 088f5c41f0..1d30c7a20d 100644
--- a/django/db/migrations/state.py
+++ b/django/db/migrations/state.py
@@ -92,7 +92,8 @@ class ProjectState:
         self.models = models or {}
         # Apps to include from main registry, usually unmigrated ones
         if real_apps:
-            self.real_apps = real_apps if isinstance(real_apps, set) else set(real_apps)
+            assert isinstance(real_apps, set), "real_apps must be a set"
+            self.real_apps = real_apps
         else:
             self.real_apps = set()
         self.is_delayed = False
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..5fcbc1f613
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test to verify the ProjectState real_apps fix.
+"""
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.migrations.state import ProjectState
+
+def test_comprehensive():
+    """Comprehensive test of the ProjectState real_apps fix."""
+    
+    print("Running comprehensive ProjectState real_apps test...")
+    
+    # Test 1: None should work (creates empty set)
+    print("\n1. Testing real_apps=None:")
+    state = ProjectState(real_apps=None)
+    assert state.real_apps == set(), f"Expected empty set, got {state.real_apps}"
+    print("   âœ“ PASS: None creates empty set")
+    
+    # Test 2: Empty set should work
+    print("\n2. Testing real_apps=set():")
+    state = ProjectState(real_apps=set())
+    assert state.real_apps == set(), f"Expected empty set, got {state.real_apps}"
+    print("   âœ“ PASS: Empty set works")
+    
+    # Test 3: Non-empty set should work
+    print("\n3. Testing real_apps={'app1', 'app2'}:")
+    state = ProjectState(real_apps={'app1', 'app2'})
+    assert state.real_apps == {'app1', 'app2'}, f"Expected {{'app1', 'app2'}}, got {state.real_apps}"
+    print("   âœ“ PASS: Non-empty set works")
+    
+    # Test 4: List should raise AssertionError
+    print("\n4. Testing real_apps=['app1', 'app2'] (should fail):")
+    try:
+        ProjectState(real_apps=['app1', 'app2'])
+        assert False, "Should have raised AssertionError"
+    except AssertionError as e:
+        assert "real_apps must be a set" in str(e)
+        print("   âœ“ PASS: List correctly raises AssertionError")
+    
+    # Test 5: Tuple should raise AssertionError
+    print("\n5. Testing real_apps=('app1', 'app2') (should fail):")
+    try:
+        ProjectState(real_apps=('app1', 'app2'))
+        assert False, "Should have raised AssertionError"
+    except AssertionError as e:
+        assert "real_apps must be a set" in str(e)
+        print("   âœ“ PASS: Tuple correctly raises AssertionError")
+    
+    # Test 6: String should raise AssertionError
+    print("\n6. Testing real_apps='app1' (should fail):")
+    try:
+        ProjectState(real_apps='app1')
+        assert False, "Should have raised AssertionError"
+    except AssertionError as e:
+        assert "real_apps must be a set" in str(e)
+        print("   âœ“ PASS: String correctly raises AssertionError")
+    
+    # Test 7: Number should raise AssertionError
+    print("\n7. Testing real_apps=123 (should fail):")
+    try:
+        ProjectState(real_apps=123)
+        assert False, "Should have raised AssertionError"
+    except AssertionError as e:
+        assert "real_apps must be a set" in str(e)
+        print("   âœ“ PASS: Number correctly raises AssertionError")
+    
+    # Test 8: Test existing Django test patterns
+    print("\n8. Testing existing Django test patterns:")
+    # Pattern from tests/migrations/test_state.py
+    state = ProjectState(real_apps={'contenttypes'})
+    assert state.real_apps == {'contenttypes'}
+    print("   âœ“ PASS: Pattern from test_state.py works")
+    
+    # Pattern from tests/auth_tests/test_management.py
+    state = ProjectState(real_apps={'contenttypes'})
+    assert state.real_apps == {'contenttypes'}
+    print("   âœ“ PASS: Pattern from test_management.py works")
+    
+    print("\nðŸŽ‰ ALL TESTS PASSED! The fix is working correctly.")
+    return True
+
+if __name__ == "__main__":
+    success = test_comprehensive()
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..2365c7c0ef
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+"""
+Script to test the ProjectState.__init__() real_apps behavior after the fix.
+"""
+from django.db.migrations.state import ProjectState
+
+def test_real_apps_behavior():
+    print("Testing ProjectState.__init__() real_apps behavior after fix...")
+    
+    # Test 1: real_apps as None (should work)
+    print("\n1. Testing with real_apps=None:")
+    state1 = ProjectState(real_apps=None)
+    print(f"   real_apps type: {type(state1.real_apps)}, value: {state1.real_apps}")
+    
+    # Test 2: real_apps as empty set (should work)
+    print("\n2. Testing with real_apps=set():")
+    state2 = ProjectState(real_apps=set())
+    print(f"   real_apps type: {type(state2.real_apps)}, value: {state2.real_apps}")
+    
+    # Test 3: real_apps as non-empty set (should work)
+    print("\n3. Testing with real_apps={'app1', 'app2'}:")
+    state3 = ProjectState(real_apps={'app1', 'app2'})
+    print(f"   real_apps type: {type(state3.real_apps)}, value: {state3.real_apps}")
+    
+    # Test 4: real_apps as list (should raise AssertionError)
+    print("\n4. Testing with real_apps=['app1', 'app2'] (should raise AssertionError):")
+    try:
+        state4 = ProjectState(real_apps=['app1', 'app2'])
+        print(f"   ERROR: Should have raised AssertionError but got: {type(state4.real_apps)}, value: {state4.real_apps}")
+    except AssertionError as e:
+        print(f"   SUCCESS: AssertionError raised as expected: {e}")
+    
+    # Test 5: real_apps as tuple (should raise AssertionError)
+    print("\n5. Testing with real_apps=('app1', 'app2') (should raise AssertionError):")
+    try:
+        state5 = ProjectState(real_apps=('app1', 'app2'))
+        print(f"   ERROR: Should have raised AssertionError but got: {type(state5.real_apps)}, value: {state5.real_apps}")
+    except AssertionError as e:
+        print(f"   SUCCESS: AssertionError raised as expected: {e}")
+
+if __name__ == "__main__":
+    test_real_apps_behavior()
\ No newline at end of file
diff --git a/run_tests.py b/run_tests.py
new file mode 100644
index 0000000000..08fdf6ef17
--- /dev/null
+++ b/run_tests.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+"""
+Simple test runner for migration state tests.
+"""
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Now run the specific test
+from django.test.utils import get_runner
+from django.conf import settings
+
+TestRunner = get_runner(settings)
+test_runner = TestRunner(verbosity=2)
+failures = test_runner.run_tests(['tests.migrations.test_state'])
+
+if failures:
+    print(f"Tests failed: {failures}")
+    exit(1)
+else:
+    print("All tests passed!")
+    exit(0)
\ No newline at end of file
diff --git a/test_django_internal.py b/test_django_internal.py
new file mode 100644
index 0000000000..885d6c381c
--- /dev/null
+++ b/test_django_internal.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""
+Test script to verify that Django's internal usage of ProjectState still works.
+"""
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.migrations.state import ProjectState
+from django.db.migrations.graph import MigrationGraph
+from django.db.migrations.loader import MigrationLoader
+from django.db import connection
+
+def test_django_internal_usage():
+    """Test that Django's internal usage of ProjectState still works."""
+    
+    print("Testing Django internal usage of ProjectState...")
+    
+    # Test 1: Create a basic ProjectState
+    print("\n1. Testing basic ProjectState creation:")
+    try:
+        state = ProjectState()
+        assert isinstance(state.models, dict)
+        assert isinstance(state.real_apps, set)
+        print("  âœ“ SUCCESS: Basic ProjectState creation works")
+    except Exception as e:
+        print(f"  âœ— FAILED: {e}")
+        return False
+    
+    # Test 2: Test with real_apps as set (as used internally by Django)
+    print("\n2. Testing ProjectState with real_apps as set (Django internal usage):")
+    try:
+        # This mimics how Django internally uses ProjectState
+        state = ProjectState(real_apps={'contenttypes'})
+        assert isinstance(state.real_apps, set)
+        assert 'contenttypes' in state.real_apps
+        print("  âœ“ SUCCESS: ProjectState with real_apps as set works")
+    except Exception as e:
+        print(f"  âœ— FAILED: {e}")
+        return False
+    
+    # Test 3: Test MigrationLoader.unmigrated_apps (which is a set)
+    print("\n3. Testing MigrationLoader.unmigrated_apps (which should be a set):")
+    try:
+        loader = MigrationLoader(connection, load=False)
+        # Initialize the unmigrated_apps attribute
+        loader.unmigrated_apps = set()
+        # Check that unmigrated_apps is indeed a set
+        assert isinstance(loader.unmigrated_apps, set)
+        print("  âœ“ SUCCESS: MigrationLoader.unmigrated_apps is a set")
+    except Exception as e:
+        print(f"  âœ— FAILED: {e}")
+        return False
+    
+    # Test 4: Test that MigrationGraph.make_state works with real_apps as set
+    print("\n4. Testing MigrationGraph.make_state with real_apps as set:")
+    try:
+        graph = MigrationGraph()
+        # This should work because real_apps is passed as a set (None or set)
+        state = graph.make_state(real_apps={'contenttypes'})
+        assert isinstance(state.real_apps, set)
+        print("  âœ“ SUCCESS: MigrationGraph.make_state with real_apps as set works")
+    except Exception as e:
+        print(f"  âœ— FAILED: {e}")
+        return False
+    
+    print("\nâœ“ All Django internal usage tests passed!")
+    return True
+
+if __name__ == "__main__":
+    success = test_django_internal_usage()
+    exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_projectstate_fix.py b/test_projectstate_fix.py
new file mode 100644
index 0000000000..4ffb7a7f5b
--- /dev/null
+++ b/test_projectstate_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Test script to verify ProjectState.__init__() works correctly with the fix.
+"""
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.migrations.state import ProjectState
+
+def test_projectstate_real_apps():
+    """Test that ProjectState.__init__() works correctly with real_apps as set."""
+    
+    print("Testing ProjectState real_apps behavior...")
+    
+    # Test cases that should work
+    test_cases = [
+        (None, "real_apps=None"),
+        (set(), "real_apps=set()"),
+        ({'app1', 'app2'}, "real_apps={'app1', 'app2'}"),
+    ]
+    
+    for real_apps, description in test_cases:
+        print(f"\nTesting {description}:")
+        try:
+            state = ProjectState(real_apps=real_apps)
+            assert isinstance(state.real_apps, set), f"real_apps should be a set, got {type(state.real_apps)}"
+            print(f"  âœ“ SUCCESS: real_apps is {state.real_apps}")
+        except Exception as e:
+            print(f"  âœ— FAILED: {e}")
+            return False
+    
+    # Test cases that should fail
+    fail_cases = [
+        (['app1', 'app2'], "real_apps=['app1', 'app2']"),
+        (('app1', 'app2'), "real_apps=('app1', 'app2')"),
+        ("app1", "real_apps='app1'"),
+        (123, "real_apps=123"),
+    ]
+    
+    for real_apps, description in fail_cases:
+        print(f"\nTesting {description} (should fail):")
+        try:
+            state = ProjectState(real_apps=real_apps)
+            print(f"  âœ— FAILED: Should have raised AssertionError but got {type(state.real_apps)}")
+            return False
+        except AssertionError as e:
+            if "real_apps must be a set" in str(e):
+                print(f"  âœ“ SUCCESS: AssertionError raised as expected: {e}")
+            else:
+                print(f"  âœ— FAILED: Wrong AssertionError: {e}")
+                return False
+        except Exception as e:
+            print(f"  âœ— FAILED: Unexpected exception: {e}")
+            return False
+    
+    print("\nâœ“ All tests passed!")
+    return True
+
+if __name__ == "__main__":
+    success = test_projectstate_real_apps()
+    exit(0 if success else 1)
\ No newline at end of file