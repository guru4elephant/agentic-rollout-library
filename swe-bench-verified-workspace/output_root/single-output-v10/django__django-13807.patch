diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..f37a652665
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix handles all edge cases correctly.
+"""
+
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.contenttypes'],
+    )
+django.setup()
+
+from django.db import connection
+
+print("=== Comprehensive Test of SQLite Table Name Quoting Fix ===")
+
+# Test 1: Regular table name (should work as before)
+print("\n1. Testing regular table name...")
+with connection.cursor() as cursor:
+    cursor.execute('CREATE TABLE normal_table (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO normal_table (name) VALUES ("test")')
+
+try:
+    connection.check_constraints(table_names=['normal_table'])
+    print("✅ SUCCESS: Regular table name works correctly")
+except Exception as e:
+    print(f"❌ ERROR with regular table: {e}")
+
+# Test 2: SQL keyword table name (the main fix)
+print("\n2. Testing SQL keyword table name...")
+with connection.cursor() as cursor:
+    cursor.execute('CREATE TABLE "order" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO "order" (name) VALUES ("test")')
+
+try:
+    connection.check_constraints(table_names=['order'])
+    print("✅ SUCCESS: SQL keyword table name works correctly")
+except Exception as e:
+    print(f"❌ ERROR with SQL keyword table: {e}")
+
+# Test 3: Multiple SQL keyword table names
+print("\n3. Testing multiple SQL keyword table names...")
+with connection.cursor() as cursor:
+    cursor.execute('CREATE TABLE "select" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('CREATE TABLE "where" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO "select" (name) VALUES ("test")')
+    cursor.execute('INSERT INTO "where" (name) VALUES ("test")')
+
+try:
+    connection.check_constraints(table_names=['select', 'where'])
+    print("✅ SUCCESS: Multiple SQL keyword table names work correctly")
+except Exception as e:
+    print(f"❌ ERROR with multiple SQL keyword tables: {e}")
+
+# Test 4: table_names=None (check all tables)
+print("\n4. Testing table_names=None (check all tables)...")
+try:
+    connection.check_constraints(table_names=None)
+    print("✅ SUCCESS: table_names=None works correctly")
+except Exception as e:
+    print(f"❌ ERROR with table_names=None: {e}")
+
+# Test 5: Non-existent table (should still produce appropriate error)
+print("\n5. Testing non-existent table...")
+try:
+    connection.check_constraints(table_names=['non_existent_table'])
+    print("✅ SUCCESS: Non-existent table handled correctly (no error expected)")
+except Exception as e:
+    if "no such table" in str(e):
+        print("✅ SUCCESS: Non-existent table produces appropriate error")
+    else:
+        print(f"❌ UNEXPECTED ERROR with non-existent table: {e}")
+
+print("\n=== All tests completed! ===")
\ No newline at end of file
diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index 2eeaf98c0d..faef4a0f8a 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -327,18 +327,18 @@ class DatabaseWrapper(BaseDatabaseWrapper):
                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()
                 else:
                     violations = chain.from_iterable(
-                        cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()
+                        cursor.execute('PRAGMA foreign_key_check("%s")' % table_name).fetchall()
                         for table_name in table_names
                     )
                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
                     foreign_key = cursor.execute(
-                        'PRAGMA foreign_key_list(%s)' % table_name
+                        'PRAGMA foreign_key_list("%s")' % table_name
                     ).fetchall()[foreign_key_index]
                     column_name, referenced_column_name = foreign_key[3:5]
                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
                     primary_key_value, bad_value = cursor.execute(
-                        'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
+                        'SELECT %s, %s FROM "%s" WHERE rowid = %%s' % (
                             primary_key_column_name, column_name, table_name
                         ),
                         (rowid,),
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..a4a5a2350e
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""
+Final test to verify the fix works correctly and doesn't break existing functionality.
+"""
+
+import django
+from django.conf import settings
+
+if not settings.configured:
+    settings.configure(
+        DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},
+        INSTALLED_APPS=['django.contrib.contenttypes'],
+    )
+django.setup()
+
+from django.db import connection
+
+print("Testing basic functionality...")
+
+# Test basic functionality
+with connection.cursor() as cursor:
+    cursor.execute('CREATE TABLE test_table (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO test_table (name) VALUES ("test")')
+    result = cursor.execute('SELECT * FROM test_table').fetchall()
+    print('Basic functionality test:', result)
+
+# Test check_constraints with regular table
+try:
+    connection.check_constraints(table_names=['test_table'])
+    print('check_constraints with regular table: SUCCESS')
+except Exception as e:
+    print('check_constraints with regular table: ERROR', e)
+
+# Test check_constraints with SQL keyword table
+with connection.cursor() as cursor:
+    cursor.execute('CREATE TABLE "order" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO "order" (name) VALUES ("test")')
+
+try:
+    connection.check_constraints(table_names=['order'])
+    print('check_constraints with SQL keyword table: SUCCESS')
+except Exception as e:
+    print('check_constraints with SQL keyword table: ERROR', e)
+
+# Test check_constraints with None (all tables)
+try:
+    connection.check_constraints(table_names=None)
+    print('check_constraints with table_names=None: SUCCESS')
+except Exception as e:
+    print('check_constraints with table_names=None: ERROR', e)
+
+print("All tests completed!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..89c42d6d65
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the SQLite loaddata issue with table names that are SQL keywords.
+"""
+
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Create a model with a name that is a SQL keyword
+class Order(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+# Now test the check_constraints method directly
+from django.db import connection
+
+# Create the table
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Order)
+
+# Insert some data
+from django.db import connection
+with connection.cursor() as cursor:
+    # First, let's see what table name was actually created
+    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%order%'")
+    table_name = cursor.fetchone()
+    if table_name:
+        print(f"Found table: {table_name[0]}")
+        cursor.execute(f'INSERT INTO "{table_name[0]}" (name) VALUES (\'Test Order\')')
+    else:
+        print("No table found with 'order' in the name")
+        # List all tables to see what was created
+        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
+        all_tables = cursor.fetchall()
+        print(f"All tables: {all_tables}")
+
+# Now call check_constraints with the table name that is a SQL keyword
+try:
+    connection.check_constraints(table_names=['test_order'])
+    print("SUCCESS: check_constraints completed without error")
+except Exception as e:
+    print(f"ERROR: {e}")
+    print("This reproduces the issue described in the GitHub issue")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d4a8f9c3b7
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Script to test edge cases for the SQLite table name quoting fix.
+"""
+
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import connection
+
+# Test multiple SQL keyword table names
+with connection.cursor() as cursor:
+    # Create tables with SQL keyword names
+    cursor.execute('CREATE TABLE "order" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('CREATE TABLE "select" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('CREATE TABLE "where" (id INTEGER PRIMARY KEY, name TEXT)')
+    
+    # Insert some data
+    cursor.execute('INSERT INTO "order" (name) VALUES (\'Test Order\')')
+    cursor.execute('INSERT INTO "select" (name) VALUES (\'Test Select\')')
+    cursor.execute('INSERT INTO "where" (name) VALUES (\'Test Where\')')
+
+# Test check_constraints with multiple SQL keyword table names
+try:
+    connection.check_constraints(table_names=['order', 'select', 'where'])
+    print("SUCCESS: check_constraints completed with multiple SQL keyword table names")
+except Exception as e:
+    print(f"ERROR with multiple tables: {e}")
+
+# Test check_constraints with None (all tables)
+try:
+    connection.check_constraints(table_names=None)
+    print("SUCCESS: check_constraints completed with table_names=None")
+except Exception as e:
+    print(f"ERROR with table_names=None: {e}")
+
+# Test check_constraints with regular table names (should still work)
+try:
+    connection.check_constraints(table_names=['normal_table'])
+    print("SUCCESS: check_constraints completed with regular table name (no error expected for non-existent table)")
+except Exception as e:
+    print(f"ERROR with regular table name: {e}")
\ No newline at end of file
diff --git a/test_fixture.json b/test_fixture.json
new file mode 100644
index 0000000000..1e0c15c00b
--- /dev/null
+++ b/test_fixture.json
@@ -0,0 +1 @@
+[{"model": "test.order", "pk": 1, "fields": {"name": "Test Order"}}]
\ No newline at end of file
diff --git a/test_reproduction.py b/test_reproduction.py
new file mode 100644
index 0000000000..51fa947c68
--- /dev/null
+++ b/test_reproduction.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the SQLite loaddata issue with table names that are SQL keywords.
+"""
+
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import connection
+
+# Create a table with a name that is a SQL keyword
+with connection.cursor() as cursor:
+    # Create a table named "order" (which is a SQL keyword)
+    cursor.execute('CREATE TABLE "order" (id INTEGER PRIMARY KEY, name TEXT)')
+    cursor.execute('INSERT INTO "order" (name) VALUES (\'Test Order\')')
+
+# Now call check_constraints with the table name that is a SQL keyword
+try:
+    connection.check_constraints(table_names=['order'])
+    print("SUCCESS: check_constraints completed without error")
+except Exception as e:
+    print(f"ERROR: {e}")
+    print("This reproduces the issue described in the GitHub issue")
\ No newline at end of file