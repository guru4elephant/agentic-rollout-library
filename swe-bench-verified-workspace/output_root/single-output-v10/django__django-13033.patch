diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index abbb1e37cb..9ca6b92e2c 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -727,7 +727,10 @@ class SQLCompiler:
         # If we get to this point and the field is a relation to another model,
         # append the default ordering for that model unless it is the pk
         # shortcut or the attribute name of the field that is specified.
-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':
+        # Also, don't apply target model ordering if we're ordering by the direct
+        # field (e.g., foreignkey_id) rather than the relation itself.
+        if (field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and 
+            name != 'pk' and pieces[-1] != field.attname):
             # Firstly, avoid infinite loops.
             already_seen = already_seen or set()
             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8bc9bab09e
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with self-referencing foreign key ordering
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models from the issue
+class OneModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-id",)
+    
+    id = models.BigAutoField(primary_key=True)
+    root = models.ForeignKey("OneModel", on_delete=models.CASCADE, null=True)
+    oneval = models.BigIntegerField(null=True)
+
+class TwoModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    id = models.BigAutoField(primary_key=True)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+    twoval = models.BigIntegerField(null=True)
+
+# Test the queryset behavior
+from django.db import connection
+from django.db.models import F
+
+def reset_queries():
+    connection.queries_log.clear()
+
+def print_query(queryset, description):
+    print(f"\n=== {description} ===")
+    print(queryset.query)
+    reset_queries()
+
+# Create test data
+def create_test_data():
+    # Create some OneModel instances
+    root1 = OneModel.objects.create(oneval=1)
+    root2 = OneModel.objects.create(oneval=2)
+    root3 = OneModel.objects.create(oneval=3)
+    
+    # Create some child instances with self-referencing foreign keys
+    child1 = OneModel.objects.create(root=root1, oneval=1)
+    child2 = OneModel.objects.create(root=root2, oneval=2)
+    child3 = OneModel.objects.create(root=root3, oneval=3)
+    
+    # Create TwoModel instances
+    TwoModel.objects.create(record=child1, twoval=100)
+    TwoModel.objects.create(record=child2, twoval=200)
+    TwoModel.objects.create(record=child3, twoval=300)
+
+if __name__ == "__main__":
+    # Just print the queries without executing them
+    # Create test data
+    # create_test_data()
+    
+    # Test the problematic queryset
+    qs1 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs1 = qs1.order_by("record__root_id")
+    print_query(qs1, "Problematic query with record__root_id")
+    
+    # Test the working queryset
+    qs2 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs2 = qs2.order_by("record__root__id")
+    print_query(qs2, "Working query with record__root__id")
+    
+    # Test the workaround
+    qs3 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs3 = qs3.annotate(root_id=F("record__root_id"))
+    qs3 = qs3.order_by("root_id")
+    print_query(qs3, "Workaround with annotation")
+    
+    # Test inverted sort order
+    qs4 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs4 = qs4.order_by("-record__root_id")
+    print_query(qs4, "Inverted sort order")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..34aceaa930
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the ordering fix
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+# Create the models from the issue
+class OneModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-id",)
+    
+    id = models.BigAutoField(primary_key=True)
+    root = models.ForeignKey("OneModel", on_delete=models.CASCADE, null=True)
+    oneval = models.BigIntegerField(null=True)
+
+class TwoModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    id = models.BigAutoField(primary_key=True)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+    twoval = models.BigIntegerField(null=True)
+
+# Test the queryset behavior
+from django.db import connection
+from django.db.models import F
+
+def reset_queries():
+    connection.queries_log.clear()
+
+def print_query(queryset, description):
+    print(f"\n=== {description} ===")
+    print(queryset.query)
+    reset_queries()
+
+if __name__ == "__main__":
+    # Test 1: Order by relation field (should still apply target model ordering)
+    qs1 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs1 = qs1.order_by("record__root")
+    print_query(qs1, "Order by relation field (record__root)")
+    
+    # Test 2: Order by direct field (should NOT apply target model ordering)
+    qs2 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs2 = qs2.order_by("record__root_id")
+    print_query(qs2, "Order by direct field (record__root_id)")
+    
+    # Test 3: Order by pk (should NOT apply target model ordering)
+    qs3 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs3 = qs3.order_by("record__pk")
+    print_query(qs3, "Order by pk (record__pk)")
+    
+    # Test 4: Order by non-relation field (should work normally)
+    qs4 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs4 = qs4.order_by("record__oneval")
+    print_query(qs4, "Order by non-relation field (record__oneval)")
+    
+    # Test 5: Order by relation field with inverted sort
+    qs5 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs5 = qs5.order_by("-record__root")
+    print_query(qs5, "Order by relation field with inverted sort (-record__root)")
+    
+    # Test 6: Order by direct field with inverted sort
+    qs6 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs6 = qs6.order_by("-record__root_id")
+    print_query(qs6, "Order by direct field with inverted sort (-record__root_id)")
\ No newline at end of file
diff --git a/test_fix_comprehensive.py b/test_fix_comprehensive.py
new file mode 100644
index 0000000000..74b22b8b8c
--- /dev/null
+++ b/test_fix_comprehensive.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the fix works correctly and doesn't break existing functionality
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+# Test models
+class Category(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-name",)
+    
+    name = models.CharField(max_length=100)
+
+class Article(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-pub_date",)
+    
+    title = models.CharField(max_length=100)
+    pub_date = models.DateField()
+    category = models.ForeignKey(Category, on_delete=models.CASCADE, null=True)
+
+class Comment(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    article = models.ForeignKey(Article, on_delete=models.CASCADE)
+    text = models.TextField()
+
+# Test the queryset behavior
+from django.db import connection
+from django.db.models import F
+
+def reset_queries():
+    connection.queries_log.clear()
+
+def print_query(queryset, description):
+    print(f"\n=== {description} ===")
+    print(queryset.query)
+    reset_queries()
+
+if __name__ == "__main__":
+    print("Testing comprehensive ordering scenarios...")
+    
+    # Test 1: Order by direct field of relation (should NOT apply target model ordering)
+    qs1 = Comment.objects.filter(article__title="test")
+    qs1 = qs1.order_by("article__category_id")
+    print_query(qs1, "Order by direct field of relation (article__category_id)")
+    
+    # Test 2: Order by relation field (should apply target model ordering)
+    qs2 = Comment.objects.filter(article__title="test")
+    qs2 = qs2.order_by("article__category")
+    print_query(qs2, "Order by relation field (article__category)")
+    
+    # Test 3: Order by direct field with inverted sort
+    qs3 = Comment.objects.filter(article__title="test")
+    qs3 = qs3.order_by("-article__category_id")
+    print_query(qs3, "Order by direct field with inverted sort (-article__category_id)")
+    
+    # Test 4: Order by relation field with inverted sort
+    qs4 = Comment.objects.filter(article__title="test")
+    qs4 = qs4.order_by("-article__category")
+    print_query(qs4, "Order by relation field with inverted sort (-article__category)")
+    
+    # Test 5: Order by non-relation field (should work normally)
+    qs5 = Comment.objects.filter(article__title="test")
+    qs5 = qs5.order_by("article__title")
+    print_query(qs5, "Order by non-relation field (article__title)")
+    
+    # Test 6: Order by pk (should work normally)
+    qs6 = Comment.objects.filter(article__title="test")
+    qs6 = qs6.order_by("article__pk")
+    print_query(qs6, "Order by pk (article__pk)")
+    
+    # Test 7: Multi-level relation ordering
+    qs7 = Comment.objects.filter(article__title="test")
+    qs7 = qs7.order_by("article__category__name")
+    print_query(qs7, "Multi-level relation ordering (article__category__name)")
+    
+    print("\nAll tests completed successfully!")
\ No newline at end of file
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..ae67d63ab3
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+"""
+Test the exact scenario from the GitHub issue to confirm it's fixed
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+# Exact models from the GitHub issue
+class OneModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-id",)
+    
+    id = models.BigAutoField(primary_key=True)
+    root = models.ForeignKey("OneModel", on_delete=models.CASCADE, null=True)
+    oneval = models.BigIntegerField(null=True)
+
+class TwoModel(models.Model):
+    class Meta:
+        app_label = 'testapp'
+    
+    id = models.BigAutoField(primary_key=True)
+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)
+    twoval = models.BigIntegerField(null=True)
+
+# Test the queryset behavior
+from django.db import connection
+from django.db.models import F
+
+def reset_queries():
+    connection.queries_log.clear()
+
+def print_query(queryset, description):
+    print(f"\n=== {description} ===")
+    print(queryset.query)
+    reset_queries()
+
+if __name__ == "__main__":
+    print("Testing the exact GitHub issue scenario...")
+    
+    # The problematic query from the issue
+    qs = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs = qs.order_by("record__root_id")
+    print_query(qs, "Problematic query with record__root_id (should be fixed)")
+    
+    # The working query from the issue
+    qs2 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs2 = qs2.order_by("record__root__id")
+    print_query(qs2, "Working query with record__root__id (should still work)")
+    
+    # The workaround from the issue
+    qs3 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs3 = qs3.annotate(root_id=F("record__root_id"))
+    qs3 = qs3.order_by("root_id")
+    print_query(qs3, "Workaround with annotation (should still work)")
+    
+    # The inverted sort order from the issue
+    qs4 = TwoModel.objects.filter(record__oneval__in=[1,2,3])
+    qs4 = qs4.order_by("-record__root_id")
+    print_query(qs4, "Inverted sort order (should be fixed)")
+    
+    print("\nGitHub issue tests completed successfully!")
+    print("\nBefore the fix:")
+    print("- record__root_id: Unnecessary LEFT OUTER JOIN + T3.id DESC (wrong!)")
+    print("- -record__root_id: Unnecessary LEFT OUTER JOIN + T3.id ASC (wrong!)")
+    print("\nAfter the fix:")
+    print("- record__root_id: Single JOIN + correct ASC ordering (fixed!)")
+    print("- -record__root_id: Single JOIN + correct DESC ordering (fixed!)")
\ No newline at end of file
diff --git a/test_self_reference.py b/test_self_reference.py
new file mode 100644
index 0000000000..ebdb6cf218
--- /dev/null
+++ b/test_self_reference.py
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""
+Test self-referencing foreign key edge cases
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+# Self-referencing model with ordering
+class Node(models.Model):
+    class Meta:
+        app_label = 'testapp'
+        ordering = ("-value",)
+    
+    value = models.IntegerField()
+    parent = models.ForeignKey("Node", on_delete=models.CASCADE, null=True)
+
+# Test the queryset behavior
+from django.db import connection
+
+def reset_queries():
+    connection.queries_log.clear()
+
+def print_query(queryset, description):
+    print(f"\n=== {description} ===")
+    print(queryset.query)
+    reset_queries()
+
+if __name__ == "__main__":
+    print("Testing self-referencing foreign key scenarios...")
+    
+    # Test 1: Order by direct field of self-referencing relation
+    qs1 = Node.objects.filter(value__gt=0)
+    qs1 = qs1.order_by("parent_id")
+    print_query(qs1, "Order by direct field of self-referencing relation (parent_id)")
+    
+    # Test 2: Order by self-referencing relation field
+    qs2 = Node.objects.filter(value__gt=0)
+    qs2 = qs2.order_by("parent")
+    print_query(qs2, "Order by self-referencing relation field (parent)")
+    
+    # Test 3: Order by direct field with inverted sort
+    qs3 = Node.objects.filter(value__gt=0)
+    qs3 = qs3.order_by("-parent_id")
+    print_query(qs3, "Order by direct field with inverted sort (-parent_id)")
+    
+    # Test 4: Order by relation field with inverted sort
+    qs4 = Node.objects.filter(value__gt=0)
+    qs4 = qs4.order_by("-parent")
+    print_query(qs4, "Order by relation field with inverted sort (-parent)")
+    
+    print("\nAll self-referencing tests completed successfully!")
\ No newline at end of file