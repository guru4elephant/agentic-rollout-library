diff --git a/django/db/models/query.py b/django/db/models/query.py
index f8d848e926..f2f9797d88 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -670,7 +670,7 @@ class QuerySet:
                 when_statements = []
                 for obj in batch_objs:
                     attr = getattr(obj, field.attname)
-                    if not isinstance(attr, Expression):
+                    if not hasattr(attr, 'resolve_expression'):
                         attr = Value(attr, output_field=field)
                     when_statements.append(When(pk=obj.pk, then=attr))
                 case_statement = Case(*when_statements, output_field=field)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..310b0bf218
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+from django.db.models import F
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    c8 = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create database tables
+from django.db import connection
+
+# Create the table using Django's schema editor
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert test data
+with connection.cursor() as cursor:
+    cursor.execute("INSERT INTO testapp_testmodel (name, c8) VALUES ('test_name', 'initial_value')")
+
+# Test the issue
+obj = TestModel.objects.first()
+print(f"Before update - name: {obj.name}, c8: {obj.c8}")
+
+obj.c8 = F('name')  # Assign F expression directly
+TestModel.objects.bulk_update([obj], ['c8'])
+
+obj.refresh_from_db()
+print(f"After update - name: {obj.name}, c8: {obj.c8}")
+
+# Check the SQL queries that were executed
+print("SQL queries:")
+for i, query in enumerate(connection.queries):
+    print(f"Query {i}: {query['sql']}")
\ No newline at end of file
diff --git a/run_bulk_update_tests.py b/run_bulk_update_tests.py
new file mode 100644
index 0000000000..68845e4f7f
--- /dev/null
+++ b/run_bulk_update_tests.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings for tests
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.queries',  # Add the queries test app
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+# Run the bulk_update tests
+from django.test.utils import get_runner
+from django.test import TestCase
+
+# Import the test class directly
+from tests.queries.test_bulk_update import BulkUpdateTests
+
+# Create a test runner
+TestRunner = get_runner(settings)
+test_runner = TestRunner(verbosity=2)
+
+# Run just the bulk update tests
+print("Running bulk_update tests...")
+result = test_runner.run_tests(['tests.queries.test_bulk_update'])
+
+print(f"\nTest result: {'PASS' if result else 'FAIL'}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..03cbf84004
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+from django.db.models import F, Value, Expression
+from django.db.models.expressions import Combinable
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    c8 = models.CharField(max_length=100)
+    value = models.IntegerField(default=0)
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Insert test data
+with connection.cursor() as cursor:
+    cursor.execute("INSERT INTO testapp_testmodel (name, c8, value) VALUES ('test_name', 'initial_value', 10)")
+    cursor.execute("INSERT INTO testapp_testmodel (name, c8, value) VALUES ('another_name', 'another_value', 20)")
+
+print("=== Test 1: Basic F expression ===")
+obj1 = TestModel.objects.get(id=1)
+print(f"Before update - name: {obj1.name}, c8: {obj1.c8}, value: {obj1.value}")
+
+obj1.c8 = F('name')  # Assign F expression directly
+TestModel.objects.bulk_update([obj1], ['c8'])
+
+obj1.refresh_from_db()
+print(f"After update - name: {obj1.name}, c8: {obj1.c8}, value: {obj1.value}")
+print(f"SUCCESS: {obj1.c8 == obj1.name}")
+
+print("\n=== Test 2: Multiple objects with F expressions ===")
+obj1 = TestModel.objects.get(id=1)
+obj2 = TestModel.objects.get(id=2)
+
+obj1.value = F('value') + 5  # F expression with arithmetic
+obj2.value = F('value') * 2  # F expression with arithmetic
+
+TestModel.objects.bulk_update([obj1, obj2], ['value'])
+
+obj1.refresh_from_db()
+obj2.refresh_from_db()
+print(f"Object 1 - value: {obj1.value} (expected: 15)")
+print(f"Object 2 - value: {obj2.value} (expected: 40)")
+print(f"SUCCESS: {obj1.value == 15 and obj2.value == 40}")
+
+print("\n=== Test 3: Regular values (should still work) ===")
+obj1.c8 = "plain_string"
+TestModel.objects.bulk_update([obj1], ['c8'])
+obj1.refresh_from_db()
+print(f"After update with plain string: {obj1.c8}")
+print(f"SUCCESS: {obj1.c8 == 'plain_string'}")
+
+print("\n=== Test 4: Value objects (should still work) ===")
+obj1.c8 = Value('value_object')
+TestModel.objects.bulk_update([obj1], ['c8'])
+obj1.refresh_from_db()
+print(f"After update with Value object: {obj1.c8}")
+print(f"SUCCESS: {obj1.c8 == 'value_object'}")
+
+# Check that F objects have resolve_expression method
+print(f"\n=== Test 5: F object has resolve_expression method ===")
+f_obj = F('name')
+print(f"F object has resolve_expression: {hasattr(f_obj, 'resolve_expression')}")
+print(f"F object is Expression: {isinstance(f_obj, Expression)}")
+print(f"F object is Combinable: {isinstance(f_obj, Combinable)}")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..e2bc80c1a9
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models, connection
+from django.db.models import F
+
+# Create a model similar to the one in the GitHub issue
+class SelfRef(models.Model):
+    name = models.CharField(max_length=100)
+    c8 = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Create database tables
+from django.db import connection
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(SelfRef)
+
+# Insert test data
+with connection.cursor() as cursor:
+    cursor.execute("INSERT INTO testapp_selfref (name, c8) VALUES ('test_name', 'initial_value')")
+
+# Reproduce the exact issue from GitHub
+print("=== Reproducing GitHub Issue ===")
+o = SelfRef.objects.all().first()
+print(f"Before: name='{o.name}', c8='{o.c8}'")
+
+o.c8 = F('name')  # model has char fields 'c8' and 'name'
+SelfRef.objects.bulk_update([o], ['c8'])
+print(f"Bulk update completed")
+
+o.refresh_from_db()
+print(f"After refresh: name='{o.name}', c8='{o.c8}'")
+
+# Check the SQL that was executed
+print("\n=== SQL Query Analysis ===")
+update_query = None
+for query in connection.queries:
+    if 'UPDATE' in query['sql'] and 'SET' in query['sql']:
+        update_query = query['sql']
+        break
+
+if update_query:
+    print(f"Update query: {update_query}")
+    
+    # The fix should show the column name, not the string 'F(name)'
+    if '"testapp_selfref"."name"' in update_query:
+        print("✓ SUCCESS: F expression correctly resolved to column reference")
+    elif "'F(name)'" in update_query:
+        print("✗ FAILURE: F expression treated as string literal")
+    else:
+        print("? UNKNOWN: Could not determine if F expression was resolved properly")
+else:
+    print("No UPDATE query found in query log")
+
+# Verify the final result
+if o.c8 == o.name:
+    print("✓ SUCCESS: Field value matches expected result")
+else:
+    print(f"✗ FAILURE: Expected '{o.name}', but got '{o.c8}'")
+
+print("\n=== GitHub Issue Verification ===")
+print("The issue was: bulk_update() does not work with plain F('...') expressions")
+print("The expected behavior: F('name') should resolve to the column value, not the string 'F(name)'")
+print(f"Actual result: c8 = '{o.c8}' (should equal name = '{o.name}')")
\ No newline at end of file