diff --git a/django/utils/decorators.py b/django/utils/decorators.py
index 5c9a5d01c7..634bccaf4e 100644
--- a/django/utils/decorators.py
+++ b/django/utils/decorators.py
@@ -38,6 +38,8 @@ def _multi_decorate(decorators, method):
         # 'func'. Also, wrap method.__get__() in a function because new
         # attributes can't be set on bound method objects, only on functions.
         bound_method = partial(method.__get__(self, type(self)))
+        # Preserve function attributes from the original method
+        update_wrapper(bound_method, method)
         for dec in decorators:
             bound_method = dec(bound_method)
         return bound_method(*args, **kwargs)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..dfda3e10a3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,27 @@
+#!/usr/bin/env python3
+"""Script to reproduce the method_decorator issue."""
+
+import functools
+from django.utils.decorators import method_decorator
+
+def logger(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            print(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+
+# This should trigger the error
+test = Test()
+result = test.hello_world()
+print(f"Result: {result}")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..aa40501822
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+"""Comprehensive test for the method_decorator fix."""
+
+import functools
+from django.utils.decorators import method_decorator
+
+def logger(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            print(f"{func.__name__} called from {func.__module__} with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+def simple_decorator(func):
+    def inner(*args, **kwargs):
+        print(f"Simple decorator wrapping {func.__name__}")
+        return func(*args, **kwargs)
+    return inner
+
+class TestClass:
+    @method_decorator(logger)
+    def method_with_logger(self):
+        return "logger_result"
+    
+    @method_decorator(simple_decorator)
+    def method_with_simple(self):
+        return "simple_result"
+    
+    @method_decorator(logger)
+    def method_with_args(self, x, y=10):
+        return f"x={x}, y={y}"
+    
+    @method_decorator(logger)
+    def method_that_raises(self):
+        raise ValueError("Test exception")
+
+# Test basic functionality
+print("=== Testing basic functionality ===")
+test = TestClass()
+result1 = test.method_with_logger()
+print(f"Result: {result1}")
+print()
+
+result2 = test.method_with_simple()
+print(f"Result: {result2}")
+print()
+
+result3 = test.method_with_args(5, y=20)
+print(f"Result: {result3}")
+print()
+
+try:
+    result4 = test.method_that_raises()
+except Exception as e:
+    print(f"Exception caught: {e}")
+print()
+
+# Test function attributes are preserved
+print("=== Testing function attributes ===")
+print(f"method_with_logger.__name__: {test.method_with_logger.__name__}")
+print(f"method_with_logger.__module__: {test.method_with_logger.__module__}")
+print()
+
+# Test multiple decorators
+def decorator1(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        print("Decorator 1")
+        return func(*args, **kwargs)
+    return inner
+
+def decorator2(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        print("Decorator 2")
+        return func(*args, **kwargs)
+    return inner
+
+class MultiDecoratorTest:
+    @method_decorator(decorator1)
+    @method_decorator(decorator2)
+    def multi_decorated(self):
+        return "multi_result"
+
+print("=== Testing multiple decorators ===")
+multi_test = MultiDecoratorTest()
+result_multi = multi_test.multi_decorated()
+print(f"Result: {result_multi}")
+print(f"Function name: {multi_test.multi_decorated.__name__}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..ce3ad551ad
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+"""Test edge cases for the method_decorator fix."""
+
+import functools
+from django.utils.decorators import method_decorator
+
+def decorator_with_attributes(func):
+    """A decorator that adds custom attributes to the function."""
+    func.custom_attr = "custom_value"
+    func.another_attr = 42
+    return func
+
+def simple_wrapper(func):
+    def wrapper(*args, **kwargs):
+        return func(*args, **kwargs)
+    return wrapper
+
+class EdgeCaseTests:
+    @method_decorator(decorator_with_attributes)
+    def method_with_custom_attrs(self):
+        return "custom_attrs"
+    
+    @method_decorator(simple_wrapper)
+    def method_with_simple_wrapper(self):
+        return "simple_wrapper"
+    
+    @method_decorator(decorator_with_attributes)
+    @method_decorator(simple_wrapper)
+    def method_with_multiple_decorators(self):
+        return "multiple_decorators"
+
+print("=== Testing edge cases ===")
+
+test = EdgeCaseTests()
+
+# Test custom attributes preservation
+result1 = test.method_with_custom_attrs()
+print(f"Custom attrs result: {result1}")
+print(f"Custom attribute: {getattr(test.method_with_custom_attrs, 'custom_attr', 'NOT FOUND')}")
+print(f"Another attribute: {getattr(test.method_with_custom_attrs, 'another_attr', 'NOT FOUND')}")
+
+# Test simple wrapper
+result2 = test.method_with_simple_wrapper()
+print(f"Simple wrapper result: {result2}")
+
+# Test multiple decorators
+result3 = test.method_with_multiple_decorators()
+print(f"Multiple decorators result: {result3}")
+
+# Test function attributes
+print(f"Method name: {test.method_with_custom_attrs.__name__}")
+print(f"Method module: {test.method_with_custom_attrs.__module__}")
+print(f"Method doc: {test.method_with_custom_attrs.__doc__}")
+
+print("All edge cases passed!")
\ No newline at end of file
diff --git a/test_github_issue.py b/test_github_issue.py
new file mode 100644
index 0000000000..b8f6bfa5a0
--- /dev/null
+++ b/test_github_issue.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""Test for the exact GitHub issue scenario."""
+
+import functools
+from django.utils.decorators import method_decorator
+
+def logger(func):
+    @functools.wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # This is the exact line from the GitHub issue that was failing
+            print(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+
+# This should work without AttributeError now
+print("Testing the exact GitHub issue scenario...")
+test = Test()
+result = test.hello_world()
+print(f"Success! Result: {result}")
+
+# Also test that other function attributes are preserved
+print(f"Function name preserved: {test.hello_world.__name__}")
+print(f"Function module preserved: {test.hello_world.__module__}")
\ No newline at end of file