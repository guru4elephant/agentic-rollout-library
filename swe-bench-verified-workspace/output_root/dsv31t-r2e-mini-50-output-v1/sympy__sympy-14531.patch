diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..c4d9f1bb9c
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,119 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, sstr, Eq, Limit, S
+from sympy.core.relational import Relational
+
+# Test the fixes comprehensively
+x, y = symbols('x y')
+
+print("Comprehensive test of sstr with sympy_integers=True:")
+print("=" * 60)
+
+# Test case 1: Original issue - Eq and Limit
+print("1. Original issue tests:")
+print("=" * 30)
+result1 = sstr(x + S(1)/2, sympy_integers=True)
+print(f"sstr(x + S(1)/2, sympy_integers=True): '{result1}'")
+expected1 = 'x + S(1)/2'
+print(f"Expected: '{expected1}' - Match: {result1 == expected1}")
+
+result2 = sstr(Eq(x, S(1)/2), sympy_integers=True)
+print(f"sstr(Eq(x, S(1)/2), sympy_integers=True): '{result2}'")
+expected2 = 'Eq(x, S(1)/2)'
+print(f"Expected: '{expected2}' - Match: {result2 == expected2}")
+
+result3 = sstr(Limit(x, x, S(1)/2), sympy_integers=True)
+print(f"sstr(Limit(x, x, S(1)/2), sympy_integers=True): '{result3}'")
+expected3 = 'Limit(x, x, S(1)/2)'
+print(f"Expected: '{expected3}' - Match: {result3 == expected3}")
+
+print()
+
+# Test case 2: Other relational operators
+print("2. Other relational operators:")
+print("=" * 30)
+result4 = sstr(Eq(x, S(1)/2), sympy_integers=True)
+print(f"sstr(Eq(x, S(1)/2), sympy_integers=True): '{result4}'")
+
+result5 = sstr(Relational(x, S(1)/2, '=='), sympy_integers=True)
+print(f"sstr(Relational(x, S(1)/2, '=='), sympy_integers=True): '{result5}'")
+
+print()
+
+# Test case 3: AppliedPredicate (if available)
+print("3. AppliedPredicate test:")
+print("=" * 30)
+# Create a simple predicate test
+try:
+    from sympy import Q
+    pred = Q.even(x)
+    result6 = sstr(pred, sympy_integers=True)
+    print(f"sstr(Q.even(x), sympy_integers=True): '{result6}'")
+except ImportError:
+    print("Q not available in this version")
+
+print()
+
+# Test case 4: Normal distribution
+print("4. Normal distribution test:")
+print("=" * 30)
+try:
+    norm = Normal('X', 0, 1)
+    result7 = sstr(norm, sympy_integers=True)
+    print(f"sstr(Normal('X', 0, 1), sympy_integers=True): '{result7}'")
+except:
+    print("Normal distribution not available")
+
+print()
+
+# Test case 5: Uniform distribution
+print("5. Uniform distribution test:")
+print("=" * 30)
+try:
+    unif = Uniform('Y', 0, 1)
+    result8 = sstr(unif, sympy_integers=True)
+    print(f"sstr(Uniform('Y', 0, 1), sympy_integers=True): '{result8}'")
+except:
+    print("Uniform distribution not available")
+
+print()
+
+# Test case 6: ExprCondPair
+print("6. ExprCondPair test:")
+print("=" * 30)
+try:
+    ecp = ExprCondPair(x, Eq(x, 0))
+    result9 = sstr(ecp, sympy_integers=True)
+    print(f"sstr(ExprCondPair(x, Eq(x, 0)), sympy_integers=True): '{result9}'")
+except:
+    print("ExprCondPair not available")
+
+print()
+
+# Test case 7: Test without sympy_integers to ensure backward compatibility
+print("7. Backward compatibility test (without sympy_integers):")
+print("=" * 40)
+result10 = sstr(Eq(x, S(1)/2))
+print(f"sstr(Eq(x, S(1)/2)): '{result10}'")
+expected10 = 'Eq(x, 1/2)'
+print(f"Expected: '{expected10}' - Match: {result10 == expected10}")
+
+result11 = sstr(Limit(x, x, S(1)/2))
+print(f"sstr(Limit(x, x, S(1)/2)): '{result11}'")
+expected11 = 'Limit(x, x, 1/2)'
+print(f"Expected: '{expected11}' - Match: {result11 == expected11}")
+
+print()
+
+# Test case 8: Edge cases with different Rational values
+print("8. Edge cases with different Rational values:")
+print("=" * 40)
+result12 = sstr(Eq(x, S(3)/4), sympy_integers=True)
+print(f"sstr(Eq(x, S(3)/4), sympy_integers=True): '{result12}'")
+expected12 = 'Eq(x, S(3)/4)'
+print(f"Expected: '{expected12}' - Match: {result12 == expected12}")
+
+result13 = sstr(Eq(x, S(-1)/2), sympy_integers=True)
+print(f"sstr(Eq(x, S(-1)/2), sympy_integers=True): '{result13}'")
+expected13 = 'Eq(x, S(-1)/2)'
+print(f"Expected: '{expected13}' - Match: {result13 == expected13}")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..da17556722
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python3
+
+from sympy import symbols, sstr, Eq, Limit, S
+
+# Reproduce the issue described in the GitHub issue
+x = symbols('x')
+
+print("Testing sstr with sympy_integers=True:")
+print("=" * 50)
+
+# Test case 1: x + S(1)/2
+result1 = sstr(x + S(1)/2, sympy_integers=True)
+print(f"sstr(x + S(1)/2, sympy_integers=True): '{result1}'")
+expected1 = 'x + S(1)/2'
+print(f"Expected: '{expected1}'")
+print(f"Match: {result1 == expected1}")
+
+print()
+
+# Test case 2: Eq(x, S(1)/2)
+result2 = sstr(Eq(x, S(1)/2), sympy_integers=True)
+print(f"sstr(Eq(x, S(1)/2), sympy_integers=True): '{result2}'")
+expected2 = 'Eq(x, S(1)/2)'
+print(f"Expected: '{expected2}'")
+print(f"Match: {result2 == expected2}")
+
+print()
+
+# Test case 3: Limit(x, x, S(1)/2)
+result3 = sstr(Limit(x, x, S(1)/2), sympy_integers=True)
+print(f"sstr(Limit(x, x, S(1)/2), sympy_integers=True): '{result3}'")
+expected3 = 'Limit(x, x, S(1)/2)'
+print(f"Expected: '{expected3}'")
+print(f"Match: {result3 == expected3}")
+
+print()
+
+# Additional test cases to understand the problem better
+print("Additional tests:")
+print("=" * 30)
+
+# Test Rational printing directly
+from sympy import Rational
+r = Rational(1, 2)
+result_r = sstr(r, sympy_integers=True)
+print(f"sstr(Rational(1, 2), sympy_integers=True): '{result_r}'")
+expected_r = 'S(1)/2'
+print(f"Expected: '{expected_r}'")
+print(f"Match: {result_r == expected_r}")
+
+print()
+
+# Test printing Rational within a tuple
+result_tuple = sstr((r,), sympy_integers=True)
+print(f"sstr((Rational(1, 2),), sympy_integers=True): '{result_tuple}'")
\ No newline at end of file
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index cc1d19fcce..02939e55d2 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -86,7 +86,7 @@ def _print_Or(self, expr):
         return self.stringify(expr.args, " | ", PRECEDENCE["BitwiseOr"])
 
     def _print_AppliedPredicate(self, expr):
-        return '%s(%s)' % (expr.func, expr.arg)
+        return '%s(%s)' % (expr.func, self._print(expr.arg))
 
     def _print_Basic(self, expr):
         l = [self._print(o) for o in expr.args]
@@ -141,7 +141,7 @@ def _print_Exp1(self, expr):
         return 'E'
 
     def _print_ExprCondPair(self, expr):
-        return '(%s, %s)' % (expr.expr, expr.cond)
+        return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))
 
     def _print_FiniteSet(self, s):
         s = sorted(s, key=default_sort_key)
@@ -216,9 +216,9 @@ def _print_LatticeOp(self, expr):
     def _print_Limit(self, expr):
         e, z, z0, dir = expr.args
         if str(dir) == "+":
-            return "Limit(%s, %s, %s)" % (e, z, z0)
+            return "Limit(%s, %s, %s)" % (self._print(e), self._print(z), self._print(z0))
         else:
-            return "Limit(%s, %s, %s, dir='%s')" % (e, z, z0, dir)
+            return "Limit(%s, %s, %s, dir='%s')" % (self._print(e), self._print(z), self._print(z0), dir)
 
     def _print_list(self, expr):
         return "[%s]" % self.stringify(expr, ", ")
@@ -341,7 +341,7 @@ def _print_NegativeInfinity(self, expr):
         return '-oo'
 
     def _print_Normal(self, expr):
-        return "Normal(%s, %s)" % (expr.mu, expr.sigma)
+        return "Normal(%s, %s)" % (self._print(expr.mu), self._print(expr.sigma))
 
     def _print_Order(self, expr):
         if all(p is S.Zero for p in expr.point) or not len(expr.variables):
@@ -630,15 +630,15 @@ def _print_Relational(self, expr):
         }
 
         if expr.rel_op in charmap:
-            return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)
+            return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs), self._print(expr.rhs))
 
         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
                            self._relationals.get(expr.rel_op) or expr.rel_op,
                            self.parenthesize(expr.rhs, precedence(expr)))
 
     def _print_ComplexRootOf(self, expr):
-        return "CRootOf(%s, %d)" % (self._print_Add(expr.expr, order='lex'),
-                                    expr.index)
+        return "CRootOf(%s, %s)" % (self._print_Add(expr.expr, order='lex'),
+                                    self._print(expr.index))
 
     def _print_RootSum(self, expr):
         args = [self._print_Add(expr.expr, order='lex')]
@@ -722,7 +722,7 @@ def _print_Transpose(self, T):
         return "%s.T" % self.parenthesize(T.arg, PRECEDENCE["Pow"])
 
     def _print_Uniform(self, expr):
-        return "Uniform(%s, %s)" % (expr.a, expr.b)
+        return "Uniform(%s, %s)" % (self._print(expr.a), self._print(expr.b))
 
     def _print_Union(self, expr):
         return 'Union(%s)' %(', '.join([self._print(a) for a in expr.args]))