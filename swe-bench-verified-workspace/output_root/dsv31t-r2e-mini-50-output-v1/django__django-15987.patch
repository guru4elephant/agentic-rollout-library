diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..51b11efc66
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python3
+"""Comprehensive test to confirm both issues with Path objects in FIXTURE_DIRS"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+def test_duplicate_check():
+    """Test the duplicate check logic"""
+    fixture_dirs_mixed = ['/same/path', Path('/same/path')]
+    fixture_dirs_paths = [Path('/same/path'), Path('/same/path')]
+    fixture_dirs_strings = ['/same/path', '/same/path']
+    
+    print("Testing duplicate detection:")
+    print(f"Mixed types: {len(fixture_dirs_mixed)} vs {len(set(fixture_dirs_mixed))}")
+    print(f"Path types: {len(fixture_dirs_paths)} vs {len(set(fixture_dirs_paths))}")
+    print(f"String types: {len(fixture_dirs_strings)} vs {len(set(fixture_dirs_strings))}")
+    
+    # The mixed types should be detected as duplicates but won't be
+    mixed_is_duplicate = len(fixture_dirs_mixed) != len(set(fixture_dirs_mixed))
+    print(f"Mixed types detected as duplicate: {mixed_is_duplicate}")
+    
+    return not mixed_is_duplicate  # Returns True if issue exists
+
+def test_membership_check():
+    """Test the membership check logic"""
+    app_dir_str = '/app/fixtures'
+    fixture_dirs_with_path = [Path('/app/fixtures')]
+    
+    print(f"\nTesting membership: '{app_dir_str}' in {fixture_dirs_with_path}")
+    result = app_dir_str in fixture_dirs_with_path
+    print(f"Result: {result}")
+    
+    return not result  # Returns True if issue exists
+
+if __name__ == "__main__":
+    issue1 = test_duplicate_check()
+    issue2 = test_membership_check()
+    
+    if issue1 or issue2:
+        print("\n‚úó Issues confirmed:")
+        if issue1:
+            print("  - Mixed type duplicates not detected in FIXTURE_DIRS")
+        if issue2:
+            print("  - String app_dir not found in Path-based FIXTURE_DIRS")
+    else:
+        print("\n‚úì No issues found")
\ No newline at end of file
diff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py
index ac97f13161..56ad38ea32 100644
--- a/django/core/management/commands/loaddata.py
+++ b/django/core/management/commands/loaddata.py
@@ -362,12 +362,14 @@ class Command(BaseCommand):
         """
         dirs = []
         fixture_dirs = settings.FIXTURE_DIRS
-        if len(fixture_dirs) != len(set(fixture_dirs)):
+        # Convert all paths to strings for consistent comparison
+        fixture_dirs_str = [str(dir_) for dir_ in fixture_dirs]
+        if len(fixture_dirs_str) != len(set(fixture_dirs_str)):
             raise ImproperlyConfigured("settings.FIXTURE_DIRS contains duplicates.")
         for app_config in apps.get_app_configs():
             app_label = app_config.label
             app_dir = os.path.join(app_config.path, "fixtures")
-            if app_dir in fixture_dirs:
+            if app_dir in fixture_dirs_str:
                 raise ImproperlyConfigured(
                     "'%s' is a default fixture directory for the '%s' app "
                     "and cannot be listed in settings.FIXTURE_DIRS."
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..cebfe30002
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+"""Final comprehensive test for the Path object fix"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_all_scenarios():
+    """Test all scenarios for Path object handling"""
+    
+    print("Testing FIXTURE_DIRS duplicate detection with Path objects:")
+    print("=" * 60)
+    
+    # Test 1: Same Path objects
+    settings.FIXTURE_DIRS = [Path('/same/path'), Path('/same/path')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs
+        print("‚ùå FAIL: Same Path objects not detected as duplicates")
+        return False
+    except ImproperlyConfigured:
+        print("‚úÖ PASS: Same Path objects correctly detected as duplicates")
+    
+    # Test 2: Mixed string and Path with same path
+    settings.FIXTURE_DIRS = ['/same/path', Path('/same/path')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs
+        print("‚ùå FAIL: Mixed types not detected as duplicates")
+        return False
+    except ImproperlyConfigured:
+        print("‚úÖ PASS: Mixed types correctly detected as duplicates")
+    
+    # Test 3: Different paths (should not raise error in duplicate check)
+    # We'll test this by checking the logic directly since we can't call fixture_dirs without app setup
+    fixture_dirs = ['/path/one', Path('/path/two')]
+    fixture_dirs_str = [str(dir_) for dir_ in fixture_dirs]
+    is_duplicate = len(fixture_dirs_str) != len(set(fixture_dirs_str))
+    
+    if not is_duplicate:
+        print("‚úÖ PASS: Different paths correctly allowed")
+    else:
+        print("‚ùå FAIL: Different paths incorrectly detected as duplicates")
+        return False
+    
+    # Test 4: App dir conflict detection with Path objects
+    print("\nTesting app dir conflict detection with Path objects:")
+    print("=" * 60)
+    
+    # Test the logic directly (since we can't easily mock the full app setup)
+    fixture_dirs = [Path('/app/fixtures')]
+    app_dir = '/app/fixtures'  # This is what os.path.join would produce
+    
+    # Convert to strings for comparison (the fix)
+    fixture_dirs_str = [str(dir_) for dir_ in fixture_dirs]
+    
+    # Original behavior (would fail)
+    original_result = app_dir in fixture_dirs
+    # Fixed behavior (should work)
+    fixed_result = app_dir in fixture_dirs_str
+    
+    print(f"App dir: {app_dir}")
+    print(f"Fixture dirs: {fixture_dirs}")
+    print(f"Original check (app_dir in fixture_dirs): {original_result}")
+    print(f"Fixed check (app_dir in fixture_dirs_str): {fixed_result}")
+    
+    if not original_result and fixed_result:
+        print("‚úÖ PASS: App dir conflict detection fixed for Path objects")
+    else:
+        print("‚ùå FAIL: App dir conflict detection not working correctly")
+        return False
+    
+    return True
+
+if __name__ == "__main__":
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=[],
+            FIXTURE_DIRS=[],
+        )
+    
+    print("Final test for Path object duplicate detection in FIXTURE_DIRS")
+    print("=" * 80)
+    
+    success = test_all_scenarios()
+    
+    if success:
+        print("\n" + "=" * 80)
+        print("üéâ ALL TESTS PASSED! The fix is working correctly.")
+        print("=" * 80)
+    else:
+        print("\n" + "=" * 80)
+        print("‚ùå SOME TESTS FAILED! The fix needs more work.")
+        print("=" * 80)
+        sys.exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..c65e67fd76
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with FIXTURE_DIRS duplicates not being detected
+when Path instances are used.
+"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_duplicate_detection():
+    """Test that duplicate FIXTURE_DIRS are properly detected"""
+    
+    # Test case 1: String paths (should work correctly)
+    settings.FIXTURE_DIRS = ['/path/to/fixtures', '/path/to/fixtures']
+    try:
+        cmd = Command()
+        cmd.fixture_dirs  # This should trigger the duplicate check
+        print("ERROR: String duplicates not detected!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì String duplicates correctly detected:", str(e))
+    
+    # Test case 2: Path objects with same path (should fail to detect duplicates)
+    settings.FIXTURE_DIRS = [Path('/path/to/fixtures'), Path('/path/to/fixtures')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs  # This should trigger the duplicate check
+        print("ERROR: Path object duplicates not detected!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì Path object duplicates correctly detected:", str(e))
+        return True
+    except Exception as e:
+        print("Unexpected error:", str(e))
+        return False
+
+if __name__ == "__main__":
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=[],
+            FIXTURE_DIRS=[],
+        )
+    
+    success = test_duplicate_detection()
+    if success:
+        print("\n‚úì Test passed: Duplicates are properly detected")
+    else:
+        print("\n‚úó Test failed: Duplicates are not properly detected")
\ No newline at end of file
diff --git a/simple_app_dir_test.py b/simple_app_dir_test.py
new file mode 100644
index 0000000000..a63c079e1e
--- /dev/null
+++ b/simple_app_dir_test.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+"""Simple test for app_dir check with Path objects"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+def test_app_dir_logic():
+    """Test the fixed app_dir logic"""
+    
+    # Simulate the fixed logic from the code
+    fixture_dirs = [Path('/path/to/app/fixtures')]
+    app_dir = '/path/to/app/fixtures'  # This is what os.path.join would produce
+    
+    # Convert fixture_dirs to strings for comparison (the fix)
+    fixture_dirs_str = [str(dir_) for dir_ in fixture_dirs]
+    
+    print(f"app_dir: {app_dir}")
+    print(f"fixture_dirs: {fixture_dirs}")
+    print(f"fixture_dirs_str: {fixture_dirs_str}")
+    print(f"app_dir in fixture_dirs: {app_dir in fixture_dirs}")
+    print(f"app_dir in fixture_dirs_str: {app_dir in fixture_dirs_str}")
+    
+    # The first should be False (original bug), the second should be True (fixed)
+    return app_dir in fixture_dirs_str
+
+if __name__ == "__main__":
+    result = test_app_dir_logic()
+    if result:
+        print("‚úì App dir check is working correctly with the fix!")
+    else:
+        print("‚úó App dir check is still not working")
\ No newline at end of file
diff --git a/simple_path_test.py b/simple_path_test.py
new file mode 100644
index 0000000000..b3a3ee3e39
--- /dev/null
+++ b/simple_path_test.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+"""Simple test to verify Path object duplicate detection works"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_path_duplicates():
+    """Test Path object duplicate detection"""
+    
+    # Test case 1: Same Path objects
+    settings.FIXTURE_DIRS = [Path('/same/path'), Path('/same/path')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs
+        print("ERROR: Same Path objects not detected as duplicates!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì Same Path objects correctly detected:", str(e))
+    
+    # Test case 2: Mixed string and Path with same path
+    settings.FIXTURE_DIRS = ['/same/path', Path('/same/path')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs
+        print("ERROR: Mixed types not detected as duplicates!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì Mixed types correctly detected:", str(e))
+        return True
+    except Exception as e:
+        print("Unexpected error:", str(e))
+        return False
+
+if __name__ == "__main__":
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=[],
+            FIXTURE_DIRS=[],
+        )
+    
+    success = test_path_duplicates()
+    if success:
+        print("\n‚úì Path object duplicate detection is working correctly!")
+    else:
+        print("\n‚úó Path object duplicate detection is not working")
\ No newline at end of file
diff --git a/test_app_dir_fix.py b/test_app_dir_fix.py
new file mode 100644
index 0000000000..bb65a3a248
--- /dev/null
+++ b/test_app_dir_fix.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python3
+"""Test that app_dir check works with Path objects in FIXTURE_DIRS"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_app_dir_with_path_objects():
+    """Test that app_dir check works when FIXTURE_DIRS contains Path objects"""
+    
+    # Create a mock scenario where an app's fixture directory conflicts with a Path in FIXTURE_DIRS
+    app_fixture_dir = '/path/to/app/fixtures'
+    
+    # Set FIXTURE_DIRS to contain a Path object with the same path as the app fixture directory
+    settings.FIXTURE_DIRS = [Path('/path/to/app/fixtures')]
+    
+    # Mock the apps.get_app_configs to return an app with the conflicting path
+    from django.apps import AppConfig
+    import unittest.mock
+    
+    class MockAppConfig(AppConfig):
+        def __init__(self):
+            self.path = '/path/to/app'
+            self.label = 'testapp'
+    
+    mock_app_config = MockAppConfig()
+    
+    # Test the fixed logic directly
+    fixture_dirs = settings.FIXTURE_DIRS
+    fixture_dirs_str = [str(dir_) for dir_ in fixture_dirs]
+    app_dir = os.path.join(mock_app_config.path, "fixtures")
+    
+    print(f"app_dir: {app_dir}")
+    print(f"fixture_dirs: {fixture_dirs}")
+    print(f"fixture_dirs_str: {fixture_dirs_str}")
+    print(f"app_dir in fixture_dirs: {app_dir in fixture_dirs}")
+    print(f"app_dir in fixture_dirs_str: {app_dir in fixture_dirs_str}")
+    
+    # The fixed version should detect the conflict
+    conflict_detected = app_dir in fixture_dirs_str
+    print(f"Conflict detected with fix: {conflict_detected}")
+    
+    return conflict_detected
+
+if __name__ == "__main__":
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=[],
+            FIXTURE_DIRS=[],
+        )
+    
+    success = test_app_dir_with_path_objects()
+    if success:
+        print("\n‚úì App dir check is working correctly with Path objects!")
+    else:
+        print("\n‚úó App dir check is not working with Path objects")
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..ac1e5826ad
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+"""Test the fix for Path object issues in FIXTURE_DIRS"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_duplicate_detection_fixed():
+    """Test that duplicate detection works with mixed types"""
+    
+    # Test case 1: Mixed string and Path with same path (should now be detected)
+    settings.FIXTURE_DIRS = ['/path/to/fixtures', Path('/path/to/fixtures')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs  # This should now trigger the duplicate check
+        print("ERROR: Mixed type duplicates still not detected!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì Mixed type duplicates correctly detected:", str(e))
+        return True
+    except Exception as e:
+        print("Unexpected error:", str(e))
+        return False
+
+def test_app_dir_check_fixed():
+    """Test that app_dir check works with Path objects in FIXTURE_DIRS"""
+    
+    # We need to mock an app config for this test
+    from django.apps import AppConfig
+    
+    class MockAppConfig(AppConfig):
+        path = '/path/to/app'
+        label = 'testapp'
+    
+    # Create a scenario where app_dir is a string but fixture_dirs contains Path
+    settings.FIXTURE_DIRS = [Path('/path/to/app/fixtures')]
+    
+    try:
+        cmd = Command()
+        # We need to mock the apps.get_app_configs() call
+        with unittest.mock.patch('django.apps.apps.get_app_configs', return_value=[MockAppConfig('testapp')]):
+            cmd.fixture_dirs  # This should trigger the app_dir check
+        print("ERROR: App dir check still not working!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì App dir check correctly detected conflict:", str(e))
+        return True
+    except Exception as e:
+        print("Unexpected error:", str(e))
+        return False
+
+if __name__ == "__main__":
+    import unittest.mock
+    
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=['testapp'],
+            FIXTURE_DIRS=[],
+        )
+    
+    print("Testing duplicate detection fix:")
+    success1 = test_duplicate_detection_fixed()
+    
+    print("\nTesting app_dir check fix:")
+    success2 = test_app_dir_check_fixed()
+    
+    if success1 and success2:
+        print("\n‚úì Fix is working correctly!")
+    else:
+        print("\n‚úó Fix needs more work")
\ No newline at end of file
diff --git a/test_path_behavior.py b/test_path_behavior.py
new file mode 100644
index 0000000000..7f325e24d1
--- /dev/null
+++ b/test_path_behavior.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""Test how Path objects behave in sets and comparisons"""
+
+from pathlib import Path
+
+# Test Path object behavior
+path1 = Path('/same/path')
+path2 = Path('/same/path')
+
+print("Path objects:")
+print(f"path1: {path1}")
+print(f"path2: {path2}")
+print(f"path1 == path2: {path1 == path2}")
+print(f"path1 is path2: {path1 is path2}")
+print(f"hash(path1): {hash(path1)}")
+print(f"hash(path2): {hash(path2)}")
+
+# Test set behavior
+path_set = {path1, path2}
+print(f"Set with both paths: {path_set}")
+print(f"Set length: {len(path_set)}")
+
+# Test string vs Path comparison
+str_path = '/same/path'
+print(f"\nString vs Path:")
+print(f"str_path: {str_path}")
+print(f"path1 == str_path: {path1 == str_path}")
+print(f"str_path == path1: {str_path == path1}")
+
+# Test mixed types in set
+mixed_set = {path1, str_path}
+print(f"Mixed set: {mixed_set}")
+print(f"Mixed set length: {len(mixed_set)}")
\ No newline at end of file
diff --git a/test_path_duplicates.py b/test_path_duplicates.py
new file mode 100644
index 0000000000..0c9ee1875c
--- /dev/null
+++ b/test_path_duplicates.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+"""Test for Path object duplicates in FIXTURE_DIRS - the specific GitHub issue"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core import management
+from django.core.exceptions import ImproperlyConfigured
+from django.test import TestCase, override_settings
+
+# Get the current directory for the test
+_cur_dir = os.path.dirname(os.path.abspath(__file__))
+
+class TestPathDuplicates(TestCase):
+    """Test that Path object duplicates are properly detected in FIXTURE_DIRS"""
+    
+    @override_settings(
+        FIXTURE_DIRS=[
+            Path(_cur_dir) / "fixtures_1",
+            Path(_cur_dir) / "fixtures_1",  # Same path as Path object
+        ]
+    )
+    def test_path_duplicates_same_path(self):
+        """Test that identical Path objects are detected as duplicates"""
+        with self.assertRaisesMessage(
+            ImproperlyConfigured, "settings.FIXTURE_DIRS contains duplicates."
+        ):
+            management.call_command("loaddata", "absolute.json", verbosity=0)
+    
+    @override_settings(
+        FIXTURE_DIRS=[
+            str(Path(_cur_dir) / "fixtures_1"),  # String path
+            Path(_cur_dir) / "fixtures_1",       # Path object with same path
+        ]
+    )
+    def test_mixed_type_duplicates(self):
+        """Test that mixed string and Path objects with same path are detected as duplicates"""
+        with self.assertRaisesMessage(
+            ImproperlyConfigured, "settings.FIXTURE_DIRS contains duplicates."
+        ):
+            management.call_command("loaddata", "absolute.json", verbosity=0)
+
+if __name__ == "__main__":
+    # Configure Django settings for standalone test
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=['fixtures_regress'],
+            FIXTURE_DIRS=[],
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': ':memory:',
+                }
+            },
+        )
+    
+    import django
+    django.setup()
+    
+    # Run the tests
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_specific_case.py b/test_specific_case.py
new file mode 100644
index 0000000000..a3e2851adf
--- /dev/null
+++ b/test_specific_case.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""Test specific case where Path and string duplicates might not be detected"""
+
+import os
+import sys
+from pathlib import Path
+
+# Add the testbed to Python path
+sys.path.insert(0, '/testbed')
+
+from django.conf import settings
+from django.core.management.commands.loaddata import Command
+from django.core.exceptions import ImproperlyConfigured
+
+def test_mixed_types():
+    """Test mixed string and Path types in FIXTURE_DIRS"""
+    
+    # Test case: Mixed string and Path with same path (should be detected as duplicates)
+    settings.FIXTURE_DIRS = ['/path/to/fixtures', Path('/path/to/fixtures')]
+    try:
+        cmd = Command()
+        cmd.fixture_dirs  # This should trigger the duplicate check
+        print("ERROR: Mixed type duplicates not detected!")
+        return False
+    except ImproperlyConfigured as e:
+        print("‚úì Mixed type duplicates correctly detected:", str(e))
+        return True
+    except Exception as e:
+        print("Unexpected error:", str(e))
+        return False
+
+def test_app_dir_check():
+    """Test the app_dir in fixture_dirs check"""
+    
+    # Create a scenario where app_dir is a string but fixture_dirs contains Path
+    app_dir_str = '/path/to/app/fixtures'
+    fixture_dirs_with_path = [Path('/path/to/app/fixtures')]
+    
+    print(f"Testing: '{app_dir_str}' in {fixture_dirs_with_path}")
+    result = app_dir_str in fixture_dirs_with_path
+    print(f"Result: {result}")
+    
+    # This should be True but might be False due to type mismatch
+    return result
+
+if __name__ == "__main__":
+    # Configure minimal Django settings
+    if not settings.configured:
+        settings.configure(
+            DEBUG=True,
+            SECRET_KEY='test-secret-key',
+            INSTALLED_APPS=[],
+            FIXTURE_DIRS=[],
+        )
+    
+    print("Testing mixed types in FIXTURE_DIRS:")
+    success1 = test_mixed_types()
+    
+    print("\nTesting app_dir in fixture_dirs check:")
+    success2 = test_app_dir_check()
+    
+    if success1 and success2:
+        print("\n‚úì All tests passed")
+    else:
+        print("\n‚úó Some tests failed")
\ No newline at end of file