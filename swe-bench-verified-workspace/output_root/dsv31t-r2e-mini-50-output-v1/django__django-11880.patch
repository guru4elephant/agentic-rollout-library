diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..f394096acd
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test to verify the deepcopy fix for error_messages.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+    )
+    django.setup()
+
+import copy
+from django.forms import CharField, Form
+
+def test_field_deepcopy_error_messages():
+    """Test that Field's __deepcopy__ properly copies error_messages."""
+    print("=== Testing Field deepcopy error_messages ===")
+    
+    # Test 1: Custom error messages
+    field1 = CharField(
+        error_messages={
+            'required': 'Custom required message',
+            'invalid': 'Custom invalid message'
+        }
+    )
+    field2 = copy.deepcopy(field1)
+    
+    # Modify original
+    field1.error_messages['required'] = 'Modified required message'
+    field1.error_messages['new_error'] = 'New error message'
+    
+    # Check copy is unaffected
+    assert field2.error_messages['required'] == 'Custom required message', "Copy should have original message"
+    assert 'new_error' not in field2.error_messages, "Copy should not have new error"
+    assert field1.error_messages is not field2.error_messages, "Should be different objects"
+    print("‚úÖ Custom error messages test passed")
+
+def test_form_deepcopy_isolation():
+    """Test that Form deepcopy creates isolated field instances."""
+    print("=== Testing Form deepcopy isolation ===")
+    
+    class TestForm(Form):
+        name = CharField(
+            error_messages={'required': 'Form specific required message'}
+        )
+    
+    form1 = TestForm()
+    form2 = copy.deepcopy(form1)
+    
+    # Modify error messages on form1's field
+    form1.fields['name'].error_messages['required'] = 'Modified message'
+    form1.fields['name'].error_messages['new_error'] = 'New error'
+    
+    # Check form2's field is unaffected
+    assert form2.fields['name'].error_messages['required'] == 'Form specific required message', "Copy should have original message"
+    assert 'new_error' not in form2.fields['name'].error_messages, "Copy should not have new error"
+    assert form1.fields['name'].error_messages is not form2.fields['name'].error_messages, "Should be different objects"
+    print("‚úÖ Form deepcopy isolation test passed")
+
+def test_multiple_instances():
+    """Test that multiple form instances don't share error_messages."""
+    print("=== Testing multiple form instances ===")
+    
+    class ProfileForm(Form):
+        username = CharField(
+            error_messages={'required': 'Username is required'}
+        )
+    
+    # Create multiple instances
+    form1 = ProfileForm()
+    form2 = ProfileForm()
+    
+    # Modify error messages on one instance
+    form1.fields['username'].error_messages['required'] = 'Modified username required'
+    form1.fields['username'].error_messages['invalid'] = 'Invalid username'
+    
+    # Check other instance is unaffected
+    assert form2.fields['username'].error_messages['required'] == 'Username is required', "Other instance should be unaffected"
+    assert 'invalid' not in form2.fields['username'].error_messages, "Other instance should not have new error"
+    print("‚úÖ Multiple instances test passed")
+
+def test_edge_cases():
+    """Test edge cases for error_messages deepcopy."""
+    print("=== Testing edge cases ===")
+    
+    # Test with empty error_messages
+    field1 = CharField(error_messages={})
+    field2 = copy.deepcopy(field1)
+    field1.error_messages['custom'] = 'test'
+    assert 'custom' not in field2.error_messages, "Empty error_messages should be isolated"
+    print("‚úÖ Empty error_messages test passed")
+    
+    # Test with None error_messages (should use defaults)
+    field1 = CharField(error_messages=None)
+    field2 = copy.deepcopy(field1)
+    field1.error_messages['required'] = 'Custom required'
+    assert field2.error_messages['required'] == 'This field is required.', "None error_messages should use defaults"
+    print("‚úÖ None error_messages test passed")
+    
+    # Test with default error_messages
+    field1 = CharField()  # No custom error_messages
+    field2 = copy.deepcopy(field1)
+    field1.error_messages['required'] = 'Custom required'
+    assert field2.error_messages['required'] == 'This field is required.', "Default error_messages should be isolated"
+    print("‚úÖ Default error_messages test passed")
+
+if __name__ == '__main__':
+    try:
+        test_field_deepcopy_error_messages()
+        test_form_deepcopy_isolation()
+        test_multiple_instances()
+        test_edge_cases()
+        print("\nüéâ All tests passed! The deepcopy fix is working correctly.")
+    except AssertionError as e:
+        print(f"\n‚ùå Test failed: {e}")
+        exit(1)
+    except Exception as e:
+        print(f"\n‚ùå Unexpected error: {e}")
+        exit(1)
\ No newline at end of file
diff --git a/django/forms/fields.py b/django/forms/fields.py
index 03cd8af8d7..4cc3133ca0 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -200,6 +200,7 @@ class Field:
         memo[id(self)] = result
         result.widget = copy.deepcopy(self.widget, memo)
         result.validators = self.validators[:]
+        result.error_messages = copy.deepcopy(self.error_messages, memo)
         return result
 
 
diff --git a/final_verification.py b/final_verification.py
new file mode 100644
index 0000000000..ea110b196f
--- /dev/null
+++ b/final_verification.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+"""
+Final verification that the deepcopy fix works for all form field types.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+    )
+    django.setup()
+
+import copy
+from django.forms import (
+    CharField, IntegerField, EmailField, URLField, BooleanField,
+    ChoiceField, DateField, DateTimeField, FloatField, DecimalField
+)
+
+def test_all_field_types():
+    """Test that all field types properly deepcopy error_messages."""
+    print("=== Testing all field types ===")
+    
+    field_classes = [
+        CharField, IntegerField, EmailField, URLField, BooleanField,
+        ChoiceField, DateField, DateTimeField, FloatField, DecimalField
+    ]
+    
+    for field_class in field_classes:
+        print(f"Testing {field_class.__name__}...")
+        
+        # Create field with custom error messages
+        if field_class == ChoiceField:
+            field1 = field_class(
+                choices=[('a', 'A'), ('b', 'B')],
+                error_messages={'required': f'{field_class.__name__} required', 'invalid': 'Invalid'}
+            )
+        else:
+            field1 = field_class(
+                error_messages={'required': f'{field_class.__name__} required', 'invalid': 'Invalid'}
+            )
+        
+        # Make a deep copy
+        field2 = copy.deepcopy(field1)
+        
+        # Modify original
+        field1.error_messages['required'] = 'Modified message'
+        field1.error_messages['new_error'] = 'New error'
+        
+        # Check copy is unaffected
+        assert field2.error_messages['required'] == f'{field_class.__name__} required', f"{field_class.__name__}: Copy should have original message"
+        assert 'new_error' not in field2.error_messages, f"{field_class.__name__}: Copy should not have new error"
+        assert field1.error_messages is not field2.error_messages, f"{field_class.__name__}: Should be different objects"
+        
+        print(f"  ‚úÖ {field_class.__name__} passed")
+
+def test_inheritance():
+    """Test that inherited __deepcopy__ methods work correctly."""
+    print("=== Testing inheritance ===")
+    
+    # Test that ChoiceField (which inherits from Field) works
+    field1 = ChoiceField(
+        choices=[('a', 'A'), ('b', 'B')],
+        error_messages={'required': 'Choice required', 'invalid': 'Invalid choice'}
+    )
+    field2 = copy.deepcopy(field1)
+    
+    field1.error_messages['required'] = 'Modified choice message'
+    field1.error_messages['new_error'] = 'New choice error'
+    
+    assert field2.error_messages['required'] == 'Choice required', "ChoiceField should inherit deepcopy fix"
+    assert 'new_error' not in field2.error_messages, "ChoiceField should not have new error"
+    assert field1.error_messages is not field2.error_messages, "ChoiceField should be different objects"
+    
+    print("‚úÖ Inheritance test passed")
+
+if __name__ == '__main__':
+    try:
+        test_all_field_types()
+        test_inheritance()
+        print("\nüéâ All final verification tests passed! The fix works for all field types.")
+    except AssertionError as e:
+        print(f"\n‚ùå Test failed: {e}")
+        exit(1)
+    except Exception as e:
+        print(f"\n‚ùå Unexpected error: {e}")
+        exit(1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..8aa7c853e6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue with Form Field's __deepcopy__ not copying error_messages.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+    )
+    django.setup()
+
+import copy
+from django.forms import CharField
+
+def test_deepcopy_error_messages():
+    print("Testing deepcopy of Form Field error_messages...")
+    
+    # Create a field with custom error messages
+    field1 = CharField(
+        error_messages={
+            'required': 'Custom required message',
+            'invalid': 'Custom invalid message'
+        }
+    )
+    
+    # Make a deep copy
+    field2 = copy.deepcopy(field1)
+    
+    # Modify error_messages on the original field
+    field1.error_messages['required'] = 'Modified required message'
+    field1.error_messages['new_error'] = 'New error message'
+    
+    # Check if the copy was affected
+    print(f"Original field required message: {field1.error_messages['required']}")
+    print(f"Copied field required message: {field2.error_messages.get('required')}")
+    print(f"Original field has new_error: {'new_error' in field1.error_messages}")
+    print(f"Copied field has new_error: {'new_error' in field2.error_messages}")
+    
+    # Check if they share the same dictionary object
+    print(f"Same error_messages object: {field1.error_messages is field2.error_messages}")
+    print(f"Same dictionary ID: {id(field1.error_messages)} vs {id(field2.error_messages)}")
+    
+    # Expected: They should be different objects and the copy should not be affected
+    if field1.error_messages is field2.error_messages:
+        print("‚ùå ISSUE CONFIRMED: error_messages dictionary is shared between copies")
+        return False
+    else:
+        print("‚úÖ Issue fixed: error_messages are properly deep copied")
+        return True
+
+if __name__ == '__main__':
+    test_deepcopy_error_messages()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..40496f86ec
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python3
+"""
+Test edge cases for the deepcopy fix.
+"""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        USE_I18N=True,
+        USE_L10N=True,
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+    )
+    django.setup()
+
+import copy
+from django.forms import CharField
+
+def test_empty_error_messages():
+    print("Testing with empty error_messages...")
+    field1 = CharField(error_messages={})
+    field2 = copy.deepcopy(field1)
+    
+    # Add a custom error to the original
+    field1.error_messages['custom_error'] = 'Custom message'
+    
+    print(f"Original has custom_error: {'custom_error' in field1.error_messages}")
+    print(f"Copy has custom_error: {'custom_error' in field2.error_messages}")
+    
+    if 'custom_error' in field2.error_messages:
+        print("‚ùå Issue: Empty error_messages not handled properly")
+        return False
+    else:
+        print("‚úÖ Empty error_messages handled correctly")
+        return True
+
+def test_none_error_messages():
+    print("Testing with None error_messages...")
+    field1 = CharField(error_messages=None)
+    field2 = copy.deepcopy(field1)
+    
+    # Should inherit default error messages
+    print(f"Original required message: {field1.error_messages.get('required')}")
+    print(f"Copy required message: {field2.error_messages.get('required')}")
+    
+    # Modify original
+    field1.error_messages['required'] = 'Custom message'
+    
+    print(f"Original modified message: {field1.error_messages.get('required')}")
+    print(f"Copy message unchanged: {field2.error_messages.get('required')}")
+    
+    if field1.error_messages.get('required') == field2.error_messages.get('required'):
+        print("‚ùå Issue: None error_messages not handled properly")
+        return False
+    else:
+        print("‚úÖ None error_messages handled correctly")
+        return True
+
+def test_default_error_messages():
+    print("Testing with default error_messages...")
+    field1 = CharField()  # No custom error_messages
+    field2 = copy.deepcopy(field1)
+    
+    # Modify original default
+    field1.error_messages['required'] = 'Custom message'
+    
+    print(f"Original modified message: {field1.error_messages.get('required')}")
+    print(f"Copy default message: {field2.error_messages.get('required')}")
+    
+    if field1.error_messages.get('required') == field2.error_messages.get('required'):
+        print("‚ùå Issue: Default error_messages not handled properly")
+        return False
+    else:
+        print("‚úÖ Default error_messages handled correctly")
+        return True
+
+if __name__ == '__main__':
+    results = []
+    results.append(test_empty_error_messages())
+    results.append(test_none_error_messages())
+    results.append(test_default_error_messages())
+    
+    if all(results):
+        print("\n‚úÖ All edge cases passed!")
+    else:
+        print("\n‚ùå Some edge cases failed!")
\ No newline at end of file