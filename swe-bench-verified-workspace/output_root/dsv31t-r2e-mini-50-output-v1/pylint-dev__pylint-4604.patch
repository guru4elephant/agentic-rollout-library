diff --git a/debug_check_imports.py b/debug_check_imports.py
new file mode 100644
index 000000000..45048a337
--- /dev/null
+++ b/debug_check_imports.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+import astroid
+from pylint.checkers.variables import VariablesChecker, _fix_dot_imports
+from pylint.lint import PyLinter
+
+# Create a simple linter instance
+linter = PyLinter()
+checker = VariablesChecker(linter)
+
+# Parse code with type comment
+code = """from typing import Dict
+import abc
+
+X = ...  # type: Dict[str, abc.ABC]
+"""
+
+tree = astroid.parse(code)
+
+# Initialize the checker
+checker.open()
+checker.visit_module(tree)
+
+# Process all nodes
+for node in tree.body:
+    if isinstance(node, astroid.Assign):
+        if node.type_annotation:
+            checker._store_type_annotation_names(node)
+
+print(f"_type_annotation_names: {checker._type_annotation_names}")
+
+# Simulate the not_consumed dict that would be passed to _check_imports
+# This is a simplified version - the real one comes from NamesConsumer
+not_consumed = {}
+for node in tree.body:
+    if isinstance(node, (astroid.Import, astroid.ImportFrom)):
+        for import_name in node.names:
+            real_name = import_name[0]
+            not_consumed[real_name] = [node]
+
+print(f"not_consumed: {not_consumed}")
+
+# Apply the same logic as _fix_dot_imports
+local_names = _fix_dot_imports(not_consumed)
+print(f"local_names after _fix_dot_imports: {list(local_names)}")
+
+# Simulate the _check_imports logic
+checked = set()
+for name, stmt in local_names:
+    for imports in stmt.names:
+        real_name = imported_name = imports[0]
+        if imported_name == "*":
+            real_name = name
+        as_name = imports[1]
+        if real_name in checked:
+            continue
+        if name not in (real_name, as_name):
+            continue
+        checked.add(real_name)
+
+        is_type_annotation_import = (
+            imported_name in checker._type_annotation_names
+            or as_name in checker._type_annotation_names
+        )
+        
+        print(f"Checking import: {imported_name} (as_name: {as_name})")
+        print(f"is_type_annotation_import: {is_type_annotation_import}")
+        print(f"imported_name in _type_annotation_names: {imported_name in checker._type_annotation_names}")
+        print(f"as_name in _type_annotation_names: {as_name in checker._type_annotation_names if as_name else False}")
+
+checker.close()
\ No newline at end of file
diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 000000000..930d16f21
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python3
+
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Create a simple linter instance
+linter = PyLinter()
+checker = VariablesChecker(linter)
+
+# Parse code with type comment
+code = """from typing import Dict
+import abc
+
+X = ...  # type: Dict[str, abc.ABC]
+"""
+
+tree = astroid.parse(code)
+print("AST tree:")
+print(tree.repr_tree())
+
+# Initialize the checker
+checker.open()
+checker.visit_module(tree)
+
+# Process all nodes
+for node in tree.body:
+    if isinstance(node, astroid.Assign):
+        print(f"\nProcessing assignment: {node}")
+        print(f"Type annotation: {node.type_annotation}")
+        if node.type_annotation:
+            checker._store_type_annotation_names(node)
+            print(f"_type_annotation_names: {checker._type_annotation_names}")
+
+# Simulate the leave_module process
+print(f"\nBefore leave_module, _type_annotation_names: {checker._type_annotation_names}")
+
+# Get the not_consumed dict (simplified)
+not_consumed = {}
+for node in tree.body:
+    if isinstance(node, (astroid.Import, astroid.ImportFrom)):
+        for import_name in node.names:
+            real_name = import_name[0]
+            not_consumed[real_name] = [node]
+
+print(f"not_consumed: {not_consumed}")
+
+# Call _check_imports
+checker._check_imports(not_consumed)
+
+checker.close()
\ No newline at end of file
diff --git a/debug_proper.py b/debug_proper.py
new file mode 100644
index 000000000..ebf8f0580
--- /dev/null
+++ b/debug_proper.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Monkey patch the _check_imports method to add debug output
+original_check_imports = VariablesChecker._check_imports
+
+def debug_check_imports(self, not_consumed):
+    print(f"DEBUG: _check_imports called with not_consumed: {not_consumed}")
+    print(f"DEBUG: _type_annotation_names: {self._type_annotation_names}")
+    return original_check_imports(self, not_consumed)
+
+VariablesChecker._check_imports = debug_check_imports
+
+# Create a simple linter instance
+linter = PyLinter()
+checker = VariablesChecker(linter)
+
+# Parse code with type comment
+code = """from typing import Dict
+import abc
+
+X = ...  # type: Dict[str, abc.ABC]
+"""
+
+tree = astroid.parse(code)
+
+# Initialize the checker
+checker.open()
+checker.visit_module(tree)
+
+# Process all nodes individually to simulate the real pylint process
+for node in tree.body:
+    if isinstance(node, astroid.ImportFrom):
+        checker.visit_importfrom(node)
+    elif isinstance(node, astroid.Import):
+        checker.visit_import(node)
+    elif isinstance(node, astroid.Assign):
+        checker.visit_assign(node)
+        checker.leave_assign(node)
+
+checker.leave_module(tree)
+checker.close()
\ No newline at end of file
diff --git a/debug_real.py b/debug_real.py
new file mode 100644
index 000000000..37b386920
--- /dev/null
+++ b/debug_real.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Monkey patch the _check_imports method to add debug output
+original_check_imports = VariablesChecker._check_imports
+
+def debug_check_imports(self, not_consumed):
+    print(f"DEBUG: _check_imports called with not_consumed: {not_consumed}")
+    print(f"DEBUG: _type_annotation_names: {self._type_annotation_names}")
+    return original_check_imports(self, not_consumed)
+
+VariablesChecker._check_imports = debug_check_imports
+
+# Create a simple linter instance
+linter = PyLinter()
+checker = VariablesChecker(linter)
+
+# Parse code with type comment
+code = """from typing import Dict
+import abc
+
+X = ...  # type: Dict[str, abc.ABC]
+"""
+
+tree = astroid.parse(code)
+
+# Initialize the checker and process the module
+checker.open()
+checker.visit_module(tree)
+checker.leave_module(tree)
+checker.close()
\ No newline at end of file
diff --git a/debug_type_annotation.py b/debug_type_annotation.py
new file mode 100644
index 000000000..5ce971167
--- /dev/null
+++ b/debug_type_annotation.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python3
+
+import astroid
+from pylint.checkers.variables import VariablesChecker
+from pylint.lint import PyLinter
+
+# Create a simple linter instance
+linter = PyLinter()
+checker = VariablesChecker(linter)
+
+# Parse code with type comment
+code = """from typing import Dict
+import abc
+
+X = ...  # type: Dict[str, abc.ABC]
+"""
+
+tree = astroid.parse(code)
+print("AST tree:")
+print(tree.repr_tree())
+
+# Initialize the checker
+checker.open()
+checker.visit_module(tree)
+
+# Process the assignments
+for node in tree.body:
+    if isinstance(node, astroid.Assign):
+        print(f"\nProcessing assignment: {node}")
+        print(f"Type annotation: {node.type_annotation}")
+        if node.type_annotation:
+            checker._store_type_annotation_names(node)
+            print(f"_type_annotation_names: {checker._type_annotation_names}")
+
+checker.close()
\ No newline at end of file
diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 3ddafd599..6947e8380 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1826,6 +1826,12 @@ class VariablesChecker(BaseChecker):
             self._type_annotation_names.append(type_annotation.name)
             return
 
+        if isinstance(type_annotation, astroid.Attribute):
+            # Handle attribute nodes like abc.ABC in type comments
+            if isinstance(type_annotation.expr, astroid.Name):
+                self._type_annotation_names.append(type_annotation.expr.name)
+            return
+
         if not isinstance(type_annotation, astroid.Subscript):
             return
 
@@ -1837,6 +1843,11 @@ class VariablesChecker(BaseChecker):
             self._type_annotation_names.append(TYPING_MODULE)
             return
 
+        # Handle general attribute nodes in subscript values (e.g., typing.Dict, abc.ABC)
+        if isinstance(type_annotation.value, astroid.Attribute):
+            if isinstance(type_annotation.value.expr, astroid.Name):
+                self._type_annotation_names.append(type_annotation.value.expr.name)
+
         self._type_annotation_names.extend(
             annotation.name
             for annotation in type_annotation.nodes_of_class(astroid.Name)
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 000000000..ba4ac30f5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,7 @@
+"""Docstring."""
+
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
\ No newline at end of file
diff --git a/test_complex_types.py b/test_complex_types.py
new file mode 100644
index 000000000..629bd3b0e
--- /dev/null
+++ b/test_complex_types.py
@@ -0,0 +1,11 @@
+import abc
+import typing
+from typing import List, Dict, Union
+
+# Test complex type annotations
+X = ...  # type: typing.Dict[str, abc.ABC]
+Y = ...  # type: Union[abc.ABC, typing.List[str]]
+Z = ...  # type: List[abc.ABC]
+
+# Test nested attributes
+A = ...  # type: typing.Optional[typing.Dict[str, abc.ABC]]
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 000000000..ba238815f
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,17 @@
+import abc
+import typing
+from abc import ABC
+from typing import List, Optional
+
+# Test various type comment patterns
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
+Z = ...  # type: typing.List[str]
+W = ...  # type: List[str]
+V = ...  # type: Optional[abc.ABC]
+
+# Test nested attributes
+A = ...  # type: typing.Optional[abc.ABC]
+
+# Test multiple attributes in same comment
+B = ...  # type: typing.Union[abc.ABC, typing.List[str]]
\ No newline at end of file
diff --git a/test_simple.py b/test_simple.py
new file mode 100644
index 000000000..6563f45be
--- /dev/null
+++ b/test_simple.py
@@ -0,0 +1,5 @@
+import abc
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
\ No newline at end of file
diff --git a/test_simple_from_import.py b/test_simple_from_import.py
new file mode 100644
index 000000000..39c4c98d6
--- /dev/null
+++ b/test_simple_from_import.py
@@ -0,0 +1,3 @@
+from typing import Dict
+
+X = ...  # type: Dict[str, int]
\ No newline at end of file
diff --git a/test_unused_should_still_work.py b/test_unused_should_still_work.py
new file mode 100644
index 000000000..38bc2210a
--- /dev/null
+++ b/test_unused_should_still_work.py
@@ -0,0 +1,6 @@
+import abc
+import os  # This should be flagged as unused
+from abc import ABC
+
+X = ...  # type: abc.ABC
+Y = ...  # type: ABC
\ No newline at end of file