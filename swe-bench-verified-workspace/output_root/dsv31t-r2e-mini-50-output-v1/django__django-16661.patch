diff --git a/analyze_issue.py b/analyze_issue.py
new file mode 100644
index 0000000000..6c657df820
--- /dev/null
+++ b/analyze_issue.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def analyze_issue():
+    # Let's create the exact models from the issue
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    # Now let's examine the field relationships
+    print("=== Field Analysis ===")
+    
+    # Get the restaurant field from Waiter
+    restaurant_field = Waiter._meta.get_field('restaurant')
+    print(f"Waiter.restaurant field: {restaurant_field}")
+    print(f"  is_relation: {restaurant_field.is_relation}")
+    print(f"  path_infos: {restaurant_field.path_infos}")
+    
+    if restaurant_field.path_infos:
+        path_info = restaurant_field.path_infos[-1]
+        print(f"  path_info.to_opts.model: {path_info.to_opts.model}")
+        print(f"  path_info.target_fields: {path_info.target_fields}")
+        for tf in path_info.target_fields:
+            print(f"    target_field: {tf}, primary_key: {tf.primary_key}")
+    
+    # Get the place field from Restaurant
+    place_field = Restaurant._meta.get_field('place')
+    print(f"\nRestaurant.place field: {place_field}")
+    print(f"  is_relation: {place_field.is_relation}")
+    print(f"  path_infos: {place_field.path_infos}")
+    
+    if place_field.path_infos:
+        path_info = place_field.path_infos[-1]
+        print(f"  path_info.to_opts.model: {path_info.to_opts.model}")
+        print(f"  path_info.target_fields: {path_info.target_fields}")
+        for tf in path_info.target_fields:
+            print(f"    target_field: {tf}, primary_key: {tf.primary_key}")
+    
+    # Get the country field from Place
+    country_field = Place._meta.get_field('country')
+    print(f"\nPlace.country field: {country_field}")
+    print(f"  is_relation: {country_field.is_relation}")
+    print(f"  path_infos: {country_field.path_infos}")
+    
+    # Now let's simulate the problematic condition
+    print("\n=== Problematic Condition Analysis ===")
+    print("Checking: field not in prev_field.path_infos[-1].target_fields")
+    
+    # Simulate restaurant -> place
+    prev_field = restaurant_field
+    field = place_field
+    
+    if prev_field.path_infos:
+        target_fields = prev_field.path_infos[-1].target_fields
+        print(f"restaurant -> place: field in target_fields = {field in target_fields}")
+        print(f"  This should be False (field should NOT be in target_fields)")
+    
+    # Simulate place -> country  
+    prev_field = place_field
+    field = country_field
+    
+    if prev_field.path_infos:
+        target_fields = prev_field.path_infos[-1].target_fields
+        print(f"place -> country: field in target_fields = {field in target_fields}")
+        print(f"  This should be False (field should NOT be in target_fields)")
+
+if __name__ == '__main__':
+    analyze_issue()
\ No newline at end of file
diff --git a/debug_lookup.py b/debug_lookup.py
new file mode 100644
index 0000000000..3d4681aad5
--- /dev/null
+++ b/debug_lookup.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+# Let's debug the lookup_allowed method by creating a simplified version
+def debug_lookup_allowed():
+    # Create a mock version to understand the logic
+    class MockField:
+        def __init__(self, is_relation=False, path_infos=None, primary_key=False):
+            self.is_relation = is_relation
+            self.path_infos = path_infos
+            self.primary_key = primary_key
+            
+    class MockPathInfo:
+        def __init__(self, target_fields=None):
+            self.target_fields = target_fields or []
+            
+    class MockModel:
+        def __init__(self, name):
+            self._meta = MockMeta(name)
+            
+    class MockMeta:
+        def __init__(self, name):
+            self.model_name = name
+            
+        def get_field(self, field_name):
+            # Simulate the field lookup
+            if field_name == 'restaurant':
+                field = MockField(is_relation=True)
+                field.path_infos = [MockPathInfo([MockField()])]
+                return field
+            elif field_name == 'place':
+                field = MockField(is_relation=True)
+                field.path_infos = [MockPathInfo([MockField(primary_key=True)])]  # This is the key issue
+                return field
+            elif field_name == 'country':
+                field = MockField(is_relation=False)
+                return field
+            raise Exception(f"Field {field_name} not found")
+    
+    # Simulate the relation_parts building logic
+    lookup = 'restaurant__place__country'
+    LOOKUP_SEP = '__'
+    
+    model = MockModel('Waiter')
+    relation_parts = []
+    prev_field = None
+    
+    print(f"Processing lookup: {lookup}")
+    
+    for part in lookup.split(LOOKUP_SEP):
+        print(f"Processing part: {part}")
+        try:
+            field = model._meta.get_field(part)
+            print(f"  Found field: {part}, is_relation: {field.is_relation}, path_infos: {bool(field.path_infos)}")
+            
+            if prev_field:
+                print(f"  prev_field.is_relation: {prev_field.is_relation}")
+                if prev_field.path_infos:
+                    target_fields = prev_field.path_infos[-1].target_fields
+                    print(f"  target_fields: {[f.primary_key for f in target_fields]}")
+                    print(f"  field in target_fields: {field in target_fields}")
+            
+            # This is the problematic condition
+            if not prev_field or (
+                prev_field.is_relation
+                and field not in prev_field.path_infos[-1].target_fields
+            ):
+                relation_parts.append(part)
+                print(f"  Added to relation_parts: {part}")
+            
+            if not getattr(field, "path_infos", None):
+                print(f"  Breaking - no path_infos")
+                break
+                
+            prev_field = field
+            model = MockModel(part)  # Simplified
+            
+        except Exception as e:
+            print(f"  Error: {e}")
+            break
+    
+    print(f"Final relation_parts: {relation_parts}")
+    print(f"LOOKUP_SEP.join(relation_parts): {LOOKUP_SEP.join(relation_parts)}")
+
+if __name__ == '__main__':
+    debug_lookup_allowed()
\ No newline at end of file
diff --git a/debug_test5.py b/debug_test5.py
new file mode 100644
index 0000000000..ea3e8e61bd
--- /dev/null
+++ b/debug_test5.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def debug_test5():
+    # Test 5: Lookup not in list_filter (should return False)
+    class NormalRestaurant(models.Model):
+        name = models.CharField(max_length=100)
+        other_field = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test'
+
+    class NormalWaiter(models.Model):
+        restaurant = models.ForeignKey(NormalRestaurant, models.CASCADE)
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test'
+
+    class NormalWaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__name',
+        ]
+
+    site = AdminSite()
+    ma = NormalWaiterAdmin(NormalWaiter, site)
+    
+    # Test the lookup that should return False
+    result = ma.lookup_allowed('restaurant__other_field', 'test_value')
+    print(f"Test 5 - Lookup not in list_filter: {result} (Expected: False)")
+    
+    # Let's also debug what relation_parts gets built
+    print("\n=== Debugging relation_parts building ===")
+    
+    # Simulate the lookup_allowed logic
+    lookup = 'restaurant__other_field'
+    LOOKUP_SEP = '__'
+    
+    model = NormalWaiter
+    relation_parts = []
+    prev_field = None
+    
+    print(f"Processing lookup: {lookup}")
+    
+    for part in lookup.split(LOOKUP_SEP):
+        print(f"Processing part: {part}")
+        try:
+            field = model._meta.get_field(part)
+            print(f"  Found field: {part}, is_relation: {field.is_relation}")
+            
+            if prev_field:
+                print(f"  prev_field.is_relation: {prev_field.is_relation}")
+                if hasattr(prev_field, 'path_infos') and prev_field.path_infos:
+                    target_fields = prev_field.path_infos[-1].target_fields
+                    print(f"  target_fields: {[f.name for f in target_fields]}")
+                    print(f"  field in target_fields: {field in target_fields}")
+                    if field in target_fields:
+                        print(f"  field.primary_key: {field.primary_key}")
+                        print(f"  field.is_relation: {field.is_relation}")
+                        print(f"  hasattr(field, 'path_infos'): {hasattr(field, 'path_infos')}")
+            
+            # Check the conditions
+            condition1 = not prev_field
+            condition2 = prev_field and prev_field.is_relation and field not in prev_field.path_infos[-1].target_fields
+            condition3 = (
+                prev_field and prev_field.is_relation 
+                and field in prev_field.path_infos[-1].target_fields
+                and field.primary_key
+                and field.is_relation
+                and hasattr(field, 'path_infos')
+            )
+            
+            print(f"  condition1 (not prev_field): {condition1}")
+            print(f"  condition2 (normal): {condition2}")
+            print(f"  condition3 (special case): {condition3}")
+            
+            if condition1 or condition2 or condition3:
+                relation_parts.append(part)
+                print(f"  Added to relation_parts: {part}")
+            
+            if not getattr(field, "path_infos", None):
+                print(f"  Breaking - no path_infos")
+                break
+                
+            prev_field = field
+            model = field.path_infos[-1].to_opts.model
+            
+        except Exception as e:
+            print(f"  Error: {e}")
+            break
+    
+    print(f"Final relation_parts: {relation_parts}")
+    print(f"LOOKUP_SEP.join(relation_parts): {'__'.join(relation_parts)}")
+    
+    # Check if this matches valid lookups
+    valid_lookups = {'restaurant__name'}  # From list_filter
+    lookup_to_check = '__'.join(relation_parts)
+    print(f"Lookup to check: {lookup_to_check}")
+    print(f"Is in valid_lookups: {lookup_to_check in valid_lookups}")
+
+if __name__ == '__main__':
+    debug_test5()
\ No newline at end of file
diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5240b07cd6..4a40ff0806 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -469,6 +469,16 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
                 and field not in prev_field.path_infos[-1].target_fields
             ):
                 relation_parts.append(part)
+            elif (
+                prev_field.is_relation
+                and field in prev_field.path_infos[-1].target_fields
+                and field.primary_key
+                and field.is_relation
+                and hasattr(field, 'path_infos')
+            ):
+                # Special case: when a foreign key is used as primary key and is a relational field,
+                # we still need to track the relationship path for proper lookup validation.
+                relation_parts.append(part)
             if not getattr(field, "path_infos", None):
                 # This is not a relational field, so further parts
                 # must be transforms.
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..8c35a38343
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def test_github_issue():
+    """Test the exact scenario described in the GitHub issue"""
+    
+    # Create the exact models from the issue
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+    
+    # Test the exact lookup from the issue
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"Result: {result}")
+    print(f"Expected: True")
+    
+    if result == True:
+        print("✓ GitHub issue FIXED!")
+        return True
+    else:
+        print("✗ GitHub issue NOT fixed!")
+        return False
+
+if __name__ == '__main__':
+    success = test_github_issue()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..5981b6885d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+            'tests.modeladmin',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def test_lookup_allowed_foreign_primary():
+    # Import the existing test models to avoid creating new ones
+    from tests.modeladmin.models import Band, Concert, Song
+    
+    # Create a test case similar to the issue description
+    class Waiter(models.Model):
+        name = models.CharField(max_length=100)
+        restaurant = models.ForeignKey(Band, models.CASCADE)
+        
+        class Meta:
+            app_label = 'modeladmin'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__name',
+        ]
+
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+    
+    # Test a simple lookup first
+    result = ma.lookup_allowed('restaurant__name', 'test_value')
+    print(f"Simple lookup result: {result}")
+    
+    return result == True
+
+if __name__ == '__main__':
+    success = test_lookup_allowed_foreign_primary()
+    print(f"Test {'PASSED' if success else 'FAILED'}")
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..f73666381d
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,127 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def test_comprehensive_lookup_allowed():
+    """Test various lookup_allowed scenarios to ensure the fix doesn't break existing functionality"""
+    
+    # Test 1: The original issue - foreign key as primary key
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+    
+    # Test the lookup that was failing
+    result1 = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"Test 1 - Foreign key as primary key: {result1} (Expected: True)")
+    
+    # Test 2: Normal foreign key relationship (should still work)
+    class NormalRestaurant(models.Model):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test'
+
+    class NormalWaiter(models.Model):
+        restaurant = models.ForeignKey(NormalRestaurant, models.CASCADE)
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = 'test'
+
+    class NormalWaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__name',
+        ]
+
+    ma2 = NormalWaiterAdmin(NormalWaiter, site)
+    result2 = ma2.lookup_allowed('restaurant__name', 'test_value')
+    print(f"Test 2 - Normal foreign key: {result2} (Expected: True)")
+    
+    # Test 3: Non-existent lookup (should return True as per existing behavior)
+    result3 = ma2.lookup_allowed('restaurant__nonexistent', 'test_value')
+    print(f"Test 3 - Non-existent lookup: {result3} (Expected: True)")
+    
+    # Test 4: Local field (should return True)
+    result4 = ma2.lookup_allowed('name', 'test_value')
+    print(f"Test 4 - Local field: {result4} (Expected: True)")
+    
+    # Test 5: Lookup not in list_filter (should return False)
+    result5 = ma2.lookup_allowed('restaurant__other_field', 'test_value')
+    print(f"Test 5 - Lookup not in list_filter: {result5} (Expected: False)")
+    
+    # All tests should pass
+    all_passed = (
+        result1 == True and  # The main fix
+        result2 == True and  # Normal functionality
+        result3 == True and  # Non-existent fields (existing behavior)
+        result4 == True and  # Local fields
+        result5 == False     # Invalid lookups
+    )
+    
+    if all_passed:
+        print("✓ All tests PASSED!")
+        return True
+    else:
+        print("✗ Some tests FAILED!")
+        return False
+
+if __name__ == '__main__':
+    success = test_comprehensive_lookup_allowed()
+    sys.exit(0 if success else 1)
\ No newline at end of file
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..8511cdb9fb
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from django.conf import settings
+from django.db import models
+from django.contrib.admin import ModelAdmin
+from django.contrib.admin.sites import AdminSite
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.admin',
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+from django import setup
+setup()
+
+def test_lookup_allowed_foreign_primary():
+    # Create the exact models from the GitHub issue
+    class Country(models.Model):
+        name = models.CharField(max_length=256)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Place(models.Model):
+        country = models.ForeignKey(Country, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Restaurant(models.Model):
+        place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        
+        class Meta:
+            app_label = 'test'
+
+    class Waiter(models.Model):
+        restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        
+        class Meta:
+            app_label = 'test'
+
+    class WaiterAdmin(ModelAdmin):
+        list_filter = [
+            'restaurant__place__country',
+        ]
+
+    site = AdminSite()
+    ma = WaiterAdmin(Waiter, site)
+    
+    # Test the lookup that was failing
+    result = ma.lookup_allowed('restaurant__place__country', 'test_value')
+    print(f"Result: {result}")
+    print(f"Expected: True")
+    
+    if result == True:
+        print("✓ Test PASSED - Fix is working!")
+        return True
+    else:
+        print("✗ Test FAILED - Fix is not working")
+        return False
+
+if __name__ == '__main__':
+    success = test_lookup_allowed_foreign_primary()
+    sys.exit(0 if success else 1)
\ No newline at end of file