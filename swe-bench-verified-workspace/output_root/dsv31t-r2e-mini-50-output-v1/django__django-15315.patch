diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 88c9ca9f28..ed8a619f56 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -542,11 +542,7 @@ class Field(RegisterLookupMixin):
         return NotImplemented
 
     def __hash__(self):
-        return hash((
-            self.creation_counter,
-            self.model._meta.app_label if hasattr(self, 'model') else None,
-            self.model._meta.model_name if hasattr(self, 'model') else None,
-        ))
+        return hash((self.creation_counter, self.__class__))
 
     def __deepcopy__(self, memodict):
         # We don't have to deepcopy very much here, since most things are not
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f9880931e6
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+
+# Reproduce the issue described in the GitHub issue
+f = models.CharField(max_length=200)
+d = {f: 1}
+
+class Book(models.Model):
+    title = f
+    
+    class Meta:
+        app_label = 'test'
+
+print(f"Hash before assignment: {hash(f)}")
+print(f"Hash after assignment: {hash(f)}")
+print(f"Dictionary contents: {d}")
+print(f"Is f in d? {f in d}")
+
+try:
+    assert f in d
+    print("SUCCESS: Assertion passed")
+except AssertionError:
+    print("FAILURE: Assertion failed - field not found in dictionary after assignment")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..b2bb97247f
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,142 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+
+def test_hash_immutability():
+    """Test that field hash doesn't change after assignment to model"""
+    print("=== Testing hash immutability ===")
+    
+    # Test the original issue
+    f = models.CharField(max_length=200)
+    original_hash = hash(f)
+    d = {f: 1}
+    
+    class Book(models.Model):
+        title = f
+        
+        class Meta:
+            app_label = 'test'
+    
+    new_hash = hash(f)
+    
+    print(f"Hash before assignment: {original_hash}")
+    print(f"Hash after assignment: {new_hash}")
+    print(f"Hash unchanged: {original_hash == new_hash}")
+    print(f"Field in dictionary: {f in d}")
+    
+    assert original_hash == new_hash, "Hash changed after assignment"
+    assert f in d, "Field not found in dictionary after assignment"
+    print("‚úì Hash immutability test passed")
+
+def test_hash_uniqueness():
+    """Test that different fields have different hashes"""
+    print("\n=== Testing hash uniqueness ===")
+    
+    # Create multiple fields
+    field1 = models.CharField(max_length=100)
+    field2 = models.IntegerField()
+    field3 = models.BooleanField()
+    
+    hashes = {hash(field1), hash(field2), hash(field3)}
+    print(f"Unique hashes for 3 different fields: {len(hashes) == 3}")
+    
+    assert len(hashes) == 3, "Hash collisions detected"
+    print("‚úì Hash uniqueness test passed")
+
+def test_dictionary_behavior():
+    """Test that fields work correctly in dictionaries"""
+    print("\n=== Testing dictionary behavior ===")
+    
+    # Create fields and add to dictionary
+    fields_dict = {}
+    field1 = models.CharField(max_length=100)
+    field2 = models.IntegerField()
+    
+    fields_dict[field1] = "char_field"
+    fields_dict[field2] = "int_field"
+    
+    # Assign fields to models
+    class TestModel1(models.Model):
+        field = field1
+        
+        class Meta:
+            app_label = 'test'
+    
+    class TestModel2(models.Model):
+        field = field2
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Check that fields are still in dictionary
+    assert field1 in fields_dict, "Field1 not found in dictionary after assignment"
+    assert field2 in fields_dict, "Field2 not found in dictionary after assignment"
+    assert fields_dict[field1] == "char_field", "Wrong value for field1"
+    assert fields_dict[field2] == "int_field", "Wrong value for field2"
+    
+    print("‚úì Dictionary behavior test passed")
+
+def test_set_behavior():
+    """Test that fields work correctly in sets"""
+    print("\n=== Testing set behavior ===")
+    
+    # Create fields and add to set
+    field_set = set()
+    field1 = models.CharField(max_length=100)
+    field2 = models.IntegerField()
+    
+    field_set.add(field1)
+    field_set.add(field2)
+    
+    # Assign fields to models
+    class TestModel1(models.Model):
+        field = field1
+        
+        class Meta:
+            app_label = 'test'
+    
+    class TestModel2(models.Model):
+        field = field2
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Check that fields are still in set
+    assert field1 in field_set, "Field1 not found in set after assignment"
+    assert field2 in field_set, "Field2 not found in set after assignment"
+    assert len(field_set) == 2, "Set size changed after assignment"
+    
+    print("‚úì Set behavior test passed")
+
+if __name__ == "__main__":
+    try:
+        test_hash_immutability()
+        test_hash_uniqueness()
+        test_dictionary_behavior()
+        test_set_behavior()
+        print("\nüéâ All tests passed!")
+    except Exception as e:
+        print(f"\n‚ùå Test failed: {e}")
+        raise
\ No newline at end of file
diff --git a/test_equality_hash_consistency.py b/test_equality_hash_consistency.py
new file mode 100644
index 0000000000..0ba2afaa2c
--- /dev/null
+++ b/test_equality_hash_consistency.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+import unittest
+
+class EqualityHashConsistencyTests(unittest.TestCase):
+    
+    def test_equality_hash_consistency(self):
+        """Test that equal fields have equal hashes (hash/eq consistency)"""
+        # Create two identical fields
+        field1 = models.CharField(max_length=100)
+        field2 = models.CharField(max_length=100)
+        
+        # They should not be equal (different creation counters)
+        self.assertNotEqual(field1, field2)
+        self.assertNotEqual(hash(field1), hash(field2))
+        
+        # Create another field of different type with same creation counter
+        field3 = models.IntegerField()
+        field3.creation_counter = field1.creation_counter
+        
+        # They should have different hashes due to different classes
+        self.assertNotEqual(hash(field1), hash(field3))
+    
+    def test_hash_eq_contract(self):
+        """Test that the hash/eq contract is maintained"""
+        # If a == b, then hash(a) == hash(b)
+        field1 = models.CharField(max_length=100)
+        
+        # field1 should be equal to itself
+        self.assertEqual(field1, field1)
+        self.assertEqual(hash(field1), hash(field1))
+        
+        # Test after assignment to model
+        class TestModel(models.Model):
+            title = field1
+            
+            class Meta:
+                app_label = 'test_contract'
+        
+        # field1 should still be equal to itself after assignment
+        self.assertEqual(field1, field1)
+        self.assertEqual(hash(field1), hash(field1))
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file
diff --git a/test_hash_fix.py b/test_hash_fix.py
new file mode 100644
index 0000000000..a74b5098e0
--- /dev/null
+++ b/test_hash_fix.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+import unittest
+
+class FieldHashTests(unittest.TestCase):
+    
+    def test_hash_immutability(self):
+        """Test that field hash doesn't change after assignment to model"""
+        f = models.CharField(max_length=200)
+        original_hash = hash(f)
+        d = {f: 1}
+        
+        class Book(models.Model):
+            title = f
+            
+            class Meta:
+                app_label = 'test_hash'
+        
+        new_hash = hash(f)
+        
+        self.assertEqual(original_hash, new_hash, "Hash changed after assignment")
+        self.assertIn(f, d, "Field not found in dictionary after assignment")
+    
+    def test_hash_uniqueness(self):
+        """Test that different fields have different hashes"""
+        field1 = models.CharField(max_length=100)
+        field2 = models.IntegerField()
+        field3 = models.BooleanField()
+        
+        hashes = {hash(field1), hash(field2), hash(field3)}
+        self.assertEqual(len(hashes), 3, "Hash collisions detected")
+    
+    def test_dictionary_behavior(self):
+        """Test that fields work correctly in dictionaries"""
+        fields_dict = {}
+        field1 = models.CharField(max_length=100)
+        field2 = models.IntegerField()
+        
+        fields_dict[field1] = "char_field"
+        fields_dict[field2] = "int_field"
+        
+        # Assign fields to models
+        class TestModel1(models.Model):
+            field = field1
+            
+            class Meta:
+                app_label = 'test_dict'
+        
+        class TestModel2(models.Model):
+            field = field2
+            
+            class Meta:
+                app_label = 'test_dict'
+        
+        # Check that fields are still in dictionary
+        self.assertIn(field1, fields_dict)
+        self.assertIn(field2, fields_dict)
+        self.assertEqual(fields_dict[field1], "char_field")
+        self.assertEqual(fields_dict[field2], "int_field")
+    
+    def test_set_behavior(self):
+        """Test that fields work correctly in sets"""
+        field_set = set()
+        field1 = models.CharField(max_length=100)
+        field2 = models.IntegerField()
+        
+        field_set.add(field1)
+        field_set.add(field2)
+        
+        # Assign fields to models
+        class TestModel1(models.Model):
+            field = field1
+            
+            class Meta:
+                app_label = 'test_set'
+        
+        class TestModel2(models.Model):
+            field = field2
+            
+            class Meta:
+                app_label = 'test_set'
+        
+        # Check that fields are still in set
+        self.assertIn(field1, field_set)
+        self.assertIn(field2, field_set)
+        self.assertEqual(len(field_set), 2)
+
+if __name__ == '__main__':
+    unittest.main()
\ No newline at end of file