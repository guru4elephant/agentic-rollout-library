diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
index ac0b62d0bf..f746654ace 100644
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -14,7 +14,7 @@ __all__ = [
 
 
 class Aggregate(Func):
-    template = '%(function)s(%(distinct)s%(expressions)s)'
+    template = '%(function)s(%(distinct)s %(expressions)s)'
     contains_aggregate = True
     name = None
     filter_template = '%s FILTER (WHERE %%(filter)s)'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..68dc4ada9d
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count, Case, When, Q
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the issue: Count with both distinct=True and Case condition
+try:
+    # This should produce the error: COUNT(DISTINCTCASE WHEN ...) instead of COUNT(DISTINCT CASE WHEN ...)
+    queryset = TestModel.objects.annotate(
+        count_field=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            ),
+            distinct=True
+        )
+    )
+    
+    # Try to generate the SQL to see the error
+    print("Generating SQL query...")
+    sql, params = queryset.query.sql_with_params()
+    print(f"SQL: {sql}")
+    print(f"Params: {params}")
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
\ No newline at end of file
diff --git a/test_aggregation_fix.py b/test_aggregation_fix.py
new file mode 100644
index 0000000000..1a86a171f4
--- /dev/null
+++ b/test_aggregation_fix.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count, Case, When, Q
+
+# Test the specific issue mentioned in the GitHub issue
+print("Testing the specific GitHub issue scenario...")
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the exact scenario from the issue: Count with both Case condition and distinct=True
+try:
+    queryset = TestModel.objects.annotate(
+        count_field=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            ),
+            distinct=True
+        )
+    )
+    
+    sql, params = queryset.query.sql_with_params()
+    print(f"Generated SQL: {sql}")
+    
+    # Check if the issue is fixed
+    if "COUNT(DISTINCT CASE" in sql:
+        print("✓ SUCCESS: The issue has been fixed! Space correctly added between DISTINCT and CASE")
+    elif "COUNT(DISTINCTCASE" in sql:
+        print("✗ FAILED: The issue still exists - no space between DISTINCT and CASE")
+    else:
+        print("? UNKNOWN: Unexpected SQL format")
+        
+except Exception as e:
+    print(f"✗ ERROR: {e}")
+    import traceback
+    traceback.print_exc()
+
+print("\nTesting that normal COUNT operations still work...")
+
+# Test normal COUNT with distinct
+try:
+    queryset2 = TestModel.objects.annotate(
+        count_normal=Count('value', distinct=True)
+    )
+    sql2, params2 = queryset2.query.sql_with_params()
+    print(f"Normal COUNT with distinct: {sql2}")
+    print("✓ Normal COUNT operations work correctly")
+except Exception as e:
+    print(f"✗ Normal COUNT operations failed: {e}")
+
+# Test COUNT with Case but no distinct
+try:
+    queryset3 = TestModel.objects.annotate(
+        count_case=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            )
+        )
+    )
+    sql3, params3 = queryset3.query.sql_with_params()
+    print(f"COUNT with Case, no distinct: {sql3}")
+    print("✓ COUNT with Case (no distinct) works correctly")
+except Exception as e:
+    print(f"✗ COUNT with Case (no distinct) failed: {e}")
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..d2f57bb083
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count, Case, When, Q
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test case 1: Count with distinct=True but no Case (should work as before)
+print("Test 1: Count with distinct=True but no Case")
+try:
+    queryset1 = TestModel.objects.annotate(
+        count_field=Count('value', distinct=True)
+    )
+    sql1, params1 = queryset1.query.sql_with_params()
+    print(f"SQL: {sql1}")
+    print("✓ PASSED")
+except Exception as e:
+    print(f"✗ FAILED: {e}")
+
+# Test case 2: Count with Case but no distinct (should work as before)
+print("\nTest 2: Count with Case but no distinct")
+try:
+    queryset2 = TestModel.objects.annotate(
+        count_field=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            )
+        )
+    )
+    sql2, params2 = queryset2.query.sql_with_params()
+    print(f"SQL: {sql2}")
+    print("✓ PASSED")
+except Exception as e:
+    print(f"✗ FAILED: {e}")
+
+# Test case 3: Count with both distinct=True and Case (the original issue)
+print("\nTest 3: Count with both distinct=True and Case")
+try:
+    queryset3 = TestModel.objects.annotate(
+        count_field=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            ),
+            distinct=True
+        )
+    )
+    sql3, params3 = queryset3.query.sql_with_params()
+    print(f"SQL: {sql3}")
+    if "DISTINCT CASE" in sql3:
+        print("✓ PASSED - Space correctly added")
+    else:
+        print("✗ FAILED - Space not found")
+except Exception as e:
+    print(f"✗ FAILED: {e}")
+
+# Test case 4: Count with distinct=False and Case (should work as before)
+print("\nTest 4: Count with distinct=False and Case")
+try:
+    queryset4 = TestModel.objects.annotate(
+        count_field=Count(
+            Case(
+                When(Q(value__gt=5), then=models.F('value'))
+            ),
+            distinct=False
+        )
+    )
+    sql4, params4 = queryset4.query.sql_with_params()
+    print(f"SQL: {sql4}")
+    print("✓ PASSED")
+except Exception as e:
+    print(f"✗ FAILED: {e}")
\ No newline at end of file
diff --git a/test_no_extra_spaces.py b/test_no_extra_spaces.py
new file mode 100644
index 0000000000..137f257dd4
--- /dev/null
+++ b/test_no_extra_spaces.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count
+
+# Test that no extra spaces are introduced when distinct=False
+print("Testing that no extra spaces are introduced...")
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test COUNT without distinct
+try:
+    queryset = TestModel.objects.annotate(
+        count_field=Count('value', distinct=False)
+    )
+    sql, params = queryset.query.sql_with_params()
+    print(f"COUNT without distinct: {sql}")
+    
+    # Check for double spaces or other spacing issues
+    if "  " in sql:  # Check for double spaces
+        print("✗ FAILED: Double spaces found in SQL")
+    elif sql.count("COUNT(") != sql.count("COUNT (") and "COUNT (value)" not in sql:
+        print("✓ PASSED: No extra spaces introduced")
+    else:
+        print("? UNKNOWN: Check SQL formatting manually")
+        
+except Exception as e:
+    print(f"✗ ERROR: {e}")
+
+# Test COUNT with distinct=False explicitly
+try:
+    queryset = TestModel.objects.annotate(
+        count_field=Count('value', distinct=False)
+    )
+    sql, params = queryset.query.sql_with_params()
+    print(f"COUNT with distinct=False: {sql}")
+    
+    # Should not have DISTINCT keyword
+    if "DISTINCT" in sql:
+        print("✗ FAILED: DISTINCT keyword found when distinct=False")
+    else:
+        print("✓ PASSED: No DISTINCT keyword when distinct=False")
+        
+except Exception as e:
+    print(f"✗ ERROR: {e}")
\ No newline at end of file
diff --git a/test_other_aggregates.py b/test_other_aggregates.py
new file mode 100644
index 0000000000..cf0405eb49
--- /dev/null
+++ b/test_other_aggregates.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import Count, Sum, Avg, Case, When, Q
+
+# Test other aggregate functions to ensure they still work
+print("Testing other aggregate functions...")
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    value = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Test Sum with distinct
+try:
+    queryset = TestModel.objects.annotate(
+        sum_field=Sum('value', distinct=True)
+    )
+    sql, params = queryset.query.sql_with_params()
+    print(f"SUM with distinct: {sql}")
+    print("✓ SUM with distinct works correctly")
+except Exception as e:
+    print(f"✗ SUM with distinct failed: {e}")
+
+# Test Avg with distinct
+try:
+    queryset = TestModel.objects.annotate(
+        avg_field=Avg('value', distinct=True)
+    )
+    sql, params = queryset.query.sql_with_params()
+    print(f"AVG with distinct: {sql}")
+    print("✓ AVG with distinct works correctly")
+except Exception as e:
+    print(f"✗ AVG with distinct failed: {e}")
+
+# Test Count with distinct on a regular field (not Case)
+try:
+    queryset = TestModel.objects.annotate(
+        count_field=Count('value', distinct=True)
+    )
+    sql, params = queryset.query.sql_with_params()
+    print(f"COUNT with distinct on regular field: {sql}")
+    print("✓ COUNT with distinct on regular field works correctly")
+except Exception as e:
+    print(f"✗ COUNT with distinct on regular field failed: {e}")
\ No newline at end of file