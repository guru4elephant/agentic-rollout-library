diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 00000000..e4646dea
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Comprehensive test to verify the fix handles all edge cases properly
+"""
+
+import sys
+import os
+
+# Add the current directory to Python path so we can import requests
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from requests.sessions import Session
+from requests.utils import to_native_string
+from requests.compat import builtin_str
+
+def test_all_edge_cases():
+    """Test the fix with various edge cases"""
+    print("Testing edge cases for method conversion:")
+    
+    # Test cases that should work
+    test_cases = [
+        # Normal cases
+        ('GET', 'GET'),
+        ('POST', 'POST'),
+        ('PUT', 'PUT'),
+        ('DELETE', 'DELETE'),
+        ('HEAD', 'HEAD'),
+        
+        # Binary cases (the main issue)
+        (b'GET', 'GET'),
+        (b'POST', 'POST'),
+        (b'PUT', 'PUT'),
+        (b'DELETE', 'DELETE'),
+        (b'HEAD', 'HEAD'),
+        
+        # Edge cases
+        ('', ''),
+        (b'', ''),
+        ('CUSTOM', 'CUSTOM'),
+        (b'CUSTOM', 'CUSTOM'),
+        
+        # Unicode cases
+        ('GÉT', 'GÉT'),  # Unicode string
+        (b'GET\xc3\xa9', 'GETé'),  # UTF-8 encoded binary
+    ]
+    
+    for input_method, expected in test_cases:
+        try:
+            # Test our fix
+            result = to_native_string(input_method)
+            
+            if result == expected:
+                print(f"✓ {repr(input_method)} -> '{result}' (CORRECT)")
+            else:
+                print(f"✗ {repr(input_method)} -> '{result}' (expected '{expected}')")
+                
+        except Exception as e:
+            print(f"✗ {repr(input_method)} -> ERROR: {e}")
+    
+    print("\nTesting that the old behavior was broken:")
+    
+    # Show the old bug
+    binary_methods = [b'GET', b'POST', b'PUT', b'DELETE', b'HEAD']
+    for method in binary_methods:
+        old_result = builtin_str(method)
+        new_result = to_native_string(method)
+        print(f"Old: {repr(method)} -> '{old_result}' (BUG!)")
+        print(f"New: {repr(method)} -> '{new_result}' (FIXED!)")
+        print()
+
+def test_session_integration():
+    """Test that the Session class works with our fix"""
+    print("Testing Session integration:")
+    
+    session = Session()
+    
+    # Test that we can create requests with binary methods
+    test_methods = [b'GET', b'POST', b'PUT', b'DELETE']
+    
+    for method in test_methods:
+        try:
+            # This tests the method processing in Session.request
+            req = session.prepare_request(session.request(method, 'http://example.com'))
+            print(f"✓ {repr(method)} -> Request with method '{req.method}' created successfully")
+        except Exception as e:
+            # Network errors are expected, we just care about method processing
+            if 'method' in str(e).lower() or 'Method' in str(e):
+                print(f"✗ {repr(method)} -> Method-related error: {e}")
+            else:
+                print(f"✓ {repr(method)} -> Method processed correctly (network error: {type(e).__name__})")
+
+if __name__ == "__main__":
+    test_all_edge_cases()
+    test_session_integration()
+    print("\nAll tests completed!")
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..b2cec2a3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Script to reproduce the builtin_str method issue
+"""
+
+from requests.compat import builtin_str
+
+# Test case 1: Normal string (should work fine)
+normal_method = 'GET'
+result1 = builtin_str(normal_method)
+print(f"Normal string '{normal_method}' -> '{result1}'")
+
+# Test case 2: Binary string (this is the problematic case)
+binary_method = b'GET'
+result2 = builtin_str(binary_method)
+print(f"Binary string {binary_method} -> '{result2}'")
+
+# Test case 3: Test what happens when we try to use this in a request
+print(f"\nTesting if '{result2}' would be a valid HTTP method:")
+
+# This should show the issue - the method becomes "b'GET'" instead of "GET"
+if result2 == "b'GET'":
+    print("BUG CONFIRMED: Binary string converted to literal string representation")
+else:
+    print("No bug detected")
+
+# Test case 4: Show what we expect to happen
+expected_result = binary_method.decode('utf-8')
+print(f"Expected result: {binary_method} -> '{expected_result}'")
+
+if result2 != expected_result:
+    print("BUG: builtin_str doesn't handle binary strings properly")
+else:
+    print("builtin_str handles binary strings correctly")
\ No newline at end of file
diff --git a/requests/sessions.py b/requests/sessions.py
index d701ff2e..adcfbac7 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -425,7 +425,7 @@ class Session(SessionRedirectMixin):
             If Tuple, ('cert', 'key') pair.
         """
 
-        method = builtin_str(method)
+        method = to_native_string(method)
 
         # Create the Request.
         req = Request(
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 00000000..5f34fbff
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Test script to verify the fix for the builtin_str method issue
+"""
+
+from requests.compat import builtin_str
+from requests.utils import to_native_string
+
+# Test the original issue
+print("Testing the original issue:")
+binary_method = b'GET'
+
+# This should show the bug (if not fixed)
+original_result = builtin_str(binary_method)
+print(f"builtin_str({binary_method}) = '{original_result}'")
+
+# This should show the fix
+fixed_result = to_native_string(binary_method)
+print(f"to_native_string({binary_method}) = '{fixed_result}'")
+
+# Test that the fix works correctly
+if fixed_result == 'GET':
+    print("✓ Fix works correctly - binary string properly decoded")
+else:
+    print("✗ Fix does not work - unexpected result")
+
+# Test edge cases
+print("\nTesting edge cases:")
+
+# Test with normal string
+normal_method = 'POST'
+normal_result = to_native_string(normal_method)
+print(f"to_native_string('{normal_method}') = '{normal_result}'")
+
+# Test with empty binary string
+empty_binary = b''
+empty_result = to_native_string(empty_binary)
+print(f"to_native_string({empty_binary}) = '{empty_result}'")
+
+# Test with unicode binary string
+unicode_binary = b'TEST\xc3\xa9'  # UTF-8 encoded 'TESTé'
+unicode_result = to_native_string(unicode_binary, encoding='utf-8')
+print(f"to_native_string({unicode_binary}, encoding='utf-8') = '{unicode_result}'")
+
+print("\nAll tests completed!")
\ No newline at end of file
diff --git a/test_fixed_session.py b/test_fixed_session.py
new file mode 100644
index 00000000..c995ab23
--- /dev/null
+++ b/test_fixed_session.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Test script to verify the Session.request method now handles binary strings correctly
+"""
+
+import sys
+import os
+
+# Add the current directory to Python path so we can import requests
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from requests.sessions import Session
+
+def test_session_request_method():
+    """Test that Session.request properly handles binary method strings"""
+    session = Session()
+    
+    # Test the method parameter processing that happens in Session.request
+    print("Testing Session.request method parameter processing:")
+    
+    # Test cases
+    test_cases = [
+        ('GET', 'Normal string'),
+        (b'GET', 'Binary string (the problematic case)'),
+        ('POST', 'Normal string'),
+        (b'POST', 'Binary string'),
+    ]
+    
+    for method, description in test_cases:
+        try:
+            # This simulates what happens in Session.request after our fix
+            from requests.utils import to_native_string
+            converted_method = to_native_string(method)
+            
+            print(f"✓ {description}: {repr(method)} -> '{converted_method}'")
+            
+            # Verify this is what we expect
+            expected = 'GET' if 'GET' in str(method) else 'POST'
+            if converted_method == expected:
+                print(f"  ✓ Correctly converted to '{expected}'")
+            else:
+                print(f"  ⚠ Unexpected conversion: '{converted_method}'")
+                
+        except Exception as e:
+            print(f"✗ {description}: {repr(method)} -> ERROR: {e}")
+    
+    print("\nTesting that the old bug would have occurred:")
+    
+    # Show what would have happened with the old code
+    from requests.compat import builtin_str
+    for method, description in test_cases:
+        if isinstance(method, bytes):
+            old_result = builtin_str(method)
+            print(f"Old code: {repr(method)} -> '{old_result}' (BUG!)")
+            print(f"New code: {repr(method)} -> '{to_native_string(method)}' (FIXED!)")
+
+if __name__ == "__main__":
+    test_session_request_method()
\ No newline at end of file
diff --git a/test_method_conversion.py b/test_method_conversion.py
new file mode 100644
index 00000000..c5d67e04
--- /dev/null
+++ b/test_method_conversion.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Test script to verify the method conversion works without network calls
+"""
+
+import sys
+import os
+
+# Add the current directory to Python path so we can import requests
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from requests.sessions import Session
+from requests.models import Request
+
+def test_method_conversion():
+    """Test the method conversion that happens in Session.request"""
+    session = Session()
+    
+    # Test what happens when we call the internal method processing
+    print("Testing method conversion in Session.request:")
+    
+    # Test cases that should work
+    test_cases = [
+        'GET',      # Normal string
+        b'GET',     # Binary string (the problematic case)
+        'POST',     # Normal string  
+        b'POST',    # Binary string
+        b'',        # Empty binary string
+        '',         # Empty string
+    ]
+    
+    for method in test_cases:
+        try:
+            # Simulate what happens in Session.request
+            from requests.utils import to_native_string
+            converted_method = to_native_string(method)
+            print(f"✓ {repr(method)} -> '{converted_method}'")
+            
+            # Verify it's a proper string that can be used as HTTP method
+            if isinstance(converted_method, str) and converted_method.isalpha():
+                print(f"  ✓ Valid HTTP method: {converted_method}")
+            else:
+                print(f"  ⚠ Not a valid HTTP method: {converted_method}")
+                
+        except Exception as e:
+            print(f"✗ {repr(method)} -> ERROR: {e}")
+    
+    print("\nTesting Request creation with converted methods:")
+    
+    # Test that we can create Request objects with the converted methods
+    for method in test_cases:
+        try:
+            converted_method = to_native_string(method)
+            # Create a Request object like Session.request does
+            req = Request(
+                method=converted_method.upper(),
+                url='http://example.com',
+            )
+            print(f"✓ Request with method '{converted_method.upper()}' created successfully")
+        except Exception as e:
+            print(f"✗ Request with method {repr(method)} failed: {e}")
+
+if __name__ == "__main__":
+    test_method_conversion()
\ No newline at end of file
diff --git a/test_session_fix.py b/test_session_fix.py
new file mode 100644
index 00000000..d5900714
--- /dev/null
+++ b/test_session_fix.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Test script to verify the fix works in the Session.request method
+"""
+
+import sys
+import os
+
+# Add the current directory to Python path so we can import requests
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
+
+from requests import Session
+
+# Create a session
+session = Session()
+
+# Test with normal string method (should work as before)
+print("Testing with normal string method:")
+try:
+    # This should work fine
+    response = session.request('GET', 'http://httpbin.org/get', timeout=5)
+    print(f"Normal string method: SUCCESS (status: {response.status_code})")
+except Exception as e:
+    print(f"Normal string method: ERROR - {e}")
+
+# Test with binary string method (this was the problematic case)
+print("\nTesting with binary string method:")
+try:
+    # This should now work with our fix
+    response = session.request(b'GET', 'http://httpbin.org/get', timeout=5)
+    print(f"Binary string method: SUCCESS (status: {response.status_code})")
+except Exception as e:
+    print(f"Binary string method: ERROR - {e}")
+
+# Test what the method parameter becomes internally
+print("\nTesting method parameter conversion:")
+
+# Let's create a simple test to see what happens to the method parameter
+def test_method_conversion(method):
+    """Simulate what happens in Session.request"""
+    from requests.utils import to_native_string
+    converted_method = to_native_string(method)
+    print(f"Input: {method} ({type(method)}) -> Output: '{converted_method}' ({type(converted_method)})")
+    return converted_method
+
+# Test various inputs
+test_method_conversion('GET')
+test_method_conversion(b'GET')
+test_method_conversion(b'POST')
+test_method_conversion('POST')
+
+print("\nAll tests completed!")
\ No newline at end of file