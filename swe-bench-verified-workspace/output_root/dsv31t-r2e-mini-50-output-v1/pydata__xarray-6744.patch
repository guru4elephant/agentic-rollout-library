diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..8feb1416
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,20 @@
+import xarray as xr
+import numpy as np
+
+# Reproduce the issue described in the GitHub issue
+my_data = xr.DataArray(np.arange(1, 10), dims="x")
+
+print("Option 1: take a center-justified rolling average")
+result1 = my_data.rolling(x=3, center=True).mean().values
+print("result1:", result1)
+
+print("\nOption 2: try to manually iterate, but the result is not centered")
+my_data_rolling = my_data.rolling(x=3, center=True)
+result2 = [window.mean().values.item() for label, window in my_data_rolling]
+print("result2:", result2)
+
+print("\nExpected result1 should be: [nan, 2., 3., 4., 5., 6., 7., 8., nan]")
+print("Actual result2 is:         [nan, nan, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]")
+
+# The issue is that result2 should match result1 when center=True
+print("\nThe issue is that manual iteration doesn't respect the center=True parameter")
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..8c96714b
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,54 @@
+import xarray as xr
+import numpy as np
+
+def test_rolling_iteration():
+    print("Testing rolling iteration with center=True...")
+    
+    # Test case 1: Original issue
+    my_data = xr.DataArray(np.arange(1, 10), dims="x")
+    
+    # Option 1: take a center-justified rolling average
+    result1 = my_data.rolling(x=3, center=True).mean().values
+    
+    # Option 2: manually iterate
+    my_data_rolling = my_data.rolling(x=3, center=True)
+    result2 = [window.mean().values.item() for label, window in my_data_rolling]
+    
+    print("Test case 1 - Original issue:")
+    print("result1:", result1)
+    print("result2:", result2)
+    print("Match:", np.allclose(result1, result2, equal_nan=True))
+    
+    # Test case 2: Even window size
+    print("\nTest case 2 - Even window size (4):")
+    result1_even = my_data.rolling(x=4, center=True).mean().values
+    my_data_rolling_even = my_data.rolling(x=4, center=True)
+    result2_even = [window.mean().values.item() for label, window in my_data_rolling_even]
+    
+    print("result1_even:", result1_even)
+    print("result2_even:", result2_even)
+    print("Match:", np.allclose(result1_even, result2_even, equal_nan=True))
+    
+    # Test case 3: Center=False (should work as before)
+    print("\nTest case 3 - Center=False:")
+    result1_no_center = my_data.rolling(x=3, center=False).mean().values
+    my_data_rolling_no_center = my_data.rolling(x=3, center=False)
+    result2_no_center = [window.mean().values.item() for label, window in my_data_rolling_no_center]
+    
+    print("result1_no_center:", result1_no_center)
+    print("result2_no_center:", result2_no_center)
+    print("Match:", np.allclose(result1_no_center, result2_no_center, equal_nan=True))
+    
+    # Test case 4: Different data
+    print("\nTest case 4 - Different data:")
+    data2 = xr.DataArray([1, 2, 3, 4, 5], dims="y")
+    result1_diff = data2.rolling(y=2, center=True).mean().values
+    data2_rolling = data2.rolling(y=2, center=True)
+    result2_diff = [window.mean().values.item() for label, window in data2_rolling]
+    
+    print("result1_diff:", result1_diff)
+    print("result2_diff:", result2_diff)
+    print("Match:", np.allclose(result1_diff, result2_diff,2, equal_nan=True))
+
+if __name__ == "__main__":
+    test_rolling_iteration()
\ No newline at end of file
diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py
index aef290f6..7a39abdd 100644
--- a/xarray/core/rolling.py
+++ b/xarray/core/rolling.py
@@ -270,9 +270,26 @@ class DataArrayRolling(Rolling["DataArray"]):
     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:
         if self.ndim > 1:
             raise ValueError("__iter__ is only supported for 1d-rolling")
-        stops = np.arange(1, len(self.window_labels) + 1)
-        starts = stops - int(self.window[0])
-        starts[: int(self.window[0])] = 0
+        
+        window_size = int(self.window[0])
+        center = self.center[0]
+        
+        if center:
+            # For centered windows, we need to adjust the start and stop positions
+            # to center the window around each label
+            half_window = window_size // 2
+            starts = np.arange(len(self.window_labels)) - half_window
+            stops = starts + window_size
+            
+            # Handle boundaries by clamping start positions
+            starts = np.maximum(starts, 0)
+            stops = np.minimum(stops, len(self.window_labels))
+        else:
+            # Original non-centered behavior
+            stops = np.arange(1, len(self.window_labels) + 1)
+            starts = stops - window_size
+            starts[:window_size] = 0
+        
         for (label, start, stop) in zip(self.window_labels, starts, stops):
             window = self.obj.isel({self.dim[0]: slice(start, stop)})