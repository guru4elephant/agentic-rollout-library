diff --git a/debug_filtered_relations.py b/debug_filtered_relations.py
new file mode 100644
index 0000000000..cea7ee7c98
--- /dev/null
+++ b/debug_filtered_relations.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import F, Q, FilteredRelation
+
+# Create a simple model structure for testing
+class Author(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test'
+
+class Book(models.Model):
+    title = models.CharField(max_length=100)
+    author = models.ForeignKey(Author, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test'
+
+def debug_filtered_relations():
+    """Debug how filtered relations are handled in query generation"""
+    
+    from django.db.models.sql.query import Query
+    
+    # Create a query
+    query = Query(Author)
+    
+    # Add multiple filtered relations with the same relation name
+    fr1 = FilteredRelation("book", condition=Q(book__title__icontains="Zone"))
+    fr2 = FilteredRelation("book", condition=Q(book__title__icontains="All"))
+    
+    query.add_filtered_relation(fr1, "relation_zone")
+    query.add_filtered_relation(fr2, "relation_all")
+    
+    print("Filtered relations in query:")
+    for alias, fr in query._filtered_relations.items():
+        print(f"  {alias}: {fr.relation_name} with condition {fr.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Test names_to_path for both aliases
+    print("Testing names_to_path for 'relation_zone__title':")
+    try:
+        path, field, targets, rest = query.names_to_path(["relation_zone", "title"], Author._meta)
+        print(f"  Path: {path}")
+        print(f"  Field: {field}")
+        print(f"  Targets: {targets}")
+        print(f"  Rest: {rest}")
+    except Exception as e:
+        print(f"  Error: {e}")
+    
+    print("\nTesting names_to_path for 'relation_all__title':")
+    try:
+        path, field, targets, rest = query.names_to_path(["relation_all", "title"], Author._meta)
+        print(f"  Path: {path}")
+        print(f"  Field: {field}")
+        print(f"  Targets: {targets}")
+        print(f"  Rest: {rest}")
+    except Exception as e:
+        print(f"  Error: {e}")
+
+if __name__ == "__main__":
+    debug_filtered_relations()
\ No newline at end of file
diff --git a/debug_or_condition.py b/debug_or_condition.py
new file mode 100644
index 0000000000..513b02a47a
--- /dev/null
+++ b/debug_or_condition.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.filtered_relation',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models import F, Q, FilteredRelation
+from tests.filtered_relation.models import Author
+
+def debug_or_condition():
+    """Debug how OR conditions are processed"""
+    
+    # Create a query with multiple filtered relations
+    qs = Author.objects.annotate(
+        relation_zone=FilteredRelation(
+            "book",
+            condition=Q(book__title__icontains="Zone")
+        ),
+        relation_all=FilteredRelation(
+            "book", 
+            condition=Q(book__title__icontains="All")
+        ),
+    )
+    
+    print("Before adding OR condition:")
+    print(f"  Filtered relations: {list(qs.query._filtered_relations.keys())}")
+    print(f"  Alias map: {list(qs.query.alias_map.keys())}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Add the OR condition
+    qs = qs.filter(Q(relation_zone__isnull=False) | Q(relation_all__isnull=False))
+    
+    print("After adding OR condition:")
+    print(f"  Filtered relations: {list(qs.query._filtered_relations.keys())}")
+    print(f"  Alias map: {list(qs.query.alias_map.keys())}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Check the where clause
+    print("Where clause structure:")
+    print(f"  Where node: {qs.query.where}")
+    if hasattr(qs.query.where, 'children'):
+        for i, child in enumerate(qs.query.where.children):
+            print(f"  Child {i}: {child}")
+            if hasattr(child, 'children'):
+                for j, grandchild in enumerate(child.children):
+                    print(f"    Grandchild {j}: {grandchild}")
+
+if __name__ == "__main__":
+    debug_or_condition()
\ No newline at end of file
diff --git a/debug_sql_generation.py b/debug_sql_generation.py
new file mode 100644
index 0000000000..a4635549bf
--- /dev/null
+++ b/debug_sql_generation.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.filtered_relation',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models import F, Q, FilteredRelation
+from tests.filtered_relation.models import Author
+
+def debug_sql_generation():
+    """Debug the SQL generation issue"""
+    
+    # Create a query with multiple filtered relations
+    qs = Author.objects.annotate(
+        relation_zone=FilteredRelation(
+            "book",
+            condition=Q(book__title__icontains="Zone")
+        ),
+        relation_all=FilteredRelation(
+            "book", 
+            condition=Q(book__title__icontains="All")
+        ),
+    ).filter(
+        Q(relation_zone__isnull=False) | Q(relation_all__isnull=False)
+    )
+    
+    print("Query object filtered_relations:")
+    for alias, fr in qs.query._filtered_relations.items():
+        print(f"  {alias}: {fr.relation_name} with condition {fr.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Check the alias map to see what joins are created
+    print("Alias map:")
+    for alias, join in qs.query.alias_map.items():
+        if hasattr(join, 'filtered_relation') and join.filtered_relation:
+            print(f"  {alias}: {join.table_name} with filtered_relation {join.filtered_relation.alias}")
+        else:
+            print(f"  {alias}: {join.table_name}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Generate SQL to see what happens
+    print("Generated SQL:")
+    sql = str(qs.query)
+    print(sql)
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Check if both filtered relations are present in the SQL
+    if "relation_zone" in sql and "relation_all" in sql:
+        print("✓ Both filtered relations are present in the SQL")
+    else:
+        print("✗ Only one filtered relation is present in the SQL")
+        if "relation_zone" in sql:
+            print("  - Only relation_zone found")
+        elif "relation_all" in sql:
+            print("  - Only relation_all found")
+        else:
+            print("  - Neither filtered relation found")
+
+if __name__ == "__main__":
+    debug_sql_generation()
\ No newline at end of file
diff --git a/django/db/models/sql/datastructures.py b/django/db/models/sql/datastructures.py
index 1edf040e82..8f8b933a0e 100644
--- a/django/db/models/sql/datastructures.py
+++ b/django/db/models/sql/datastructures.py
@@ -162,8 +162,12 @@ class Join:
         return hash(self.identity)
 
     def equals(self, other):
-        # Ignore filtered_relation in equality check.
-        return self.identity[:-1] == other.identity[:-1]
+        # Include filtered_relation in equality check when present
+        if self.filtered_relation or other.filtered_relation:
+            return self.identity == other.identity
+        else:
+            # Ignore filtered_relation in equality check when not present
+            return self.identity[:-1] == other.identity[:-1]
 
     def demote(self):
         new = self.relabeled_clone({})
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 54f3258eac..e3f753dc48 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1643,6 +1643,8 @@ class Query(BaseExpression):
                         path.extend(filtered_relation_path[:-1])
                     else:
                         field = opts.get_field(filtered_relation.relation_name)
+                        # Store the filtered relation in the field so it can be used later
+                        field.filtered_relation = filtered_relation
             if field is not None:
                 # Fields that contain one-to-many relations with a generic
                 # model (like a GenericForeignKey) cannot generate reverse
@@ -1689,6 +1691,8 @@ class Query(BaseExpression):
             if hasattr(field, "path_infos"):
                 if filtered_relation:
                     pathinfos = field.get_path_info(filtered_relation)
+                elif hasattr(field, "filtered_relation"):
+                    pathinfos = field.get_path_info(field.filtered_relation)
                 else:
                     pathinfos = field.path_infos
                 if not allow_many:
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..066e1b3fb2
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import F, Q, FilteredRelation, Case, When
+
+def test_multiple_filtered_relations():
+    print("Testing multiple FilteredRelation on same relation...")
+    
+    # Create the query similar to the issue description
+    # We'll just test the query construction without executing it
+    from django.db.models.query import QuerySet
+    from django.db.models.sql.query import Query
+    
+    # Create a mock query to test the SQL generation
+    query = Query(models.Model)
+    
+    # Add filtered relations directly to test the issue
+    fr1 = FilteredRelation("book", condition=Q(book__zone=F("author__zone")))
+    fr2 = FilteredRelation("book", condition=Q(book__zone__isnull=True))
+    
+    query.add_filtered_relation(fr1, "relation_zone")
+    query.add_filtered_relation(fr2, "relation_all")
+    
+    print("Filtered relations in query:")
+    for alias, fr in query._filtered_relations.items():
+        print(f"  {alias}: {fr.relation_name} with condition {fr.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Check if both filtered relations are stored
+    if "relation_zone" in query._filtered_relations and "relation_all" in query._filtered_relations:
+        print("✓ Both filtered relations are stored in the query")
+    else:
+        print("✗ Only one filtered relation is stored in the query")
+        if "relation_zone" in query._filtered_relations:
+            print("  - Only relation_zone found")
+        elif "relation_all" in query._filtered_relations:
+            print("  - Only relation_all found")
+        else:
+            print("  - Neither filtered relation found")
+
+if __name__ == "__main__":
+    # Test the issue
+    test_multiple_filtered_relations()
\ No newline at end of file
diff --git a/simple_debug.py b/simple_debug.py
new file mode 100644
index 0000000000..1b8cf6ca17
--- /dev/null
+++ b/simple_debug.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.filtered_relation',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models import F, Q, FilteredRelation
+
+def debug_core_issue():
+    """Debug the core issue with multiple FilteredRelation instances"""
+    
+    # Create multiple FilteredRelation instances with same relation name
+    fr1 = FilteredRelation("book", condition=Q(book__title__icontains="Zone"))
+    fr2 = FilteredRelation("book", condition=Q(book__title__icontains="All"))
+    
+    print("FilteredRelation 1:")
+    print(f"  relation_name: {fr1.relation_name}")
+    print(f"  alias: {fr1.alias}")
+    print(f"  condition: {fr1.condition}")
+    
+    print("\nFilteredRelation 2:")
+    print(f"  relation_name: {fr2.relation_name}")
+    print(f"  alias: {fr2.alias}")
+    print(f"  condition: {fr2.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # The issue: both have same relation_name but different conditions
+    # When used in a query, only one gets processed
+    
+    # Let's examine what happens in the query when we add both
+    from django.db.models.sql.query import Query
+    from tests.filtered_relation.models import Author
+    
+    query = Query(Author)
+    
+    # Add both filtered relations
+    query._filtered_relations["relation_zone"] = fr1
+    query._filtered_relations["relation_all"] = fr2
+    
+    print("Filtered relations stored in query:")
+    for alias, fr in query._filtered_relations.items():
+        print(f"  {alias}: {fr.relation_name} with condition {fr.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # The issue: when names_to_path is called, it looks up by the first part of the path
+    # So for "relation_zone__title", it looks up "relation_zone" in _filtered_relations
+    # For "relation_all__title", it looks up "relation_all" in _filtered_relations
+    # But when it processes the actual relation name "book", it doesn't know which alias to use
+    
+    print("The core issue:")
+    print("1. Both filtered relations have relation_name='book'")
+    print("2. They have different aliases: 'relation_zone' and 'relation_all'")
+    print("3. When resolving paths like 'relation_zone__title' and 'relation_all__title'")
+    print("4. The names_to_path method correctly finds the filtered relation by alias")
+    print("5. BUT: when it processes the actual relation name 'book', it doesn't")
+    print("   maintain the connection to the original filtered relation alias")
+    print("6. This causes only one filtered relation to be used in the final SQL")
+
+if __name__ == "__main__":
+    debug_core_issue()
\ No newline at end of file
diff --git a/targeted_debug.py b/targeted_debug.py
new file mode 100644
index 0000000000..dd0e6feecd
--- /dev/null
+++ b/targeted_debug.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.filtered_relation',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db.models import F, Q, FilteredRelation
+from tests.filtered_relation.models import Author
+
+def debug_path_resolution():
+    """Debug the path resolution issue"""
+    
+    from django.db.models.sql.query import Query
+    
+    # Create a query
+    query = Query(Author)
+    
+    # Add multiple filtered relations with the same relation name
+    fr1 = FilteredRelation("book", condition=Q(book__title__icontains="Zone"))
+    fr2 = FilteredRelation("book", condition=Q(book__title__icontains="All"))
+    
+    query.add_filtered_relation(fr1, "relation_zone")
+    query.add_filtered_relation(fr2, "relation_all")
+    
+    print("Filtered relations in query:")
+    for alias, fr in query._filtered_relations.items():
+        print(f"  {alias}: {fr.relation_name} with condition {fr.condition}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Test names_to_path for both aliases
+    print("Testing names_to_path for 'relation_zone':")
+    try:
+        path, field, targets, rest = query.names_to_path(["relation_zone"], Author._meta)
+        print(f"  Path: {[p.__class__.__name__ for p in path]}")
+        print(f"  Field: {field}")
+        print(f"  Targets: {targets}")
+        print(f"  Rest: {rest}")
+        
+        # Check if filtered_relation is properly set in the path
+        for i, p in enumerate(path):
+            if hasattr(p, 'filtered_relation'):
+                print(f"  Path[{i}].filtered_relation: {p.filtered_relation}")
+    except Exception as e:
+        print(f"  Error: {e}")
+    
+    print("\nTesting names_to_path for 'relation_all':")
+    try:
+        path, field, targets, rest = query.names_to_path(["relation_all"], Author._meta)
+        print(f"  Path: {[p.__class__.__name__ for p in path]}")
+        print(f"  Field: {field}")
+        print(f"  Targets: {targets}")
+        print(f"  Rest: {rest}")
+        
+        # Check if filtered_relation is properly set in the path
+        for i, p in enumerate(path):
+            if hasattr(p, 'filtered_relation'):
+                print(f"  Path[{i}].filtered_relation: {p.filtered_relation}")
+    except Exception as e:
+        print(f"  Error: {e}")
+
+if __name__ == "__main__":
+    debug_path_resolution()
\ No newline at end of file
diff --git a/test_multiple_filtered_relations.py b/test_multiple_filtered_relations.py
new file mode 100644
index 0000000000..ced96b2fdb
--- /dev/null
+++ b/test_multiple_filtered_relations.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'tests.filtered_relation',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models import F, Q, FilteredRelation, Case, When
+from tests.filtered_relation.models import Author, Book, Editor
+
+def test_multiple_filtered_relations():
+    """Test that demonstrates the issue with multiple FilteredRelation on same relation"""
+    
+    # Create a simple query with multiple FilteredRelation on the same relation
+    qs = Author.objects.annotate(
+        relation_zone=FilteredRelation(
+            "book",
+            condition=Q(book__title__icontains="Zone")
+        ),
+        relation_all=FilteredRelation(
+            "book", 
+            condition=Q(book__title__icontains="All")
+        ),
+    ).filter(
+        Q(relation_zone__isnull=False) | Q(relation_all__isnull=False)
+    )
+    
+    print("Query SQL:")
+    sql = str(qs.query)
+    print(sql)
+    print("\n" + "="*50 + "\n")
+    
+    # Check if both filtered relations are present in the SQL
+    if "relation_zone" in sql and "relation_all" in sql:
+        print("✓ Both filtered relations are present in the SQL")
+        return True
+    else:
+        print("✗ Only one filtered relation is present in the SQL")
+        if "relation_zone" in sql:
+            print("  - Only relation_zone found")
+        elif "relation_all" in sql:
+            print("  - Only relation_all found")
+        else:
+            print("  - Neither filtered relation found")
+        return False
+
+if __name__ == "__main__":
+    # Test the issue
+    success = test_multiple_filtered_relations()
+    sys.exit(0 if success else 1)
\ No newline at end of file