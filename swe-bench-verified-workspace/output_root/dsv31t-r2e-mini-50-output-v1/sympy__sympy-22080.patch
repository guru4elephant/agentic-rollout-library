diff --git a/check_mod_precedence.py b/check_mod_precedence.py
new file mode 100644
index 0000000000..228670fa1f
--- /dev/null
+++ b/check_mod_precedence.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python3
+"""Check the precedence of Mod."""
+
+from sympy import Mod, symbols
+from sympy.printing.precedence import precedence
+
+x, y = symbols('x y')
+mod_expr = Mod(x, y)
+
+print(f"Mod(x, y) precedence: {precedence(mod_expr)}")
+print(f"Mod type: {type(mod_expr)}")
+print(f"Mod class: {mod_expr.__class__}")
+print(f"Mod class name: {mod_expr.__class__.__name__}")
+
+# Check precedence of Mul for comparison
+from sympy import Mul
+mul_expr = x * y
+print(f"Mul(x, y) precedence: {precedence(mul_expr)}")
\ No newline at end of file
diff --git a/debug_expression.py b/debug_expression.py
new file mode 100644
index 0000000000..d53562a057
--- /dev/null
+++ b/debug_expression.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+"""Debug the expression structure."""
+
+from sympy import Mod, symbols, pprint
+
+x, y, z = symbols('x y z')
+expr = z * Mod(x, y)
+
+print("Original expression:")
+pprint(expr)
+print()
+
+print("Expression structure:")
+print(f"Type: {type(expr)}")
+print(f"Args: {expr.args}")
+print()
+
+# Check if the expression is already transformed
+print("Is the expression already transformed?")
+print(f"expr.args[0]: {expr.args[0]} (type: {type(expr.args[0])})")
+print(f"expr.args[1]: {expr.args[1]} (type: {type(expr.args[1])})")
\ No newline at end of file
diff --git a/debug_lambdify.py b/debug_lambdify.py
new file mode 100644
index 0000000000..2fbc03cd05
--- /dev/null
+++ b/debug_lambdify.py
@@ -0,0 +1,24 @@
+#!/usr/bin/env python3
+"""Debug the lambdify process."""
+
+from sympy import Mod, lambdify, symbols
+from sympy.utilities.lambdify import _EvaluatorPrinter
+from sympy.printing.pycode import PythonCodePrinter
+
+x, y, z = symbols('x y z')
+expr = z * Mod(x, y)
+
+print("Original expression:", expr)
+print("Expression type:", type(expr))
+print("Expression args:", expr.args)
+
+# Test the printer directly
+printer = PythonCodePrinter()
+printed = printer._print(expr)
+print("Printed expression:", printed)
+
+# Test the evaluator printer
+evaluator = _EvaluatorPrinter(printer, dummify=False)
+funcstr = evaluator.doprint('test_func', [x, y, z], expr)
+print("Evaluator output:")
+print(funcstr)
\ No newline at end of file
diff --git a/debug_negative_mod.py b/debug_negative_mod.py
new file mode 100644
index 0000000000..c67735387e
--- /dev/null
+++ b/debug_negative_mod.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+"""Debug the negative Mod case."""
+
+from sympy import Mod, symbols
+
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Original expression:", expr)
+print("Expression type:", type(expr))
+print("Expression args:", expr.args)
+
+# Check if the negative sign is applied to the Mod or to the first argument
+if hasattr(expr, 'func') and hasattr(expr, 'args'):
+    print("Expression func:", expr.func)
+    print("First arg:", expr.args[0])
+    print("Second arg:", expr.args[1] if len(expr.args) > 1 else "None")
+
+# Evaluate to see if it changes
+evaluated = expr.doit()
+print("Evaluated expression:", evaluated)
+print("Are they the same?", expr == evaluated)
\ No newline at end of file
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..ba14e5f65a
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+"""Script to reproduce the Mod function lambdify bug."""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Reproduce the issue from the GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test without modules=[] (should work correctly)
+f = lambdify([x, y], expr)
+result_f = f(3, 7)
+source_f = inspect.getsource(f)
+print("Without modules=[]:")
+print(f"Result: {result_f}")
+print(f"Source: {source_f}")
+print()
+
+# Test with modules=[] (shows the bug)
+g = lambdify([x, y], expr, modules=[])
+result_g = g(3, 7)
+source_g = inspect.getsource(g)
+print("With modules=[]:")
+print(f"Result: {result_g}")
+print(f"Source: {source_g}")
+print()
+
+# Expected result should be -3 % 7 = 4
+expected = -3 % 7
+print(f"Expected result: {expected}")
+print(f"Bug confirmed: {result_g == expected}")
\ No newline at end of file
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index b669a2c783..90431cee64 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -233,8 +233,14 @@ def _print_ComplexInfinity(self, expr):
         return self._print_NaN(expr)
 
     def _print_Mod(self, expr):
-        PREC = precedence(expr)
-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+        # For PythonCodePrinter (used when modules=[] is specified), use Mod function call
+        # For other printers, use % operator
+        if self.__class__.__name__ == 'PythonCodePrinter':
+            PREC = precedence(expr)
+            return ('Mod({}, {})'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
+        else:
+            PREC = precedence(expr)
+            return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))
 
     def _print_Piecewise(self, expr):
         result = []
diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py
index 0ed6ce2eb1..c7ff62db5b 100644
--- a/sympy/utilities/lambdify.py
+++ b/sympy/utilities/lambdify.py
@@ -796,6 +796,11 @@ def _lambdifygenerated(x):
         for term in syms:
             namespace.update({str(term): term})
 
+    # Add Mod function to namespace when modules=[] is specified
+    if namespaces == []:
+        from sympy import Mod
+        namespace['Mod'] = Mod
+
     if printer is None:
         if _module_present('mpmath', namespaces):
             from sympy.printing.pycode import MpmathPrinter as Printer # type: ignore
@@ -882,6 +887,14 @@ def _lambdifygenerated(x):
                     exec(ln, {}, namespace)
                 imp_mod_lines.append(ln)
 
+    # Add Mod import when modules=[] is specified
+    if namespaces == [] and 'Mod' not in namespace:
+        try:
+            exec("from sympy import Mod", {}, namespace)
+            imp_mod_lines.append("from sympy import Mod")
+        except ImportError:
+            pass
+
     # Provide lambda expression with builtins, and compatible implementation of range
     namespace.update({'builtins':builtins, 'range':range})
 
diff --git a/test_different_modules.py b/test_different_modules.py
new file mode 100644
index 0000000000..7d54cd56d2
--- /dev/null
+++ b/test_different_modules.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""Test to see how different modules handle Mod."""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Test with different modules
+x, y, z = symbols('x y z')
+expr = z * Mod(x, y)
+
+modules_to_test = [
+    None,           # Default behavior
+    [],             # Empty list (the problematic case)
+    ['sympy'],      # SymPy module
+    ['numpy'],      # NumPy module
+    ['math'],       # Math module
+]
+
+for modules in modules_to_test:
+    try:
+        if modules is None:
+            f = lambdify([x, y, z], expr)
+            name = "None (default)"
+        else:
+            f = lambdify([x, y, z], expr, modules=modules)
+            name = str(modules)
+        
+        result = f(3, 7, 2)
+        source = inspect.getsource(f)
+        print(f"Modules: {name}")
+        print(f"Result: {result}")
+        print(f"Source: {source}")
+        print()
+        
+    except Exception as e:
+        print(f"Modules: {name} - Error: {e}")
+        print()
\ No newline at end of file
diff --git a/test_evaluation.py b/test_evaluation.py
new file mode 100644
index 0000000000..6cf4ecfeb7
--- /dev/null
+++ b/test_evaluation.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python3
+"""Test if the expression is being transformed during evaluation."""
+
+from sympy import Mod, symbols
+
+x, y, z = symbols('x y z')
+expr = z * Mod(x, y)
+
+print("Original expression:", expr)
+print("Expression type:", type(expr))
+print("Expression args:", expr.args)
+
+# Evaluate the expression to see if it gets transformed
+evaluated = expr.doit()
+print("Evaluated expression:", evaluated)
+print("Evaluated type:", type(evaluated))
+print("Evaluated args:", evaluated.args if hasattr(evaluated, 'args') else "No args")
+
+# Check if they are the same
+print("Are they the same?", expr == evaluated)
\ No newline at end of file
diff --git a/test_exact_issue.py b/test_exact_issue.py
new file mode 100644
index 0000000000..b4dead3181
--- /dev/null
+++ b/test_exact_issue.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+"""Test to reproduce the exact issue from GitHub."""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Exact example from GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test without modules=[] (should work correctly)
+f = lambdify([x, y], expr)
+result_f = f(3, 7)
+source_f = inspect.getsource(f)
+print("Without modules=[]:")
+print(f"Result: {result_f}")
+print(f"Source: {source_f}")
+print()
+
+# Test with modules=[] (should show the bug according to GitHub issue)
+g = lambdify([x, y], expr, modules=[])
+result_g = g(3, 7)
+source_g = inspect.getsource(g)
+print("With modules=[]:")
+print(f"Result: {result_g}")
+print(f"Source: {source_g}")
+print()
+
+# According to GitHub issue, the bug is:
+# When modules=[] is specified, it should return Mod(-x, y) but instead returns -x % y
+# The result should be the same (-3 % 7 = 4), but the source code should be different
+
+# Expected source with modules=[] should be: return Mod(-x, y)
+# Actual source with modules=[] is: return -x % y
+
+print("Expected source with modules=[]: return Mod(-x, y)")
+print("Actual source with modules=[]:", source_g.split('\n')[1].strip())
\ No newline at end of file
diff --git a/test_expression_structure.py b/test_expression_structure.py
new file mode 100644
index 0000000000..f42c65c811
--- /dev/null
+++ b/test_expression_structure.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+"""Test the actual expression structure during lambdify."""
+
+from sympy import Mod, lambdify, symbols
+from sympy.utilities.lambdify import _EvaluatorPrinter
+from sympy.printing.pycode import PythonCodePrinter
+
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+print("Original expression:", expr)
+print("Expression type:", type(expr))
+print("Expression args:", expr.args)
+
+# Test what happens during lambdify
+print("\n=== Lambdify process ===")
+
+# Test with modules=[]
+printer = PythonCodePrinter()
+evaluator = _EvaluatorPrinter(printer, dummify=False)
+funcstr = evaluator.doprint('test_func', [x, y], expr)
+print("With modules=[]:")
+print(funcstr)
+
+# Test with default modules
+# This would use a different printer, but let's see what PythonCodePrinter produces
+print("With default modules (using PythonCodePrinter):")
+print(funcstr)  # Same as above since we're using the same printer
+
+# The issue might be that different printers should behave differently
\ No newline at end of file
diff --git a/test_mod_multiplier.py b/test_mod_multiplier.py
new file mode 100644
index 0000000000..b96ef5cd89
--- /dev/null
+++ b/test_mod_multiplier.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""Test to check if multiplier is incorrectly moved into Mod argument."""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Test the specific case mentioned: expr * Mod(a, b)
+x, y, z = symbols('x y z')
+expr = z * Mod(x, y)
+
+# Test without modules=[] 
+f = lambdify([x, y, z], expr)
+result_f = f(3, 7, 2)
+source_f = inspect.getsource(f)
+print("Without modules=[]:")
+print(f"Result: {result_f}")
+print(f"Source: {source_f}")
+print()
+
+# Test with modules=[] 
+g = lambdify([x, y, z], expr, modules=[])
+result_g = g(3, 7, 2)
+source_g = inspect.getsource(g)
+print("With modules=[]:")
+print(f"Result: {result_g}")
+print(f"Source: {source_g}")
+print()
+
+# Expected: 2 * (3 % 7) = 2 * 3 = 6
+# If bug exists: Mod(2 * 3, 7) = 6 % 7 = 6 (same result but different computation)
+expected = 2 * (3 % 7)
+print(f"Expected result: {expected}")
+print(f"Bug confirmed: {result_g == expected}")
\ No newline at end of file
diff --git a/test_module_selection.py b/test_module_selection.py
new file mode 100644
index 0000000000..370cf6a982
--- /dev/null
+++ b/test_module_selection.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Test what printer is selected for different module settings."""
+
+from sympy import Mod, lambdify, symbols
+from sympy.utilities.lambdify import _module_present
+
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test what happens with different module settings
+test_cases = [
+    (None, "No modules specified"),
+    ([], "Empty modules list"),
+    (['sympy'], "SymPy modules"),
+]
+
+for modules, description in test_cases:
+    print(f"=== {description} ===")
+    
+    if modules is None:
+        f = lambdify([x, y], expr)
+    else:
+        f = lambdify([x, y], expr, modules=modules)
+    
+    # Check what modules are present
+    if modules is None:
+        # For default case, check what modules would be used
+        try:
+            _module_present('numpy', ['numpy'])
+            print("Would use numpy printer")
+        except:
+            print("Would use PythonCodePrinter")
+    else:
+        # For explicit modules, check what's present
+        for mod in ['numpy', 'sympy', 'mpmath']:
+            if _module_present(mod, modules):
+                print(f"Module {mod} is present")
+    
+    # Get the source to see what printer was used
+    import inspect
+    source = inspect.getsource(f)
+    print(f"Source: {source.splitlines()[1].strip()}")
+    print()
\ No newline at end of file
diff --git a/test_negative_mod.py b/test_negative_mod.py
new file mode 100644
index 0000000000..7a41cd60b1
--- /dev/null
+++ b/test_negative_mod.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+"""Test the specific case from GitHub issue: -Mod(x, y)"""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Exact example from GitHub issue
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test without modules=[] 
+f = lambdify([x, y], expr)
+result_f = f(3, 7)
+source_f = inspect.getsource(f)
+print("Without modules=[]:")
+print(f"Result: {result_f}")
+print(f"Source: {source_f}")
+print()
+
+# Test with modules=[] 
+g = lambdify([x, y], expr, modules=[])
+result_g = g(3, 7)
+source_g = inspect.getsource(g)
+print("With modules=[]:")
+print(f"Result: {result_g}")
+print(f"Source: {source_g}")
+print()
+
+# Expected: -3 % 7 = 4
+expected = -3 % 7
+print(f"Expected result: {expected}")
+print(f"Bug confirmed: {result_g == expected}")
+
+# Check if the source is different
+print("Expected source with modules=[]: return Mod(-x, y)")
+print("Actual source with modules=[]:", source_g.split('\n')[1].strip())
\ No newline at end of file
diff --git a/test_parenthesization.py b/test_parenthesization.py
new file mode 100644
index 0000000000..474278084c
--- /dev/null
+++ b/test_parenthesization.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""Test parenthesization behavior."""
+
+from sympy import Mod, symbols
+from sympy.printing.pycode import PythonCodePrinter
+from sympy.printing.precedence import precedence
+
+x, y, z = symbols('x y z')
+mod_expr = Mod(x, y)
+
+# Create a printer instance
+printer = PythonCodePrinter()
+
+# Test parenthesization of Mod arguments
+PREC = precedence(mod_expr)
+print(f"Mod precedence: {PREC}")
+
+# Test how parenthesize works
+arg1_parenthesized = printer.parenthesize(x, PREC)
+arg2_parenthesized = printer.parenthesize(y, PREC)
+
+print(f"Parenthesized x: '{arg1_parenthesized}'")
+print(f"Parenthesized y: '{arg2_parenthesized}'")
+
+# Test the full Mod printing
+mod_printed = printer._print_Mod(mod_expr)
+print(f"Printed Mod: '{mod_printed}'")
+
+# Test with a more complex expression
+complex_expr = z * Mod(x, y)
+print(f"Complex expression: {complex_expr}")
+complex_printed = printer._print(complex_expr)
+print(f"Printed complex: '{complex_printed}'")
\ No newline at end of file
diff --git a/test_sympy_modules.py b/test_sympy_modules.py
new file mode 100644
index 0000000000..a09b5b1f15
--- /dev/null
+++ b/test_sympy_modules.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python3
+"""Test to see how modules=['sympy'] behaves."""
+
+from sympy import Mod, lambdify, symbols
+import inspect
+
+# Reproduce the issue with modules=['sympy']
+x, y = symbols('x y')
+expr = -Mod(x, y)
+
+# Test with modules=['sympy']
+h = lambdify([x, y], expr, modules=['sympy'])
+result_h = h(3, 7)
+source_h = inspect.getsource(h)
+print("With modules=['sympy']:")
+print(f"Result: {result_h}")
+print(f"Source: {source_h}")
+print()
+
+# Expected result should be -3 % 7 = 4
+expected = -3 % 7
+print(f"Expected result: {expected}")
+print(f"Correct behavior: {result_h == expected}")
\ No newline at end of file