diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..90169f55e4
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.migrations.operations import AddConstraint
+from django.db.migrations.state import ProjectState
+from django.db.migrations import Migration
+from django.db.migrations.executor import MigrationExecutor
+from django.db import connection
+
+# Create the test model
+class TestConstraint(models.Model):
+    field_1 = models.IntegerField(blank=True, null=True)
+    flag = models.BooleanField(blank=False, null=False)
+    
+    class Meta:
+        app_label = 'testapp'
+        constraints = [
+            models.CheckConstraint(
+                check=models.Q(flag__exact=True, field_1__isnull=False) |
+                       models.Q(flag__exact=False),
+                name='field_1_has_value_if_flag_set'
+            ),
+        ]
+
+# Create a migration
+class Migration0001(Migration):
+    dependencies = []
+    operations = [
+        migrations.CreateModel(
+            name='TestConstraint',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('field_1', models.IntegerField(blank=True, null=True)),
+                ('flag', models.BooleanField()),
+            ],
+        ),
+        migrations.AddConstraint(
+            model_name='testconstraint',
+            constraint=models.CheckConstraint(
+                check=models.Q(
+                    models.Q(('field_1__isnull', False), ('flag__exact', True)), 
+                    ('flag__exact', False), 
+                    _connector='OR'
+                ), 
+                name='field_1_has_value_if_flag_set'
+            ),
+        ),
+    ]
+
+def test_constraint_sql():
+    print("Testing constraint SQL generation...")
+    
+    # Get the constraint SQL
+    from django.db.models.constraints import CheckConstraint
+    constraint = CheckConstraint(
+        check=models.Q(flag__exact=True, field_1__isnull=False) |
+               models.Q(flag__exact=False),
+        name='field_1_has_value_if_flag_set'
+    )
+    
+    # Create a model state for the constraint
+    from django.db.migrations.state import ModelState
+    model_state = ModelState(
+        app_label='testapp',
+        name='TestConstraint',
+        fields=[
+            ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+            ('field_1', models.IntegerField(blank=True, null=True)),
+            ('flag', models.BooleanField()),
+        ],
+        options={'constraints': [constraint]},
+    )
+    
+    # Get the SQL for the constraint
+    from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+    schema_editor = BaseDatabaseSchemaEditor(connection)
+    
+    sql = constraint.constraint_sql(TestConstraint, schema_editor)
+    print(f"Constraint SQL: {sql}")
+    
+    # Also test the _get_check_sql method directly
+    check_sql = constraint._get_check_sql(TestConstraint, schema_editor)
+    print(f"Check SQL: {check_sql}")
+
+if __name__ == '__main__':
+    test_constraint_sql()
\ No newline at end of file