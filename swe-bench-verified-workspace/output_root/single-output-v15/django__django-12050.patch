diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..fdc26b4b37
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,81 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the issue where Query.resolve_lookup_value coerces list to tuple
+This affects ORM field types that are dependent on matching input types such as PickledField.
+"""
+
+import os
+import sys
+
+# Add the current directory to Python path to import Django modules
+sys.path.insert(0, '.')
+
+# Create a minimal mock Query class for testing
+class MockQuery:
+    def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col):
+        # Copy the actual implementation from django/db/models/sql/query.py
+        if hasattr(value, 'resolve_expression'):
+            kwargs = {'reuse': can_reuse, 'allow_joins': allow_joins}
+            if isinstance(value, F):
+                kwargs['simple_col'] = simple_col
+            value = value.resolve_expression(self, **kwargs)
+        elif isinstance(value, (list, tuple)):
+            # The items of the iterable may be expressions and therefore need
+            # to be resolved independently.
+            resolved_values = []
+            for sub_value in value:
+                if hasattr(sub_value, 'resolve_expression'):
+                    if isinstance(sub_value, F):
+                        resolved_values.append(sub_value.resolve_expression(
+                            self, reuse=can_reuse, allow_joins=allow_joins,
+                            simple_col=simple_col,
+                        ))
+                    else:
+                        resolved_values.append(sub_value.resolve_expression(
+                            self, reuse=can_reuse, allow_joins=allow_joins,
+                        ))
+                else:
+                    resolved_values.append(sub_value)
+            value = tuple(resolved_values)  # This is the problematic line
+        return value
+
+# Create a Query instance
+query = MockQuery()
+    
+    # Test with list input
+    input_value = [1, 2, 3, 4]
+    print(f"Input value type: {type(input_value)}")
+    print(f"Input value: {input_value}")
+    
+    # Call resolve_lookup_value
+    result = query.resolve_lookup_value(input_value, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"Output value type: {type(result)}")
+    print(f"Output value: {result}")
+    
+    # Check if the type is preserved
+    if type(result) == type(input_value):
+        print("SUCCESS: Input type preserved")
+    else:
+        print("FAILURE: Input type changed")
+        print(f"Expected: {type(input_value)}, Got: {type(result)}")
+    
+    # Test with tuple input
+    input_tuple = (1, 2, 3, 4)
+    print(f"\nInput tuple type: {type(input_tuple)}")
+    print(f"Input tuple: {input_tuple}")
+    
+    result_tuple = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)
+    
+    print(f"Output tuple type: {type(result_tuple)}")
+    print(f"Output tuple: {result_tuple}")
+    
+    # Check if the type is preserved
+    if type(result_tuple) == type(input_tuple):
+        print("SUCCESS: Tuple type preserved")
+    else:
+        print("FAILURE: Tuple type changed")
+        print(f"Expected: {type(input_tuple)}, Got: {type(result_tuple)}")
+
+if __name__ == "__main__":
+    test_resolve_lookup_value()
\ No newline at end of file